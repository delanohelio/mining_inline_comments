{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NTI0ODA4", "number": 4414, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjowNzoyOFrODcytcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjowODoxNVrODcyuXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTE3NTU0OnYy", "diffSide": "LEFT", "path": "ksql-streams/src/test/java/io/confluent/ksql/execution/streams/AggregateParamsFactoryTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjowNzoyOFrOFlBp8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMToyMzozMlrOFlj83g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2ODc1NQ==", "bodyText": "The NON_AGG_COLUMNS example in this unit test file confuses me since it seems to suggest non-aggregate columns may be intermingled with aggregate columns in the input, and violates the assumption that enables the refactor in this PR. I assume it's just the unit test that needs to be updated?", "url": "https://github.com/confluentinc/ksql/pull/4414#discussion_r374368755", "createdAt": "2020-02-03T22:07:28Z", "author": {"login": "vcrfxia"}, "path": "ksql-streams/src/test/java/io/confluent/ksql/execution/streams/AggregateParamsFactoryTest.java", "diffHunk": "@@ -132,10 +140,21 @@ public void init() {\n   @SuppressWarnings(\"unchecked\")\n   @Test\n   public void shouldCreateAggregatorWithCorrectParams() {\n-    verify(udafFactory).create(\n-        ImmutableList.of(0, 2),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5901b729455817f84615377a56c8620380657c5c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg4MTAzOA==", "bodyText": "Yeah, just the test out of whack. It's ok now though, right?", "url": "https://github.com/confluentinc/ksql/pull/4414#discussion_r374881038", "createdAt": "2020-02-04T19:38:15Z", "author": {"login": "big-andy-coates"}, "path": "ksql-streams/src/test/java/io/confluent/ksql/execution/streams/AggregateParamsFactoryTest.java", "diffHunk": "@@ -132,10 +140,21 @@ public void init() {\n   @SuppressWarnings(\"unchecked\")\n   @Test\n   public void shouldCreateAggregatorWithCorrectParams() {\n-    verify(udafFactory).create(\n-        ImmutableList.of(0, 2),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2ODc1NQ=="}, "originalCommit": {"oid": "5901b729455817f84615377a56c8620380657c5c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMDY1NA==", "bodyText": "Did anything change here? I don't see an update: https://github.com/confluentinc/ksql/blob/master/ksql-streams/src/test/java/io/confluent/ksql/execution/streams/AggregateParamsFactoryTest.java#L54-L55", "url": "https://github.com/confluentinc/ksql/pull/4414#discussion_r374930654", "createdAt": "2020-02-04T21:23:32Z", "author": {"login": "vcrfxia"}, "path": "ksql-streams/src/test/java/io/confluent/ksql/execution/streams/AggregateParamsFactoryTest.java", "diffHunk": "@@ -132,10 +140,21 @@ public void init() {\n   @SuppressWarnings(\"unchecked\")\n   @Test\n   public void shouldCreateAggregatorWithCorrectParams() {\n-    verify(udafFactory).create(\n-        ImmutableList.of(0, 2),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2ODc1NQ=="}, "originalCommit": {"oid": "5901b729455817f84615377a56c8620380657c5c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTE3Njg3OnYy", "diffSide": "LEFT", "path": "ksql-common/src/main/java/io/confluent/ksql/GenericRow.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjowNzo1MVrOFlBqwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxOTo0MTozN1rOFlhBeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2ODk2MA==", "bodyText": "What happened to this concern about double comparison? Are doubles never being compared in tests?", "url": "https://github.com/confluentinc/ksql/pull/4414#discussion_r374368960", "createdAt": "2020-02-03T22:07:51Z", "author": {"login": "vcrfxia"}, "path": "ksql-common/src/main/java/io/confluent/ksql/GenericRow.java", "diffHunk": "@@ -15,83 +15,111 @@\n \n package io.confluent.ksql;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import java.util.stream.Collectors;\n \n public class GenericRow {\n \n-  private final List<Object> columns;\n+  private final ArrayList<Object> values;\n \n   public GenericRow() {\n-    columns = new ArrayList<>();\n+    this(0);\n   }\n \n-  public GenericRow(final List<Object> columns) {\n-    Objects.requireNonNull(columns);\n-    this.columns = columns;\n+  public GenericRow(final int initialCapacity) {\n+    this.values = new ArrayList<>(initialCapacity);\n   }\n \n-  public GenericRow(final Object ...columns) {\n-    this(Arrays.asList(columns));\n+  @VisibleForTesting // Only use from tests\n+  public static GenericRow genericRow(final Object... columns) {\n+    return new GenericRow().appendAll(Arrays.asList(columns));\n+  }\n+\n+  /**\n+   * Ensure the row has enough capacity to hold {@code additionalCapacity} more elements that its\n+   * current size.\n+   *\n+   * <p>Useful to avoid unnecessary array copies when adding multiple elements.\n+   *\n+   * @param additionalCapacity the number of additional elements\n+   */\n+  public void ensureAdditionalCapacity(final int additionalCapacity) {\n+    values.ensureCapacity(additionalCapacity + values.size());\n+  }\n+\n+  public int size() {\n+    return values.size();\n+  }\n+\n+  public Object get(final int index) {\n+    return values.get(index);\n+  }\n+\n+  public void set(final int index, final Object value) {\n+    values.set(index, value);\n+  }\n+\n+  public GenericRow append(final Object value) {\n+    values.add(value);\n+    return this;\n+  }\n+\n+  public GenericRow appendAll(final Collection<?> values) {\n+    this.values.addAll(values);\n+    return this;\n+  }\n+\n+  @JsonProperty(\"columns\")\n+  public List<Object> values() {\n+    return Collections.unmodifiableList(values);\n   }\n \n   @Override\n   public String toString() {\n-    final StringBuilder stringBuilder = new StringBuilder(\"[ \");\n-    int currentIndex = 0;\n-    for (int i = 0; i < columns.size(); i++) {\n-      final Object obj = columns.get(i);\n-      if (obj == null) {\n-        stringBuilder.append(\"null\");\n-      } else if (obj.getClass().isArray()) {\n-        stringBuilder.append(Arrays.toString((Object[]) obj));\n-      } else if (obj instanceof String) {\n-        stringBuilder.append(\"'\")\n-            .append(obj)\n-            .append(\"'\");\n-      } else {\n-        stringBuilder.append(obj);\n-      }\n-\n-      currentIndex++;\n-      if (currentIndex < columns.size()) {\n-        stringBuilder.append(\" | \");\n-      }\n-    }\n-    stringBuilder.append(\" ]\");\n-    return stringBuilder.toString();\n+    return values.stream()\n+        .map(GenericRow::formatValue)\n+        .collect(Collectors.joining(\" | \", \"[ \", \" ]\"));\n   }\n \n   @Override\n   public boolean equals(final Object o) {\n     if (this == o) {\n       return true;\n     }\n+\n     if (o == null || getClass() != o.getClass()) {\n       return false;\n     }\n-    final GenericRow that = (GenericRow) o;\n-    if (columns.size() != that.columns.size()) {\n-      return false;\n-    }\n \n-    // For now string matching is used to compare the rows as double comparison will cause issues", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5901b729455817f84615377a56c8620380657c5c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg4MjY4MA==", "bodyText": "So GenericRow.equals is only used in tests, so it's only tests that are an issue.\nWhen I made the change some tests passed because the GenericRow was being serialized and deserialized and Jackson is configured to deserializes decimal numbers as BigDecimal. So, for example, serializing a generic row with the double value 1.2 would get deserilized as BigDecimal.valueOf(1.2)... which would cause original.equals(deserialised) to fail.\nBut I just fixed up the tests to do the right thing.", "url": "https://github.com/confluentinc/ksql/pull/4414#discussion_r374882680", "createdAt": "2020-02-04T19:41:37Z", "author": {"login": "big-andy-coates"}, "path": "ksql-common/src/main/java/io/confluent/ksql/GenericRow.java", "diffHunk": "@@ -15,83 +15,111 @@\n \n package io.confluent.ksql;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import java.util.stream.Collectors;\n \n public class GenericRow {\n \n-  private final List<Object> columns;\n+  private final ArrayList<Object> values;\n \n   public GenericRow() {\n-    columns = new ArrayList<>();\n+    this(0);\n   }\n \n-  public GenericRow(final List<Object> columns) {\n-    Objects.requireNonNull(columns);\n-    this.columns = columns;\n+  public GenericRow(final int initialCapacity) {\n+    this.values = new ArrayList<>(initialCapacity);\n   }\n \n-  public GenericRow(final Object ...columns) {\n-    this(Arrays.asList(columns));\n+  @VisibleForTesting // Only use from tests\n+  public static GenericRow genericRow(final Object... columns) {\n+    return new GenericRow().appendAll(Arrays.asList(columns));\n+  }\n+\n+  /**\n+   * Ensure the row has enough capacity to hold {@code additionalCapacity} more elements that its\n+   * current size.\n+   *\n+   * <p>Useful to avoid unnecessary array copies when adding multiple elements.\n+   *\n+   * @param additionalCapacity the number of additional elements\n+   */\n+  public void ensureAdditionalCapacity(final int additionalCapacity) {\n+    values.ensureCapacity(additionalCapacity + values.size());\n+  }\n+\n+  public int size() {\n+    return values.size();\n+  }\n+\n+  public Object get(final int index) {\n+    return values.get(index);\n+  }\n+\n+  public void set(final int index, final Object value) {\n+    values.set(index, value);\n+  }\n+\n+  public GenericRow append(final Object value) {\n+    values.add(value);\n+    return this;\n+  }\n+\n+  public GenericRow appendAll(final Collection<?> values) {\n+    this.values.addAll(values);\n+    return this;\n+  }\n+\n+  @JsonProperty(\"columns\")\n+  public List<Object> values() {\n+    return Collections.unmodifiableList(values);\n   }\n \n   @Override\n   public String toString() {\n-    final StringBuilder stringBuilder = new StringBuilder(\"[ \");\n-    int currentIndex = 0;\n-    for (int i = 0; i < columns.size(); i++) {\n-      final Object obj = columns.get(i);\n-      if (obj == null) {\n-        stringBuilder.append(\"null\");\n-      } else if (obj.getClass().isArray()) {\n-        stringBuilder.append(Arrays.toString((Object[]) obj));\n-      } else if (obj instanceof String) {\n-        stringBuilder.append(\"'\")\n-            .append(obj)\n-            .append(\"'\");\n-      } else {\n-        stringBuilder.append(obj);\n-      }\n-\n-      currentIndex++;\n-      if (currentIndex < columns.size()) {\n-        stringBuilder.append(\" | \");\n-      }\n-    }\n-    stringBuilder.append(\" ]\");\n-    return stringBuilder.toString();\n+    return values.stream()\n+        .map(GenericRow::formatValue)\n+        .collect(Collectors.joining(\" | \", \"[ \", \" ]\"));\n   }\n \n   @Override\n   public boolean equals(final Object o) {\n     if (this == o) {\n       return true;\n     }\n+\n     if (o == null || getClass() != o.getClass()) {\n       return false;\n     }\n-    final GenericRow that = (GenericRow) o;\n-    if (columns.size() != that.columns.size()) {\n-      return false;\n-    }\n \n-    // For now string matching is used to compare the rows as double comparison will cause issues", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2ODk2MA=="}, "originalCommit": {"oid": "5901b729455817f84615377a56c8620380657c5c"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTE3Nzg4OnYy", "diffSide": "RIGHT", "path": "ksql-common/src/main/java/io/confluent/ksql/GenericRow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjowODoxNVrOFlBrZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjowODoxNVrOFlBrZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2OTEyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Ensure the row has enough capacity to hold {@code additionalCapacity} more elements that its\n          \n          \n            \n               * Ensure the row has enough capacity to hold {@code additionalCapacity} more elements than its\n          \n      \n    \n    \n  \n\nnit: typo", "url": "https://github.com/confluentinc/ksql/pull/4414#discussion_r374369124", "createdAt": "2020-02-03T22:08:15Z", "author": {"login": "vcrfxia"}, "path": "ksql-common/src/main/java/io/confluent/ksql/GenericRow.java", "diffHunk": "@@ -15,83 +15,111 @@\n \n package io.confluent.ksql;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import java.util.stream.Collectors;\n \n public class GenericRow {\n \n-  private final List<Object> columns;\n+  private final ArrayList<Object> values;\n \n   public GenericRow() {\n-    columns = new ArrayList<>();\n+    this(0);\n   }\n \n-  public GenericRow(final List<Object> columns) {\n-    Objects.requireNonNull(columns);\n-    this.columns = columns;\n+  public GenericRow(final int initialCapacity) {\n+    this.values = new ArrayList<>(initialCapacity);\n   }\n \n-  public GenericRow(final Object ...columns) {\n-    this(Arrays.asList(columns));\n+  @VisibleForTesting // Only use from tests\n+  public static GenericRow genericRow(final Object... columns) {\n+    return new GenericRow().appendAll(Arrays.asList(columns));\n+  }\n+\n+  /**\n+   * Ensure the row has enough capacity to hold {@code additionalCapacity} more elements that its", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5901b729455817f84615377a56c8620380657c5c"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2316, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}