{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjA1MTI0", "number": 4816, "title": "fix: fix repartition semantics", "bodyText": "Description\nFixes: #4749. (Note: the feature is currently disabled behind the 'allow any key column name' feature flag).\nBackground\nThis change fixes an issue with our repartition semantics.\nOld style query semantics for partition by are broken:\nS1: ROWKEY => B, C  (Meaning S1 has a schema with ROWKEY as the key column, and B and C as value columns - types aren't important).\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\nS2: ROWKEY => B, C\nAs you can see the schema of S2 is still the same.  However, the old data in the key has been lost as its been overridden with the data from B, and the key now duplicates the data stored in B.\nThis loss of data on a SELECT * .. PARTITION BY needed fixing.\nSecondly, with new primitive key work to remove the restriction on key column naming, the same query semantics do not work. e.g.\nS1: A => B, C\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\nS2: B => B, C\nThis fails as the B value column clashes with the B key column!\nThe fix\nThis commit fixes the PARTITION BY semantics so that any PARTITION BY on a specific column sees the old key column being moved to the value and the new key column being moved from the value to the key. For example,\nS1: A => B, C\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\nResults in the schema: S2: B => C, A.\nIf a PARTITION BY is an expression other than a column reference, then ksql will synthesis a new column name. For example,\nS1: A => B, C\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY CAST(B AS INT);\nResults in the schema: S2: KSQL_COL_0 => B, C, A.\nThis github issue will add the ability to use aliases in PARTITION BY expressions, allowing a custom name to be assigned.\nThe approach\nThere are main changes:\n\n\nThe LogicalPlanner has been updated to build the new repartitioned schema via a new PartitionByParamsFactory class.\n\n\nThe streams topology is built differently by introducing a new version of the SelectKey plan step.  The data passed is the same as the old version. However, the new version is handled by a new builder, which knows to build the streams topology in the right way.\n\n\nIt would also have been possible to achieve the second step by adding a defaulted flag to the existing SelectKey step. However, it was felt that clear separation was better.  This means once we go version 1.0 we can just delete the old V1 step, rather than trying to unpick the code that handled a boolean flag.\nTesting done\nUsual.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-03-18T18:44:29Z", "url": "https://github.com/confluentinc/ksql/pull/4816", "merged": true, "mergeCommit": {"oid": "609e9e28ca5cbbc9302e66f0fc54a983afd256de"}, "closed": true, "closedAt": "2020-03-20T15:52:13Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcO70B1gH2gAyMzkwNjA1MTI0OmVmNjNmZWI1Yjk3Y2FjMjc3MWZmMTViZTExM2ViNjI5ZWI0YWQ0OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPiW4vgFqTM3ODU5MDQ0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/ef63feb5b97cac2771ff15be113eb629eb4ad498", "committedDate": "2020-03-18T18:42:15Z", "message": "fix: fix repartition semantics\n\nFixes: https://github.com/confluentinc/ksql/issues/4749\n\n##### Background\n\nThis change fixes an issue with our repartition semantics.\n\nOld style query semantics for partition by are broken:\n\nS1: ROWKEY => B, C  (Meaning S1 has a schema with ROWKEY as the key column, and B and C as value columns - types aren't important).\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\n```\n\nS2: ROWKEY => B, C\n\nAs you can see the schema of S2 is still the same.  However, the old data in the key has been lost as its been overridden with the data from B, and the key now duplicates the data stored in B.\n\nThis loss of data on a `SELECT * .. PARTITION BY` needed fixing.\n\nSecondly, with new primitive key [work to remove the restriction on key column naming](https://github.com/confluentinc/ksql/issues/3536), the same query semantics do not work. e.g.\n\nS1: A => B, C\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\n```\n\nS2: B => B, C\n\nThis fails as the `B` value column clashes with the `B` key column!\n\n##### The fix\n\nThis commit fixes the PARTITION BY semantics so that any PARTITION BY on a specific column sees the old key column being moved to the value and the new key column being moved from the value to the key. For example,\n\nS1: A => B, C\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\n```\n\nResults in the schema: S2: B => C, A.\n\nIf a PARTITION BY is an expression other than a column reference, then ksql will synthesis a new column name. For example,\n\nS1: A => B, C\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY CAST(B AS INT);\n```\n\nResults in the schema: S2: KSQL_COL_0 => B, C, A.\n\n[This github issue](https://github.com/confluentinc/ksql/issues/4813) will add the ability to use aliases in PARTITION BY expressions, allowing a custom name to be assigned."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3OTY3NzAz", "url": "https://github.com/confluentinc/ksql/pull/4816#pullrequestreview-377967703", "createdAt": "2020-03-19T18:01:53Z", "commit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowMTo1NFrOF46S-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoyMToyMlrOF46-2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA==", "bodyText": "clearly this happens somewhere, but I'm not sure where, don't we need to remove the paritionByCol if it existed in the value?", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395219704", "createdAt": "2020-03-19T18:01:54Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMTMwOA==", "bodyText": "we might already have been doing this, but why do we filter out null keys and values?\n\nEDIT: just saw #4823", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395221308", "createdAt": "2020-03-19T18:04:35Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());\n+\n+    if (!partitionByCol.isPresent()) {\n+      // New key column added, copy in to value schema:\n+      builder.valueColumn(newKeyName, keyType);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  private static Optional<Column> getPartitionByCol(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy\n+  ) {\n+    if (!(partitionBy instanceof ColumnReferenceExp)) {\n+      return Optional.empty();\n+    }\n+\n+    final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+    final Column column = sourceSchema\n+        .findValueColumn(columnName)\n+        .orElseThrow(() -> new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+    return Optional.of(column);\n+  }\n+\n+  private static PartitionByParams buildMapper(\n+      final LogicalSchema resultSchema,\n+      final Optional<Column> partitionByCol,\n+      final Function<GenericRow, Object> evaluator\n+  ) {\n+    // If partitioning by something other than an existing column, then a new key will have\n+    // been synthesized. This new key must be appended to the value to make it available for\n+    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n+    final boolean appendNewKey = !partitionByCol.isPresent();\n+\n+    final KeyBuilder keyBuilder = StructKeyUtil.keyBuilder(resultSchema);\n+\n+    final BiPredicate<Struct, GenericRow> predicate = (k, v) -> {\n+      if (v == null) {\n+        return false;\n+      }\n+\n+      return evaluator.apply(v) != null;\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMjY4Mg==", "bodyText": "I thought we should never get to the situation where a key and value column have the same name? (or is this now temporarily possible during the partition by step? that seems not ideal)", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395222682", "createdAt": "2020-03-19T18:06:58Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "diffHunk": "@@ -75,7 +79,7 @@\n \n   private static final LogicalSchema RESULT_SCHEMA = LogicalSchema.builder()\n       .withRowTime()\n-      .keyColumn(SchemaUtil.ROWKEY_NAME, SqlTypes.BIGINT)\n+      .keyColumn(ColumnName.of(\"BOI\"), SqlTypes.BIGINT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzAwNQ==", "bodyText": "I feel like we should generate the name of the partition by column during the AstSanitizer step (just as we do for other expressions without column names). Unfortunately that probably requires supporting column names in PARTITION BY - is that something that's on your radar? This isn't a blocker for this PR, but I want to make sure we have a path forward that's backwards compatible.\nThis change might be hard to implement in the future - we generate KSQL_COL_x based on the location of the column, not the number of previous generated columns, so the algorithms wouldn't necessarily line up. Is this nextGeneratedColumnAlias specified anywhere in the serialized plan?", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395227005", "createdAt": "2020-03-19T18:14:36Z", "author": {"login": "agavra"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -61,4 +70,42 @@ public static ColumnName generatedJoinColumnAlias(\n   public static boolean isAggregate(final ColumnName name) {\n     return name.text().startsWith(AGGREGATE_COLUMN_PREFIX);\n   }\n+\n+  /**\n+   * Determines the next unique column alias.\n+   *\n+   * <p>Finds any existing {@code KSQL_COL_x} column names in the supplied {@code sourceSchema} to\n+   * ensure the returned generated column name is unique.\n+   *\n+   * @param sourceSchema the source schema.\n+   * @return a column name in the form {@code KSQL_COL_x} which does not clash with source schema.\n+   */\n+  public static ColumnName nextGeneratedColumnAlias(final LogicalSchema sourceSchema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyOTkxOQ==", "bodyText": "can we add a test here to partition by an expression?", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395229919", "createdAt": "2020-03-19T18:19:39Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1,5 +1,121 @@\n {\n   \"tests\": [\n+    {\n+      \"name\": \"only key column - select star\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIzMDkzOQ==", "bodyText": "will we be able to change this in the future or will we always have a V2 stuck in there? that seems like it might be motivation to go down the boolean path...", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395230939", "createdAt": "2020-03-19T18:21:22Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/resources/ksql-plan-schema/schema.json", "diffHunk": "@@ -427,6 +429,28 @@\n       \"title\" : \"streamSelectKeyV1\",\n       \"required\" : [ \"@type\", \"properties\", \"source\", \"keyExpression\" ]\n     },\n+    \"StreamSelectKey\" : {\n+      \"type\" : \"object\",\n+      \"additionalProperties\" : false,\n+      \"properties\" : {\n+        \"@type\" : {\n+          \"type\" : \"string\",\n+          \"enum\" : [ \"streamSelectKeyV2\" ],\n+          \"default\" : \"streamSelectKeyV2\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e35587a5d918307a002546289414b63fa829624", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/8e35587a5d918307a002546289414b63fa829624", "committedDate": "2020-03-20T11:09:49Z", "message": "chore: changes requested by Almog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTkwNDQ5", "url": "https://github.com/confluentinc/ksql/pull/4816#pullrequestreview-378590449", "createdAt": "2020-03-20T15:36:43Z", "commit": {"oid": "8e35587a5d918307a002546289414b63fa829624"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 32, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}