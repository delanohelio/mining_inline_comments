{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3ODIwMzA2", "number": 5360, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToxMToxNlrOD8hfaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMTo0OVrOD8hycw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzg5ODY3OnYy", "diffSide": "RIGHT", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToxMToxNlrOGVg-yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozOToxNFrOGVrbcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIxMzY0MQ==", "bodyText": "Why wrap it in an exception?", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425213641", "createdAt": "2020-05-14T15:11:16Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -55,6 +56,7 @@ protected void handleValue(final Row row) {\n \n   @Override\n   protected void handleError(final Throwable t) {\n+    failed = true;\n     errorHandler.accept(new Exception(t));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NDgxNw==", "bodyText": "Previously it was being passed into a handler that required an Exception rather than a Throwable but this is no longer the case so I've removed this.\nOut of curiosity, do you know why reactive streams methods expect Throwables for errors, rather than Exceptions? Most other APIs I've seen work with Exceptions.", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425384817", "createdAt": "2020-05-14T19:39:14Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -55,6 +56,7 @@ protected void handleValue(final Row row) {\n \n   @Override\n   protected void handleError(final Throwable t) {\n+    failed = true;\n     errorHandler.accept(new Exception(t));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIxMzY0MQ=="}, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzkzODI1OnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BufferedPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToxOTo1N1rOGVhXxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozNjowNVrOGVrVCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDAzOA==", "bodyText": "If hasSentComplete, isn't complete always true?", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425220038", "createdAt": "2020-05-14T15:19:57Z", "author": {"login": "purplefox"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BufferedPublisher.java", "diffHunk": "@@ -90,10 +90,10 @@ public BufferedPublisher(final Context ctx, final int bufferMaxSize) {\n    */\n   public boolean accept(final T t) {\n     checkContext();\n-    if (complete) {\n+    if (isComplete() || hasSentComplete()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MzE3Ng==", "bodyText": "Not necessarily. A user could call close() on the publisher, which immediately calls subscriber.onComplete() (if a subscriber is present) without marking the publisher as complete (or waiting for any buffered rows to be delivered, in the case of BufferedPublisher).\nIs this not the expected behavior?", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425383176", "createdAt": "2020-05-14T19:36:05Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BufferedPublisher.java", "diffHunk": "@@ -90,10 +90,10 @@ public BufferedPublisher(final Context ctx, final int bufferMaxSize) {\n    */\n   public boolean accept(final T t) {\n     checkContext();\n-    if (complete) {\n+    if (isComplete() || hasSentComplete()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDAzOA=="}, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzk0MTgyOnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMDozOVrOGVhZ-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozMjowOFrOGVrMxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDYwMQ==", "bodyText": "I think cancelled can be removed completely now?", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425220601", "createdAt": "2020-05-14T15:20:39Z", "author": {"login": "purplefox"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "diffHunk": "@@ -37,6 +37,8 @@\n   private Subscriber<? super T> subscriber;\n   private long demand;\n   private boolean cancelled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MTA2MQ==", "bodyText": "A user can still call cancel() on the subscription right? If this happens, subsequent calls to BufferedPublisher#accept() will not actually add to the buffer.", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425381061", "createdAt": "2020-05-14T19:32:08Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "diffHunk": "@@ -37,6 +37,8 @@\n   private Subscriber<? super T> subscriber;\n   private long demand;\n   private boolean cancelled;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDYwMQ=="}, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzk0NzM5OnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMTo0OVrOGVhdaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMDo0ODo0M1rOGVtpgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMTQ4MQ==", "bodyText": "I think sentComplete and failure should be volatile as they're accessed outside of a monitor", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425221481", "createdAt": "2020-05-14T15:21:49Z", "author": {"login": "purplefox"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "diffHunk": "@@ -37,6 +37,8 @@\n   private Subscriber<? super T> subscriber;\n   private long demand;\n   private boolean cancelled;\n+  private boolean sentComplete;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MDEzOQ==", "bodyText": "The same is true for subscriber, demand, and cancelled, right? I've marked them all as volatile.", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425380139", "createdAt": "2020-05-14T19:30:10Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "diffHunk": "@@ -37,6 +37,8 @@\n   private Subscriber<? super T> subscriber;\n   private long demand;\n   private boolean cancelled;\n+  private boolean sentComplete;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMTQ4MQ=="}, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMTE4NQ==", "bodyText": "Nvm, I misread.\n\nYou're certainly right that failure needs to be volatile since it's access from BasePublisher#subscribe() before the check that guarantees we're on the right context.\nsubscriber needs to be volatile since it's accessed from TestQueryPublisher#hasSubscriber() and TestQueryPublisher#sendError(), which don't have the context guarantee.\nsentComplete, demand, and cancelled don't need to be volatile at the moment since all current usages of these fields are after corresponding context checks, but they all have protected accessors so we're liable to reintroducing similar bugs in the future :-/ Is there a way to guard against this?\n\nI've removed the extra volatiles I added and only left the keyword on failure and subscriber for now.", "url": "https://github.com/confluentinc/ksql/pull/5360#discussion_r425421185", "createdAt": "2020-05-14T20:48:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/reactive/BasePublisher.java", "diffHunk": "@@ -37,6 +37,8 @@\n   private Subscriber<? super T> subscriber;\n   private long demand;\n   private boolean cancelled;\n+  private boolean sentComplete;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMTQ4MQ=="}, "originalCommit": {"oid": "630c823a12447c1f025036819fd7b5ed75738086"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3417, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}