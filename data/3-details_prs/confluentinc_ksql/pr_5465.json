{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMTA4NTcw", "number": 5465, "title": "chore: switch synthetic join key to use ROWKEY", "bodyText": "Description\nThis change switching the naming of the synthetic key column created by some joins to use the name ROWKEY, or ROWKEY_1, ROWKEY_2 etc if the is a name clash.\nThe change also contains tidy up and refactoring. Specifically, realizing that the validation Analyzer does is shared with pull queries, so it doesn't make sense to move this validation.  Instead, given the synthetic key column is a short to medium term problem only, i.e. it will go away with time, switched the design so that all validation returns to Analyzer, except is now won't through on an unknown column is it might be a synthetic key column.  Validation of potential synthetic key columns are handled by the logic model. This works because pull queries don't (yet) have this problem.\n\nThere was duplicate logic between AstSantizer and Analayzer around reporting ambiguous and unknown columns.\n\nChanged so that, for now, AstSanitzer reports ambiguous columns and Analyzer reports unknown columns. Not perfect, but better than both attempting to do both.\n\n\nIt puts back the validation of Selects in Analyser and enhanced it and ColumnReferenceValidator to know when a synthetic key column is possible and to not throw on one. False positives are possible, but are caught by the logical model.\nSimplified the logical model to only worry about validating synthetic key columns in projections.\nSplit RepartitionNode into classes specific for its two use-cases.\n\nReviewing notes:\nCommits split in the usual way.\nTesting done\nusual\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-05-22T19:29:47Z", "url": "https://github.com/confluentinc/ksql/pull/5465", "merged": true, "mergeCommit": {"oid": "9ed09e1da53f768f71cc83f4ee33d73ddb87fc12"}, "closed": true, "closedAt": "2020-05-23T09:18:27Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcj3b_ZgH2gAyNDIyMTA4NTcwOmJjODMwNjZjYTBkMjdiNDY1ZWU4ZDcwYmI4ODBlMjNlZDhhNzY5ZjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcj7eOvgH2gAyNDIyMTA4NTcwOmIxZDViYmRiYWE0ODYxZjU3OTgyNTA5OTg2NWZlMmNlNWQ4Nzg4N2Q=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "committedDate": "2020-05-22T19:28:47Z", "message": "chore: switch synthetic join key to use ROWKEY\n\nThis change switching the naming of the synthetic key column created by some joins to use the name `ROWKEY`, or `ROWKEY_1`, `ROWKEY_2` etc if the is a name clash.\n\nThe change also contains tidy up and refactoring. Specifically, realizing that the validation `Analyzer` does is shared with pull queries, so it doesn't make sense to move this validation.  Instead, given the synthetic key column is a short to medium term problem only, i.e. it will go away with time, switched the design so that all validation returns to `Analyzer`, except is now won't through on an unknown column is it _might_ be a synthetic key column.  Validation of potential synthetic key columns are handled by the logic model. This works because pull queries don't (yet) have this problem.\n\n - There was duplicate logic between `AstSantizer` and `Analayzer` around reporting ambiguous and unknown columns.\n    - Changed so that, for now, `AstSanitzer` reports ambiguous columns and `Analyzer` reports unknown columns. Not perfect, but better than both attempting to do both.\n - It puts back the validation of Selects in `Analyser` and enhanced it and `ColumnReferenceValidator` to know when a synthetic key column is possible and to not throw on one. False positives are possible, but are caught by the logical model.\n - Simplified the logical model to only worry about validating synthetic key columns in projections.\n - Split `RepartitionNode` into classes specific for its two use-cases."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f71f852804cc9570179e7d3532f5ab7e2af60dba", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/f71f852804cc9570179e7d3532f5ab7e2af60dba", "committedDate": "2020-05-22T19:30:59Z", "message": "test: test code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a6a8013a5fb0b52eb79a3a699e4833d5e7aadeb", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/0a6a8013a5fb0b52eb79a3a699e4833d5e7aadeb", "committedDate": "2020-05-22T19:31:14Z", "message": "test: historical plans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjIyNzc5", "url": "https://github.com/confluentinc/ksql/pull/5465#pullrequestreview-417222779", "createdAt": "2020-05-22T23:23:38Z", "commit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyMzozOVrOGZl1zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyNzozOFrOGZl4Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzU2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // AstSanitizer should catches ambiguous columns\n          \n          \n            \n                        // AstSanitizer should catch ambiguous columns", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487565", "createdAt": "2020-05-22T23:23:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw==", "bodyText": "seems like if we're checking equality it should be made either an enum or a constant", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487713", "createdAt": "2020-05-22T23:24:49Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns\n+            return Iterables.getOnlyElement(sourcesWithField);\n+          });\n+\n+      referencedSources.add(source);\n+    }\n \n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + name.text() + \"' is ambiguous. \"\n-            + \"Could be any of: \" + possibilities);\n+    private boolean couldBeSyntheticJoinColumn(final ColumnReferenceExp colRef) {\n+      if (!possibleSyntheticColumns) {\n+        // Some queries never have synthetic columns, e.g. pull or aggregations.\n+        return false;\n       }\n \n-      return Optional.of(Iterables.getOnlyElement(sourcesWithField));\n-    }\n+      if (!sourceSchemas.isJoin()) {\n+        // Synthetic join columns only occur in joins... duh!\n+        return false;\n+      }\n \n-    private String errorPrefix(final Optional<NodeLocation> location) {\n-      final String loc = location\n-          .map(Objects::toString)\n-          .map(text -> text + \": \")\n-          .orElse(\"\");\n+      if (colRef instanceof QualifiedColumnReferenceExp) {\n+        // Synthetic join columns can't be qualified, as they don't belong to any source\n+        return false;\n+      }\n+\n+      if (!clauseType.equals(\"SELECT\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4ODE1OA==", "bodyText": "would be nice to javadoc", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429488158", "createdAt": "2020-05-22T23:27:38Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+\n+public class PreJoinRepartitionNode extends RepartitionNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1d5bbdbaa4861f579825099865fe2ce5d87887d", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/b1d5bbdbaa4861f579825099865fe2ce5d87887d", "committedDate": "2020-05-23T00:10:51Z", "message": "chore: almog's requested changes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4672, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}