{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzYyNzcy", "number": 4507, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxMzowMlrODepubA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo0NDo1N1rODe7__w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDY3NTAwOnYy", "diffSide": "RIGHT", "path": "docs-md/developer-guide/ksqldb-reference/print.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxMzowMlrOFn6Kbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxMzowMlrOFn6Kbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTcyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\n          \n          \n            \n            ksqlDB attempts to determine the format of the data in the topic and outputs what it thinks are", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377391727", "createdAt": "2020-02-11T00:13:02Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/developer-guide/ksqldb-reference/print.md", "diffHunk": "@@ -39,13 +39,24 @@ The following statement shows how to print all of the records in a topic named\n PRINT ksql__commands FROM BEGINNING;\r\n ```\r\n \r\n+ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDY3NjYwOnYy", "diffSide": "RIGHT", "path": "docs-md/developer-guide/ksqldb-reference/print.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxMzo1MFrOFn6LVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxMzo1MFrOFn6LVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTk1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE`s, as\n          \n          \n            \n               For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE` values, because", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377391959", "createdAt": "2020-02-11T00:13:50Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/developer-guide/ksqldb-reference/print.md", "diffHunk": "@@ -39,13 +39,24 @@ The following statement shows how to print all of the records in a topic named\n PRINT ksql__commands FROM BEGINNING;\r\n ```\r\n \r\n+ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\r\n+the key and value formats at the top of the output.\r\n+\r\n+!!! note\r\n+   Attempting to determine a data format from only the serialized bytes is not an exact science!\r\n+   For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE`s, as\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDY3NzM4OnYy", "diffSide": "RIGHT", "path": "docs-md/developer-guide/ksqldb-reference/print.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxNDoxN1rOFn6LyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMDoxNDoxN1rOFn6LyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MjA3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               they both occupy 8 bytes. Short strings can also be mistaken for serialized numbers.\n          \n          \n            \n               they both occupy eight bytes. Short strings can also be mistaken for serialized numbers.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377392073", "createdAt": "2020-02-11T00:14:17Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/developer-guide/ksqldb-reference/print.md", "diffHunk": "@@ -39,13 +39,24 @@ The following statement shows how to print all of the records in a topic named\n PRINT ksql__commands FROM BEGINNING;\r\n ```\r\n \r\n+ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\r\n+the key and value formats at the top of the output.\r\n+\r\n+!!! note\r\n+   Attempting to determine a data format from only the serialized bytes is not an exact science!\r\n+   For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE`s, as\r\n+   they both occupy 8 bytes. Short strings can also be mistaken for serialized numbers.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzU5MzUzOnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOToyMTo0NlrOFoV61g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1NTowNFrOFoW_hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NjQ4Ng==", "bodyText": "nit (not your code): constants for 3 and 1 (no idea what these mean \ud83d\ude02 )", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377846486", "createdAt": "2020-02-11T19:21:46Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NDA2OQ==", "bodyText": "neither do I! :D", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377864069", "createdAt": "2020-02-11T19:55:04Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NjQ4Ng=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzU5OTQ4OnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOToyMzozM1rOFoV-yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1NTo0MVrOFoXAyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NzQ5OA==", "bodyText": "nit(personal preference): for internal variables I actually prefer nulls to Optionals as we're not exposing it anywhere and then we don't need to keep calling get everywhere when we know it'll be not-null at that point", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377847498", "createdAt": "2020-02-11T19:23:33Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NDM5NQ==", "bodyText": "Next PR removes these anyway.  Though I still prefer encoding optionality into the type system.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377864395", "createdAt": "2020-02-11T19:55:41Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NzQ5OA=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzYyNTIxOnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTozMToyMFrOFoWPZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1NjozMVrOFoXCbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MTc0OA==", "bodyText": "can you add some documentation on how this \"algorithm\" works? i.e. explain how it chooses the formatter, what the default is and the batching mechanism", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377851748", "createdAt": "2020-02-11T19:31:20Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NDgxMw==", "bodyText": "Good call. It's changing in the next PR. I'll add a local todo to add docs.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377864813", "createdAt": "2020-02-11T19:56:31Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MTc0OA=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzYyOTE0OnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTozMjozNlrOFoWR1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1ODozMVrOFoXGQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MjM3Mg==", "bodyText": "I'm not sure I understand why we needed to turn this into a String?", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377852372", "createdAt": "2020-02-11T19:32:36Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {\n+      return keyFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    public String getValueFormat() {\n+      return valueFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    private Optional<Formatter> getKeyFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::key);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> getValueFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::value);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> findFormatter(final Stream<Bytes> dataStream) {\n+      final List<Formatter> formatters = dataStream\n+          .filter(Objects::nonNull)\n+          .filter(d -> d.get() != null)\n+          .map(this::findFormatter)\n+          .collect(Collectors.toList());\n+\n+      final Set<String> formats = formatters.stream()\n+          .map(Formatter::getFormat)\n+          .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NTc5Mg==", "bodyText": "Because the format now has more info in it, e.g. KAFKA (STRING).  The (STRING) is additional info.\nHowever, again, this will change in the next PR.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377865792", "createdAt": "2020-02-11T19:58:31Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {\n+      return keyFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    public String getValueFormat() {\n+      return valueFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    private Optional<Formatter> getKeyFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::key);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> getValueFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::value);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> findFormatter(final Stream<Bytes> dataStream) {\n+      final List<Formatter> formatters = dataStream\n+          .filter(Objects::nonNull)\n+          .filter(d -> d.get() != null)\n+          .map(this::findFormatter)\n+          .collect(Collectors.toList());\n+\n+      final Set<String> formats = formatters.stream()\n+          .map(Formatter::getFormat)\n+          .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MjM3Mg=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzYzMzU2OnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTozNDowN1rOFoWUnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDowMDo1MFrOFoXKpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzA4NA==", "bodyText": "nit: getKeyFormatName", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377853084", "createdAt": "2020-02-11T19:34:07Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NjkxOA==", "bodyText": "Maybe. Though what's being returned hasn't changed really. Sure it returned an enum before, but the only place that was used changed it to a string.  Now it returns a string containing the details of the format.\nIf it stays in the new code I'll look into the naming.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377866918", "createdAt": "2020-02-11T20:00:50Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzA4NA=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzYzNjUyOnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTozNTowN1rOFoWWgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDowMTowNlrOFoXLLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzU2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String getFormat();\n          \n          \n            \n                String getFormatName();", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377853569", "createdAt": "2020-02-11T19:35:07Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {\n+      return keyFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    public String getValueFormat() {\n+      return valueFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    private Optional<Formatter> getKeyFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::key);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> getValueFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::value);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> findFormatter(final Stream<Bytes> dataStream) {\n+      final List<Formatter> formatters = dataStream\n+          .filter(Objects::nonNull)\n+          .filter(d -> d.get() != null)\n+          .map(this::findFormatter)\n+          .collect(Collectors.toList());\n+\n+      final Set<String> formats = formatters.stream()\n+          .map(Formatter::getFormat)\n+          .collect(Collectors.toSet());\n+\n+      switch (formats.size()) {\n+        case 0:\n+          // No viable records (will try again with next batch):\n+          return Optional.empty();\n+\n+        case 1:\n+          // Single format:\n+          return Optional.of(formatters.get(0));\n+\n+        default:\n+          // Mixed format topic:\n+          return Format.MIXED.maybeGetFormatter(topicName, null, avroDeserializer);\n+      }\n     }\n \n-    private Formatter getFormatter(final ConsumerRecord<String, Bytes> record) {\n+    private Formatter findFormatter(final Bytes data) {\n       return Arrays.stream(Format.values())\n-          .map(f -> f.maybeGetFormatter(topicName, record, avroDeserializer, dateFormat))\n+          .map(f -> f.maybeGetFormatter(topicName, data, avroDeserializer))\n           .filter(Optional::isPresent)\n           .map(Optional::get)\n           .findFirst()\n-          .orElseThrow(() -> new RuntimeException(\"Unexpected\"));\n+          .orElseThrow(() -> new IllegalStateException(\"Unexpected\"));\n     }\n   }\n \n   interface Formatter {\n \n-    String print(ConsumerRecord<String, Bytes> consumerRecord) throws IOException;\n+    String print(Bytes data) throws IOException;\n \n-    Format getFormat();\n+    String getFormat();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NzA1NQ==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377867055", "createdAt": "2020-02-11T20:01:06Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {\n+      return keyFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    public String getValueFormat() {\n+      return valueFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    private Optional<Formatter> getKeyFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::key);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> getValueFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::value);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> findFormatter(final Stream<Bytes> dataStream) {\n+      final List<Formatter> formatters = dataStream\n+          .filter(Objects::nonNull)\n+          .filter(d -> d.get() != null)\n+          .map(this::findFormatter)\n+          .collect(Collectors.toList());\n+\n+      final Set<String> formats = formatters.stream()\n+          .map(Formatter::getFormat)\n+          .collect(Collectors.toSet());\n+\n+      switch (formats.size()) {\n+        case 0:\n+          // No viable records (will try again with next batch):\n+          return Optional.empty();\n+\n+        case 1:\n+          // Single format:\n+          return Optional.of(formatters.get(0));\n+\n+        default:\n+          // Mixed format topic:\n+          return Format.MIXED.maybeGetFormatter(topicName, null, avroDeserializer);\n+      }\n     }\n \n-    private Formatter getFormatter(final ConsumerRecord<String, Bytes> record) {\n+    private Formatter findFormatter(final Bytes data) {\n       return Arrays.stream(Format.values())\n-          .map(f -> f.maybeGetFormatter(topicName, record, avroDeserializer, dateFormat))\n+          .map(f -> f.maybeGetFormatter(topicName, data, avroDeserializer))\n           .filter(Optional::isPresent)\n           .map(Optional::get)\n           .findFirst()\n-          .orElseThrow(() -> new RuntimeException(\"Unexpected\"));\n+          .orElseThrow(() -> new IllegalStateException(\"Unexpected\"));\n     }\n   }\n \n   interface Formatter {\n \n-    String print(ConsumerRecord<String, Bytes> consumerRecord) throws IOException;\n+    String print(Bytes data) throws IOException;\n \n-    Format getFormat();\n+    String getFormat();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzU2OQ=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzY1ODM3OnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo0MTo0MFrOFoWj_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDowMTo1OFrOFoXMsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1NzAyMQ==", "bodyText": "this comment is a little confusing - so what if they're indistinguishable? Are we returning Optional.empty because we'd rather default to DELIMITED than \"inline\" JSON?", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377857021", "createdAt": "2020-02-11T19:41:40Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -150,87 +258,128 @@ public Format getFormat() {\n       @Override\n       public Optional<Formatter> maybeGetFormatter(\n           final String topicName,\n-          final ConsumerRecord<String, Bytes> record,\n-          final KafkaAvroDeserializer avroDeserializer,\n-          final DateFormat dateFormat) {\n+          final Bytes data,\n+          final KafkaAvroDeserializer avroDeserializer\n+      ) {\n         try {\n-          final JsonNode jsonNode = JsonMapper.INSTANCE.mapper.readTree(record.value().toString());\n+          final JsonNode jsonNode = JsonMapper.INSTANCE.mapper.readTree(data.toString());\n \n-          // If the JsonNode is not structured like 'key:value', then do not use JSON to print\n-          // this value\n-          if (!(jsonNode instanceof ObjectNode)) {\n+          if (!(jsonNode instanceof ObjectNode) && !(jsonNode instanceof ArrayNode)) {\n+            // Other valid JSON types, e.g. NumericNode, BooleanNode, etc\n+            // are indistinguishable from single column delimited format:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NzQ0Mg==", "bodyText": "If this stays in the next version I'll add more info. However, I don't think it will be.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377867442", "createdAt": "2020-02-11T20:01:58Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -150,87 +258,128 @@ public Format getFormat() {\n       @Override\n       public Optional<Formatter> maybeGetFormatter(\n           final String topicName,\n-          final ConsumerRecord<String, Bytes> record,\n-          final KafkaAvroDeserializer avroDeserializer,\n-          final DateFormat dateFormat) {\n+          final Bytes data,\n+          final KafkaAvroDeserializer avroDeserializer\n+      ) {\n         try {\n-          final JsonNode jsonNode = JsonMapper.INSTANCE.mapper.readTree(record.value().toString());\n+          final JsonNode jsonNode = JsonMapper.INSTANCE.mapper.readTree(data.toString());\n \n-          // If the JsonNode is not structured like 'key:value', then do not use JSON to print\n-          // this value\n-          if (!(jsonNode instanceof ObjectNode)) {\n+          if (!(jsonNode instanceof ObjectNode) && !(jsonNode instanceof ArrayNode)) {\n+            // Other valid JSON types, e.g. NumericNode, BooleanNode, etc\n+            // are indistinguishable from single column delimited format:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1NzAyMQ=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzY2OTExOnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStreamWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo0NDo1N1rOFoWqxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDowNDoyNlrOFoXQ_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1ODc1Nw==", "bodyText": "is it possible that the format has changed between last time we did a format and now (e.g. first few records happened to deserialize as JSON, but actually it was KAFKA or something like that)? if so should we print it again?", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377858757", "createdAt": "2020-02-11T19:44:57Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStreamWriter.java", "diffHunk": "@@ -60,59 +62,66 @@ public static TopicStreamWriter create(\n             serviceContext,\n             consumerProperties,\n             printTopic),\n-        printTopic.getTopic().toString(),\n+        printTopic.getTopic(),\n         printTopic.getIntervalValue(),\n         disconnectCheckInterval,\n         printTopic.getLimit());\n   }\n \n   TopicStreamWriter(\n       final SchemaRegistryClient schemaRegistryClient,\n-      final KafkaConsumer<String, Bytes> topicConsumer,\n+      final KafkaConsumer<Bytes, Bytes> topicConsumer,\n       final String topicName,\n       final long interval,\n       final Duration disconnectCheckInterval,\n       final OptionalInt limit\n   ) {\n-    this.topicConsumer = topicConsumer;\n-    this.schemaRegistryClient = schemaRegistryClient;\n-    this.topicName = topicName;\n+    this.topicConsumer = requireNonNull(topicConsumer, \"topicConsumer\");\n+    this.schemaRegistryClient = requireNonNull(schemaRegistryClient, \"schemaRegistryClient\");\n+    this.topicName = requireNonNull(topicName, \"topicName\");\n     this.interval = interval;\n-    this.limit = limit;\n-    this.disconnectCheckInterval = Objects\n-        .requireNonNull(disconnectCheckInterval, \"disconnectCheckInterval\");\n-\n+    this.limit = requireNonNull(limit, \"limit\");\n+    this.disconnectCheckInterval =\n+        requireNonNull(disconnectCheckInterval, \"disconnectCheckInterval\");\n     this.messagesWritten = 0;\n     this.messagesPolled = 0;\n+\n+    if (interval < 1) {\n+      throw new IllegalArgumentException(\"INTERVAL must be greater than one, but was: \" + interval);\n+    }\n   }\n \n   @Override\n   public void write(final OutputStream out) {\n     try {\n       final RecordFormatter formatter = new RecordFormatter(schemaRegistryClient, topicName);\n+\n       boolean printFormat = true;\n       while (true) {\n-        final ConsumerRecords<String, Bytes> records = topicConsumer.poll(disconnectCheckInterval);\n+        final ConsumerRecords<Bytes, Bytes> records = topicConsumer.poll(disconnectCheckInterval);\n         if (records.isEmpty()) {\n-          out.write(\"\\n\".getBytes(StandardCharsets.UTF_8));\n+          out.write(\"\\n\".getBytes(UTF_8));\n           out.flush();\n-        } else {\n-          final List<String> values = formatter.format(records);\n-          for (final String value : values) {\n-            if (printFormat) {\n-              printFormat = false;\n-              out.write((\"Format:\" + formatter.getFormat().name() + \"\\n\")\n-                            .getBytes(StandardCharsets.UTF_8));\n-            }\n-            if (messagesPolled++ % interval == 0) {\n-              messagesWritten++;\n-              out.write(value.getBytes(StandardCharsets.UTF_8));\n-              out.flush();\n-            }\n+          continue;\n+        }\n+\n+        final List<Supplier<String>> values = formatter.format(records.records(topicName));\n+        for (final Supplier<String> value : values) {\n+          if (printFormat) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2ODU0MQ==", "bodyText": "That's not how it works.\nThe formatter previously based its choice of format on the first record and then stuck with that. The new version improves this slightly by looking at the first batch of records. However, once the format is detected its never changed.\nThis boolean hasn't changed either. It just ensures the format is output before the first row of data.\nAgain, as discussed offline, this is also changing in the next verison.", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377868541", "createdAt": "2020-02-11T20:04:26Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStreamWriter.java", "diffHunk": "@@ -60,59 +62,66 @@ public static TopicStreamWriter create(\n             serviceContext,\n             consumerProperties,\n             printTopic),\n-        printTopic.getTopic().toString(),\n+        printTopic.getTopic(),\n         printTopic.getIntervalValue(),\n         disconnectCheckInterval,\n         printTopic.getLimit());\n   }\n \n   TopicStreamWriter(\n       final SchemaRegistryClient schemaRegistryClient,\n-      final KafkaConsumer<String, Bytes> topicConsumer,\n+      final KafkaConsumer<Bytes, Bytes> topicConsumer,\n       final String topicName,\n       final long interval,\n       final Duration disconnectCheckInterval,\n       final OptionalInt limit\n   ) {\n-    this.topicConsumer = topicConsumer;\n-    this.schemaRegistryClient = schemaRegistryClient;\n-    this.topicName = topicName;\n+    this.topicConsumer = requireNonNull(topicConsumer, \"topicConsumer\");\n+    this.schemaRegistryClient = requireNonNull(schemaRegistryClient, \"schemaRegistryClient\");\n+    this.topicName = requireNonNull(topicName, \"topicName\");\n     this.interval = interval;\n-    this.limit = limit;\n-    this.disconnectCheckInterval = Objects\n-        .requireNonNull(disconnectCheckInterval, \"disconnectCheckInterval\");\n-\n+    this.limit = requireNonNull(limit, \"limit\");\n+    this.disconnectCheckInterval =\n+        requireNonNull(disconnectCheckInterval, \"disconnectCheckInterval\");\n     this.messagesWritten = 0;\n     this.messagesPolled = 0;\n+\n+    if (interval < 1) {\n+      throw new IllegalArgumentException(\"INTERVAL must be greater than one, but was: \" + interval);\n+    }\n   }\n \n   @Override\n   public void write(final OutputStream out) {\n     try {\n       final RecordFormatter formatter = new RecordFormatter(schemaRegistryClient, topicName);\n+\n       boolean printFormat = true;\n       while (true) {\n-        final ConsumerRecords<String, Bytes> records = topicConsumer.poll(disconnectCheckInterval);\n+        final ConsumerRecords<Bytes, Bytes> records = topicConsumer.poll(disconnectCheckInterval);\n         if (records.isEmpty()) {\n-          out.write(\"\\n\".getBytes(StandardCharsets.UTF_8));\n+          out.write(\"\\n\".getBytes(UTF_8));\n           out.flush();\n-        } else {\n-          final List<String> values = formatter.format(records);\n-          for (final String value : values) {\n-            if (printFormat) {\n-              printFormat = false;\n-              out.write((\"Format:\" + formatter.getFormat().name() + \"\\n\")\n-                            .getBytes(StandardCharsets.UTF_8));\n-            }\n-            if (messagesPolled++ % interval == 0) {\n-              messagesWritten++;\n-              out.write(value.getBytes(StandardCharsets.UTF_8));\n-              out.flush();\n-            }\n+          continue;\n+        }\n+\n+        final List<Supplier<String>> values = formatter.format(records.records(topicName));\n+        for (final Supplier<String> value : values) {\n+          if (printFormat) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1ODc1Nw=="}, "originalCommit": {"oid": "cc623bebb23bf6393b350381c684121790cc77c9"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2144, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}