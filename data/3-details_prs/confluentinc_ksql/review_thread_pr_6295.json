{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNTIzMzc0", "number": 6295, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToxNTo0M1rOEoInXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToxNzoxMVrOEoIreg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTE5NjQ3OnYy", "diffSide": "RIGHT", "path": "ksqldb-serde/src/test/java/io/confluent/ksql/serde/json/KsqlJsonDeserializerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToxNTo0M1rOHZDJQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoyMTo0NVrOHZ2kzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyNzk3MQ==", "bodyText": "Does ksqlDB always throw when deserializing decimals that don't fit into the specified precision/scale? What about when casting from other numeric types to decimals? There's no way for the user to specify rounding behavior? (Asking in case you know off the top of your head. If not I can poke around the code, not seeing anything in the docs one way or the other.)", "url": "https://github.com/confluentinc/ksql/pull/6295#discussion_r496027971", "createdAt": "2020-09-28T15:15:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-serde/src/test/java/io/confluent/ksql/serde/json/KsqlJsonDeserializerTest.java", "diffHunk": "@@ -538,6 +538,40 @@ public void shouldDeserializeDecimalsWithoutStrippingTrailingZeros() {\n     assertThat(result, is(new BigDecimal(\"10.0\")));\n   }\n \n+  @Test\n+  public void shouldFixScaleWhenDeserializingDecimalsWithTooSmallAScale() {\n+    // Given:\n+    final KsqlJsonDeserializer<BigDecimal> deserializer =\n+        givenDeserializerForSchema(DecimalUtil.builder(4, 3).build(), BigDecimal.class);\n+\n+    final byte[] bytes = addMagic(\"1.1\".getBytes(UTF_8));\n+\n+    // When:\n+    final Object result = deserializer.deserialize(SOME_TOPIC, bytes);\n+\n+    // Then:\n+    assertThat(result, is(new BigDecimal(\"1.100\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfDecimalHasLargerScale() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb34f94c7e6cf228e29d1cff60c94c47ca2fbbc"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NjQ0NQ==", "bodyText": "@agavra can probably answer more definitely than me, as he did the initial work. However, I believe a deserializer should throw if the deserialized value doesn't fit in the ksql decimal scale and precision.  (See DecimalUtil.ensureFit). This isn't necessary for some formats, e.g. AVRO, as the Avro schema dictates scale and precision, and the ksql schema is driven from the Avro one.\nCasting is supported, and I'm assuming ensureFit is being called appropriately.\nI don't think there's any way for a user to specify rounding behaviour, though I'm fairly certain it was discussed during the design, but punted to a later feature.", "url": "https://github.com/confluentinc/ksql/pull/6295#discussion_r496076445", "createdAt": "2020-09-28T16:21:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/test/java/io/confluent/ksql/serde/json/KsqlJsonDeserializerTest.java", "diffHunk": "@@ -538,6 +538,40 @@ public void shouldDeserializeDecimalsWithoutStrippingTrailingZeros() {\n     assertThat(result, is(new BigDecimal(\"10.0\")));\n   }\n \n+  @Test\n+  public void shouldFixScaleWhenDeserializingDecimalsWithTooSmallAScale() {\n+    // Given:\n+    final KsqlJsonDeserializer<BigDecimal> deserializer =\n+        givenDeserializerForSchema(DecimalUtil.builder(4, 3).build(), BigDecimal.class);\n+\n+    final byte[] bytes = addMagic(\"1.1\".getBytes(UTF_8));\n+\n+    // When:\n+    final Object result = deserializer.deserialize(SOME_TOPIC, bytes);\n+\n+    // Then:\n+    assertThat(result, is(new BigDecimal(\"1.100\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfDecimalHasLargerScale() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyNzk3MQ=="}, "originalCommit": {"oid": "9bb34f94c7e6cf228e29d1cff60c94c47ca2fbbc"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MDYwNw==", "bodyText": "it's been a while since i've looked at the code but I agree with what Andy is saying. As far as casting is concerned, we hardcode the scale/precision for casts:\n  /**\n   * Schema of an INT up-cast to a DECIMAL\n   */\n  public static final SqlDecimal INT_UPCAST_TO_DECIMAL = SqlDecimal.of(10, 0);\n\n  /**\n   * Schema of an BIGINT up-cast to a DECIMAL\n   */\n  public static final SqlDecimal BIGINT_UPCAST_TO_DECIMAL = SqlDecimal.of(19, 0);\nAnd then for double we do some other magic", "url": "https://github.com/confluentinc/ksql/pull/6295#discussion_r496870607", "createdAt": "2020-09-29T16:21:45Z", "author": {"login": "agavra"}, "path": "ksqldb-serde/src/test/java/io/confluent/ksql/serde/json/KsqlJsonDeserializerTest.java", "diffHunk": "@@ -538,6 +538,40 @@ public void shouldDeserializeDecimalsWithoutStrippingTrailingZeros() {\n     assertThat(result, is(new BigDecimal(\"10.0\")));\n   }\n \n+  @Test\n+  public void shouldFixScaleWhenDeserializingDecimalsWithTooSmallAScale() {\n+    // Given:\n+    final KsqlJsonDeserializer<BigDecimal> deserializer =\n+        givenDeserializerForSchema(DecimalUtil.builder(4, 3).build(), BigDecimal.class);\n+\n+    final byte[] bytes = addMagic(\"1.1\".getBytes(UTF_8));\n+\n+    // When:\n+    final Object result = deserializer.deserialize(SOME_TOPIC, bytes);\n+\n+    // Then:\n+    assertThat(result, is(new BigDecimal(\"1.100\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfDecimalHasLargerScale() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyNzk3MQ=="}, "originalCommit": {"oid": "9bb34f94c7e6cf228e29d1cff60c94c47ca2fbbc"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTIwNjk4OnYy", "diffSide": "RIGHT", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToxNzoxMVrOHZDPjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNjo1NlrOHZF68g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyOTU4MA==", "bodyText": "What's the philosophy behind when it makes sense to copy the underlying error message into the new error message?", "url": "https://github.com/confluentinc/ksql/pull/6295#discussion_r496029580", "createdAt": "2020-09-28T15:17:11Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "diffHunk": "@@ -126,7 +126,7 @@ public T deserialize(final String topic, final byte[] bytes) {\n       return SerdeUtils.castToTargetType(coerced, targetType);\n     } catch (final Exception e) {\n       throw new SerializationException(\n-          \"Failed to deserialize \" + target + \" from topic: \" + topic, e);\n+          \"Failed to deserialize \" + target + \" from topic: \" + topic + \". \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb34f94c7e6cf228e29d1cff60c94c47ca2fbbc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MzQ1OA==", "bodyText": "Humm.. hard to give a hard and fast rule, but I generally make this change if otherwise the user would be presented with a less than useful error message.  In this case, I added it to make debugging easier... both for us and for users interacting with the processing logger.  Having the cause's message as part of the top level message means you can quickly understand what's happening without having to scroll through exception call stacks.", "url": "https://github.com/confluentinc/ksql/pull/6295#discussion_r496073458", "createdAt": "2020-09-28T16:16:56Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "diffHunk": "@@ -126,7 +126,7 @@ public T deserialize(final String topic, final byte[] bytes) {\n       return SerdeUtils.castToTargetType(coerced, targetType);\n     } catch (final Exception e) {\n       throw new SerializationException(\n-          \"Failed to deserialize \" + target + \" from topic: \" + topic, e);\n+          \"Failed to deserialize \" + target + \" from topic: \" + topic + \". \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyOTU4MA=="}, "originalCommit": {"oid": "9bb34f94c7e6cf228e29d1cff60c94c47ca2fbbc"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2840, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}