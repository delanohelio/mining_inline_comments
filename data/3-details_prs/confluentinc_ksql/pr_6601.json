{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMDYzOTE2", "number": 6601, "title": "chore: refuse INSERT VALUES that would modify key schema", "bodyText": "Description\nPrevents INSERT VALUES from overwriting the schema in schema registry.\nTesting done\n\nunit tests\nmanual testing to make sure that we can still insert values if ksqlDB created the schema via CREATE STREAM/TABLE\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-11-12T18:08:50Z", "url": "https://github.com/confluentinc/ksql/pull/6601", "merged": true, "mergeCommit": {"oid": "5e6e2effff12f28835af861ad14ef327adf94fb8"}, "closed": true, "closedAt": "2020-11-12T21:33:15Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdb2PDDAH2gAyNTIwMDYzOTE2OmJmNTFlYTJmNmM2MDhhOTFlNWIzNTA4MTE1NGNlMzJiYzdiOGNhZDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddR8Q7gFqTUzMjAxNTQ2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bf51ea2f6c608a91e5b35081154ce32bc7b8cad7", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/bf51ea2f6c608a91e5b35081154ce32bc7b8cad7", "committedDate": "2020-11-12T17:44:30Z", "message": "chore: refuse INSERT VALUES that would modify key schema"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDQ3NDcy", "url": "https://github.com/confluentinc/ksql/pull/6601#pullrequestreview-529447472", "createdAt": "2020-11-12T19:59:29Z", "commit": {"oid": "bf51ea2f6c608a91e5b35081154ce32bc7b8cad7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDE0NTEy", "url": "https://github.com/confluentinc/ksql/pull/6601#pullrequestreview-532014512", "createdAt": "2020-11-17T04:31:57Z", "commit": {"oid": "bf51ea2f6c608a91e5b35081154ce32bc7b8cad7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNDozMTo1OFrOH0kAvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNDozMTo1OFrOH0kAvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg3ODAxMw==", "bodyText": "How come we're not using SchemaRegistryUtil#getLatestSchema() here?", "url": "https://github.com/confluentinc/ksql/pull/6601#discussion_r524878013", "createdAt": "2020-11-17T04:31:58Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "diffHunk": "@@ -266,12 +274,52 @@ private void throwIfDisabled(final KsqlConfig config) {\n           FormatFactory.fromName(dataSource.getKsqlTopic().getKeyFormat().getFormat()),\n           topicName,\n           true,\n+          \"write\",\n           e);\n       LOG.error(\"Could not serialize key.\", e);\n       throw new KsqlException(\"Could not serialize key: \" + keyValue, e);\n     }\n   }\n \n+  /**\n+   * Ensures that the key schema that we generate will be identical\n+   * to the schema that is registered in schema registry, if it exists.\n+   * Otherwise, it is possible that we will publish messages with a new\n+   * schemaID, meaning that logically identical keys might be routed to\n+   * different partitions.\n+   */\n+  private void ensureKeySchemasMatch(\n+      final PersistenceSchema keySchema,\n+      final DataSource dataSource,\n+      final ServiceContext serviceContext\n+  ) {\n+    final KeyFormat keyFormat = dataSource.getKsqlTopic().getKeyFormat();\n+    final Format format = FormatFactory.fromName(keyFormat.getFormat());\n+    if (!format.supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n+      return;\n+    }\n+\n+    final ParsedSchema schema = format\n+        .getSchemaTranslator(keyFormat.getFormatInfo().getProperties())\n+        .toParsedSchema(keySchema);\n+\n+    try {\n+      final SchemaMetadata latest = serviceContext.getSchemaRegistryClient()\n+          .getLatestSchemaMetadata(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf51ea2f6c608a91e5b35081154ce32bc7b8cad7"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDE1NDY3", "url": "https://github.com/confluentinc/ksql/pull/6601#pullrequestreview-532015467", "createdAt": "2020-11-17T04:35:14Z", "commit": {"oid": "bf51ea2f6c608a91e5b35081154ce32bc7b8cad7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNDozNToxNFrOH0kD_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNDozNToxNFrOH0kD_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg3ODg0Ng==", "bodyText": "Are we handling the case where no schema is present in Schema Registry? I know this doesn't happen under normal circumstances since ksqlDB registers schemas at source creation time, but we should handle potential subsequent deletion by the user gracefully rather than throwing an NPE.", "url": "https://github.com/confluentinc/ksql/pull/6601#discussion_r524878846", "createdAt": "2020-11-17T04:35:14Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "diffHunk": "@@ -266,12 +274,52 @@ private void throwIfDisabled(final KsqlConfig config) {\n           FormatFactory.fromName(dataSource.getKsqlTopic().getKeyFormat().getFormat()),\n           topicName,\n           true,\n+          \"write\",\n           e);\n       LOG.error(\"Could not serialize key.\", e);\n       throw new KsqlException(\"Could not serialize key: \" + keyValue, e);\n     }\n   }\n \n+  /**\n+   * Ensures that the key schema that we generate will be identical\n+   * to the schema that is registered in schema registry, if it exists.\n+   * Otherwise, it is possible that we will publish messages with a new\n+   * schemaID, meaning that logically identical keys might be routed to\n+   * different partitions.\n+   */\n+  private void ensureKeySchemasMatch(\n+      final PersistenceSchema keySchema,\n+      final DataSource dataSource,\n+      final ServiceContext serviceContext\n+  ) {\n+    final KeyFormat keyFormat = dataSource.getKsqlTopic().getKeyFormat();\n+    final Format format = FormatFactory.fromName(keyFormat.getFormat());\n+    if (!format.supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n+      return;\n+    }\n+\n+    final ParsedSchema schema = format\n+        .getSchemaTranslator(keyFormat.getFormatInfo().getProperties())\n+        .toParsedSchema(keySchema);\n+\n+    try {\n+      final SchemaMetadata latest = serviceContext.getSchemaRegistryClient()\n+          .getLatestSchemaMetadata(\n+              KsqlConstants.getSRSubject(dataSource.getKafkaTopicName(), true));\n+      if (!latest.getSchema().equals(schema.canonicalString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf51ea2f6c608a91e5b35081154ce32bc7b8cad7"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4607, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}