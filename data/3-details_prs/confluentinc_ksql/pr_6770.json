{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMDA1MTAx", "number": 6770, "title": "chore: support multi-column keys in GROUP BY", "bodyText": "Description\nFixes #6371.\nThis PR adds support for multi-column GROUP BY. With this change, GROUP BY multiple columns will result in multiple key columns, rather than a single key column that is the string concatenation of the individual key fields (with delimiter |+|. A consequence of this change is that GROUP BY multiple columns is no longer allowed when using key formats that do not support it, such as the KAFKA format.\nThis is a breaking change, and is currently guarded by a feature flag until we've added the corresponding pull query support and are ready to release.\nThis PR adds test coverage in a new QTT file group-by-multi-col.json which is a copy-paste of the existing group-by.json with some additional tests added. Once the feature flag is removed, the current group-by.json will be deleted in favor of group-by-multi-col.json (which will be renamed to simply group-by.json). The easiest way to review the QTT changes, to see the breaking changes in this PR in addition to the next test coverage, is to diff the existing group-by.json with the new group-by-multi-col.json.\nTesting done\nUnit + QTT.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-12-15T06:14:40Z", "url": "https://github.com/confluentinc/ksql/pull/6770", "merged": true, "mergeCommit": {"oid": "4b8a2c79baed8e58c798526e48bf5bb77d37ed4f"}, "closed": true, "closedAt": "2020-12-15T22:58:24Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmUMADAH2gAyNTQwMDA1MTAxOjA2MTEzMDM2Nzc2YjI5OTgxM2ZiZmU4ZDIyYzM4Y2Y2M2RhNGNhYTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmgb5-AFqTU1MjgyMjkyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/06113036776b299813fbfe8d22c38cf63da4caa9", "committedDate": "2020-12-15T06:17:34Z", "message": "feat: support multi-column keys in GROUP BY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f9538f22c150ad2a8f5e0d5cd4743fd5ae269da", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/9f9538f22c150ad2a8f5e0d5cd4743fd5ae269da", "committedDate": "2020-12-15T06:06:50Z", "message": "feat: support multi-column keys in GROUP BY"}, "afterCommit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/06113036776b299813fbfe8d22c38cf63da4caa9", "committedDate": "2020-12-15T06:17:34Z", "message": "feat: support multi-column keys in GROUP BY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTM1OTU5", "url": "https://github.com/confluentinc/ksql/pull/6770#pullrequestreview-552135959", "createdAt": "2020-12-15T06:19:09Z", "commit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoxOTowOVrOIF6vEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoxOTowOVrOIF6vEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjExNA==", "bodyText": "Is there a reason we weren't applying config overrides here? Seems like a bug. This fix is needed in order to pass the feature flag into the GroupByParamsFactory.", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543076114", "createdAt": "2020-12-15T06:19:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -478,7 +478,7 @@ private PersistentQueryMetadata executePersistentQuery(\n   }\n \n   private String buildPlanSummary(final QueryId queryId, final ExecutionStep<?> plan) {\n-    return new PlanSummary(queryId, config.getConfig(false), engineContext.getMetaStore())\n+    return new PlanSummary(queryId, config.getConfig(true), engineContext.getMetaStore())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTM2NDc1", "url": "https://github.com/confluentinc/ksql/pull/6770#pullrequestreview-552136475", "createdAt": "2020-12-15T06:20:21Z", "commit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoyMDoyMlrOIF6xGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoyMDoyMlrOIF6xGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjYzNA==", "bodyText": "This fix is needed, else sanitizeKeyFormat() adds in key wrapping after groupBy() removes it in the case of multi-column keys.", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543076634", "createdAt": "2020-12-15T06:20:22Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKGroupedStream.java", "diffHunk": "@@ -85,7 +85,7 @@\n     } else {\n       keyFormat = SerdeFeaturesFactory.sanitizeKeyFormat(\n           this.keyFormat,\n-          true\n+          schema.key().size() == 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTM3MjM1", "url": "https://github.com/confluentinc/ksql/pull/6770#pullrequestreview-552137235", "createdAt": "2020-12-15T06:22:09Z", "commit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoyMjowOVrOIF6z1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoyMjowOVrOIF6z1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NzMzMg==", "bodyText": "This test is identical to the existing shouldReturnNullIfAnyMultiExpressionResolvesToNull() and is therefore redundant.", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543077332", "createdAt": "2020-12-15T06:22:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/GroupByParamsFactoryTest.java", "diffHunk": "@@ -238,37 +341,84 @@ public void shouldLogProcessingErrorIfAnyMultiExpressionResolvesToNull() {\n   }\n \n   @Test\n-  public void shouldUseNullInGroupByIfOneExpressionFailsOrReturnsNullInMulti() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "originalPosition": 193}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "095cbed3fe3501a8491bb78f2e6bd352511fec43", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/095cbed3fe3501a8491bb78f2e6bd352511fec43", "committedDate": "2020-12-15T17:56:58Z", "message": "chore: fix qtt formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyODIyOTI0", "url": "https://github.com/confluentinc/ksql/pull/6770#pullrequestreview-552822924", "createdAt": "2020-12-15T20:01:39Z", "commit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDowMTozOVrOIGdo7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDoyMDozNVrOIGeVMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0Nzk4Mg==", "bodyText": "off the top of my head, I don't think there's any good reason. We should make sure that it's not being used in the pull query path as this (calling getConfig(true)) is shockingly expensive at high throughput.", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543647982", "createdAt": "2020-12-15T20:01:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -478,7 +478,7 @@ private PersistentQueryMetadata executePersistentQuery(\n   }\n \n   private String buildPlanSummary(final QueryId queryId, final ExecutionStep<?> plan) {\n-    return new PlanSummary(queryId, config.getConfig(false), engineContext.getMetaStore())\n+    return new PlanSummary(queryId, config.getConfig(true), engineContext.getMetaStore())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjExNA=="}, "originalCommit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1OTMxMw==", "bodyText": "not your original code, but I'm wondering why we can't leverage the schema that we built in LogicalPlanner. It seems like these two schemas have to align perfectly or else this won't work (and the code is quite similar, this just handles ExpressionMetadata instead of Expression directly). Am I right? I haven't actually dug into it that much.", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543659313", "createdAt": "2020-12-15T20:20:35Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "diffHunk": "@@ -219,4 +229,69 @@ private static LogicalSchema multiExpressionSchema(\n     final ColumnName keyName = ColumnNames.nextKsqlColAlias(sourceSchema);\n     return buildSchemaWithKeyType(sourceSchema, keyName, SqlTypes.STRING);\n   }\n+\n+  private static final class ExpressionGrouper implements Grouper {\n+\n+    private final LogicalSchema schema;\n+    private final ImmutableList<ExpressionMetadata> groupBys;\n+    private final ProcessingLogger logger;\n+\n+    ExpressionGrouper(\n+        final LogicalSchema sourceSchema,\n+        final List<ExpressionMetadata> groupBys,\n+        final ProcessingLogger logger\n+    ) {\n+      this.schema = expressionSchema(sourceSchema, groupBys);\n+      this.groupBys = ImmutableList.copyOf(requireNonNull(groupBys, \"groupBys\"));\n+      this.logger = Objects.requireNonNull(logger, \"logger\");\n+\n+      if (this.groupBys.isEmpty()) {\n+        throw new IllegalArgumentException(\"Empty group by\");\n+      }\n+    }\n+\n+    @Override\n+    public LogicalSchema getSchema() {\n+      return schema;\n+    }\n+\n+    @Override\n+    public GenericKey apply(final GenericRow row) {\n+      final GenericKey.Builder builder = GenericKey.builder(groupBys.size());\n+\n+      for (int i = 0; i < groupBys.size(); i++) {\n+        final Object result = processColumn(i, groupBys.get(i), row, logger);\n+        if (result == null) {\n+          return null;\n+        }\n+\n+        builder.append(result);\n+      }\n+\n+      return builder.build();\n+    }\n+  }\n+\n+  private static LogicalSchema expressionSchema(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4525, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}