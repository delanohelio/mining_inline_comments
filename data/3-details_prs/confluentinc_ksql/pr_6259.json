{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NTE3OTQw", "number": 6259, "title": "docs: KLIP-38 for Variable Substitution", "bodyText": "Description\nAdd KLIP-38 to support variable substitution in ksqlDB.\nTesting done\nDescribe the testing strategy. Unit and integration tests are expected for any behavior changes.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-09-18T20:09:42Z", "url": "https://github.com/confluentinc/ksql/pull/6259", "merged": true, "mergeCommit": {"oid": "ab6dc68d51c1ebaee2a09f3f1f10031621a621b3"}, "closed": true, "closedAt": "2020-10-08T15:36:39Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdKMFC7gFqTQ5MTc2NTUyMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQivOtgBqjM4NTU4NzMzOTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzY1NTIy", "url": "https://github.com/confluentinc/ksql/pull/6259#pullrequestreview-491765522", "createdAt": "2020-09-18T20:35:33Z", "commit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDozNTozM1rOHUbITg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDo1ODo0NlrOHUbuFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3ODA2Mg==", "bodyText": "Is this because the ksqlDB language is itself case-insensitive?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491178062", "createdAt": "2020-09-18T20:35:33Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MTM4Mg==", "bodyText": "This seems like an important limitation. With \"hard-coded\" here, are you referring to language elements beyond the set of literals (i.e. null, number, boolean, string)?\nThis would mean for example that you couldn't use a variable for a source name, correct? In other words this wouldn't be possible:\nCREATE STREAM {stream_name} (...\nINSERT INTO {stream_name} (...", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491181382", "createdAt": "2020-09-18T20:43:46Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MjIxMQ==", "bodyText": "nit: I suggest making the variable value different than the variable name. Something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ksql> DEFINE topic_prod = 'topic_prod';\n          \n          \n            \n            ksql> DEFINE topic_qa = 'topic_qa';\n          \n          \n            \n            ksql> DEFINE topic_prod = 'my_prod_topic';\n          \n          \n            \n            ksql> DEFINE topic_qa = 'my_qa_topic';", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491182211", "createdAt": "2020-09-18T20:45:37Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MzQ0MA==", "bodyText": "At first glance, it seems like this could be more confusing than it's worth. (As much as I love Lisp-like nesting \ud83d\ude02 .) Do you have other use-cases in mind?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491183440", "createdAt": "2020-09-18T20:47:56Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NTg1Mw==", "bodyText": "Will this mean that variables defined lexically after a statement that refers to them will use the latest value? As an illustration, what would be the result of following in headless mode?\nDEFINE topic = 'foo';\nCREATE STREAM ... WITH (kafka_topic='{topic}');\nDEFINE topic = 'bar';", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491185853", "createdAt": "2020-09-18T20:53:57Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.\n+\n+For headless, variable substitution will happen in the server side. Seems the `KsqlContext` is the right place for that.\n+\n+Variable substitution will be done by using two pre-parsing steps. First, it will use the `KsqlParser.parse()` method to verify variable substitution rules.  \n+These rules will be defined in the `SqlBase.g4` syntax file. Once this step passes, then we'll use the `StringSubstitutor` class from Apache libraries to  \n+replace `{...}` variables. This library gives us easily variable replacement including nested variables, and others features we can use in the future, such as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NjExNQ==", "bodyText": "We can also discuss not supporting substitution in headless mode.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491186115", "createdAt": "2020-09-18T20:54:35Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.\n+\n+For headless, variable substitution will happen in the server side. Seems the `KsqlContext` is the right place for that.\n+\n+Variable substitution will be done by using two pre-parsing steps. First, it will use the `KsqlParser.parse()` method to verify variable substitution rules.  \n+These rules will be defined in the `SqlBase.g4` syntax file. Once this step passes, then we'll use the `StringSubstitutor` class from Apache libraries to  \n+replace `{...}` variables. This library gives us easily variable replacement including nested variables, and others features we can use in the future, such as", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NTg1Mw=="}, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzczMw==", "bodyText": "Should we also consider substitution in the context of the Java Client API? If so, what would a session be in this context?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491187733", "createdAt": "2020-09-18T20:58:46Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 259}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxODI0MTU3", "url": "https://github.com/confluentinc/ksql/pull/6259#pullrequestreview-491824157", "createdAt": "2020-09-18T22:59:17Z", "commit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1OToxN1rOHUeL6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNDozMzoxMFrOHUsJgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyODEzNw==", "bodyText": "Yes. We could be case-sensitive, but I didn't see the reason of that if our SQL statements are insensitive. One quick example while writing examples is I was defining variables in uppercase, then making references in lowercase without noticing it. I thought users would face the same situation, so better to keep this insensitive.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491228137", "createdAt": "2020-09-18T22:59:17Z", "author": {"login": "spena"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3ODA2Mg=="}, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyOTcyNA==", "bodyText": "I'm still opened to use variables as column-names and other expressions, such as: CREATE STREAM .. WHERE {expression}. I had something else in mind initially when defining a char variable and replacing the variable including single- or double- quotes. That wouldn't have worked with column names. But now I completed the klip, I think we could support other places.\nI still want to stay away of replacing reserved words. I noticed other systems (hive & spark) seem tp allow replacing the whole statement, like:\nksql> define select =  'select * from stream emit changes;';\nksql> {select}\n\nI'm not sure we want to do that. It's easier to implement, but I'm not sure is correct. Most of the DBs in the market do not allow that. What do you think?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491229724", "createdAt": "2020-09-18T23:06:17Z", "author": {"login": "spena"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MTM4Mg=="}, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDMxMQ==", "bodyText": "Yeah. The StringSubstitutor library allows that, so I thought that was a nice feature without complicating the ksqlDB code. But from the user side, they could end up with a long \"chorizo\" that would confuse them {topic_{env_{num}_{user}}}. We can ask for feedback to some users.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491230311", "createdAt": "2020-09-18T23:09:10Z", "author": {"login": "spena"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MzQ0MA=="}, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDU4Ng==", "bodyText": "Mmm, forgot about that. REST API is out of scope because a session is usually a request which is one command. But Java API might be different. I'll investigate that see how it opens sessions.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491230586", "createdAt": "2020-09-18T23:10:23Z", "author": {"login": "spena"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzczMw=="}, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTAyNg==", "bodyText": "The above example will end up with CREATE STREAM ... WITH (kafka_topic='foo');, then the variable topic will change to bar, but it won't cause any changes to the previous stream. Variables will not be persisted, so they will be evaluated and replaces at run-time and before sending the request to the server.\nAbout headless. Let's talk about it. Being headless a mode we won't want to support more, it would make sense not to do it. It will keep the code less complex too.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491231026", "createdAt": "2020-09-18T23:12:29Z", "author": {"login": "spena"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.\n+\n+For headless, variable substitution will happen in the server side. Seems the `KsqlContext` is the right place for that.\n+\n+Variable substitution will be done by using two pre-parsing steps. First, it will use the `KsqlParser.parse()` method to verify variable substitution rules.  \n+These rules will be defined in the `SqlBase.g4` syntax file. Once this step passes, then we'll use the `StringSubstitutor` class from Apache libraries to  \n+replace `{...}` variables. This library gives us easily variable replacement including nested variables, and others features we can use in the future, such as", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NTg1Mw=="}, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ1Njg5Nw==", "bodyText": "I might change the prefix/suffix for '${}' to avoid conflicting with JSON literal strings.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491456897", "createdAt": "2020-09-19T14:33:10Z", "author": {"login": "spena"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86bad6aa26418ae7d093c189c2c2350845ac5984"}, "originalPosition": 186}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9223aa69d48769e130e37e78fd1552840cfa168b", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/9223aa69d48769e130e37e78fd1552840cfa168b", "committedDate": "2020-09-21T19:38:30Z", "message": "docs: addressed feedback 1\n\n- Use ${} instead of {} to avoid JSON literal conflicts\n- Use variables for other identifiers such as column names and source names\n- Minor doc fixes"}, "afterCommit": {"oid": "d4d905feae50519b77d5c2a572f0129f927a3d1e", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/d4d905feae50519b77d5c2a572f0129f927a3d1e", "committedDate": "2020-09-21T20:48:15Z", "message": "docs: addressed feedback 1\n\n- Use ${} instead of {} to avoid JSON literal conflicts\n- Use variables for other identifiers such as column names and source names\n- Minor doc fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTM1ODEw", "url": "https://github.com/confluentinc/ksql/pull/6259#pullrequestreview-492935810", "createdAt": "2020-09-21T19:58:42Z", "commit": {"oid": "9223aa69d48769e130e37e78fd1552840cfa168b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTo1ODo0MlrOHVgUIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzoyOTo0OVrOHVl1uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMTU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # KLIP 34 - Variable Substitution\n          \n          \n            \n            # KLIP 38 - Variable Substitution", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492311587", "createdAt": "2020-09-21T19:58:42Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,295 @@\n+# KLIP 34 - Variable Substitution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9223aa69d48769e130e37e78fd1552840cfa168b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NzI0OQ==", "bodyText": "can you link to the Oracle docs here for future reference (is it https://docs.oracle.com/cd/E18283_01/server.112/e16604/ch_twelve017.htm ?)\nThough if I had to choose, I think the SQL+ syntax here is a little unintuitive. MySQL: https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/user-variables.html uses something that to me is more intuitive (and is similar to SqlServer)", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492397249", "createdAt": "2020-09-21T23:14:08Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d905feae50519b77d5c2a572f0129f927a3d1e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5ODkzMw==", "bodyText": "If we're following Oracle SQL+ why not use & or && to reference the variables?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492398933", "createdAt": "2020-09-21T23:19:17Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d905feae50519b77d5c2a572f0129f927a3d1e"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMDY1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n          \n          \n            \n            `ksql.headless.variable.substitution.enable` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492400653", "createdAt": "2020-09-21T23:24:44Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:\n+\n+Note: `{VAR}` is used a reference where variables are permitted.\n+```\n+ksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n+      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n+      \n+ksql> INSERT INTO ${streamName} (${colName1}, ${colName2}) \\\n+      VALUES (${val1}, '${val2}');\n+\n+ksql> SELECT * FROM ${streamName} \\\n+      WHERE ${colName1} == ${val1} and ${colName2} == '${val2}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_${var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '${offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP ${WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'my_prod_topic';\n+ksql> DEFINE topic_qa = 'my_qa_topic';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='${topic_${env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='${topic_${env}}');\n+Error: Fail because ${topic_${env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d905feae50519b77d5c2a572f0129f927a3d1e"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMjEwNw==", "bodyText": "what if I don't want a literal ${foo} to be replaced? e.g. I actually want ${foo} to be the value in the statement (SELECT '${foo}' as dolla_foo FROM bar)? do i need to turn substitution off and then on after I issue the statement?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492402107", "createdAt": "2020-09-21T23:29:49Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d905feae50519b77d5c2a572f0129f927a3d1e"}, "originalPosition": 214}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDM1ODU1", "url": "https://github.com/confluentinc/ksql/pull/6259#pullrequestreview-493435855", "createdAt": "2020-09-22T13:04:36Z", "commit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzowNDozNlrOHV4_sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyNTozOVrOHV56Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcxNTk1NQ==", "bodyText": "Do we have plans to support variable substitution in the UI? The UI handles setting properties differently from the CLI: rather than the SET/UNSET syntax for session properties supported by the CLI, query properties instead have to be set using the dropdown in the UI editor. This divergence from the CLI has confused users in the past and I worry that having a different mechanism for defining variables in the UI will lead to similar confusion.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492715955", "createdAt": "2020-09-22T13:04:36Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNTM4Mw==", "bodyText": "+1 to defining a new method for this rather than trying to piggyback off existing methods. If we don't support variable substitution in the REST API, the Java client will have to maintain variables in its own code, similar to the CLI. If we updated the CLI to use the Java client (#6269) we'd have fewer issues like these in the future but that's out of scope for this work for sure.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492725383", "createdAt": "2020-09-22T13:18:05Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNjcwOA==", "bodyText": "What's the benefit in having SOURCE allow users to execute statements similar to RUN SCRIPT? It seems confusing to have two ways to do this with only a very subtle distinction (variables set in SOURCE persist into the sessions outside the scope of the command while those for RUN SCRIPT don't). Can we have SOURCE only load variables from a file, and then ask users to use RUN SCRIPT afterwards if they want to also load statements?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492726708", "createdAt": "2020-09-22T13:20:00Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyODE2Mw==", "bodyText": "Is it normal for variables to not be allowed as keywords? I don't mind but if we go with this we need to make sure we have good error messages since a natural extension (unless it's just my naivete speaking?) from the example below:\nksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n\nis to wonder about\nksql> CREATE STREAM ${streamName} (${colName1} ${colType1}, ${colName2} ${colType2}) \\\n      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n\nwhich won't be accepted based on this proposal. Hopefully the error message makes it very clear why.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492728163", "createdAt": "2020-09-22T13:22:00Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyOTgyNA==", "bodyText": "It's interesting to me that the contents of variables are substituted into the statement directly, and it's left to the user to get the quoting of the variables correct. This makes sense but it'd be great to have helpful error messages when this goes wrong. For example, if the user mistakenly submits\nksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n      WITH (kafka_topic=${topicName}, format='${format}', replicas=${replicas}, ...);\n\ninstead of\nksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n\nwhere the difference is that they're missing quotes around the topic name, it'd be great to have a useful error message so they aren't left guessing in the dark.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492729824", "createdAt": "2020-09-22T13:24:14Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:\n+\n+Note: `{VAR}` is used a reference where variables are permitted.\n+```\n+ksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n+      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n+      \n+ksql> INSERT INTO ${streamName} (${colName1}, ${colName2}) \\\n+      VALUES (${val1}, '${val2}');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMDk2Mg==", "bodyText": "fail with the current SQL parsing error found when parsing the variable string\n\nAs mentioned above, I think we'll want better error messages here. The SQL parsing errors we see today are awful in terms of debuggability and I worry that variable substitution will make this all the more confusing. Can we make improving these error messages in scope for this work, or is that too much?", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492730962", "createdAt": "2020-09-22T13:25:39Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:\n+\n+Note: `{VAR}` is used a reference where variables are permitted.\n+```\n+ksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n+      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n+      \n+ksql> INSERT INTO ${streamName} (${colName1}, ${colName2}) \\\n+      VALUES (${val1}, '${val2}');\n+\n+ksql> SELECT * FROM ${streamName} \\\n+      WHERE ${colName1} == ${val1} and ${colName2} == '${val2}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 227}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/57d885e63b31382fb53f1b6ff77521296fc3963a", "committedDate": "2020-09-21T23:59:22Z", "message": "fix: address feedback\n\n- fix minor doc details"}, "afterCommit": {"oid": "20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f", "committedDate": "2020-09-24T16:25:11Z", "message": "fix: address feedback\n\n- fix minor doc details"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4OTI4OTE3", "url": "https://github.com/confluentinc/ksql/pull/6259#pullrequestreview-498928917", "createdAt": "2020-09-29T22:08:43Z", "commit": {"oid": "20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMjowODo0M1rOHaD7Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMjoxMDozM1rOHaD-Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4OTMxMA==", "bodyText": "Does MySQL also have a RUN SCRIPT? I tend to agree with Victoria that this seems a little confusing.", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r497089310", "createdAt": "2020-09-29T22:08:43Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNjcwOA=="}, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5MDA1OA==", "bodyText": "I think given the goal (running these scripts in different environments) it's probably OK to not allow the types", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r497090058", "createdAt": "2020-09-29T22:10:33Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyODE2Mw=="}, "originalCommit": {"oid": "57d885e63b31382fb53f1b6ff77521296fc3963a"}, "originalPosition": 212}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e0d551fb2db3157895e36648c28169eae77b04f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/1e0d551fb2db3157895e36648c28169eae77b04f", "committedDate": "2020-10-07T21:26:10Z", "message": "docs: KLIP-38 for Variable Substitution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "010a86c21ac791185f70e020f2ce39a7e6d222e5", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/010a86c21ac791185f70e020f2ce39a7e6d222e5", "committedDate": "2020-10-07T21:26:10Z", "message": "docs: addressed feedback 1\n\n- Use ${} instead of {} to avoid JSON literal conflicts\n- Use variables for other identifiers such as column names and source names\n- Minor doc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "139b81d1627a968d38acdaf771f9c5baae3e6f5f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/139b81d1627a968d38acdaf771f9c5baae3e6f5f", "committedDate": "2020-10-07T21:26:10Z", "message": "fix: address feedback\n\n- fix minor doc details"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f", "committedDate": "2020-09-24T16:25:11Z", "message": "fix: address feedback\n\n- fix minor doc details"}, "afterCommit": {"oid": "c406bfb86a9193156247bcd784667c25bf549e2c", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/c406bfb86a9193156247bcd784667c25bf549e2c", "committedDate": "2020-10-07T21:26:10Z", "message": "fix: add server-side variable substitution and other details"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5481d8b74f5b6ba5d532148baf553b05936633c1", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/5481d8b74f5b6ba5d532148baf553b05936633c1", "committedDate": "2020-10-07T21:41:01Z", "message": "fix: add server-side variable substitution and other details"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c406bfb86a9193156247bcd784667c25bf549e2c", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/c406bfb86a9193156247bcd784667c25bf549e2c", "committedDate": "2020-10-07T21:26:10Z", "message": "fix: add server-side variable substitution and other details"}, "afterCommit": {"oid": "5481d8b74f5b6ba5d532148baf553b05936633c1", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/5481d8b74f5b6ba5d532148baf553b05936633c1", "committedDate": "2020-10-07T21:41:01Z", "message": "fix: add server-side variable substitution and other details"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODQ0MTk5", "url": "https://github.com/confluentinc/ksql/pull/6259#pullrequestreview-504844199", "createdAt": "2020-10-08T14:28:38Z", "commit": {"oid": "5481d8b74f5b6ba5d532148baf553b05936633c1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "committedDate": "2020-10-08T14:48:14Z", "message": "fix: remove SOURCE command proposal"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7f5d329ef3f5a6b105d7b2bd216cddfa6e87697", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f7f5d329ef3f5a6b105d7b2bd216cddfa6e87697", "committedDate": "2020-10-08T14:43:36Z", "message": "fix: remove SOURCE command proposal"}, "afterCommit": {"oid": "52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "committedDate": "2020-10-08T14:48:14Z", "message": "fix: remove SOURCE command proposal"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4663, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}