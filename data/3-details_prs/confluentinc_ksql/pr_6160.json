{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MTQ4MjY4", "number": 6160, "title": "fix: delete zombie consumer groups \ud83e\udddf", "bodyText": "fixes #1283\nDescription\nBefore this PR, we don't clean up consumer groups that are leftover which makes it really annoying for users to look into their existing consumer groups. This PR adds cleanup on close for persistent and transient queries.\nThe unfortunate part, is that the consumer group API takes a while to update when the last consumer has left the group (specifically, the heartbeat.interval.ms which is default to 3 seconds, needs to pass after the last consumer leaves the group). To account for this, I've taken the external resource cleanup out of the main execution path so that the UI doesn't hang when we terminate a query.\nTesting done\nUnit testing, and manual testing to make sure the resources are cleaned up.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-09-04T01:02:16Z", "url": "https://github.com/confluentinc/ksql/pull/6160", "merged": true, "mergeCommit": {"oid": "2d1697a9014c397ab8924cd12102cf374ebb166f"}, "closed": true, "closedAt": "2020-09-10T22:49:33Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFayZTAH2gAyNDc5MTQ4MjY4OjU1ZDcyYTc4MzRhM2ZiZWVkMGU3ODA1NmNlNmEyMTYyNGQxMDI5NzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHn2XVgFqTQ4NjMyOTkyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/55d72a7834a3fbeed0e78056ce6a21624d102970", "committedDate": "2020-09-04T01:19:26Z", "message": "fix: delete zombie consumer groups \ud83e\udddf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61632425effa87fdc15ec4b89682e98d7f2fc508", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/61632425effa87fdc15ec4b89682e98d7f2fc508", "committedDate": "2020-09-04T01:01:03Z", "message": "fix: delete zombie consumer groups \ud83e\udddf"}, "afterCommit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/55d72a7834a3fbeed0e78056ce6a21624d102970", "committedDate": "2020-09-04T01:19:26Z", "message": "fix: delete zombie consumer groups \ud83e\udddf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MjAyMzQ5", "url": "https://github.com/confluentinc/ksql/pull/6160#pullrequestreview-486202349", "createdAt": "2020-09-10T18:24:31Z", "commit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoyNDozMVrOHQAhDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoyNDozMVrOHQAhDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0NzcyNg==", "bodyText": "If this is only used for testing, isn't it safer/better to move it to the testing code? You already have a method for adding tasks, all you need is a getter and then you can achieve the same, no?", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486547726", "createdAt": "2020-09-10T18:24:31Z", "author": {"login": "vpapavas"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryCleanupService.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractExecutionThreadService;\n+import io.confluent.ksql.schema.registry.SchemaRegistryUtil;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code QueryCleanupService} helps cleanup external resources from queries\n+ * out of the main line of query execution. This ensures that tasks that might\n+ * take a long time don't happen on the CLI feedback path (such as cleaning up\n+ * consumer groups).\n+ *\n+ * <p>NOTE: this cleanup service is intended to be used across threads and across\n+ * real/sandboxed engines.</p>\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+class QueryCleanupService extends AbstractExecutionThreadService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(QueryCleanupService.class);\n+  private static final Runnable SHUTDOWN_SENTINEL = () -> { };\n+\n+  private final BlockingQueue<Runnable> cleanupTasks;\n+\n+  QueryCleanupService() {\n+    cleanupTasks = new LinkedBlockingDeque<>();\n+  }\n+\n+  @Override\n+  protected void run() {\n+    try {\n+      while (true) {\n+        final Runnable task = cleanupTasks.take();\n+        if (task == SHUTDOWN_SENTINEL) {\n+          return;\n+        }\n+\n+        task.run();\n+      }\n+    } catch (final InterruptedException e) {\n+      // gracefully exit if this method was interrupted and reset\n+      // the interrupt flag\n+      Thread.currentThread().interrupt();\n+    }\n+  }\n+\n+  @Override\n+  protected void triggerShutdown() {\n+    cleanupTasks.add(SHUTDOWN_SENTINEL);\n+  }\n+\n+  public Set<String> pendingApplicationIds() {\n+    return cleanupTasks.stream()\n+        .filter(QueryCleanupTask.class::isInstance)\n+        .map(QueryCleanupTask.class::cast)\n+        .map(t -> t.appId).collect(ImmutableSet.toImmutableSet());\n+  }\n+\n+  public void addCleanupTask(final QueryCleanupTask task) {\n+    cleanupTasks.add(task);\n+  }\n+\n+  @VisibleForTesting\n+  void awaitAllPreviousProcessed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MjAzMjkz", "url": "https://github.com/confluentinc/ksql/pull/6160#pullrequestreview-486203293", "createdAt": "2020-09-10T18:25:51Z", "commit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoyNTo1MVrOHQAlLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoyNTo1MVrOHQAlLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0ODc4MQ==", "bodyText": "Do we want these three cleanups to happen atomically, i.e all or nothing?", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486548781", "createdAt": "2020-09-10T18:25:51Z", "author": {"login": "vpapavas"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryCleanupService.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractExecutionThreadService;\n+import io.confluent.ksql.schema.registry.SchemaRegistryUtil;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code QueryCleanupService} helps cleanup external resources from queries\n+ * out of the main line of query execution. This ensures that tasks that might\n+ * take a long time don't happen on the CLI feedback path (such as cleaning up\n+ * consumer groups).\n+ *\n+ * <p>NOTE: this cleanup service is intended to be used across threads and across\n+ * real/sandboxed engines.</p>\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+class QueryCleanupService extends AbstractExecutionThreadService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(QueryCleanupService.class);\n+  private static final Runnable SHUTDOWN_SENTINEL = () -> { };\n+\n+  private final BlockingQueue<Runnable> cleanupTasks;\n+\n+  QueryCleanupService() {\n+    cleanupTasks = new LinkedBlockingDeque<>();\n+  }\n+\n+  @Override\n+  protected void run() {\n+    try {\n+      while (true) {\n+        final Runnable task = cleanupTasks.take();\n+        if (task == SHUTDOWN_SENTINEL) {\n+          return;\n+        }\n+\n+        task.run();\n+      }\n+    } catch (final InterruptedException e) {\n+      // gracefully exit if this method was interrupted and reset\n+      // the interrupt flag\n+      Thread.currentThread().interrupt();\n+    }\n+  }\n+\n+  @Override\n+  protected void triggerShutdown() {\n+    cleanupTasks.add(SHUTDOWN_SENTINEL);\n+  }\n+\n+  public Set<String> pendingApplicationIds() {\n+    return cleanupTasks.stream()\n+        .filter(QueryCleanupTask.class::isInstance)\n+        .map(QueryCleanupTask.class::cast)\n+        .map(t -> t.appId).collect(ImmutableSet.toImmutableSet());\n+  }\n+\n+  public void addCleanupTask(final QueryCleanupTask task) {\n+    cleanupTasks.add(task);\n+  }\n+\n+  @VisibleForTesting\n+  void awaitAllPreviousProcessed() {\n+    // add a task to the end of the queue to make sure that\n+    // we've finished processing everything up until this point\n+    cleanupTasks.add(() -> { });\n+\n+    // busy wait is fine here because this should only be\n+    // used in tests - if we ever have the need to make this\n+    // production ready, then we should properly implement this\n+    // with a condition variable wait/notify pattern\n+    while (!cleanupTasks.isEmpty()) {\n+      Thread.yield();\n+    }\n+  }\n+\n+  static class QueryCleanupTask implements Runnable {\n+    private final String appId;\n+    private final boolean isTransient;\n+    private final ServiceContext serviceContext;\n+\n+    QueryCleanupTask(\n+        final ServiceContext serviceContext,\n+        final String appId,\n+        final boolean isTransient\n+    ) {\n+      this.appId = appId;\n+      this.isTransient = isTransient;\n+      this.serviceContext = serviceContext;\n+    }\n+\n+    @Override\n+    public void run() {\n+      tryRun(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MjA0OTg3", "url": "https://github.com/confluentinc/ksql/pull/6160#pullrequestreview-486204987", "createdAt": "2020-09-10T18:28:15Z", "commit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoyODoxNVrOHQAsAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoyODoxNVrOHQAsAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDUyOQ==", "bodyText": "Why not use the actual value of heartbeat.interval.ms? Why hardcode it to 3 seconds?", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486550529", "createdAt": "2020-09-10T18:28:15Z", "author": {"login": "vpapavas"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/services/KafkaConsumerGroupClientImpl.java", "diffHunk": "@@ -100,4 +105,23 @@ public ConsumerGroupSummary describeConsumerGroup(final String group) {\n       throw new KafkaResponseGetFailedException(\"Failed to list Kafka consumer groups offsets\", e);\n     }\n   }\n+\n+  @Override\n+  public void deleteConsumerGroups(final Set<String> groups) {\n+    final AtomicInteger retryCount = new AtomicInteger(0);\n+    try {\n+      // it takes heartbeat.interval.ms after a consumer is closed for the broker\n+      // to recognize that there are no more consumers in the consumer group - for\n+      // that reason, we retry after 3 seconds (the default heartbeat.interval.ms)\n+      // in the case that we get a GroupNotEmptyException\n+      ExecutorUtil.executeWithRetries(\n+          () -> adminClient.get().deleteConsumerGroups(groups).all().get(),\n+          e -> (e instanceof RetriableException)\n+              || (e instanceof GroupNotEmptyException && retryCount.getAndIncrement() < 5),\n+          () -> Duration.of(3, ChronoUnit.SECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51ec960e0e5ee803aa5f6e660bff586f148fb7fa", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/51ec960e0e5ee803aa5f6e660bff586f148fb7fa", "committedDate": "2020-09-10T20:25:34Z", "message": "test: move test-only code out of QueryCleanupService"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzI5OTIz", "url": "https://github.com/confluentinc/ksql/pull/6160#pullrequestreview-486329923", "createdAt": "2020-09-10T21:40:23Z", "commit": {"oid": "51ec960e0e5ee803aa5f6e660bff586f148fb7fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4641, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}