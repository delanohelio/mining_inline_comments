{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MjM2NDMz", "number": 6194, "title": "feat: add `KEY_FORMAT` and `FORMAT` WITH clause properties", "bodyText": "Description\nFixes: #6208\nThis PR:\n\nadds two new WITH clause properties: KEY_FORMAT and FORMAT. An error is thrown if FORMAT is provided in addition to either KEY_FORMAT or VALUE_FORMAT. If one or neither of KEY_FORMAT and VALUE_FORMAT is provided in CS/CT statement, the missing one(s) will be injected into the statement via DefaultFormatInjector.\nadds two server configs to provide default key and value formats: ksql.persistence.default.format.key and ksql.persistence.default.format.value. The former defaults to \"KAFKA\" whereas the latter has no default.\nadds a feature flag for the primitive key work (ksql.key.format.enabled) that defaults to false. If false, the current behavior of requiring VALUE_FORMAT is preserved, and an error is thrown if either KEY_FORMAT or FORMAT is provided.\n\nAs of this PR, the only supported key format is \"KAFKA\". An error is thrown if other formats are provided (in both C* statements and also C*AS statements).\nSeparate PR for docs: #6252\nTesting done\nUnit + QTT. Not all tests are passing which is why this is a draft PR -- see comments inline.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-09-13T20:35:29Z", "url": "https://github.com/confluentinc/ksql/pull/6194", "merged": true, "mergeCommit": {"oid": "4b81912b01a16a663abf5ee29d9583cf514b3635"}, "closed": true, "closedAt": "2020-09-21T22:58:32Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdIkmIuAH2gAyNDg2MjM2NDMzOmY0Y2FlZDMzZTcyMjk5NjRjNzliOTZlNzc5NTQxZDFjZjgwN2FiMjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLKXdygH2gAyNDg2MjM2NDMzOjcxOWJjNDM0YTkzOTFlZDVmNTU5ZGEyZjMzNmE0MjQzMjQ5YTliNTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f4caed33e7229964c79b96e779541d1cf807ab24", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f4caed33e7229964c79b96e779541d1cf807ab24", "committedDate": "2020-09-13T20:26:52Z", "message": "feat: add KEY_FORMAT and FORMAT WITH clause properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/c7fa102fcd062f84cba757fdff27ca0c257153cb", "committedDate": "2020-09-13T21:06:23Z", "message": "test: fix DefaultFormatInjectorTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MzM5OTEx", "url": "https://github.com/confluentinc/ksql/pull/6194#pullrequestreview-487339911", "createdAt": "2020-09-13T21:07:05Z", "commit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMTowNzowNVrOHQ_Xow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMToxMjozMVrOHQ_ZuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzUwNw==", "bodyText": "This test (and also \"unsupported format\" below) currently does not pass in QTT even though it works if you actually spin up a server. This is because QTT does not run the RequestValidator, which is where the check is currently performed. I looked into adding the RequestValidator into QTT but it's not clear to me whether this is possible / the correct thing to do.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577507", "createdAt": "2020-09-13T21:07:05Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA==", "bodyText": "PlannedTestsUpToDateTest currently fails because of two changes:\n\nthe removal of the create or replace feature flag from this properties blacklist, as this adds a field into the plan\nthe additional of the DefaultFormatInjector in this PR, which injects KEY_FORMAT into CS/CT statements where only VALUE_FORMAT has been explicitly provided, which is currently all tests.\n\nI think these two changes are acceptable, and therefore the way to fix the test is to regenerate test plans, but I'm curious to hear what others think, especially regarding whether it makes sense to inject key/value formats into CS/CT statements that don't explicitly provide them. Note that this behavior is inline with the DefaultSchemaInjector injecting schemas into statements for which schema inference is performed.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577540", "createdAt": "2020-09-13T21:07:19Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "diffHunk": "@@ -50,7 +50,7 @@ public static boolean isNotExcluded(final TestCase testCase) {\n     // Place temporary logic here to exclude test cases based on feature flags, etc.\n     return !(boolean) testCase\n         .properties()\n-        .getOrDefault(KsqlConfig.KSQL_CREATE_OR_REPLACE_ENABLED, false);\n+        .getOrDefault(KsqlConfig.KSQL_KEY_FORMAT_ENABLED, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzY0OQ==", "bodyText": "This is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577649", "createdAt": "2020-09-13T21:08:41Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -197,7 +200,11 @@ private static Topic createTopicFromStatement(\n \n         if (isCsOrCT(stmt)) {\n           final PreparedStatement<?> prepare = parser.prepare(stmt, metaStore);\n-          topics.add(extractTopic.apply(prepare));\n+          final ConfiguredStatement<?> configured =\n+              ConfiguredStatement.of(prepare, Collections.emptyMap(), ksqlConfig);\n+          // TODO: cleaner way to handle this?\n+          final ConfiguredStatement<?> withFormats = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzcyNw==", "bodyText": "Same as above: this is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577727", "createdAt": "2020-09-13T21:09:25Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -438,10 +439,13 @@ public ConfiguredKsqlPlan next() {\n         return Optional.empty();\n       }\n \n+      // TODO: cleaner way to handle this?\n+      final ConfiguredStatement<?> withFormats =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3Nzg2OQ==", "bodyText": "Same problem as with the QTT framework above: this is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577869", "createdAt": "2020-09-13T21:10:41Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -210,9 +211,11 @@ private void execute(final ParsedStatement parsedStatement) {\n       return;\n     }\n \n+    // TODO: what's a cleaner way around this failure?\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA==", "bodyText": "Is the RequestValidator the right place to perform this validation? This felt more correct to me than either the executor or the DefaultFormatInjector, but given that neither QTT nor YATT calls the RequestValidator, I'm no longer sure.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487578040", "createdAt": "2020-09-13T21:12:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzA2Nzg2", "url": "https://github.com/confluentinc/ksql/pull/6194#pullrequestreview-487706786", "createdAt": "2020-09-14T12:35:18Z", "commit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "state": "COMMENTED", "comments": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNToxOFrOHRRntw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDowMTo0MlrOHRV5mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NjUzNQ==", "bodyText": "nit: lets get these moved up a line so they're next to VALUE_FORMAT_PROPERTY.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487876535", "createdAt": "2020-09-14T12:35:18Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/properties/with/CommonCreateConfigs.java", "diffHunk": "@@ -39,13 +39,14 @@\n   public static final String VALUE_AVRO_SCHEMA_FULL_NAME = \"VALUE_AVRO_SCHEMA_FULL_NAME\";\n   public static final String VALUE_FORMAT_PROPERTY = \"VALUE_FORMAT\";\n   public static final String WRAP_SINGLE_VALUE = \"WRAP_SINGLE_VALUE\";\n+  public static final String KEY_FORMAT_PROPERTY = \"KEY_FORMAT\";\n+  public static final String FORMAT_PROPERTY = \"FORMAT\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzA1OA==", "bodyText": "FORMAT and KEY_FORMAT are equally valid in CREATE AS statements, so this check is also needed in CreateSourceAsProperties class.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487883058", "createdAt": "2020-09-14T12:45:55Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NDY2Mw==", "bodyText": "Having these throw if the property is not set smells to me.  Better to have them return an Optional, meaning the optionality of the property is baked into the type system.\nThis would also decouple this class from DefaultFormatInjector, meaning you could remove all the comments about DefaultFormatInjector.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487884663", "createdAt": "2020-09-14T12:48:21Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4ODQ4Mw==", "bodyText": "Nothing wrong with the code above, but how about the following to remove some duplicate calls and code:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * This method may be called before the DefaultFormatInjector has run, in which case a\n          \n          \n            \n               * key format may not be present.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getKeyFormatName() {\n          \n          \n            \n                final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n          \n          \n            \n                    ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n          \n          \n            \n                    : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n          \n          \n            \n                return Optional.ofNullable(keyFormat);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n               * This method may be called before the DefaultFormatInjector has run, in which case a\n          \n          \n            \n               * value format may not be present.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getValueFormatName() {\n          \n          \n            \n                final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n          \n          \n            \n                    ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n          \n          \n            \n                    : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n          \n          \n            \n                return Optional.ofNullable(valueFormat);\n          \n          \n            \n              }\n          \n          \n            \n              /**\n          \n          \n            \n               * The key format name, if supplied explicitly.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getKeyFormatName() {\n          \n          \n            \n                final String keyFormat = getFormatName()\n          \n          \n            \n                   .orElse(props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY));\n          \n          \n            \n                return Optional.ofNullable(keyFormat);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n               * The value format name, if supplied explicitly.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getValueFormatName() {\n          \n          \n            \n                final String valueFormat = getFormatName()\n          \n          \n            \n                  .orElse(props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY));\n          \n          \n            \n                return Optional.ofNullable(valueFormat);\n          \n          \n            \n              }\n          \n          \n            \n              \n          \n          \n            \n              private Optional<String> getFormatName() {\n          \n          \n            \n                 return Optional.ofNullable(props.getString(CommonCreateConfigs.FORMAT_PROPERTY));\n          \n          \n            \n              }", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487888483", "createdAt": "2020-09-14T12:54:13Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTUwOQ==", "bodyText": "Add unit test / QTT test to cover the situation where FORMAT is supplied.  (Looks like this code would fail as its setting KEY_FORMAT and VALUE_FORMAT, but not clearing FORMAT if its provided.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487889509", "createdAt": "2020-09-14T12:55:37Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -182,6 +238,14 @@ public CreateSourceProperties withPartitionsAndReplicas(\n     return new CreateSourceProperties(originals, durationParser);\n   }\n \n+  public CreateSourceProperties withFormats(final String keyFormat, final String valueFormat) {\n+    final Map<String, Literal> originals = props.copyOfOriginalLiterals();\n+    originals.put(CommonCreateConfigs.KEY_FORMAT_PROPERTY, new StringLiteral(keyFormat));\n+    originals.put(CommonCreateConfigs.VALUE_FORMAT_PROPERTY, new StringLiteral(valueFormat));\n+\n+    return new CreateSourceProperties(originals, durationParser);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTgzNw==", "bodyText": "PropertiesConfig is meant to be a general purpose class, not specific to CreateSourceAsProperties and CreateSourceProperties. So while it makes sense to have general purpose code in there to handle timestamps, (validateDateTimeFormat), it probably doesn't make sense to have code in their for handle key & value formats.  That's probably best defined somewhere else. Maybe CommonCreateConfigs could have a utility method?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487889837", "createdAt": "2020-09-14T12:56:04Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/PropertiesConfig.java", "diffHunk": "@@ -69,6 +69,28 @@ public String toString() {\n     return new HashMap<>(originalLiterals);\n   }\n \n+  void validateKeyValueFormats(\n+      final String keyFormatConfig,\n+      final String valueFormatConfig,\n+      final String formatConfig\n+  ) {\n+    final Object value = originals().get(formatConfig);\n+    if (value == null) {\n+      return;\n+    }\n+\n+    if (originals().get(keyFormatConfig) != null) {\n+      throw new KsqlException(\"Cannot supply both '\" + keyFormatConfig + \"' and '\"\n+          + formatConfig + \"' properties. Did you mean to use '\" + valueFormatConfig\n+          + \"' instead of '\" + formatConfig + \"'?\");\n+    }\n+    if (originals().get(valueFormatConfig) != null) {\n+      throw new KsqlException(\"Cannot supply both '\" + valueFormatConfig + \"' and '\"\n+          + formatConfig + \"' properties. Did you mean to use '\" + keyFormatConfig\n+          + \"' instead of '\" + formatConfig + \"'?\");\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg==", "bodyText": "This test class needs shouldThrowIfKeyFormatAndFormatProvided and shouldThrowIfValueFormatAndFormatProvided tests as well.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487890442", "createdAt": "2020-09-14T12:56:59Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "diffHunk": "@@ -391,22 +391,6 @@ public void shouldFailIfNoKafkaTopicName() {\n     assertThat(e.getMessage(), containsString(\"Missing required property \\\"KAFKA_TOPIC\\\" which has no default value.\"));\n   }\n \n-  @Test\n-  public void shouldFailIfNoValueFormat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTY0Mw==", "bodyText": "nice catch!", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487891643", "createdAt": "2020-09-14T12:58:45Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/logging/processing/ProcessingLogServerUtils.java", "diffHunk": "@@ -78,20 +78,24 @@ public static String processingLogStreamCreateStatement(\n   ) {\n     return processingLogStreamCreateStatement(\n         config.getString(ProcessingLogConfig.STREAM_NAME),\n-        getTopicName(config, ksqlConfig)\n+        getTopicName(config, ksqlConfig),\n+        ksqlConfig.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTgxOQ==", "bodyText": "Likewise, nice catch!", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487891819", "createdAt": "2020-09-14T12:59:03Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -881,7 +881,11 @@ private void registerCommandTopic() {\n \n     final String createCmd = \"CREATE STREAM \" + COMMANDS_STREAM_NAME\n         + \" (STATEMENT STRING)\"\n-        + \" WITH(VALUE_FORMAT='JSON', KAFKA_TOPIC='\" + commandTopic + \"');\";\n+        + \" WITH(\"\n+        + (ksqlConfigNoPort.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+            ? \"KEY_FORMAT='KAFKA' \"\n+            : \"\")\n+        + \"VALUE_FORMAT='JSON', KAFKA_TOPIC='\" + commandTopic + \"');\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NzY4MQ==", "bodyText": "This doesn't look like the right place to me.  RequestValidator doesn't look to be called in headless mode.\nHow about putting a check at the top of EngineExecutor.plan(ConfiguredStatement<?> statement)?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487897681", "createdAt": "2020-09-14T13:08:14Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5ODk4MQ==", "bodyText": "Personally, I'd remove this bit from the JavaDocs (avoids the chance of it getting missed when the feature flag is removed).  And anyway, I don't think the injector needs to validate and throw the format properties. That only needs doing in one place.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487898981", "createdAt": "2020-09-14T13:09:57Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw==", "bodyText": "generally better to move code into functions to make the code much easier to read at a higher level, making this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              @Override\n          \n          \n            \n              public <T extends Statement> ConfiguredStatement<T> inject(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (statement.getStatement() instanceof CreateSource) {\n          \n          \n            \n                  final ConfiguredStatement<CreateSource> createStatement =\n          \n          \n            \n                      (ConfiguredStatement<CreateSource>) statement;\n          \n          \n            \n            \n          \n          \n            \n                  if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n          \n          \n            \n                    throwIfKeyFormatDisabled(createStatement);\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  try {\n          \n          \n            \n                    return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n          \n          \n            \n                  } catch (final KsqlStatementException e) {\n          \n          \n            \n                    throw e;\n          \n          \n            \n                  } catch (final KsqlException e) {\n          \n          \n            \n                    throw new KsqlStatementException(\n          \n          \n            \n                        ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                        statement.getStatementText(),\n          \n          \n            \n                        e.getCause());\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (statement.getStatement() instanceof CreateAsSelect) {\n          \n          \n            \n                  final ConfiguredStatement<CreateAsSelect> createAsSelect =\n          \n          \n            \n                      (ConfiguredStatement<CreateAsSelect>) statement;\n          \n          \n            \n            \n          \n          \n            \n                  if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n          \n          \n            \n                    throwIfKeyFormatDisabled(createAsSelect);\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              @Override\n          \n          \n            \n              public <T extends Statement> ConfiguredStatement<T> inject(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (featureFlagNotEnabled(statement)) {\n          \n          \n            \n                   return statement;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                if (statement.getStatement() instanceof CreateSource) {\n          \n          \n            \n                  return handleCreateSource((ConfiguredStatement<CreateSource>)statement);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (statement.getStatement() instanceof CreateAsSelect) {\n          \n          \n            \n                   return handleCreateSourceAs((ConfiguredStatement<CreateAsSelect>)statement);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nThis also limits the scope of the disabling of the unchecked warnings to only the bits of code that do this and it's clear that code is first checking the type.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487901117", "createdAt": "2020-09-14T13:13:07Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA==", "bodyText": "I think these can be removed. EngineExecutor.plan should be the only place you need to throw if key format is provided (or set to something other than KAFKA).\nI think all that is needed here is for inject to do nothing if the feature flag is not set.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487902704", "createdAt": "2020-09-14T13:15:28Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg4Ng==", "bodyText": "I think these can be removed. EngineExecutor.plan should be the only place you need to throw if key format is provided (or set to something other than KAFKA).\nI think all that is needed here is for inject to do nothing if the feature flag is not set.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487902886", "createdAt": "2020-09-14T13:15:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTY3NQ==", "bodyText": "This can go if you just early out of the inject method whenever the feature flag is not set.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487905675", "createdAt": "2020-09-14T13:19:54Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjM1OA==", "bodyText": "nit: unnecessary brackets:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n          \n          \n            \n                    && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487906358", "createdAt": "2020-09-14T13:20:50Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzA1OQ==", "bodyText": "You don't need T, so this can just become:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static <T extends Statement> KsqlConfig getConfig(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n          \n          \n            \n              }\n          \n          \n            \n              private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n          \n          \n            \n                return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n          \n          \n            \n              }", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487907059", "createdAt": "2020-09-14T13:21:50Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static <T extends Statement> KsqlConfig getConfig(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzM0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static <T extends Statement> void throwIfKeyFormatDisabled(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              private static void throwIfKeyFormatDisabled(final ConfiguredStatement<?> statement", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487907349", "createdAt": "2020-09-14T13:22:14Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static <T extends Statement> KsqlConfig getConfig(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static <T extends Statement> void throwIfKeyFormatDisabled(\n+      final ConfiguredStatement<T> statement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMDM4OA==", "bodyText": "I've leave the removal of the KSQL_CREATE_OR_REPLACE_ENABLED to another PR. It's not related to this PR.  You could just ping Almog to have him remove it.\nDefaultFormatInjector should, (as I've noted above), do nothing if the feature flag is not set.  Hence no plans should need to change.  In general, if you find you need to generate a new set of plans before the feature flag is removed... something is wrong! ;)", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487910388", "createdAt": "2020-09-14T13:26:25Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "diffHunk": "@@ -50,7 +50,7 @@ public static boolean isNotExcluded(final TestCase testCase) {\n     // Place temporary logic here to exclude test cases based on feature flags, etc.\n     return !(boolean) testCase\n         .properties()\n-        .getOrDefault(KsqlConfig.KSQL_CREATE_OR_REPLACE_ENABLED, false);\n+        .getOrDefault(KsqlConfig.KSQL_KEY_FORMAT_ENABLED, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMjQxNg==", "bodyText": "If we move the check, (see comments above), we can solve this issue.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487912416", "createdAt": "2020-09-14T13:28:57Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzUwNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzc5Mg==", "bodyText": "In the interest of keeping tests succinct:\n\ninput and output are not required when expectedException is provided.\ntopics is generally not needed, (and defo not needed in these cases). It's only needed if you want to set up the topic (Schema) before the test runs.\n\nCan you update this and other tests please?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487913792", "createdAt": "2020-09-14T13:30:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDY3MA==", "bodyText": "Would be nice if this message said key format...", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487914670", "createdAt": "2020-09-14T13:31:27Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA==", "bodyText": "You can add a post check to ensure the source in the meta store has the right key format:\n\"post\": {\n        \"sources\": [\n          {\n            \"name\": \"OUTPUT\",\n            \"type\": \"stream\",\n            \"keyFormat\": {\"format\": \"KAFKA\"},\n            \"schema\": \"`K` BIGINT KEY, `ID` BIGINT, `VALUE` BIGINT\"\n          }\n        ]\n      }\n\nMore details on the model of the QTT tests can be found in the module's README.md", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487917648", "createdAt": "2020-09-14T13:34:16Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxODgwMA==", "bodyText": "Maybe add in defaults in the properties, so the test proves the config is ignored when the user supplies it in the sstatement?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487918800", "createdAt": "2020-09-14T13:35:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxOTgyNw==", "bodyText": "Why is this complaining about the key format being AVRO...? Shoudln't this be JSON?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487919827", "createdAt": "2020-09-14T13:36:17Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyMDg1OA==", "bodyText": "Might be nice if this message said something about the fact that FORMAT sets both key and value format. So they should either set just FORMAT or both key and value.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487920858", "createdAt": "2020-09-14T13:37:17Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key format and format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', key_format='KAFKA', format='KAFKA');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Cannot supply both 'KEY_FORMAT' and 'FORMAT' properties. Did you mean to use 'VALUE_FORMAT' instead of 'FORMAT'?\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw==", "bodyText": "I actually think having the getValueFormat is too tightly coupling this properties class to FormatFactory.  It would be better if these weren't coupled IMHO.\nI'm happy for you to leave this for another day. But if you have the time, rather than adding a new getKeyFormat method, maybe you could just remove the getValueFormat method and move the FormatFactory call inline.  Then rename getValueFormatInfo to just getValueFormat.\nAlso, getValueFormatProperties shouldn't be public.  It's just API bloat. Better callers just call getValueFormat().getProperties().", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487924203", "createdAt": "2020-09-14T13:40:27Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "diffHunk": "@@ -69,8 +69,12 @@ private CreateSourceAsProperties(final Map<String, Literal> originals) {\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n   }\n \n+  public Optional<Format> getKeyFormat() {\n+    return getKeyFormatInfo().map(FormatFactory::of);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNjUyNA==", "bodyText": "As for the other properties class - can we inline these please and rename getKeyFormatInfo -> getKeyFormat etc?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487926524", "createdAt": "2020-09-14T13:42:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(\n+        CommonCreateConfigs.KEY_FORMAT_PROPERTY,\n+        CommonCreateConfigs.VALUE_FORMAT_PROPERTY,\n+        CommonCreateConfigs.FORMAT_PROPERTY\n+    );\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n     validateWindowInfo();\n   }\n \n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public Format getKeyFormat() {\n+    return FormatFactory.of(getKeyFormatInfo());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNzIwNg==", "bodyText": "These feel like API bloat to me. Calls can just call getKeyFormat().getName() or similar.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487927206", "createdAt": "2020-09-14T13:43:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw==", "bodyText": "I wouldn't worry about having this on the interface. In time, all key formats will be supported.  It's ok to just hard code the check in one place, rejecting any key formats we don't support yet.  Then once we're done, all will be supported and that bit of code can be removed.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487931503", "createdAt": "2020-09-14T13:47:33Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMzExNQ==", "bodyText": "Hummm.... lot of changes in this class, but no test changes to match!  If it possible to extend some of the YATT tests themselves to set the feature flag and defaults configs and/or set KEY_FORMAT?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487933115", "createdAt": "2020-09-14T13:49:07Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -60,41 +61,50 @@\n   static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n       .add(new SourceProperty(\n           DataSource::getSchema,\n-          cs -> cs.getElements().toLogicalSchema(),\n+          (cs, cfg) -> cs.getElements().toLogicalSchema(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NTM0NQ==", "bodyText": "Welcome to the mess of the testing tool!\nYou're approach is generally correct - we need your injector in QTT to do its thing, so unfortunately, this means adding it to QTT, given QTT doesn't currently just use the default Injectors class, (not sure it actually can... not something I'm that familiar with - @agavra  may have more context).\nFor background: this bit of code is attempting to extract the topic info from the statement.  Later in TestExecutorUtil we run the statement for real.  Ideally, we don't want to have to add your injector to both places.  That's just making the code worse.\nMaybe an OK approach would be to have a common method (probably in TestExecutorUtil), that knows how to prepare the statement, with the correct injectors.  You add your injector there, and have both places call that method.\nNot ideal, but....", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487945345", "createdAt": "2020-09-14T14:00:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -197,7 +200,11 @@ private static Topic createTopicFromStatement(\n \n         if (isCsOrCT(stmt)) {\n           final PreparedStatement<?> prepare = parser.prepare(stmt, metaStore);\n-          topics.add(extractTopic.apply(prepare));\n+          final ConfiguredStatement<?> configured =\n+              ConfiguredStatement.of(prepare, Collections.emptyMap(), ksqlConfig);\n+          // TODO: cleaner way to handle this?\n+          final ConfiguredStatement<?> withFormats = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzY0OQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NTY4Ng==", "bodyText": "See aboive.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487945686", "createdAt": "2020-09-14T14:00:48Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -438,10 +439,13 @@ public ConfiguredKsqlPlan next() {\n         return Optional.empty();\n       }\n \n+      // TODO: cleaner way to handle this?\n+      final ConfiguredStatement<?> withFormats =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzcyNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NjY0OQ==", "bodyText": "@agavra is probably the best person to comment here...", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487946649", "createdAt": "2020-09-14T14:01:42Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -210,9 +211,11 @@ private void execute(final ParsedStatement parsedStatement) {\n       return;\n     }\n \n+    // TODO: what's a cleaner way around this failure?\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3Nzg2OQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85ea098d1f6ac63e41238470c8508370285a2f77", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/85ea098d1f6ac63e41238470c8508370285a2f77", "committedDate": "2020-09-15T21:53:50Z", "message": "Merge branch 'master' into key-format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9614f7baca9c228120e4b4de239c6733cda8955d", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/9614f7baca9c228120e4b4de239c6733cda8955d", "committedDate": "2020-09-16T01:34:40Z", "message": "chore: move supported key format validation into engine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ffb7d294743e7c94848eba80f19a2e661dc4577", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/7ffb7d294743e7c94848eba80f19a2e661dc4577", "committedDate": "2020-09-16T01:55:56Z", "message": "chore: clean up use of feature flag in injector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fc1ae7dd034eb1777e70446b13603017b9cdbc0", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/9fc1ae7dd034eb1777e70446b13603017b9cdbc0", "committedDate": "2020-09-16T02:45:58Z", "message": "chore: feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MjI0NzU0", "url": "https://github.com/confluentinc/ksql/pull/6194#pullrequestreview-489224754", "createdAt": "2020-09-16T02:10:28Z", "commit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjoxMDoyOVrOHSddiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjo1NTo0M1rOHSeMfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExOTExNQ==", "bodyText": "Much nicer! Thanks for the tip.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489119115", "createdAt": "2020-09-16T02:10:29Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4ODQ4Mw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyMjgwNw==", "bodyText": "I've incorporated the meta-point in this comment as best I could but the result isn't as clean as in your example since I can't figure out what the method signature of handleCreateSource() in this example would be. In order to return the result directly the return type would need to be ConfiguredStatement<T> but the helper method wouldn't know what T is if the input param has type ConfiguredStatement<CreateSource>. As a result, I wasn't able to isolate the unchecked warning beyond where it's at currently.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489122807", "createdAt": "2020-09-16T02:23:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNDI3NQ==", "bodyText": "Not sure what this comment is getting at. shouldThrowIfKeyFormatAndFormatProvided and shouldThrowIfValueFormatAndFormatProvided were already added to this file (with those exact names). Did you mean that CreateSourceAsPropertiesTest would need these tests as well, once the analogous validation was added to CreateAsSelectProperties? If so, this is done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489124275", "createdAt": "2020-09-16T02:29:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "diffHunk": "@@ -391,22 +391,6 @@ public void shouldFailIfNoKafkaTopicName() {\n     assertThat(e.getMessage(), containsString(\"Missing required property \\\"KAFKA_TOPIC\\\" which has no default value.\"));\n   }\n \n-  @Test\n-  public void shouldFailIfNoValueFormat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNDYwMA==", "bodyText": "Yup, good catch. The test wasn't running previously for the reason given above. Fixed now.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489124600", "createdAt": "2020-09-16T02:30:16Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxOTgyNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyODQ5Nw==", "bodyText": "Interesting that the \"sources\" post condition only allows specification of key format and not value format. I think it makes sense to check both so I've used the \"topics\" post condition for now instead. The README says the \"partitions\" field of the \"topics\" post condition is optional but the test fails if I don't provide it. Two things to investigate, will do so after addressing the remaining comments on the meat on this PR.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489128497", "createdAt": "2020-09-16T02:45:47Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTgyMg==", "bodyText": "As discussed offline, this injector can't be a direct pass-through if the feature flag is not enabled because we still need to validate that VALUE_FORMAT is explicitly provided in this case, and I think it also makes sense to throw if KEY_FORMAT is supplied here rather than forcing downstream code to handle that. As discussed, I've cleaned up the feature flag handling logic in this class to only check the flag in one place so it's much more readable now.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129822", "createdAt": "2020-09-16T02:51:07Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTg0Mw==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129843", "createdAt": "2020-09-16T02:51:14Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg4Ng=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTkzNg==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129936", "createdAt": "2020-09-16T02:51:29Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTY3NQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzMTEzMg==", "bodyText": "Ah, good call on the RequestValidator not being called in headless mode! Moved to the check into EngineExecutor (as you've suggested) instead.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489131132", "createdAt": "2020-09-16T02:55:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e963da8ce78801f76e45f0fafe8cf663bc28e4f", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/9e963da8ce78801f76e45f0fafe8cf663bc28e4f", "committedDate": "2020-09-16T18:29:45Z", "message": "test: fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7428c71c734b450589947e7052a73b3bd17ff173", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/7428c71c734b450589947e7052a73b3bd17ff173", "committedDate": "2020-09-16T18:40:05Z", "message": "chore: inline getKeyFormat and getValueFormat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aeb706ba3f5fb2117cd94af0f65260d840d51800", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/aeb706ba3f5fb2117cd94af0f65260d840d51800", "committedDate": "2020-09-16T18:41:05Z", "message": "chore: rename getXXXFormatInfo to getXXXFormat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "915fe50c4a72b75ff761ebfb2a33e3238c77edb1", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/915fe50c4a72b75ff761ebfb2a33e3238c77edb1", "committedDate": "2020-09-16T18:56:36Z", "message": "chore: getXXXFormat in CS props now return optional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "048fa84e68b5024c62fa7b740410cb95ebbc032e", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/048fa84e68b5024c62fa7b740410cb95ebbc032e", "committedDate": "2020-09-16T19:04:47Z", "message": "chore: remove getXXXFormatName"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ffc8e08f5f54c3fd6b14de335507ac15d0019b9", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/7ffc8e08f5f54c3fd6b14de335507ac15d0019b9", "committedDate": "2020-09-17T03:35:10Z", "message": "chore: fix PlannedTestsUpToDateTest by removing statement text from comparison"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8863eb45fcd26e30164384bf4f27d0eb0dd1f7a1", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/8863eb45fcd26e30164384bf4f27d0eb0dd1f7a1", "committedDate": "2020-09-17T03:35:10Z", "message": "chore: update error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee96cd76dc6046c4c5e7fc79ce1987fc4e08e315", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ee96cd76dc6046c4c5e7fc79ce1987fc4e08e315", "committedDate": "2020-09-17T03:35:10Z", "message": "test: add YATT tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMjE1OTE1", "url": "https://github.com/confluentinc/ksql/pull/6194#pullrequestreview-490215915", "createdAt": "2020-09-17T03:22:24Z", "commit": {"oid": "9fc1ae7dd034eb1777e70446b13603017b9cdbc0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzoyMjoyNFrOHTOvRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzozNDoyNVrOHTPLIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyNjQ2OA==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489926468", "createdAt": "2020-09-17T03:22:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key format and format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', key_format='KAFKA', format='KAFKA');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Cannot supply both 'KEY_FORMAT' and 'FORMAT' properties. Did you mean to use 'VALUE_FORMAT' instead of 'FORMAT'?\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyMDg1OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyOTg2MQ==", "bodyText": "I'm happy for you to leave this for another day. But if you have the time, rather than adding a new getKeyFormat method, maybe you could just remove the getValueFormat method and move the FormatFactory call inline. Then rename getValueFormatInfo to just getValueFormat.\n\nDone.\n\nAlso, getValueFormatProperties shouldn't be public. It's just API bloat. Better callers just call getValueFormat().getProperties().\n\ngetValueFormat() returns an Optional which may be empty, whereas there are uses of getValueFormatProperties() even if getValueFormat() is empty, for example: \n  \n    \n      ksql/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java\n    \n    \n        Lines 177 to 179\n      in\n      0f04061\n    \n    \n    \n    \n\n        \n          \n           // overwrite any inheritable properties if they were explicitly \n        \n\n        \n          \n           // specified in the statement \n        \n\n        \n          \n           sourceProperties.putAll(sink.getProperties().getFormatProperties());", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489929861", "createdAt": "2020-09-17T03:27:53Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "diffHunk": "@@ -69,8 +69,12 @@ private CreateSourceAsProperties(final Map<String, Literal> originals) {\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n   }\n \n+  public Optional<Format> getKeyFormat() {\n+    return getKeyFormatInfo().map(FormatFactory::of);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMDE4Ng==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489930186", "createdAt": "2020-09-17T03:28:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(\n+        CommonCreateConfigs.KEY_FORMAT_PROPERTY,\n+        CommonCreateConfigs.VALUE_FORMAT_PROPERTY,\n+        CommonCreateConfigs.FORMAT_PROPERTY\n+    );\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n     validateWindowInfo();\n   }\n \n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public Format getKeyFormat() {\n+    return FormatFactory.of(getKeyFormatInfo());\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNjUyNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMzYwMw==", "bodyText": "Added tests to ensure that YATT is properly verifying KEY_FORMAT of sources, and that FORMAT behaves as expected too. Didn't add tests to check that default format values are picked up from the config since there are already QTT tests for that, and I don't see the value of duplication here.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489933603", "createdAt": "2020-09-17T03:34:25Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -60,41 +61,50 @@\n   static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n       .add(new SourceProperty(\n           DataSource::getSchema,\n-          cs -> cs.getElements().toLogicalSchema(),\n+          (cs, cfg) -> cs.getElements().toLogicalSchema(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMzExNQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d580e4fd38d12fbbbd62b25365701b8c1ed83721", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/d580e4fd38d12fbbbd62b25365701b8c1ed83721", "committedDate": "2020-09-17T20:42:02Z", "message": "chore: refactor injector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d374c6bcd6493fceac0a32354efb0ab85bb4edd9", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/d374c6bcd6493fceac0a32354efb0ab85bb4edd9", "committedDate": "2020-09-17T20:50:07Z", "message": "chore: test injector cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5d9b5bbc3ed8748cb559b3ce090d5ab23223d83", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f5d9b5bbc3ed8748cb559b3ce090d5ab23223d83", "committedDate": "2020-09-18T02:37:55Z", "message": "test: fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20d64a782e94d628e6a4bf4025f5f012bf3a4d77", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/20d64a782e94d628e6a4bf4025f5f012bf3a4d77", "committedDate": "2020-09-18T02:37:55Z", "message": "fix: fix execution of pre-plan statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/efae981d3defa43ee390e65bd43e9685377dfc54", "committedDate": "2020-09-18T02:50:30Z", "message": "chore: checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMTE2OTE5", "url": "https://github.com/confluentinc/ksql/pull/6194#pullrequestreview-491116919", "createdAt": "2020-09-18T02:58:36Z", "commit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMjo1ODozNlrOHT8PdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMzowMjowOVrOHT8S0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA==", "bodyText": "Yuck :[\nThis is needed because statements read from the command topic aren't passed through injectors, yet the engine expects key formats to be present which is not the case for pre-execution-plan statements.\nRather than using the injector here, we could create the KsqlConfig and fill in the default, or we could hard-code the Kafka format, all of which are effectively equivalent.\nIs this sufficient reason to not use an injector in order to populate the default from the config? I don't think so but this is really gross.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490671988", "createdAt": "2020-09-18T02:58:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -310,8 +311,9 @@ private String executeDdlStatement(final PreparedStatement<?> statement, final C\n     final KsqlConfig mergedConfig = buildMergedConfig(command);\n     final ConfiguredStatement<?> configured =\n         ConfiguredStatement.of(statement, command.getOverwriteProperties(), mergedConfig);\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3Mjg0OQ==", "bodyText": "Unless the feature flag is enabled, this test fails if this check is present since the statement in the response contains KEY_FORMAT whereas the original statement text does not. Once we enable the feature flag by default, and the test is updated to include KEY_FORMAT in the request, this can be added back in. Same for the other changes in this file.\nIf desirable, we can add a version of these tests with the feature flag enabled and the statementText response check present, but I'm not sure how much value we gain from these particular checks so that doesn't seem worth it.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490672849", "createdAt": "2020-09-18T03:02:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "diffHunk": "@@ -15,7 +15,7 @@\n         {\"topic\": \"test_topic\", \"timestamp\": 1234, \"key\": \"key\", \"value\": {\"ID\": 10}}\n       ],\n       \"responses\": [\n-        {\"admin\": {\"@type\": \"currentStatus\", \"statementText\": \"{STATEMENT}\"}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "596a9723ff909250b169db50666a473da1fd1436", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/596a9723ff909250b169db50666a473da1fd1436", "committedDate": "2020-09-18T03:12:59Z", "message": "Merge branch 'master' into key-format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f24796946c7f7cfd88b1a503d1822b42ba8e67bf", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f24796946c7f7cfd88b1a503d1822b42ba8e67bf", "committedDate": "2020-09-18T03:57:20Z", "message": "test: more test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa32869968114bf36934e1a41224c4751fbe7def", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/aa32869968114bf36934e1a41224c4751fbe7def", "committedDate": "2020-09-20T15:03:06Z", "message": "Merge branch 'master' into key-format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebe62a5b48a29f72484ecb7b7c82699321b45e3f", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ebe62a5b48a29f72484ecb7b7c82699321b45e3f", "committedDate": "2020-09-20T15:14:43Z", "message": "test: more test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46bdd57357e639400c1ffdca8f66c31687501cef", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/46bdd57357e639400c1ffdca8f66c31687501cef", "committedDate": "2020-09-20T15:17:50Z", "message": "chore: checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f9cb6596c2b43a8c28a01e468de7b7081b7f4e9", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/4f9cb6596c2b43a8c28a01e468de7b7081b7f4e9", "committedDate": "2020-09-20T20:50:58Z", "message": "test: more test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62951e00ffbc4878e214a458d03c1e837758a790", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/62951e00ffbc4878e214a458d03c1e837758a790", "committedDate": "2020-09-20T22:04:00Z", "message": "chore: validate default formats up front"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe945d192db52623a1c747af7a16bd9cbb34ad76", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/fe945d192db52623a1c747af7a16bd9cbb34ad76", "committedDate": "2020-09-20T22:09:22Z", "message": "chore: enable json as key format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "committedDate": "2020-09-21T00:14:32Z", "message": "test: another test fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNTgxMDU4", "url": "https://github.com/confluentinc/ksql/pull/6194#pullrequestreview-492581058", "createdAt": "2020-09-21T13:07:27Z", "commit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "state": "APPROVED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzowNzoyN1rOHVPHww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo1Mjo0M1rOHVRGMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ==", "bodyText": "You're calling throwOnUnsupportedKeyFormat from within the plan method's try/catch block already, so I don't think you need this try/catch, just let the exception bubble up.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492029891", "createdAt": "2020-09-21T13:07:27Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -342,6 +349,36 @@ private static void throwOnNonExecutableStatement(final ConfiguredStatement<?> s\n     }\n   }\n \n+  private static void throwOnUnsupportedKeyFormat(final ConfiguredStatement<?> statement) {\n+    try {\n+      if (statement.getStatement() instanceof CreateSource) {\n+        final CreateSource createSource = (CreateSource) statement.getStatement();\n+        throwOnUnsupportedKeyFormat(\n+            SourcePropertiesUtil.getKeyFormat(createSource.getProperties()));\n+      }\n+\n+      if (statement.getStatement() instanceof CreateAsSelect) {\n+        final CreateAsSelect createAsSelect = (CreateAsSelect) statement.getStatement();\n+        createAsSelect.getProperties().getKeyFormat()\n+            .ifPresent(EngineExecutor::throwOnUnsupportedKeyFormat);\n+      }\n+    } catch (KsqlStatementException e) {\n+      throw e;\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMTMzNA==", "bodyText": "And for the record... ErrorMessageUtil... yuck!!!! I'd avoid using this class. It's one that should be shot in the head at some point.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492031334", "createdAt": "2020-09-21T13:09:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -342,6 +349,36 @@ private static void throwOnNonExecutableStatement(final ConfiguredStatement<?> s\n     }\n   }\n \n+  private static void throwOnUnsupportedKeyFormat(final ConfiguredStatement<?> statement) {\n+    try {\n+      if (statement.getStatement() instanceof CreateSource) {\n+        final CreateSource createSource = (CreateSource) statement.getStatement();\n+        throwOnUnsupportedKeyFormat(\n+            SourcePropertiesUtil.getKeyFormat(createSource.getProperties()));\n+      }\n+\n+      if (statement.getStatement() instanceof CreateAsSelect) {\n+        final CreateAsSelect createAsSelect = (CreateAsSelect) statement.getStatement();\n+        createAsSelect.getProperties().getKeyFormat()\n+            .ifPresent(EngineExecutor::throwOnUnsupportedKeyFormat);\n+      }\n+    } catch (KsqlStatementException e) {\n+      throw e;\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMjg3Ng==", "bodyText": "I'd suggest putting some java docs on here explaining that the DefaultFormatInjector ensures that the formats are always present, i.e. tie up the code that avoids the Illegal state exception from being thrown with this code.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492032876", "createdAt": "2020-09-21T13:12:05Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/SourcePropertiesUtil.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.properties.with;\n+\n+import io.confluent.ksql.serde.FormatInfo;\n+\n+public final class SourcePropertiesUtil {\n+\n+  private SourcePropertiesUtil() {\n+  }\n+\n+  public static FormatInfo getKeyFormat(final CreateSourceProperties properties) {\n+    return properties.getKeyFormat()\n+        .orElseThrow(() -> new IllegalStateException(\"Key format not present\"));\n+  }\n+\n+  public static FormatInfo getValueFormat(final CreateSourceProperties properties) {\n+    return properties.getValueFormat()\n+        .orElseThrow(() -> new IllegalStateException(\"Value format not present\"));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNDAyMg==", "bodyText": "As above, remove this from the interface.  A format shouldn't know if its supported by the engine as a value or key format, it should know about itself.  It's the engine that knows what it does and does not support as a key format.  (Think about this interface soon being a 'user defined format' interface... we wouldn't expect implementers to say if its supported as a key format or not.)", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492034022", "createdAt": "2020-09-21T13:13:53Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNTA2MA==", "bodyText": "As discussed above, let's only throw if non KAFKA.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492035060", "createdAt": "2020-09-21T13:15:25Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNzM3Mg==", "bodyText": "nit:\nRather than having a method throwKeyFormatDisabled  that always throws an exception, I'd suggest having a keyFormatDisabledException method that creates the exception:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (createStatement.getProperties().getKeyFormat().isPresent()) {\n          \n          \n            \n                    throwKeyFormatDisabled(statement.getStatementText());\n          \n          \n            \n                  }\n          \n          \n            \n                  if (createStatement.getProperties().getKeyFormat().isPresent()) {\n          \n          \n            \n                    throw keyFormatDisabledException(statement.getStatementText());\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nThe benefit, is that it's easier to grok as you know by looking at the code that an exception is always thrown, without having to go check another function. This pattern can also avoid compiler issues, e.g. warnings and errors about code paths not initializing variables.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492037372", "createdAt": "2020-09-21T13:18:56Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzOTkwMg==", "bodyText": "As discussed above, the following avoids the need for casting and suppressing warnings in the calling function:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n          \n          \n            \n                  final ConfiguredStatement<CreateSource> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                try {\n          \n          \n            \n                  // Safe to cast as we know `T` is `CreateSource`\n          \n          \n            \n                  return (ConfiguredStatement<T>)\n          \n          \n            \n                      injectForCreateStatement(statement).orElse(statement);\n          \n          \n            \n                } catch (final KsqlStatementException e) {\n          \n          \n            \n                  throw e;\n          \n          \n            \n                } catch (final KsqlException e) {\n          \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (!(statement.getStatement() instanceOf CreateSource) {\n          \n          \n            \n                   throw new IllegalArgumentException(\"blah\");\n          \n          \n            \n                }\n          \n          \n            \n                try {\n          \n          \n            \n                  // Safe to cast as we know `T` is `CreateSource`\n          \n          \n            \n                  return (ConfiguredStatement<T>)\n          \n          \n            \n                      injectForCreateStatement(statement).orElse(statement);\n          \n          \n            \n                } catch (final KsqlStatementException e) {\n          \n          \n            \n                  throw e;\n          \n          \n            \n                } catch (final KsqlException e) {\n          \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nIf you don't link the double checking of types and loss of type safety, then stick with what you have. No biggie.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492039902", "createdAt": "2020-09-21T13:22:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzExNg==", "bodyText": "nit:  this code is correct and works.  However, just a suggestion in terms of the pattern...\nThis code separates the validation from the access.  You first validate the state is what you need, then you access the state.  This works well until someone comes along and changes one side without realizing they should update the other.\nI'd suggest a better pattern is to access the state and validate what you extract. This makes it much harder for someone to come along and miss something, e.g.\nprivate Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n      final ConfiguredStatement<CreateSource> original\n  ) {\n   ....\n \n   final KsqlConfig config = getConfig(original);\n\n    final CreateSourceProperties injectedProps = properties.withFormats(\n        keyFormat.map(FormatInfo::getFormat).orElseGet(() -> getDefaultKeyFormat(config)),\n        valueFormat.map(FormatInfo::getFormat).orElseGet(() -> getDefaultValueFormat(config))\n    );\n\n    ...\n }\n\n private String getDefaultKeyFormat(final KsqlConfig config) {\n     final String format = config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG);\n    if (format == null) {\n        throw new KsqlException(\"Statement is missing the '\"\n          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n          + \"Either provide one or set a default via the '\"\n          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n    }\n\n    return format;\n }\n\n // Same pattern for getDefaultValueFormat\nHere, both the accessing and validating of the default key format is done in one place: the getDefaultKeyFormat method.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492047116", "createdAt": "2020-09-21T13:32:42Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MTM1Mw==", "bodyText": "Avoid use of ErrorMessageUtil... it's nasty.  How about just:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                  throw new KsqlStatementException(e.getMessage(), statement.getStatementText(), e);", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492051353", "createdAt": "2020-09-21T13:38:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MzAxNw==", "bodyText": "nit: Pull SourcePropertiesUtil.getKeyFormat(properties) out in to a variable?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492053017", "createdAt": "2020-09-21T13:40:32Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/topic/TopicFactory.java", "diffHunk": "@@ -37,13 +36,16 @@ public static KsqlTopic create(final CreateSourceProperties properties) {\n     final Optional<WindowType> windowType = properties.getWindowType();\n     final Optional<Duration> windowSize = properties.getWindowSize();\n \n+\n     final KeyFormat keyFormat = windowType\n         .map(type -> KeyFormat\n-            .windowed(FormatInfo.of(FormatFactory.KAFKA.name()), WindowInfo.of(type, windowSize)))\n+            .windowed(\n+                SourcePropertiesUtil.getKeyFormat(properties),\n+                WindowInfo.of(type, windowSize)))\n         .orElseGet(() -> KeyFormat\n-            .nonWindowed(FormatInfo.of(FormatFactory.KAFKA.name())));\n+            .nonWindowed(SourcePropertiesUtil.getKeyFormat(properties)));\n \n-    final ValueFormat valueFormat = ValueFormat.of(properties.getFormatInfo());\n+    final ValueFormat valueFormat = ValueFormat.of(SourcePropertiesUtil.getValueFormat(properties));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NTY3Mw==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Injector statementInjector;\n          \n          \n            \n              private Injector formatInjector;", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492055673", "createdAt": "2020-09-21T13:44:05Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -108,6 +110,7 @@\n   private ServiceContext serviceContext;\n   private KsqlEngine engine;\n   private KsqlConfig config;\n+  private Injector statementInjector;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NjE1NA==", "bodyText": "Todo: allow... right?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492056154", "createdAt": "2020-09-21T13:44:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -1,22 +1,276 @@\n {\n   \"tests\": [\n     {\n-      \"name\": \"invalid format name\",\n+      \"name\": \"invalid value format\",\n       \"statements\": [\n         \"CREATE STREAM TEST WITH (kafka_topic='test_topic', value_format='FOO');\"\n       ],\n-      \"topics\": [\n-        {\n-          \"name\": \"test_topic\",\n-          \"format\": \"JSON\"\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      }\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      }\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      }\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1OTQzNQ==", "bodyText": "We shouldn't really be removing this.. it's testing the API is returning the correct statement text with the response.\nTricky...", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492059435", "createdAt": "2020-09-21T13:48:57Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "diffHunk": "@@ -15,7 +15,7 @@\n         {\"topic\": \"test_topic\", \"timestamp\": 1234, \"key\": \"key\", \"value\": {\"ID\": 10}}\n       ],\n       \"responses\": [\n-        {\"admin\": {\"@type\": \"currentStatus\", \"statementText\": \"{STATEMENT}\"}}\n+        {\"admin\": {\"@type\": \"currentStatus\"}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2MTc4MQ==", "bodyText": "You upper-case here, but not elsewhere in the code when accessing the property.  Maybe just move the uppercasing into fromName?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492061781", "createdAt": "2020-09-21T13:52:06Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlServerMain.java", "diffHunk": "@@ -101,6 +102,47 @@ void tryStartApp() throws Exception {\n     }\n   }\n \n+  private static void validateConfig(final KsqlConfig config) {\n+    validateStateDir(config);\n+    validateDefaultTopicFormats(config);\n+  }\n+\n+  private static void validateStateDir(final KsqlConfig config) {\n+    final String streamsStateDirPath = config.getKsqlStreamConfigProps().getOrDefault(\n+        StreamsConfig.STATE_DIR_CONFIG,\n+        StreamsConfig.configDef().defaultValues().get(StreamsConfig.STATE_DIR_CONFIG)).toString();\n+    enforceStreamStateDirAvailability(new File(streamsStateDirPath));\n+  }\n+\n+  @VisibleForTesting\n+  static void validateDefaultTopicFormats(final KsqlConfig config) {\n+    validateTopicFormat(config, KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG, \"key\");\n+    validateTopicFormat(config, KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG, \"value\");\n+  }\n+\n+  private static void validateTopicFormat(\n+      final KsqlConfig config,\n+      final String configName,\n+      final String type\n+  ) {\n+    final String formatName = config.getString(configName);\n+    if (formatName == null) {\n+      return;\n+    }\n+\n+    final Format format;\n+    try {\n+      format = FormatFactory.fromName(formatName.toUpperCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2MjI1OA==", "bodyText": "Just replace it with a Util class method.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492062258", "createdAt": "2020-09-21T13:52:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e61bb75bb491acf207f108cc56856b4e1f66d766", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/e61bb75bb491acf207f108cc56856b4e1f66d766", "committedDate": "2020-09-21T17:45:44Z", "message": "chore: remove isSupportedKeyFormat from interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "066a4f411e4af366fb1e863ffee82fd40ece4eaa", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/066a4f411e4af366fb1e863ffee82fd40ece4eaa", "committedDate": "2020-09-21T18:19:05Z", "message": "chore: feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0592fe03aab5062130c9dd22334685a0840cb02e", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/0592fe03aab5062130c9dd22334685a0840cb02e", "committedDate": "2020-09-21T18:30:06Z", "message": "chore: allow use of key_format and format without feature flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "429740a32867b66ced69d94a39e95190d3192be4", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/429740a32867b66ced69d94a39e95190d3192be4", "committedDate": "2020-09-21T18:48:43Z", "message": "fix: use of FORMAT in C*AS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe947af3c52632ca866155610bc23cad70df66e", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/0fe947af3c52632ca866155610bc23cad70df66e", "committedDate": "2020-09-21T18:53:51Z", "message": "test: qtt for key_format without feature flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49460ae9a3b7fbecce19c035936e3d4ba4ab49fb", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/49460ae9a3b7fbecce19c035936e3d4ba4ab49fb", "committedDate": "2020-09-21T18:56:51Z", "message": "chore: historic plans for qtt without feature flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1f0ca19302bc44a11269e355f9d8345b1d14668", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f1f0ca19302bc44a11269e355f9d8345b1d14668", "committedDate": "2020-09-21T21:27:12Z", "message": "Merge branch 'master' into key-format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "719bc434a9391ed5f559da2f336a4243249a9b51", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/719bc434a9391ed5f559da2f336a4243249a9b51", "committedDate": "2020-09-21T21:35:05Z", "message": "chore: another merge conflict"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4650, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}