{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTU4MTc0", "number": 4376, "title": "feat: Support JSON format for responses and other refactorings", "bodyText": "Description\nCompletes #4317\nThis PR:\n\nDepending on content-type in accept header query/insert responses will be in delimited or JSON format.\nExtracts endpoint handlers into their own classes\nExtracts and cleans up query close logic into separate classes.\nA few bits and pieces.\n\nTesting done\nIncludes new tests for the content type of response\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-01-23T20:42:08Z", "url": "https://github.com/confluentinc/ksql/pull/4376", "merged": true, "mergeCommit": {"oid": "1ecaeee6780d214372abc12848c99b6a0cfd1b7f"}, "closed": true, "closedAt": "2020-01-24T19:09:45Z", "author": {"login": "purplefox"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9ds5qAFqTM0Nzg3NjQ3NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9i-WVgBqjI5NzgxMjg5OTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODc2NDc0", "url": "https://github.com/confluentinc/ksql/pull/4376#pullrequestreview-347876474", "createdAt": "2020-01-24T10:49:52Z", "commit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "state": "COMMENTED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMDo0OTo1MlrOFhaFoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMTo1MToxNVrOFhbc2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NDc1Mw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370574753", "createdAt": "2020-01-24T10:49:52Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -31,21 +30,22 @@\n  */\n public class AcksSubscriber extends ReactiveSubscriber<JsonObject> {\n \n-  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n-      .appendString(\"\\n\");\n   private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n   private static final int REQUEST_BATCH_SIZE = 1000;\n \n   private final HttpServerResponse response;\n+  private final InsertsStreamResponseWriter insertsStreamResponseWriter;\n   private Long insertsSent;\n   private long acksSent;\n   private boolean drainHandlerSet;\n   private Subscription subscription;\n   private boolean cancelled;\n \n-  public AcksSubscriber(final Context context, final HttpServerResponse response) {\n+  public AcksSubscriber(final Context context, final HttpServerResponse response,\n+      final InsertsStreamResponseWriter insertsStreamResponseWriter) {\n     super(context);\n     this.response = response;\n+    this.insertsStreamResponseWriter = insertsStreamResponseWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NTE5Mw==", "bodyText": "If this is specifically only for push queries, as per java-doc above, maybe it should have Push in the name?", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370575193", "createdAt": "2020-01-24T10:50:54Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java", "diffHunk": "@@ -15,46 +15,39 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.Objects;\n import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n  * cryptographically secure. This is important as we don't want random users guessing query IDs and\n  * closing other peoples queries.\n  */\n-public final class ApiQueryID {\n+public class ApiQuery {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NTI5OA==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370575298", "createdAt": "2020-01-24T10:51:08Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java", "diffHunk": "@@ -15,46 +15,39 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.Objects;\n import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n  * cryptographically secure. This is important as we don't want random users guessing query IDs and\n  * closing other peoples queries.\n  */\n-public final class ApiQueryID {\n+public class ApiQuery {\n \n+  private final Server server;\n   private final String id;\n+  private final ConnectionQueries connectionQueries;\n+  private final QuerySubscriber querySubscriber;\n \n-  public ApiQueryID() {\n+  public ApiQuery(final Server server, final ConnectionQueries connectionQueries,\n+      final QuerySubscriber querySubscriber) {\n+    this.server = server;\n     this.id = UUID.randomUUID().toString();\n+    this.connectionQueries = connectionQueries;\n+    this.querySubscriber = querySubscriber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NjE5Mw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370576193", "createdAt": "2020-01-24T10:53:21Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handles requests to the close-query endpoint\n+ */\n+public class CloseQueryHandler implements Handler<RoutingContext> {\n+\n+  private final Server server;\n+\n+  public CloseQueryHandler(final Server server) {\n+    this.server = server;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NjUwMw==", "bodyText": "As with other PR, our convention would have it as queryId. Best to be consistent.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370576503", "createdAt": "2020-01-24T10:53:56Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handles requests to the close-query endpoint\n+ */\n+public class CloseQueryHandler implements Handler<RoutingContext> {\n+\n+  private final Server server;\n+\n+  public CloseQueryHandler(final Server server) {\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final JsonObject requestBody = routingContext.getBodyAsJson();\n+    final String queryID = requestBody.getString(\"queryID\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzExNQ==", "bodyText": "still think queryId would benefit from being a concrete type other than String, as it was before. This will help disambiguate this query id from others in the system.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370577115", "createdAt": "2020-01-24T10:55:24Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handles requests to the close-query endpoint\n+ */\n+public class CloseQueryHandler implements Handler<RoutingContext> {\n+\n+  private final Server server;\n+\n+  public CloseQueryHandler(final Server server) {\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final JsonObject requestBody = routingContext.getBodyAsJson();\n+    final String queryID = requestBody.getString(\"queryID\");\n+    if (queryID == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+          \"No queryID in arguments\");\n+      return;\n+    }\n+    final ApiQuery query = server.removeQuery(queryID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzI3Mw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370577273", "createdAt": "2020-01-24T10:55:49Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  private final Set<ApiQuery> queries = new HashSet<>();\n+\n+  public ConnectionQueries(final HttpConnection conn, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.conn = conn;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzM0Mw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370577343", "createdAt": "2020-01-24T10:56:00Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  private final Set<ApiQuery> queries = new HashSet<>();\n+\n+  public ConnectionQueries(final HttpConnection conn, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.conn = conn;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;\n+    conn.closeHandler(this);\n+    server.registerQueryConnection(conn);\n+  }\n+\n+  public void addQuery(final ApiQuery query) {\n+    queries.add(query);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3ODg0OQ==", "bodyText": "Take defensive, ideally immutable, copy.  At the moment any change to the connectionsMap  constructor parameter by forces outside this instance will change the state of this object, i.e. it breaks encapsulation.\nIf the intent is to share state between multiple actors in the system then this is best achieved by having a type that owns the data, and changing the others that need to view / modify the data to call methods on the owning type.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370578849", "createdAt": "2020-01-24T10:59:57Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  private final Set<ApiQuery> queries = new HashSet<>();\n+\n+  public ConnectionQueries(final HttpConnection conn, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.conn = conn;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTQzNA==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370579434", "createdAt": "2020-01-24T11:01:37Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedInsertsStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the inserts response stream in delimited format.\n+ *\n+ * <p>Each insert in the incoming stream will have a corresponding entry in the response stream, in\n+ * the same order as the inserts.\n+ *\n+ * <p>Each entry is a JSON object, separated by newline. The overall response does not form a\n+ * single JSON object or array. This makes it easier to parse at the client without recourse to\n+ * streaming JSON parsers.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n+\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedInsertsStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTY0OA==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370579648", "createdAt": "2020-01-24T11:02:14Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MDAyNQ==", "bodyText": "would benefit from parameters being more strongly typed.  But assuming you'll be doing that in your Pojo PR?", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370580025", "createdAt": "2020-01-24T11:03:17Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeMetadata(final JsonObject metaData) {\n+    response.write(metaData.toBuffer().appendString(\"\\n\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeRow(final JsonArray row) {\n+    response.write(row.toBuffer().appendString(\"\\n\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeError(final JsonObject error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MjQzMQ==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370582431", "createdAt": "2020-01-24T11:09:59Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.decodeJsonObject;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+\n+/**\n+ * Handles requests to the query-stream endpoint\n+ */\n+public class QueryStreamHandler implements Handler<RoutingContext> {\n+\n+  static final String JSON_CONTENT_TYPE = \"application/json\";\n+  static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n+\n+  private final Endpoints endpoints;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.endpoints = endpoints;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MzI0MQ==", "bodyText": "connectionsMap is only used here. Could it not be a created by QueryStreamHandler, rather than created here and passed in.   Or do you envisage this state being used by others later?", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370583241", "createdAt": "2020-01-24T11:12:07Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -85,123 +73,18 @@ public void stop(final Promise<Void> stopPromise) {\n \n   private Router setupRouter() {\n     final Router router = Router.router(vertx);\n-    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n-        .handler(this::handleQueryStream);\n-    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/query-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(BodyHandler.create())\n+        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NDc2OA==", "bodyText": "Consider using computeIfAbscent for this kind of operation, as it leads to less, and makes it easier to switch to concurrent/atomic types and operations in the future, if needed:\nfinal ConnectionQueries connectionQueries = connectionsMap\n        .computeIfAbsent(conn, k -> new ConnectionQueries(k, server, connectionsMap));```", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370584768", "createdAt": "2020-01-24T11:16:35Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.decodeJsonObject;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+\n+/**\n+ * Handles requests to the query-stream endpoint\n+ */\n+public class QueryStreamHandler implements Handler<RoutingContext> {\n+\n+  static final String JSON_CONTENT_TYPE = \"application/json\";\n+  static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n+\n+  private final Endpoints endpoints;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.endpoints = endpoints;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+\n+    final String contentType = routingContext.getAcceptableContentType();\n+    final QueryStreamResponseWriter queryStreamResponseWriter;\n+    if (DELIMITED_CONTENT_TYPE.equals(contentType) || contentType == null) {\n+      // Default\n+      queryStreamResponseWriter =\n+          new DelimitedQueryStreamResponseWriter(routingContext.response());\n+    } else {\n+      queryStreamResponseWriter = new JsonQueryStreamResponseWriter(routingContext.response());\n+    }\n+\n+    final JsonObject requestBody = decodeJsonObject(routingContext.getBody(), routingContext);\n+    if (requestBody == null) {\n+      return;\n+    }\n+    final String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    final Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    final JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    final QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+\n+    final QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response(),\n+        queryStreamResponseWriter);\n+\n+    final HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn, server, connectionsMap);\n+      connectionsMap.put(conn, connectionQueries);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NTUzNA==", "bodyText": "consider having these flow methods return DelimitedQueryStreamResponseWriter, rather than the interface type.  This would, in the future, allow chaining of methods not on the interface.\nNot biggie though.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370585534", "createdAt": "2020-01-24T11:18:46Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeMetadata(final JsonObject metaData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NjM3Nw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370586377", "createdAt": "2020-01-24T11:21:11Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java", "diffHunk": "@@ -38,39 +40,60 @@\n  * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n  * followed by a new-line.\n  */\n-public class InsertsBodyHandler {\n+public class InsertsStreamHandler implements Handler<RoutingContext> {\n \n   private final Context ctx;\n   private final Endpoints endpoints;\n-  private final RoutingContext routingContext;\n-  private final RecordParser recordParser;\n-  private boolean hasReadArguments;\n-  private BufferedPublisher<JsonObject> publisher;\n-  private long rowsReceived;\n-  private AcksSubscriber acksSubscriber;\n-\n-  public InsertsBodyHandler(final Context ctx, final Endpoints endpoints,\n-      final RoutingContext routingContext) {\n+\n+  public InsertsStreamHandler(final Context ctx, final Endpoints endpoints) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NjY0Nw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370586647", "createdAt": "2020-01-24T11:21:52Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java", "diffHunk": "@@ -38,39 +40,60 @@\n  * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n  * followed by a new-line.\n  */\n-public class InsertsBodyHandler {\n+public class InsertsStreamHandler implements Handler<RoutingContext> {\n \n   private final Context ctx;\n   private final Endpoints endpoints;\n-  private final RoutingContext routingContext;\n-  private final RecordParser recordParser;\n-  private boolean hasReadArguments;\n-  private BufferedPublisher<JsonObject> publisher;\n-  private long rowsReceived;\n-  private AcksSubscriber acksSubscriber;\n-\n-  public InsertsBodyHandler(final Context ctx, final Endpoints endpoints,\n-      final RoutingContext routingContext) {\n+\n+  public InsertsStreamHandler(final Context ctx, final Endpoints endpoints) {\n     this.ctx = ctx;\n     this.endpoints = Objects.requireNonNull(endpoints);\n-    this.routingContext = Objects.requireNonNull(routingContext);\n-    this.recordParser = RecordParser.newDelimited(\"\\n\", routingContext.request());\n   }\n \n-  public void handleBodyEnd(final Void v) {\n-    if (publisher != null) {\n-      publisher.complete();\n-      if (acksSubscriber == null) {\n-        routingContext.response().end();\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    // The record parser takes in potentially fragmented buffers from the request and spits\n+    // out the chunks delimited by \\n\n+    final RecordParser recordParser = RecordParser.newDelimited(\"\\n\", routingContext.request());\n+    final RequestHandler requestHandler = new RequestHandler(routingContext, recordParser);\n+    recordParser.handler(requestHandler::handleBodyBuffer);\n+    recordParser.endHandler(requestHandler::handleBodyEnd);\n+  }\n+\n+  private class RequestHandler {\n+\n+    private final RoutingContext routingContext;\n+    private final RecordParser recordParser;\n+    private final InsertsStreamResponseWriter insertsStreamResponseWriter;\n+    private boolean hasReadArguments;\n+    private BufferedPublisher<JsonObject> publisher;\n+    private long rowsReceived;\n+    private AcksSubscriber acksSubscriber;\n+\n+    RequestHandler(final RoutingContext routingContext,\n+        final RecordParser recordParser) {\n+      this.routingContext = routingContext;\n+      this.recordParser = recordParser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NzM2Mw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370587363", "createdAt": "2020-01-24T11:23:52Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the inserts response stream in JSON format.\n+ *\n+ * <p>The completed response will form a single JSON array, and each insert in the incoming stream\n+ * will have a corresponding entry in the response stream, in the same order as the inserts.\n+ *\n+ * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n+ * clients. However this should be used with caution with very large responses when not using a\n+ * streaming JSON parser as the entire response will have to be stored in memory.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class JsonInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n+\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer();\n+\n+  protected final HttpServerResponse response;\n+  private boolean dataWritten;\n+\n+  public JsonInsertsStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4ODI5NA==", "bodyText": "Can we avoid the dup code? e.g. something like:\nprivate void writeBuffer(final Buffer buffer) {\n    final Buffer buff = dataWritten\n        ? Buffer.buffer().appendByte((byte) ',')\n        : Buffer.buffer().appendByte((byte) '[');\n\n    dataWritten = true;\n\n    buff.appendBuffer(buffer);\n    response.write(buff);\n  }", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370588294", "createdAt": "2020-01-24T11:26:26Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the inserts response stream in JSON format.\n+ *\n+ * <p>The completed response will form a single JSON array, and each insert in the incoming stream\n+ * will have a corresponding entry in the response stream, in the same order as the inserts.\n+ *\n+ * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n+ * clients. However this should be used with caution with very large responses when not using a\n+ * streaming JSON parser as the entire response will have to be stored in memory.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class JsonInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n+\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer();\n+\n+  protected final HttpServerResponse response;\n+  private boolean dataWritten;\n+\n+  public JsonInsertsStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public InsertsStreamResponseWriter writeInsertResponse() {\n+    writeBuffer(ACK_RESPONSE_LINE);\n+    return this;\n+  }\n+\n+  @Override\n+  public InsertsStreamResponseWriter writeError(final JsonObject error) {\n+    writeBuffer(error.toBuffer());\n+    return this;\n+  }\n+\n+  @Override\n+  public void end() {\n+    if (!dataWritten) {\n+      response.write(\"[]\").end();\n+    } else {\n+      response.write(\"]\").end();\n+    }\n+  }\n+\n+  private void writeBuffer(final Buffer buffer) {\n+    if (dataWritten) {\n+      final Buffer buff = Buffer.buffer().appendByte((byte) ',');\n+      buff.appendBuffer(buffer);\n+      response.write(buff);\n+    } else {\n+      final Buffer buff = Buffer.buffer().appendByte((byte) '[');\n+      buff.appendBuffer(buffer);\n+      response.write(buff);\n+      dataWritten = true;\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4ODM2Nw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370588367", "createdAt": "2020-01-24T11:26:37Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/JsonQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in JSON format.\n+ *\n+ * <p>The completed response will form a single JSON array.\n+ *\n+ * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n+ * clients. However this should be used with caution with very large responses when not using a\n+ * streaming JSON parser as the entire response will have to be stored in memory.\n+ *\n+ * <p>The first entry in the array is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the array is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class JsonQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public JsonQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTAzNg==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370589036", "createdAt": "2020-01-24T11:28:26Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java", "diffHunk": "@@ -35,13 +35,16 @@\n   private static final Logger log = LoggerFactory.getLogger(QuerySubscriber.class);\n \n   private final HttpServerResponse response;\n+  private final QueryStreamResponseWriter queryStreamResponseWriter;\n   private Subscription subscription;\n   private long tokens;\n \n   private static final int BATCH_SIZE = 4;\n \n-  public QuerySubscriber(final HttpServerResponse response) {\n-    this.response = Objects.requireNonNull(response);\n+  public QuerySubscriber(final HttpServerResponse response,\n+      final QueryStreamResponseWriter queryStreamResponseWriter) {\n+    this.response = response;\n+    this.queryStreamResponseWriter = queryStreamResponseWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTI5Nw==", "bodyText": "I think removing ApiQueryId is a bad thing.  It helps disambiguate between it and other queryIds we have in the system.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370589297", "createdAt": "2020-01-24T11:29:14Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -44,7 +44,7 @@\n   private final JsonObject config;\n   private final Endpoints endpoints;\n   private final HttpServerOptions httpServerOptions;\n-  private final Map<ApiQueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Map<String, ApiQuery> queries = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTg0NQ==", "bodyText": "This method will currently return null if the queryId can not be found.\nIf this is expected, then better to encode the optionality into the return value, i.e. Optional<ApiQuery>, rather than relying on engineers checking the implementation to realize this is the case.\nAlternatively, if it not existing is an error, then consider throwing an exception.\nReturning nulls tends to lead to either null checks all over the code, or NPEs", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370589845", "createdAt": "2020-01-24T11:30:51Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -93,22 +93,20 @@ public synchronized void stop() {\n     }\n   }\n \n-  ApiQueryID registerQuery(final QuerySubscriber querySubscriber) {\n-    Objects.requireNonNull(querySubscriber);\n-    final ApiQueryID queryID = new ApiQueryID();\n-    if (queries.putIfAbsent(queryID, querySubscriber) != null) {\n+  void registerQuery(final ApiQuery query) {\n+    Objects.requireNonNull(query);\n+    if (queries.putIfAbsent(query.getId(), query) != null) {\n       // It should never happen\n       // https://stackoverflow.com/questions/2513573/how-good-is-javas-uuid-randomuuid\n       throw new IllegalStateException(\"Glitch in the matrix\");\n     }\n-    return queryID;\n   }\n \n-  QuerySubscriber removeQuery(final ApiQueryID queryID) {\n+  ApiQuery removeQuery(final String queryID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MDQ3OQ==", "bodyText": "Use of specific types here is much nicer :D", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370590479", "createdAt": "2020-01-24T11:32:32Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -85,123 +73,18 @@ public void stop(final Promise<Void> stopPromise) {\n \n   private Router setupRouter() {\n     final Router router = Router.router(vertx);\n-    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n-        .handler(this::handleQueryStream);\n-    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/query-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(BodyHandler.create())\n+        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));\n+    router.route(HttpMethod.POST, \"/inserts-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(new InsertsStreamHandler(context, endpoints));\n     router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n-        .handler(this::handleCloseQuery);\n+        .handler(new CloseQueryHandler(server));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MzgwMw==", "bodyText": "Unnecessary coupling to Server, QuerySubscriber and ConnectionQueries?\nSeems that this class could be decoupled from these types by having the QueryStreamHandler perform these two steps after constructing the ApiQuery:\n connectionQueries.addQuery(this);\n    server.registerQuery(this);\nAnd having ApiQuery constructor take a callback that will be called on close.  QueryStreamHandler can then pass in a lambda that does :\nconnectionQueries.removeQuery(this);\nserver.removeQuery(id);\n querySubscriber.close();\nWhich would result in less coupling (and more easily unit tested code)", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370593803", "createdAt": "2020-01-24T11:42:08Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java", "diffHunk": "@@ -15,46 +15,39 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.Objects;\n import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n  * cryptographically secure. This is important as we don't want random users guessing query IDs and\n  * closing other peoples queries.\n  */\n-public final class ApiQueryID {\n+public class ApiQuery {\n \n+  private final Server server;\n   private final String id;\n+  private final ConnectionQueries connectionQueries;\n+  private final QuerySubscriber querySubscriber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5Mzk2Mw==", "bodyText": "nit: used.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370593963", "createdAt": "2020-01-24T11:42:35Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.decodeJsonObject;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+\n+/**\n+ * Handles requests to the query-stream endpoint\n+ */\n+public class QueryStreamHandler implements Handler<RoutingContext> {\n+\n+  static final String JSON_CONTENT_TYPE = \"application/json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NjUzNA==", "bodyText": "Do we really need to duplicate each response writer to have a delimited vs Json one?  two for queries, two for inserts, etc.\nWhy not have two classes that handle the JSON vs Delimited bit, and then compose that with one class for each type of response? e.g. to DelimitedQueryStreamResponseWriter you'd compose a DelimitedResponseWriter with a QueryStreamResponseWriter.\n(The DelimitedResponseWriter could be more of a DelimitedResponseFormatter or some such, rather than a ResponseRwriter.)", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370596534", "createdAt": "2020-01-24T11:49:40Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NzA4Mg==", "bodyText": "Unnecessary coupling.\nAs with ApiQuery, the calling code could be response for registering, and the constructor could take a callback thats called on close.  This would decouple the code better.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370597082", "createdAt": "2020-01-24T11:51:15Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDMyMzk2", "url": "https://github.com/confluentinc/ksql/pull/4376#pullrequestreview-348032396", "createdAt": "2020-01-24T15:31:42Z", "commit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "state": "APPROVED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTozMTo0MlrOFhhYWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo1Mzo1MFrOFhiGdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDIzMg==", "bodyText": "We see this method in a lot of places. Shame Vert.x Context doesn't have a method that does this ;) e.g. context.throwIfDifferentContext().\nI guess we could have a VertxUtils class that had this as a util method. I know its only small, but maybe worth it.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370694232", "createdAt": "2020-01-24T15:31:42Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {\n+\n+  private final Context context;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+\n+  public ConnectionQueryManager(final Context context, final Server server) {\n+    this.context = Objects.requireNonNull(context);\n+    this.server = Objects.requireNonNull(server);\n+  }\n+\n+  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n+      final HttpServerRequest request) {\n+    checkContext();\n+    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n+    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n+        connectionQueries::removeQuery);\n+    connectionQueries.addQuery(query);\n+    return query;\n+  }\n+\n+  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n+    final HttpConnection conn = request.connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+    }\n+    return connectionQueries;\n+  }\n+\n+  private void checkContext() {\n+    if (Vertx.currentContext() != context) {\n+      throw new IllegalStateException(\"On wrong context\");\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDQ4Nw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370694487", "createdAt": "2020-01-24T15:32:09Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryId.java", "diffHunk": "@@ -16,24 +16,21 @@\n package io.confluent.ksql.api.server;\n \n import java.util.Objects;\n-import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n+ * Surprisingly, the id of a push query\n  */\n-public final class ApiQueryID {\n+public class PushQueryId {\n \n   private final String id;\n \n-  public ApiQueryID() {\n-    this.id = UUID.randomUUID().toString();\n+  public PushQueryId(final String id) {\n+    this.id = id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NjM1MQ==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370696351", "createdAt": "2020-01-24T15:35:47Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {\n+\n+  private final Context context;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+\n+  public ConnectionQueryManager(final Context context, final Server server) {\n+    this.context = Objects.requireNonNull(context);\n+    this.server = Objects.requireNonNull(server);\n+  }\n+\n+  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n+      final HttpServerRequest request) {\n+    checkContext();\n+    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n+    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n+        connectionQueries::removeQuery);\n+    connectionQueries.addQuery(query);\n+    return query;\n+  }\n+\n+  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n+    final HttpConnection conn = request.connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+    }\n+    return connectionQueries;\n+  }\n+\n+  private void checkContext() {\n+    if (Vertx.currentContext() != context) {\n+      throw new IllegalStateException(\"On wrong context\");\n+    }\n+  }\n+\n+  private class ConnectionQueries implements Handler<Void> {\n+\n+    private final HttpConnection conn;\n+    private final Set<PushQueryHolder> queries = new HashSet<>();\n+\n+    ConnectionQueries(final HttpConnection conn) {\n+      this.conn = conn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5ODE4NA==", "bodyText": "FYI, with reference to #4376 (comment), using computeIfAbsent does only a single lookup into the map, where as this code does two: one in get and one in put.\nBit surprised you prefer the more verbose / old-school approach, rather than making use of the newer features of the language, given you're the one pushing for using a more modern JDK version :p", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370698184", "createdAt": "2020-01-24T15:39:13Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {\n+\n+  private final Context context;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+\n+  public ConnectionQueryManager(final Context context, final Server server) {\n+    this.context = Objects.requireNonNull(context);\n+    this.server = Objects.requireNonNull(server);\n+  }\n+\n+  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n+      final HttpServerRequest request) {\n+    checkContext();\n+    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n+    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n+        connectionQueries::removeQuery);\n+    connectionQueries.addQuery(query);\n+    return query;\n+  }\n+\n+  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n+    final HttpConnection conn = request.connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5ODM2NQ==", "bodyText": "IMHO this is a lot better - thanks!", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370698365", "createdAt": "2020-01-24T15:39:37Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5OTM3Nw==", "bodyText": "Can the querySubscriber.close() call not be part of the closeHandler call?", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370699377", "createdAt": "2020-01-24T15:41:31Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n+ * cryptographically secure. This is important as we don't want random users guessing query IDs and\n+ * closing other peoples queries.\n+ */\n+public class PushQueryHolder {\n+\n+  private final Server server;\n+  private final PushQueryId id;\n+  private final QuerySubscriber querySubscriber;\n+  private final Consumer<PushQueryHolder> closeHandler;\n+\n+  PushQueryHolder(final Server server, final QuerySubscriber querySubscriber,\n+      final Consumer<PushQueryHolder> closeHandler) {\n+    this.server = Objects.requireNonNull(server);\n+    this.querySubscriber = Objects.requireNonNull(querySubscriber);\n+    this.closeHandler = Objects.requireNonNull(closeHandler);\n+    this.id = new PushQueryId(UUID.randomUUID().toString());\n+    server.registerQuery(this);\n+  }\n+\n+  public void close() {\n+    server.removeQuery(id);\n+    querySubscriber.close();\n+    closeHandler.accept(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5OTU2OQ==", "bodyText": "consider having the caller do this call, decoupling this class from Server.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370699569", "createdAt": "2020-01-24T15:41:50Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n+ * cryptographically secure. This is important as we don't want random users guessing query IDs and\n+ * closing other peoples queries.\n+ */\n+public class PushQueryHolder {\n+\n+  private final Server server;\n+  private final PushQueryId id;\n+  private final QuerySubscriber querySubscriber;\n+  private final Consumer<PushQueryHolder> closeHandler;\n+\n+  PushQueryHolder(final Server server, final QuerySubscriber querySubscriber,\n+      final Consumer<PushQueryHolder> closeHandler) {\n+    this.server = Objects.requireNonNull(server);\n+    this.querySubscriber = Objects.requireNonNull(querySubscriber);\n+    this.closeHandler = Objects.requireNonNull(closeHandler);\n+    this.id = new PushQueryId(UUID.randomUUID().toString());\n+    server.registerQuery(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMTg2NA==", "bodyText": "QQ: does the use of BodyHandler here mean the user can't provide a stream of query requests, as its trying to \"gather the entire request body\"?", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370701864", "createdAt": "2020-01-24T15:46:13Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -85,123 +71,18 @@ public void stop(final Promise<Void> stopPromise) {\n \n   private Router setupRouter() {\n     final Router router = Router.router(vertx);\n-    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n-        .handler(this::handleQueryStream);\n-    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/query-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(BodyHandler.create())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMjgyMA==", "bodyText": "OK, np.", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370702820", "createdAt": "2020-01-24T15:47:49Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NjUzNA=="}, "originalCommit": {"oid": "37bfe38df4f957e7db2a156167ffb2e217550e4a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwNjAzOA==", "bodyText": "with reference to this comment: #4376 (comment)\nWe really do try and avoid returning nulls in the code by encoding optionality into the type system.  Please use Optional. Pretty please?", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370706038", "createdAt": "2020-01-24T15:53:50Z", "author": {"login": "big-andy-coates"}, "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -93,22 +93,20 @@ public synchronized void stop() {\n     }\n   }\n \n-  ApiQueryID registerQuery(final QuerySubscriber querySubscriber) {\n-    Objects.requireNonNull(querySubscriber);\n-    final ApiQueryID queryID = new ApiQueryID();\n-    if (queries.putIfAbsent(queryID, querySubscriber) != null) {\n+  void registerQuery(final PushQueryHolder query) {\n+    Objects.requireNonNull(query);\n+    if (queries.putIfAbsent(query.getId(), query) != null) {\n       // It should never happen\n       // https://stackoverflow.com/questions/2513573/how-good-is-javas-uuid-randomuuid\n       throw new IllegalStateException(\"Glitch in the matrix\");\n     }\n-    return queryID;\n   }\n \n-  QuerySubscriber removeQuery(final ApiQueryID queryID) {\n-    return queries.remove(queryID);\n+  PushQueryHolder removeQuery(final PushQueryId queryId) {\n+    return queries.remove(queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b6eb9047dc25136665851a72d567ca82fa71930"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "committedDate": "2020-01-24T18:08:41Z", "message": "Factor different endpoints into their own handler classes and abstract out the writing of responses. Support both JSON and delimited response format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b77c75c0182a56d11e7588a36a52b695fa50b99", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/5b77c75c0182a56d11e7588a36a52b695fa50b99", "committedDate": "2020-01-24T18:08:41Z", "message": "More refactoring + more javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e6178aab9821fff844559d14831ca46967170da", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/8e6178aab9821fff844559d14831ca46967170da", "committedDate": "2020-01-24T18:08:41Z", "message": "updates after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4fdc0e723d613ef680ca354abdc1668294e4037", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/e4fdc0e723d613ef680ca354abdc1668294e4037", "committedDate": "2020-01-24T18:08:41Z", "message": "updates after review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43c9bd37e14d7c69149b85e0479dc94105a8c3f4", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/43c9bd37e14d7c69149b85e0479dc94105a8c3f4", "committedDate": "2020-01-24T17:17:08Z", "message": "updates after review"}, "afterCommit": {"oid": "e4fdc0e723d613ef680ca354abdc1668294e4037", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/e4fdc0e723d613ef680ca354abdc1668294e4037", "committedDate": "2020-01-24T18:08:41Z", "message": "updates after review"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 144, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}