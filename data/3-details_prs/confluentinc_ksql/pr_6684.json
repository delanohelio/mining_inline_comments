{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MjczNTE0", "number": 6684, "title": "feat: Move code from physical to logical plan for Projection", "bodyText": "Description\nNo changes made to the persistent query code path. Ideally, I wanted to re-use the existing code without special casing for pull queries but that was not possible since the schemas are handled so differently. Below I describe with examples their differences.\nAssume pull query SELECT * from agg WHERE STR=foo; where table is created as\nCREATE TABLE agg AS SELECT STR, LATEST_BY_OFFSET(LONG) AS LONG FROM stream GROUP BY STR;\"\n\nLogical schema handling in pull query project code.\nThere are 3 schemas we handling, the input schema, the intermediate schema used for codegen and the output schema.\n\nThe input is the materialization schema. For example, mat.schema = STR STRING KEY, LONG BIGINT\nCodeGen is used only if the SELECT is not *. For CodeGen, an intermediate schema is created as follows: Check if projection contains system or key columns. If not, the intermediate schema is the input schema. If there are any of these columns, the input schema is extended with inputSchema\t .withPseudoAndKeyColsInValue(windowed); that basically copies the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\nThe output schema (the schema of the row produced by the project operator), takes as input the materialization schema and: if the projection is  SELECT *, add windowstart and windowend to key columns and keep value columns the same as input. If projection is not SELECT *, then process each select and if it is a key or windowstart and windowend add them to the key part else add them to the value part. In our example, output schema is STR STRING KEY, LONG BIGINT.\n\nLogical schema handling in logical plan builder.\nEach node of the logical plan has a logical schema associated with it and has access to its child logical schema. For pull queries the leaf is always a single DataSourceNode\n\nThe output schema of the DataSourceNode (for the same example query as above) is STR STRING KEY, LONG BIGINT, ROWTIME BIGINT, STR STRING. This is the input to the Project operator, compare this to the mat.schema\nThe output schema of the FinalProjectNode is STR STRING KEY, STR STRING, LONG BIGINT (it has the extra key column in the value)\n\nDifferent queries that highlight how the schema handling of pull queries differs from persistent queries\n\n\nSELECT long from agg WHERE STR=foo\n-----> FinalProjectNode input schema: STR STRING KEY, LONG BIGINT, ROWTIME BIGINT, STR STRING\n-----> mat.schema = STR STRING KEY, LONG BIGINT\n-----> intermediate schema = STR STRING KEY, LONG BIGINT, ROWTIME BIGINT, STR STRING\n-----> FinalProjectNode output schema=STR STRING KEY, LONG BIGINT\n-----> pull query output schema= LONG BIGINT\n\n\nSELECT long, rowtime from agg WHERE STR=foo\n-----> FinalProjectNode input schema: STR STRING KEY, LONG BIGINT, ROWTIME BIGINT, STR STRING\n-----> mat.schema = STR STRING KEY, LONG BIGINT\n-----> intermediate schema= STR STRING KEY, LONG BIGINT, ROWTIME BIGINT, STR STRING\n-----> Project output schema=STR STRING KEY, LONG BIGINT, ROWTIME BIGINT\n-----> pull query output schema= LONG BIGINT, ROWTIME BIGINT\n\n\nSELECT long, windowstart, windowend from agg WHERE STR=foo assuming table is windowed\n-----> FinalProjectNode input schema: STR STRING KEY, ROWTIME BIGINT, WINDOWSTART BIGINT, WINDOWEND BIGINT\n-----> mat.schema = STR STRING KEY, LONG BIGINT, WINDOWSTART BIGINT, WINDOWEND BIGINT\n-----> intermediate schema= STR STRING KEY, LONG BIGINT, ROWTIME BIGINT, STR STRING,  WINDOWSTART BIGINT, WINDOWEND BIGINT\n-----> Project output schema=STR STRING KEY\n-----> pull query output schema= LONG BIGINT,  WINDOWSTART BIGINT KEY, WINDOWEND BIGINT KEY\n\n\nQuestions:\n\n\nWhat is the correspondence between DataSource and Materialization? Why do their schemas differ? If the Materialization is a table, then shouldn't the schema of the DataSource match that of the table? I.e not have the rowtime and key in the value?\n\n\nWhy do the output schemas of the pull query and FinalProjectNode differ? Basically, it seems that the output schemas of persistent queries are different than that of pull queries? Moreover, the output schema of FinalProjectNode seems to have extra columns that are not in the projection. Why?\n\n\nTesting done\nAdded new unit tests for building the pull query schema\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-11-26T21:35:48Z", "url": "https://github.com/confluentinc/ksql/pull/6684", "merged": true, "mergeCommit": {"oid": "cb0e6f21b20a57858cb35e578e3fd2a1849647eb"}, "closed": true, "closedAt": "2020-12-17T00:12:20Z", "author": {"login": "vpapavas"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdislnPABqjQwNzA0MTk0MDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdm3EVMAH2gAyNTI4MjczNTE0OmQ0YjllYWU4MzA3NjI3ZTU5NmQ3ZTg1MmZlZjUzMjk2NzJhMzU1ZTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d101ea746e413e756064156168ec158a78dca04a", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/d101ea746e413e756064156168ec158a78dca04a", "committedDate": "2020-12-03T01:25:08Z", "message": "added tests for pull queries"}, "afterCommit": {"oid": "92e7e17d330a2b37c4f38de9ce334f14e2763553", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/92e7e17d330a2b37c4f38de9ce334f14e2763553", "committedDate": "2020-12-04T00:27:15Z", "message": "rebase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDE2NDgz", "url": "https://github.com/confluentinc/ksql/pull/6684#pullrequestreview-546416483", "createdAt": "2020-12-07T18:22:58Z", "commit": {"oid": "a11156c785b42a4dd363c01e712d7b4e77b2cc9d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyMjo1OFrOIA0SQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyMjo1OFrOIA0SQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzU1NA==", "bodyText": "What is the correspondence between DataSource and Materialization? Why do their schemas differ? If the Materialization is a table, then shouldn't the schema of the DataSource match that of the table? I.e not have the rowtime and key in the value?\nWhy do the output schemas of the pull query and FinalProjectNode differ? Basically, it seems that the output schemas of persistent queries are different than that of pull queries? Moreover, the output schema of FinalProjectNode seems to have extra columns that are not in the projection. Why?\n\nOff the top of my head (see bottom), I don't know the answers to these questions (and I'm not sure that without digging anyone on the team knows) but I think these are exactly the ones we need to answer (and document for the future! Ideally in the code...) before merging this pr. Then, we can see if we can change it to be a single code path for both persistent/pull queries.\nOtherwise (if we can't merge the code paths), I think we need to have two different logical nodes since they (logically) represent different operations and construct different schemas (they can extend a common base so that it's clear which code they share and which is different). We shouldn't make the pull and persistent code more intertwined but with a nuanced difference as it will make it harder to develop them independently without context on the other.\nFWIW, you can change the behavior of any logical node of the persistent queries so long as the QTT tests pass. Any old query will continue to work because the physical plans are persisted, not the logical ones, in the command topic.\n\n\nMoreover, the output schema of FinalProjectNode seems to have extra columns that are not in the projection.\n\nMy best guess on this one is that the rowkey-in-value/rowtime-in-value/windowstart/windowend columns are needed to handle the processing. At the moment, the way we've coded it up, most operations accept only the value and not the key (or other metadata information) - so we need to copy information from the key into the value. I've looked into changing this and I got pretty close, but the problem is that the Joiner code in streams doesn't yet have the signature that I need to fully get rid of it so I abandoned the change. I'll try to revisit it (and hopefully change that in streams if necessary) at some point.", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r537727554", "createdAt": "2020-12-07T18:22:58Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FinalProjectNode.java", "diffHunk": "@@ -56,23 +67,54 @@\n   private final Optional<Analysis.Into> into;\n   private final LogicalSchema schema;\n   private final ImmutableList<SelectExpression> selectExpressions;\n+  private final Optional<LogicalSchema> pullQueryOutputSchema;\n+  private final Optional<LogicalSchema> pullQueryIntermediateSchema;\n+  private final Optional<List<ExpressionMetadata>> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isPullQuerySelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n \n   public FinalProjectNode(\n       final PlanNodeId id,\n       final PlanNode source,\n       final List<SelectItem> selectItems,\n       final Optional<Analysis.Into> into,\n-      final MetaStore metaStore\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n   ) {\n     super(id, source);\n     this.projection = Projection.of(selectItems);\n     this.into = into;\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n \n     final Pair<LogicalSchema, List<SelectExpression>> result = build(metaStore);\n     this.schema = result.left;\n     this.selectExpressions = ImmutableList.copyOf(result.right);\n+    if (analysis.isPullQuery()) {\n+      this.isPullQuerySelectStar = isPullQuerySelectStar();\n+      this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+      this.pullQueryOutputSchema = Optional.of(buildPullQueryOutputSchema(metaStore));\n+      this.pullQueryIntermediateSchema = Optional.of(buildPullQueryIntermediateSchema());\n+      this.compiledSelectExpressions = Optional.of(selectExpressions\n+          .stream()\n+          .map(selectExpression -> CodeGenRunner.compileExpression(\n+              selectExpression.getExpression(),\n+              \"Select\",\n+              pullQueryIntermediateSchema.get(),\n+              ksqlConfig,\n+              metaStore\n+          ))\n+          .collect(ImmutableList.toImmutableList()));\n+    } else {\n+      this.isPullQuerySelectStar = false;\n+      this.addAdditionalColumnsToIntermediateSchema = false;\n+      this.pullQueryOutputSchema = Optional.empty();\n+      this.pullQueryIntermediateSchema = Optional.empty();\n+      this.compiledSelectExpressions = Optional.empty();\n+      throwOnEmptyValueOrUnknownColumns();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a11156c785b42a4dd363c01e712d7b4e77b2cc9d"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjMwOTM3", "url": "https://github.com/confluentinc/ksql/pull/6684#pullrequestreview-546630937", "createdAt": "2020-12-07T23:37:01Z", "commit": {"oid": "a11156c785b42a4dd363c01e712d7b4e77b2cc9d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozNzowMVrOIA_4GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOToyMDo1OVrOIClXag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNzQ2NA==", "bodyText": "What exactly is the difference between FinalProjectNode and ProjectNode?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r537917464", "createdAt": "2020-12-07T23:37:01Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java", "diffHunk": "@@ -137,17 +124,18 @@ public PullPhysicalPlan buildPullPhysicalPlan(final LogicalPlanNode logicalPlanN\n     while (true) {\n \n       AbstractPhysicalOperator currentPhysicalOp = null;\n-      if (currentLogicalNode instanceof ProjectNode) {\n-        currentPhysicalOp = translateProjectNode((ProjectNode)currentLogicalNode);\n+      if (currentLogicalNode instanceof FinalProjectNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a11156c785b42a4dd363c01e712d7b4e77b2cc9d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDYxMA==", "bodyText": "One nice benefit of splitting this up is that it's easier to throw errors for things that are not supported.  E.g. we could throw an error if there's a group by?  Where is this currently done at the moment?  It seems like at the very least we have the error Error in translating logical to physical plan for pull queries: unrecognized logical node. but ideally this should be caught at the logical layer.\nShould we do some of these checks here and throw errors if there are unsupported expressions?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539544610", "createdAt": "2020-12-09T18:27:22Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -170,6 +171,25 @@ public OutputNode buildPlan() {\n     return buildOutputNode(currentNode);\n   }\n \n+  public OutputNode buildPullLogicalPlan() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjI2NA==", "bodyText": "The intermediate schema is only used to evaluate these select expressions, right?\nI assume that for the where clause, you'd effectively have access to the same columns and want to build the same schema for evaluating those expressions.  Will you be able to share this or will you have to rebuild it in the SelectNode?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539566264", "createdAt": "2020-12-09T18:59:15Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjUxNA==", "bodyText": "Should this be package private and @VisibleForTesting?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539566514", "createdAt": "2020-12-09T18:59:36Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MDEwMg==", "bodyText": "If you just apply the transform immediately, can you just call it directly rather than returning a function?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539570102", "createdAt": "2020-12-09T19:05:03Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java", "diffHunk": "@@ -163,17 +86,17 @@ public Object next() {\n     if (row == null) {\n       return null;\n     }\n-    if (isSelectStar) {\n+    if (logicalNode.getIsSelectStar()) {\n       return createRow(row);\n     }\n-    final GenericRow intermediate = preSelectTransform.apply(row);\n+    final GenericRow intermediate = getPreSelectTransform().apply(row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4MDI2Ng==", "bodyText": "Maybe this should be called getIntermediateRow to match the terminology of the logical node?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539580266", "createdAt": "2020-12-09T19:20:59Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java", "diffHunk": "@@ -207,8 +135,34 @@ public AbstractPhysicalOperator getChild(final int index) {\n     throw new UnsupportedOperationException();\n   }\n \n-  public LogicalSchema getOutputSchema() {\n-    return outputSchema;\n+  private Function<TableRow, GenericRow> getPreSelectTransform() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTQxMTM1", "url": "https://github.com/confluentinc/ksql/pull/6684#pullrequestreview-548541135", "createdAt": "2020-12-09T19:35:40Z", "commit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTozNTo0MFrOICl9Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0MDozMFrOICmJsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4OTk1MQ==", "bodyText": "But that's fine because this intermediate schema is never exposed, right?  The output schema puts these fields correctly as keys.", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539589951", "createdAt": "2020-12-09T19:35:40Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  public boolean getIsSelectStar() {\n+    return isSelectStar;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  /**\n+   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n+   * need to be extended with system columns if they are part of the projection.\n+   * @return the intermediate schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildIntermediateSchema() {\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    if (!addAdditionalColumnsToIntermediateSchema) {\n+      return parentSchema;\n+    } else {\n+      // SelectValueMapper requires the rowTime & key fields in the value schema :(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MTUwOQ==", "bodyText": "This is just to use the SelectValueMapper, right?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539591509", "createdAt": "2020-12-09T19:38:02Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzEzNg==", "bodyText": "Does this mean ExpressionTypeManager expects it?  That's the main place where this schema is used is just to evaluate the type of the expression.", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539593136", "createdAt": "2020-12-09T19:40:30Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  public boolean getIsSelectStar() {\n+    return isSelectStar;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  /**\n+   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n+   * need to be extended with system columns if they are part of the projection.\n+   * @return the intermediate schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildIntermediateSchema() {\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    if (!addAdditionalColumnsToIntermediateSchema) {\n+      return parentSchema;\n+    } else {\n+      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n+      final boolean isWindowed = analysis\n+          .getFrom()\n+          .getDataSource()\n+          .getKsqlTopic()\n+          .getKeyFormat().isWindowed();\n+\n+      return parentSchema\n+          .withPseudoAndKeyColsInValue(isWindowed);\n+    }\n+  }\n+\n+  /**\n+   * Builds the output schema of the project node.\n+   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n+   * query.\n+   * @param metaStore the metastore\n+   * @return the project node's output schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n+    final LogicalSchema outputSchema;\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+    final boolean isWindowed = analysis\n+        .getFrom()\n+        .getDataSource()\n+        .getKsqlTopic()\n+        .getKeyFormat().isWindowed();\n+\n+    if (isSelectStar()) {\n+      outputSchema = buildPullQuerySelectStarSchema(\n+          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n+    } else {\n+      final List<SelectExpression> projects = projection.selectItems().stream()\n+          .map(SingleColumn.class::cast)\n+          .map(si -> SelectExpression\n+              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n+          .collect(Collectors.toList());\n+\n+      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n+    }\n+    return outputSchema;\n+  }\n+\n+  /**\n+   * Checks whether the intermediate schema should be extended with system and key columns.\n+   * @return true if the intermediate schema should be extended\n+   */\n+  private boolean shouldAddAdditionalColumnsInSchema() {\n+\n+    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n+        SystemColumns::isSystemColumn\n+    );\n+\n+    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n+        getSource().getSchema().isKeyColumn(cn)\n+    );\n+\n+    return hasSystemColumns || hasKeyColumns;\n+  }\n+\n+  private boolean isSelectStar() {\n+    final boolean someStars = projection.selectItems().stream()\n+        .anyMatch(s -> s instanceof AllColumns);\n+\n+    if (someStars && projection.selectItems().size() != 1) {\n+      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n+                                  + \"if they are the only expression\");\n+    }\n+\n+    return someStars;\n+  }\n+\n+  private LogicalSchema buildPullQuerySelectStarSchema(\n+      final LogicalSchema schema,\n+      final boolean windowed\n+  ) {\n+    final Builder builder = LogicalSchema.builder()\n+        .keyColumns(schema.key());\n+\n+    if (windowed) {\n+      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n+      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n+    }\n+\n+    return builder\n+        .valueColumns(schema.value())\n+        .build();\n+  }\n+\n+  private LogicalSchema selectOutputSchema(\n+      final MetaStore metaStore,\n+      final List<SelectExpression> selectExpressions,\n+      final boolean isWindowed\n+  ) {\n+    final Builder schemaBuilder = LogicalSchema.builder();\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    // Copy meta & key columns into the value schema as SelectValueMapper expects it:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 239}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTM3MjIx", "url": "https://github.com/confluentinc/ksql/pull/6684#pullrequestreview-549537221", "createdAt": "2020-12-10T19:35:32Z", "commit": {"oid": "a66694a0518fb72d9eb26a900b4983be215b77f4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTozNTozMlrOIDaAtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo1MDoxMFrOIDajww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0MjgwNQ==", "bodyText": "thank you for the javadoc!", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r540442805", "createdAt": "2020-12-10T19:35:32Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a66694a0518fb72d9eb26a900b4983be215b77f4"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NDk2MA==", "bodyText": "excuse me while I philosophize for a bit...\njust wondering, is 'child' and 'parent' standard terminology in databases when discussing logical plans? I know we've standardized on it, but it always confuses me because the \"child\" is the \"source node\" which makes me feel like it's a \"parent\" \ud83e\udd14\nWhat do you think about upstream/downstream nodes? That way it's clear that the direction of data is flowing from the source nodes (upstream) to the sink nodes (downstream)", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r540444960", "createdAt": "2020-12-10T19:39:09Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a66694a0518fb72d9eb26a900b4983be215b77f4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1MTc3OQ==", "bodyText": "any reason this is no longer final?", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r540451779", "createdAt": "2020-12-10T19:50:10Z", "author": {"login": "agavra"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/transform/select/SelectValueMapperFactory.java", "diffHunk": "@@ -32,26 +33,34 @@\n  * Factor class for {@link SelectValueMapper}.\n  */\n public final class SelectValueMapperFactory {\n-\n   private static final String EXP_TYPE = \"Select\";\n \n-  private final CodeGenRunner codeGenerator;\n+  private CodeGenRunner codeGenerator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a66694a0518fb72d9eb26a900b4983be215b77f4"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNDc0OTAz", "url": "https://github.com/confluentinc/ksql/pull/6684#pullrequestreview-550474903", "createdAt": "2020-12-11T18:52:50Z", "commit": {"oid": "a66694a0518fb72d9eb26a900b4983be215b77f4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1Mjo1MFrOIEFo5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1Mjo1MFrOIEFo5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1NzYwNQ==", "bodyText": "I guess I just meant that schema is only used with the ExpressionTypeManager and the comment is a bit misleading.", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r541157605", "createdAt": "2020-12-11T18:52:50Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  public boolean getIsSelectStar() {\n+    return isSelectStar;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  /**\n+   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n+   * need to be extended with system columns if they are part of the projection.\n+   * @return the intermediate schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildIntermediateSchema() {\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    if (!addAdditionalColumnsToIntermediateSchema) {\n+      return parentSchema;\n+    } else {\n+      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n+      final boolean isWindowed = analysis\n+          .getFrom()\n+          .getDataSource()\n+          .getKsqlTopic()\n+          .getKeyFormat().isWindowed();\n+\n+      return parentSchema\n+          .withPseudoAndKeyColsInValue(isWindowed);\n+    }\n+  }\n+\n+  /**\n+   * Builds the output schema of the project node.\n+   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n+   * query.\n+   * @param metaStore the metastore\n+   * @return the project node's output schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n+    final LogicalSchema outputSchema;\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+    final boolean isWindowed = analysis\n+        .getFrom()\n+        .getDataSource()\n+        .getKsqlTopic()\n+        .getKeyFormat().isWindowed();\n+\n+    if (isSelectStar()) {\n+      outputSchema = buildPullQuerySelectStarSchema(\n+          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n+    } else {\n+      final List<SelectExpression> projects = projection.selectItems().stream()\n+          .map(SingleColumn.class::cast)\n+          .map(si -> SelectExpression\n+              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n+          .collect(Collectors.toList());\n+\n+      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n+    }\n+    return outputSchema;\n+  }\n+\n+  /**\n+   * Checks whether the intermediate schema should be extended with system and key columns.\n+   * @return true if the intermediate schema should be extended\n+   */\n+  private boolean shouldAddAdditionalColumnsInSchema() {\n+\n+    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n+        SystemColumns::isSystemColumn\n+    );\n+\n+    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n+        getSource().getSchema().isKeyColumn(cn)\n+    );\n+\n+    return hasSystemColumns || hasKeyColumns;\n+  }\n+\n+  private boolean isSelectStar() {\n+    final boolean someStars = projection.selectItems().stream()\n+        .anyMatch(s -> s instanceof AllColumns);\n+\n+    if (someStars && projection.selectItems().size() != 1) {\n+      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n+                                  + \"if they are the only expression\");\n+    }\n+\n+    return someStars;\n+  }\n+\n+  private LogicalSchema buildPullQuerySelectStarSchema(\n+      final LogicalSchema schema,\n+      final boolean windowed\n+  ) {\n+    final Builder builder = LogicalSchema.builder()\n+        .keyColumns(schema.key());\n+\n+    if (windowed) {\n+      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n+      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n+    }\n+\n+    return builder\n+        .valueColumns(schema.value())\n+        .build();\n+  }\n+\n+  private LogicalSchema selectOutputSchema(\n+      final MetaStore metaStore,\n+      final List<SelectExpression> selectExpressions,\n+      final boolean isWindowed\n+  ) {\n+    final Builder schemaBuilder = LogicalSchema.builder();\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    // Copy meta & key columns into the value schema as SelectValueMapper expects it:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzEzNg=="}, "originalCommit": {"oid": "f31c2df7dd36bdda2d026809c400b8646fefa94e"}, "originalPosition": 239}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "committedDate": "2020-12-16T18:29:46Z", "message": "compiling expression sin logical plan\n\nlogical refactoring\n\nfilter and project\n\nrefactoring\n\nmove project operator code into logical plan\n\nstill in progress, fixed some tests and made refactor smaller\n\nfixing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0c4652af706865cf7f51f905f61986260216b78", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/b0c4652af706865cf7f51f905f61986260216b78", "committedDate": "2020-12-16T18:29:46Z", "message": "added tests for pull queries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5832aa4b5f496d02c8bfe12f4b2a56528d0a73e6", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/5832aa4b5f496d02c8bfe12f4b2a56528d0a73e6", "committedDate": "2020-12-16T18:29:46Z", "message": "rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bab50b37a003e2226915eb1e6a3255c89689bdd", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/8bab50b37a003e2226915eb1e6a3255c89689bdd", "committedDate": "2020-12-16T18:29:46Z", "message": "remove comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9933eabb493594a555ba5024d0e4088afd765848", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/9933eabb493594a555ba5024d0e4088afd765848", "committedDate": "2020-12-16T18:29:47Z", "message": "add separate logicl nodes for pull"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7838a4c6227856d394b2c5cc4b2204559a3952d0", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/7838a4c6227856d394b2c5cc4b2204559a3952d0", "committedDate": "2020-12-16T18:29:47Z", "message": "fix comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94b2bf3606bc96df553f4eb8d5e0dd3d71e46473", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/94b2bf3606bc96df553f4eb8d5e0dd3d71e46473", "committedDate": "2020-12-16T18:29:47Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a201187586df35665aa622e0562c27d92b05f7a", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/9a201187586df35665aa622e0562c27d92b05f7a", "committedDate": "2020-12-16T18:29:48Z", "message": "remove unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4c6cf26d42251c95710f5d1cc9bda80c9643e83", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/c4c6cf26d42251c95710f5d1cc9bda80c9643e83", "committedDate": "2020-12-16T18:29:48Z", "message": "Address alans comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd3233434482f73ca223c66e098236571dd29dab", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/dd3233434482f73ca223c66e098236571dd29dab", "committedDate": "2020-12-16T18:29:48Z", "message": "add back final"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a66694a0518fb72d9eb26a900b4983be215b77f4", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/a66694a0518fb72d9eb26a900b4983be215b77f4", "committedDate": "2020-12-10T00:39:35Z", "message": "Address alans comments"}, "afterCommit": {"oid": "dd3233434482f73ca223c66e098236571dd29dab", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/dd3233434482f73ca223c66e098236571dd29dab", "committedDate": "2020-12-16T18:29:48Z", "message": "add back final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4b9eae8307627e596d7e852fef5329672a355e6", "author": {"user": {"login": "vpapavas", "name": "Vicky Papavasileiou"}}, "url": "https://github.com/confluentinc/ksql/commit/d4b9eae8307627e596d7e852fef5329672a355e6", "committedDate": "2020-12-16T22:55:52Z", "message": "remove unused field"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4556, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}