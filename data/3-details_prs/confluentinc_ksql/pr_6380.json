{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NTU4OTYx", "number": 6380, "title": "chore: support inference of key schemas from Schema Registry", "bodyText": "Description\nPartial work for #6222\nThis PR adds support for reading key schemas from Schema Registry. As part of doing so, the undocumented feature SCHEMA_ID has been renamed to VALUE_SCHEMA_ID and a separate KEY_SCHEMA_ID has been added. Whether we want to document these features and make them officially supported or not is a separate conversation from this PR, though this PR does wire up the new config.\nThree commits:\n\nrename SCHEMA_ID to VALUE_SCHEMA_ID and add KEY_SCHEMA_ID\nenhance TopicSchemaSupplier to support fetching key schemas from Schema Registry\nenhance DefaultSchemaInjector to support key schema inference\n\nTesting done\nAdded unit tests. Waiting on QTT enhancements for key schema support in order to add QTT and test more fully.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-10-07T22:52:09Z", "url": "https://github.com/confluentinc/ksql/pull/6380", "merged": true, "mergeCommit": {"oid": "d00aa2e16394446ebf9618f12eb158fe6ec1f9bd"}, "closed": true, "closedAt": "2020-10-12T21:04:48Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQOOl7AH2gAyNDk5NTU4OTYxOmVlODRhYmQzN2Y1OTMzNTI3YThjNTZhMjEzZjMyYzA3ZDU1YmY3Y2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdR3JhyAH2gAyNDk5NTU4OTYxOjEyMGNlNmFiMWMzMDQzMzgwNThkZjI5ZWVkNDM4NGM3MjY3Njg4M2M=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ee84abd37f5933527a8c56a213f32c07d55bf7cf", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ee84abd37f5933527a8c56a213f32c07d55bf7cf", "committedDate": "2020-10-07T14:54:38Z", "message": "chore: rename SCHEMA_ID to VALUE_SCHEMA_ID"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c737657b02730aa215db5996222e84fcb052a10", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/5c737657b02730aa215db5996222e84fcb052a10", "committedDate": "2020-10-07T16:04:52Z", "message": "chore: support getting key schemas from supplier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "committedDate": "2020-10-07T22:13:42Z", "message": "chore: support key schema inference in injector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzIzNzQ2", "url": "https://github.com/confluentinc/ksql/pull/6380#pullrequestreview-504323746", "createdAt": "2020-10-07T22:56:46Z", "commit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMjo1Njo0NlrOHeIXNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMjo1Njo0NlrOHeIXNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1NjM0Mw==", "bodyText": "This previous code had the following behavior: if VALUE_SCHEMA_ID was explicitly supplied by the user, then the create properties were not updated with the schema ID returned from the topic schema supplier. The new behavior is to always update the create properties with the schema ID returned from the topic schema supplier. Unless I'm mistaken, the topic schema supplier implementation always returns the same schema ID that was supplied, if relevant. Even if this changes in the future (not sure why it would), I think the new behavior is more accurate since the create properties after the injector runs reflect exactly what the engine is going to execute.", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501356343", "createdAt": "2020-10-07T22:56:46Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/DefaultSchemaInjector.java", "diffHunk": "@@ -91,94 +94,167 @@ public DefaultSchemaInjector(final TopicSchemaSupplier schemaSupplier) {\n   private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    if (hasValueElements(statement) || !valueFormatSupportsSchemaInference(statement)) {\n+    final Optional<SchemaAndId> keySchema = getKeySchema(statement);\n+    final Optional<SchemaAndId> valueSchema = getValueSchema(statement);\n+    if (!keySchema.isPresent() && !valueSchema.isPresent()) {\n       return Optional.empty();\n     }\n \n-    final SchemaAndId valueSchema = getValueSchema(statement);\n-    final CreateSource withSchema = addSchemaFields(statement, valueSchema);\n+    final CreateSource withSchema = addSchemaFields(statement, keySchema, valueSchema);\n     final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withSchema);\n     final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n         .of(prepared, statement.getSessionConfig());\n \n     return Optional.of(configured);\n   }\n \n-  private SchemaAndId getValueSchema(\n+  private Optional<SchemaAndId> getKeySchema(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(props);\n \n-    final FormatInfo expectedValueFormat = SourcePropertiesUtil.getValueFormat(props);\n+    if (hasKeyElements(statement) || !formatSupportsSchemaInference(keyFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getKeySchemaId(),\n+        keyFormat,\n+        statement.getStatementText(),\n+        true\n+    ));\n+  }\n+\n+  private Optional<SchemaAndId> getValueSchema(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(props);\n \n-    final SchemaResult result = schemaSupplier\n-        .getValueSchema(props.getKafkaTopic(), props.getSchemaId(), expectedValueFormat);\n+    if (hasValueElements(statement) || !formatSupportsSchemaInference(valueFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getValueSchemaId(),\n+        valueFormat,\n+        statement.getStatementText(),\n+        false\n+    ));\n+  }\n+\n+  private SchemaAndId getSchema(\n+      final String topicName,\n+      final Optional<Integer> schemaId,\n+      final FormatInfo expectedFormat,\n+      final String statementText,\n+      final boolean isKey\n+  ) {\n+    final SchemaResult result = isKey\n+        ? schemaSupplier.getKeySchema(topicName, schemaId, expectedFormat)\n+        : schemaSupplier.getValueSchema(topicName, schemaId, expectedFormat);\n \n     if (result.failureReason.isPresent()) {\n       final Exception cause = result.failureReason.get();\n       throw new KsqlStatementException(\n           cause.getMessage(),\n-          statement.getStatementText(),\n+          statementText,\n           cause);\n     }\n \n     return result.schemaAndId.get();\n   }\n \n-  private static boolean hasValueElements(\n+  private static boolean hasKeyElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     return statement.getStatement().getElements().stream()\n-        .anyMatch(e -> e.getNamespace().equals(Namespace.VALUE));\n+        .anyMatch(e -> e.getNamespace().isKey());\n   }\n \n-  private static boolean valueFormatSupportsSchemaInference(\n+  private static boolean hasValueElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    final FormatInfo valueFormat = SourcePropertiesUtil\n-        .getValueFormat(statement.getStatement().getProperties());\n+    return statement.getStatement().getElements().stream()\n+        .anyMatch(e -> !e.getNamespace().isKey());\n+  }\n \n-    return FormatFactory.of(valueFormat).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n+  private static boolean formatSupportsSchemaInference(final FormatInfo format) {\n+    return FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n   }\n \n   private static CreateSource addSchemaFields(\n       final ConfiguredStatement<CreateSource> preparedStatement,\n-      final SchemaAndId schema\n+      final Optional<SchemaAndId> keySchema,\n+      final Optional<SchemaAndId> valueSchema\n   ) {\n-    final TableElements elements = buildElements(schema.columns, preparedStatement);\n+    final TableElements elements = buildElements(preparedStatement, keySchema, valueSchema);\n \n     final CreateSource statement = preparedStatement.getStatement();\n     final CreateSourceProperties properties = statement.getProperties();\n \n-    if (properties.getSchemaId().isPresent()) {\n-      return statement.copyWith(elements, properties);\n-    }\n-    return statement.copyWith(elements, properties.withSchemaId(schema.id));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzU2MzIx", "url": "https://github.com/confluentinc/ksql/pull/6380#pullrequestreview-504356321", "createdAt": "2020-10-08T00:34:13Z", "commit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMDozNDoxM1rOHeKHZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMTowMTowMVrOHeKinw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NTA2Mw==", "bodyText": "I think that if we're going down the route of structs-as-keys, then this should not flatten into multiple table elements (I have yet to look at the SchemaSupplier code, I suspect that's what should be handling this). To ensure this, for now I think this should assert that there is no more than one key column.", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501385063", "createdAt": "2020-10-08T00:34:13Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/DefaultSchemaInjector.java", "diffHunk": "@@ -91,94 +94,167 @@ public DefaultSchemaInjector(final TopicSchemaSupplier schemaSupplier) {\n   private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    if (hasValueElements(statement) || !valueFormatSupportsSchemaInference(statement)) {\n+    final Optional<SchemaAndId> keySchema = getKeySchema(statement);\n+    final Optional<SchemaAndId> valueSchema = getValueSchema(statement);\n+    if (!keySchema.isPresent() && !valueSchema.isPresent()) {\n       return Optional.empty();\n     }\n \n-    final SchemaAndId valueSchema = getValueSchema(statement);\n-    final CreateSource withSchema = addSchemaFields(statement, valueSchema);\n+    final CreateSource withSchema = addSchemaFields(statement, keySchema, valueSchema);\n     final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withSchema);\n     final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n         .of(prepared, statement.getSessionConfig());\n \n     return Optional.of(configured);\n   }\n \n-  private SchemaAndId getValueSchema(\n+  private Optional<SchemaAndId> getKeySchema(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(props);\n \n-    final FormatInfo expectedValueFormat = SourcePropertiesUtil.getValueFormat(props);\n+    if (hasKeyElements(statement) || !formatSupportsSchemaInference(keyFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getKeySchemaId(),\n+        keyFormat,\n+        statement.getStatementText(),\n+        true\n+    ));\n+  }\n+\n+  private Optional<SchemaAndId> getValueSchema(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(props);\n \n-    final SchemaResult result = schemaSupplier\n-        .getValueSchema(props.getKafkaTopic(), props.getSchemaId(), expectedValueFormat);\n+    if (hasValueElements(statement) || !formatSupportsSchemaInference(valueFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getValueSchemaId(),\n+        valueFormat,\n+        statement.getStatementText(),\n+        false\n+    ));\n+  }\n+\n+  private SchemaAndId getSchema(\n+      final String topicName,\n+      final Optional<Integer> schemaId,\n+      final FormatInfo expectedFormat,\n+      final String statementText,\n+      final boolean isKey\n+  ) {\n+    final SchemaResult result = isKey\n+        ? schemaSupplier.getKeySchema(topicName, schemaId, expectedFormat)\n+        : schemaSupplier.getValueSchema(topicName, schemaId, expectedFormat);\n \n     if (result.failureReason.isPresent()) {\n       final Exception cause = result.failureReason.get();\n       throw new KsqlStatementException(\n           cause.getMessage(),\n-          statement.getStatementText(),\n+          statementText,\n           cause);\n     }\n \n     return result.schemaAndId.get();\n   }\n \n-  private static boolean hasValueElements(\n+  private static boolean hasKeyElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     return statement.getStatement().getElements().stream()\n-        .anyMatch(e -> e.getNamespace().equals(Namespace.VALUE));\n+        .anyMatch(e -> e.getNamespace().isKey());\n   }\n \n-  private static boolean valueFormatSupportsSchemaInference(\n+  private static boolean hasValueElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    final FormatInfo valueFormat = SourcePropertiesUtil\n-        .getValueFormat(statement.getStatement().getProperties());\n+    return statement.getStatement().getElements().stream()\n+        .anyMatch(e -> !e.getNamespace().isKey());\n+  }\n \n-    return FormatFactory.of(valueFormat).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n+  private static boolean formatSupportsSchemaInference(final FormatInfo format) {\n+    return FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n   }\n \n   private static CreateSource addSchemaFields(\n       final ConfiguredStatement<CreateSource> preparedStatement,\n-      final SchemaAndId schema\n+      final Optional<SchemaAndId> keySchema,\n+      final Optional<SchemaAndId> valueSchema\n   ) {\n-    final TableElements elements = buildElements(schema.columns, preparedStatement);\n+    final TableElements elements = buildElements(preparedStatement, keySchema, valueSchema);\n \n     final CreateSource statement = preparedStatement.getStatement();\n     final CreateSourceProperties properties = statement.getProperties();\n \n-    if (properties.getSchemaId().isPresent()) {\n-      return statement.copyWith(elements, properties);\n-    }\n-    return statement.copyWith(elements, properties.withSchemaId(schema.id));\n+    final CreateSourceProperties withSchemaIds = properties.withSchemaIds(\n+        keySchema.map(s -> s.id),\n+        valueSchema.map(s -> s.id));\n+    return statement.copyWith(elements, withSchemaIds);\n   }\n \n   private static TableElements buildElements(\n-      final List<? extends SimpleColumn> valueColumns,\n-      final ConfiguredStatement<CreateSource> preparedStatement\n+      final ConfiguredStatement<CreateSource> preparedStatement,\n+      final Optional<SchemaAndId> keySchema,\n+      final Optional<SchemaAndId> valueSchema\n   ) {\n     final List<TableElement> elements = new ArrayList<>();\n \n-    getKeyColumns(preparedStatement)\n-        .forEach(elements::add);\n+    if (keySchema.isPresent()) {\n+      final Namespace namespace = getKeyNamespace(preparedStatement.getStatement());\n+      keySchema.get().columns.stream()\n+          .map(col -> new TableElement(namespace, col.name(), new Type(col.type())))\n+          .forEach(elements::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njg3NA==", "bodyText": "as I alluded to above, I think the behavior here needs to be different for keys/values. Namely, when we call the translator.toColumns(parsedSchema) we should only ever return one column for keys.\nI think we can leave that for a separate PR, and for this PR we can just assert that it only returns one column (i.e. we only support primitive keys and single field structs)", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501386874", "createdAt": "2020-10-08T00:41:01Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegistryTopicSchemaSupplier.java", "diffHunk": "@@ -74,52 +93,57 @@ public SchemaResult getValueSchema(\n       }\n \n       final ParsedSchema schema = srClient.getSchemaBySubjectAndId(subject, id);\n-      return fromParsedSchema(topicName, id, schema, expectedFormat);\n+      return fromParsedSchema(topicName, id, schema, expectedFormat, isKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MjAzMQ==", "bodyText": "nit: I used this pattern quite a bit, maybe we should move it to a util and refactor this? (and then we can also make SCHEMA_REGISTRY_*_SUFFIX private and just use this method) can be done in follow-up PR", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501392031", "createdAt": "2020-10-08T01:01:01Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegistryTopicSchemaSupplier.java", "diffHunk": "@@ -175,4 +201,11 @@ private static SchemaResult notCompatible(\n             + \"Schema:\" + schema,\n         cause));\n   }\n+\n+  private static String getSubject(final String topicName, final boolean isKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4de239431d7d7ffd36ff75c88bf509743b18071", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/e4de239431d7d7ffd36ff75c88bf509743b18071", "committedDate": "2020-10-08T12:56:25Z", "message": "test: fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "643ddc6b781d652a4a6fa4890e7960c7612a949d", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/643ddc6b781d652a4a6fa4890e7960c7612a949d", "committedDate": "2020-10-09T13:53:51Z", "message": "chore: throw from schema supplier on multiple key columns"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d17d3293f5f44294ed02236aaa293173828d5ca", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/2d17d3293f5f44294ed02236aaa293173828d5ca", "committedDate": "2020-10-09T14:03:58Z", "message": "refactor: util method for SR suffixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NzUxNDAy", "url": "https://github.com/confluentinc/ksql/pull/6380#pullrequestreview-505751402", "createdAt": "2020-10-09T14:56:02Z", "commit": {"oid": "2d17d3293f5f44294ed02236aaa293173828d5ca"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88ac55f162b70bdcf8374a835019e4b6835ba8c7", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/88ac55f162b70bdcf8374a835019e4b6835ba8c7", "committedDate": "2020-10-12T13:04:20Z", "message": "Merge branch 'master' into key-schema-register"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "120ce6ab1c304338058df29eed4384c72676883c", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/120ce6ab1c304338058df29eed4384c72676883c", "committedDate": "2020-10-12T17:09:08Z", "message": "fix: throw on unsupported key format from injector"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4625, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}