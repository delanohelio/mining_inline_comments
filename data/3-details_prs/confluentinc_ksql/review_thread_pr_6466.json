{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MzgyMDc1", "number": 6466, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyMzo0MlrOEv39CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNzoyMVrOEv4C-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM1MjczOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/PostConditionsNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyMzo0M1rOHlGrmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyMzo0M1rOHlGrmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODgyNw==", "bodyText": "nit: can we move this matcher logic into PostTopicNode, so someone updating PostTopicNode is less likely to forget to update the matcher? The other QTT classes all follow a particular pattern with this, for example: https://github.com/confluentinc/ksql/blob/master/ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/SourceNode.java#L114", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508668827", "createdAt": "2020-10-20T16:23:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/PostConditionsNode.java", "diffHunk": "@@ -133,7 +138,34 @@ Pattern buildBlackList() {\n     @SuppressWarnings(\"unchecked\")\n     Matcher<Iterable<PostTopicNode>> buildTopics() {\n       final Matcher<PostTopicNode>[] matchers = topics.stream()\n-          .map(Matchers::is)\n+          .map(topic -> new BaseMatcher<PostTopicNode>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM2MDA5OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNToyM1rOHlGwDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNzowMzo0MVrOHlIQ2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2OTk2Ng==", "bodyText": "Can we add a comment explaining that we need this special case because protobuf schemas aren't valid JSON? If I hadn't coincidentally encountered this in SerdeUtil (link) the other day, I would've been confused by this.\nRelatedly, it sucks that we have to duplicate this special-casing in multiple places... can't think of a good alternative at the moment though.", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508669966", "createdAt": "2020-10-20T16:25:23Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutor.java", "diffHunk": "@@ -229,6 +241,22 @@ public void buildAndExecuteQuery(\n     }\n   }\n \n+  private static JsonNode fromSchemaMetadata(final Optional<SchemaMetadata> metadata) {\n+    if (!metadata.isPresent()) {\n+      return NullNode.getInstance();\n+    }\n+\n+    if (ProtobufFormat.NAME.equals(metadata.get().getSchemaType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NDc0Nw==", "bodyText": "I was originally going to refactor all of it to just be a string, but then that made the QTT tests really annoying to write (escaped JSON inside JSON strings really sucks)", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508694747", "createdAt": "2020-10-20T17:03:41Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutor.java", "diffHunk": "@@ -229,6 +241,22 @@ public void buildAndExecuteQuery(\n     }\n   }\n \n+  private static JsonNode fromSchemaMetadata(final Optional<SchemaMetadata> metadata) {\n+    if (!metadata.isPresent()) {\n+      return NullNode.getInstance();\n+    }\n+\n+    if (ProtobufFormat.NAME.equals(metadata.get().getSchemaType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2OTk2Ng=="}, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM2MzMzOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/as_value.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNjoxMlrOHlGyGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNjoxMlrOHlGyGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MDQ5MA==", "bodyText": "Can we also add array and map for completeness? Same for the other tests (group by, partition by, etc). I don't think the coverage needs to be as thorough as what you've added for struct but I still think it'd be good to cover our bases.", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508670490", "createdAt": "2020-10-20T16:26:12Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/as_value.json", "diffHunk": "@@ -149,6 +149,27 @@\n           {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID DECIMAL(4,2) KEY, ID_COPY DECIMAL(4,2), V1 INT\"}\n         ]\n       }\n+    },\n+    {\n+      \"name\": \"STRUCT\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM2NzY5OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNzoxN1rOHlG0yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNzoxN1rOHlG0yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MTE3OQ==", "bodyText": "nit: unwrap singles is implicitly set on all key formats that support both wrapping and unwrapping, including AVRO. (I was confused for a moment when I read first this since I thought Avro was somehow special.)", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508671179", "createdAt": "2020-10-20T16:27:17Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "diffHunk": "@@ -2272,6 +2313,277 @@\n         {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n         {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n       ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO primitive key\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM2Nzk0OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyNzoyMVrOHlG08Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozOTowOFrOHlL51Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MTIxNw==", "bodyText": "This test looks identical to the one above it?", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508671217", "createdAt": "2020-10-20T16:27:21Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "diffHunk": "@@ -2272,6 +2313,277 @@\n         {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n         {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n       ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO primitive key\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`VAL` BOOLEAN KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ]\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO struct key group by primitive\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"name\": \"key\", \"type\": \"record\", \"fields\": [{\"name\": \"F1\", \"type\": [\"null\", \"int\"]}]},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 0}, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 0}, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 1}, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`VAL` BOOLEAN KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ]\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO group by struct\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"A\", \"type\": \"int\"}, {\"name\": \"B\", \"type\": \"int\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`ROWKEY` STRUCT<A INTEGER, B INTEGER> KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ],\n+        \"topics\": {\n+          \"topics\": [\n+            {\n+              \"name\": \"OUTPUT\",\n+              \"keyFormat\" : { \"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"] },\n+              \"keySchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"A\", \"type\": [ \"null\", \"int\" ], \"default\": null },\n+                  { \"name\": \"B\", \"type\": [ \"null\", \"int\" ], \"default\": null }\n+                ]\n+              },\n+              \"valueFormat\" : { \"format\" : \"AVRO\" },\n+              \"valueSchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"COUNT\", \"type\": [ \"null\", \"long\" ], \"default\": null }\n+                ]\n+              }\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct convert key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='AVRO') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"topics\": {\n+          \"topics\": [\n+            {\n+              \"name\": \"OUTPUT\",\n+              \"keyFormat\" : { \"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"] },\n+              \"keySchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"A\", \"type\": [ \"null\", \"int\" ], \"default\": null },\n+                  { \"name\": \"B\", \"type\": [ \"null\", \"int\" ], \"default\": null }\n+                ]\n+              },\n+              \"valueFormat\" : { \"format\" : \"JSON\" }\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct convert to incompatible key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='DELIMITED') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'DELIMITED' format does not support type 'STRUCT', column: `ROWKEY`\"\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"Struct key used in aggregate expression\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT AS SELECT ID, SUM(ID->F1) AS sum FROM TEST GROUP BY ID;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 1}, \"value\": {\"VAL\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 2}, \"value\": {\"VAL\": 2}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"F1\": 1}, \"value\": {\"SUM\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"F1\": 2}, \"value\": {\"SUM\": 3}}\n+      ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"Struct key used in aggregate expression\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NDM4OQ==", "bodyText": "eh, I forgot to remove the one above it (which actually fails - the data is different)", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508754389", "createdAt": "2020-10-20T18:39:08Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "diffHunk": "@@ -2272,6 +2313,277 @@\n         {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n         {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n       ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO primitive key\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`VAL` BOOLEAN KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ]\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO struct key group by primitive\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"name\": \"key\", \"type\": \"record\", \"fields\": [{\"name\": \"F1\", \"type\": [\"null\", \"int\"]}]},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 0}, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 0}, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 1}, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`VAL` BOOLEAN KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ]\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO group by struct\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"A\", \"type\": \"int\"}, {\"name\": \"B\", \"type\": \"int\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`ROWKEY` STRUCT<A INTEGER, B INTEGER> KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ],\n+        \"topics\": {\n+          \"topics\": [\n+            {\n+              \"name\": \"OUTPUT\",\n+              \"keyFormat\" : { \"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"] },\n+              \"keySchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"A\", \"type\": [ \"null\", \"int\" ], \"default\": null },\n+                  { \"name\": \"B\", \"type\": [ \"null\", \"int\" ], \"default\": null }\n+                ]\n+              },\n+              \"valueFormat\" : { \"format\" : \"AVRO\" },\n+              \"valueSchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"COUNT\", \"type\": [ \"null\", \"long\" ], \"default\": null }\n+                ]\n+              }\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct convert key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='AVRO') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"topics\": {\n+          \"topics\": [\n+            {\n+              \"name\": \"OUTPUT\",\n+              \"keyFormat\" : { \"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"] },\n+              \"keySchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"A\", \"type\": [ \"null\", \"int\" ], \"default\": null },\n+                  { \"name\": \"B\", \"type\": [ \"null\", \"int\" ], \"default\": null }\n+                ]\n+              },\n+              \"valueFormat\" : { \"format\" : \"JSON\" }\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct convert to incompatible key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='DELIMITED') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'DELIMITED' format does not support type 'STRUCT', column: `ROWKEY`\"\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"Struct key used in aggregate expression\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT AS SELECT ID, SUM(ID->F1) AS sum FROM TEST GROUP BY ID;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 1}, \"value\": {\"VAL\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 2}, \"value\": {\"VAL\": 2}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"F1\": 1}, \"value\": {\"SUM\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"F1\": 2}, \"value\": {\"SUM\": 3}}\n+      ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"Struct key used in aggregate expression\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MTIxNw=="}, "originalCommit": {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452"}, "originalPosition": 310}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2540, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}