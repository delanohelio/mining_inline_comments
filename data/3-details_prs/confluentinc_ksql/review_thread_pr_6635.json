{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNjgzNjYx", "number": 6635, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNToxNVrOE6N-sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MzozNVrOE7rG8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDgxOTA3OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNToxNVrOH1JtOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozODoyNFrOH1KhOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NTYwOA==", "bodyText": "If we want to fix the first inefficiency mentioned in the PR description (that we currently force repartitions even if not strictly necessary), this is the bit of logic that would be updated.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525495608", "createdAt": "2020-11-17T20:25:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwODkyMg==", "bodyText": "might be good to link this to a GH issue and place the issue inline", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525508922", "createdAt": "2020-11-17T20:38:24Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NTYwOA=="}, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDgyNDA4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNTo1N1rOH1JwiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNTo1N1rOH1JwiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjQ1Nw==", "bodyText": "This PR does not add support for joining on windowed sources with SR-enableld key formats. This will be a follow-up PR.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525496457", "createdAt": "2020-11-17T20:25:57Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDgyOTEzOnYy", "diffSide": "LEFT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKStreamTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNjo0MFrOH1J0VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNjo0MFrOH1J0VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NzQyOQ==", "bodyText": "This test is identical to shouldNotRepartitionIfSameKeyField above, so the duplicate has been removed.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525497429", "createdAt": "2020-11-17T20:26:40Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKStreamTest.java", "diffHunk": "@@ -146,31 +143,39 @@ public void shouldBuildSchemaForSelect() {\n   @Test\n   public void shouldNotRepartitionIfSameKeyField() {\n     // Given:\n-    final PlanNode logicalPlan = givenInitialKStreamOf(\n+    givenInitialKStreamOf(\n         \"SELECT col0, col2, col3 FROM test1 PARTITION BY col0 EMIT CHANGES;\");\n-    final UserRepartitionNode repartitionNode = (UserRepartitionNode) logicalPlan.getSources().get(0).getSources().get(0);\n \n     // When:\n     final SchemaKStream<?> result = initialSchemaKStream\n-        .selectKey(repartitionNode.getPartitionBy(), Optional.empty(), childContextStacker);\n+        .selectKey(valueFormat.getFormatInfo(), new UnqualifiedColumnReferenceExp(ColumnName.of(\"COL0\")), Optional.empty(), childContextStacker, false);\n \n     // Then:\n     assertThat(result, is(initialSchemaKStream));\n   }\n \n   @Test\n-  public void shouldNotRepartitionIfRowkey() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDgzNjcyOnYy", "diffSide": "LEFT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNzo0NFrOH1J5iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNzo0NFrOH1J5iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5ODc2MA==", "bodyText": "The test immediately above this one has the same name. I've renamed this one to indicate the difference and avoid confusion.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525498760", "createdAt": "2020-11-17T20:27:44Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -442,11 +442,14 @@\n       \"post\": {\n         \"sources\": [\n           {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"T_ID BIGINT KEY, NAME STRING, VALUE BIGINT, F1 STRING, F2 BIGINT\"}\n-        ]\n+        ],\n+        \"topics\": {\n+          \"blacklist\": \".*-repartition\"\n+        }\n       }\n     },\n     {\n-      \"name\": \"stream stream left join\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDg0MjM3OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyODozM1rOH1J9fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyODozM1rOH1J9fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5OTc3Mg==", "bodyText": "This is an example of the fact that we have two changelog topics here when we really only want to have one :(", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525499772", "createdAt": "2020-11-17T20:28:33Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},\n+        {\"topic\": \"s2\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-JOINTHIS-0000000016-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-OUTEROTHER-0000000017-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"stream-table key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}},\n+        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KafkaTopic_Right-Reduce-changelog\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDg1NDU3OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMDoxOFrOH1KFrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMDoxOFrOH1KFrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwMTg3MA==", "bodyText": "Ideally this topic would be named _confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition (or similar) to indicate that it's the repartition topic on the left side of the join, but this would be a breaking change and I'm not sure it's worth the confusion it will save. (The reason it's unambiguous prior to this PR is because for stream-table joins, only the stream side (left side) would ever be repartitioned, but that's no longer true with this PR.)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525501870", "createdAt": "2020-11-17T20:30:18Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},\n+        {\"topic\": \"s2\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-JOINTHIS-0000000016-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-OUTEROTHER-0000000017-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"stream-table key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}},\n+        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-repartition\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDg2OTc0OnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSelectKeyBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMjozN1rOH1KQNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTowMTozOVrOH1LUGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNDU2Ng==", "bodyText": "I've tried to implement this new plan step in a generic way so that it can also support user table repartitions in the future, rather than baking in assumptions such as the fact that today the logical schema (and key format) never change when this step is called, as the step is only used to enable a specific join use case. However, there's no testing for the more general table rekey functionality, so maybe it's more misleading to have the step appear general, and we should be failing if any of these assumptions are violated instead?", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525504566", "createdAt": "2020-11-17T20:32:37Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSelectKeyBuilder.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.materialization.MaterializationInfo;\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.execution.plan.KeySerdeFactory;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+public final class TableSelectKeyBuilder {\n+\n+  private TableSelectKeyBuilder() {\n+  }\n+\n+  public static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory\n+  ) {\n+    return build(\n+        table,\n+        selectKey,\n+        queryBuilder,\n+        materializedFactory,\n+        PartitionByParamsFactory::build\n+    );\n+  }\n+\n+  @VisibleForTesting\n+  static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory,\n+      final PartitionByParamsBuilder paramsBuilder\n+  ) {\n+    final LogicalSchema sourceSchema = table.getSchema();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTk0NA==", "bodyText": "I think it's fine to implement it generically, we should have tests that fail if a user tries to repartition a table so I think that covers that this isn't being used for evil", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525521944", "createdAt": "2020-11-17T21:01:39Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSelectKeyBuilder.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.materialization.MaterializationInfo;\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.execution.plan.KeySerdeFactory;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+public final class TableSelectKeyBuilder {\n+\n+  private TableSelectKeyBuilder() {\n+  }\n+\n+  public static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory\n+  ) {\n+    return build(\n+        table,\n+        selectKey,\n+        queryBuilder,\n+        materializedFactory,\n+        PartitionByParamsFactory::build\n+    );\n+  }\n+\n+  @VisibleForTesting\n+  static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory,\n+      final PartitionByParamsBuilder paramsBuilder\n+  ) {\n+    final LogicalSchema sourceSchema = table.getSchema();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNDU2Ng=="}, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDkwODMwOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo0MToxNlrOH1KpHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMToxNzoxOFrOH1SAuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMDk0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"\n          \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on windowed Schema-Registry-enabled key formats \"", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525510940", "createdAt": "2020-11-17T20:41:16Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMTY3NQ==", "bodyText": "Whoops -- nice catch.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525631675", "createdAt": "2020-11-18T01:17:18Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMDk0MA=="}, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDkxNTMxOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo0MzozMFrOH1KtOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo0MzozMFrOH1KtOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMTk5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"\n          \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on windowed Schema-Registry-enabled key formats \"", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525511994", "createdAt": "2020-11-17T20:43:30Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -157,10 +162,46 @@ public SchemaKTable(\n           + \"a join, joins on tables with multiple columns is not yet supported.\");\n     }\n \n-    throw new UnsupportedOperationException(\"Cannot repartition a TABLE source. \"\n-        + \"If this is a join, make sure that the criteria uses the TABLE's key column \"\n-        + Iterables.getOnlyElement(schema.key()).name().text() + \" instead of \"\n-        + keyExpression);\n+    // Table repartitioning is only supported for internal use in enabling joins\n+    if (!forceRepartition) {\n+      throw new UnsupportedOperationException(\"Cannot repartition a TABLE source. \"\n+          + \"If this is a join, make sure that the criteria uses the TABLE's key column \"\n+          + Iterables.getOnlyElement(schema.key()).name().text() + \" instead of \"\n+          + keyExpression);\n+    }\n+\n+    if (keyFormat.isWindowed()) {\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDkzOTYwOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo1MDoyM1rOH1K78w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMToxNjo0NlrOH1SADw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNTc2Mw==", "bodyText": "did this topic always exist and now we're just adding it to the postcondition?", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525515763", "createdAt": "2020-11-17T20:50:23Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2171,6 +2210,11 @@\n               \"keyFormat\" : {\"format\" : \"DELIMITED\"},\n               \"valueFormat\" : {\"format\" : \"JSON\"}\n             },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMTUwMw==", "bodyText": "Yes, that's correct. I thought it was odd that this test was checking the presence of one of the repartition topics but not the other, so I added the other in as well.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525631503", "createdAt": "2020-11-18T01:16:46Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2171,6 +2210,11 @@\n               \"keyFormat\" : {\"format\" : \"DELIMITED\"},\n               \"valueFormat\" : {\"format\" : \"JSON\"}\n             },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNTc2Mw=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDk0OTUyOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo1MzoxMlrOH1LCAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1NDoxN1rOH3X6EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzMxMg==", "bodyText": "we might want to introduce a pre-topics node here so that we have control over the actual schema in schema registry. I think we also have the ability to ensure the schema at the end. It would be good to have both of these in the test to make sure we don't accidentally create a backwards incompatible change if/when we optimize away unnecessary repartitions\nI think it also makes sense to add tests for:\n\nschemas are identical, should repartition anyway\nschemas are logically identical but physically different\nschemas are logically different, should fail (in table-table joins anyway)\n\nAlso we should make sure what happens when we have an SR-enabled value format as well (I don't imagine anything should go wrong, but it makes sure that when we piped through the value format in the table select key we don't mess things up)\n\n\ud83d\ude82\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n          \n          \n            \n                  \"name\": \"stream-stream key-to-key - SR-enabled key format\",", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525517312", "createdAt": "2020-11-17T20:53:12Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMzcyNQ==", "bodyText": "we might want to introduce a pre-topics node here so that we have control over the actual schema in schema registry. I think we also have the ability to ensure the schema at the end.\n\nYes, I've been thinking this as well. Wanted to open the PR first in order to sanity-check the approach -- since we're on the same page I'll pursue beefing up the tests \ud83d\udc4d\n\nI think it also makes sense to add tests for:\n\nschemas are identical, should repartition anyway\nschemas are logically identical but physically different\nschemas are logically different, should fail (in table-table joins anyway)\n\n\nThe new tests I added are already case (1). Tests for case (3) exist for non-SR-enabled formats, but I'll add one for an SR-enabled format. I'll add (2) and also tests with SR-enabled value formats as a sanity check.\n\n\ud83d\ude82\n\nHaha! I fell victim to copy-paste from existing tests. I made the update, which required renaming existing historic plans so this PR diff just became a lot larger in terms of number of lines.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525633725", "createdAt": "2020-11-18T01:23:39Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzMxMg=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNTQyNQ==", "bodyText": "Added the different tests discussed above. Good call on testing table-table join with nulls -- turns out we've got a bug. The newly added test won't pass until #6647 is merged.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527825425", "createdAt": "2020-11-20T16:54:17Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzMxMg=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDk2ODMwOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo1ODozN1rOH1LNVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1NDozNFrOH3X7FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMDIxNA==", "bodyText": "I think we might want to add the following tests:\n\nselect both keys in the output (use AS_VALUE)\nentirely null values (and then joining post-tombstone)\ntest full outer joins\nnegative test for windowed sources join", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525520214", "createdAt": "2020-11-17T20:58:37Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNTY4NQ==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527825685", "createdAt": "2020-11-20T16:54:34Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMDIxNA=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDk3NDY1OnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/MaterializationUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTowMDoyM1rOH1LRHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1NTowMlrOH3X8zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTE4Mw==", "bodyText": "+1 nice refactor, can you add short javadoc? otherwise \"utils\" can be dumping ground for misc things", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525521183", "createdAt": "2020-11-17T21:00:23Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/MaterializationUtil.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.SchemaNotSupportedException;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.plan.ExecutionStep;\n+import io.confluent.ksql.execution.plan.Formats;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+final class MaterializationUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNjEyNw==", "bodyText": "Added a short javadoc but I'm not sure how much it adds beyond the name of the class. LMK if you had something else in mind.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527826127", "createdAt": "2020-11-20T16:55:02Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/MaterializationUtil.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.SchemaNotSupportedException;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.plan.ExecutionStep;\n+import io.confluent.ksql.execution.plan.Formats;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+final class MaterializationUtil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTE4Mw=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTAwNzY3OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMToxMDoxNVrOH1Llcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1NToxMlrOH3X9lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjM4Nw==", "bodyText": "we might want to move this into JoiningNode so that we can leverage it both here and in JoinNode#getValueFormatForSource (that way, we can ensure that they line up - if for some reason we decide to switch JoinNode to use the right most value format, we won't have to make that change here too)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525526387", "createdAt": "2020-11-17T21:10:15Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -54,6 +59,10 @@ public PreJoinRepartitionNode(\n     this.joiningNode = source instanceof JoiningNode\n         ? Optional.of((JoiningNode) source)\n         : Optional.empty();\n+    this.valueFormat = getLeftmostSourceNode()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNjMyNA==", "bodyText": "Done -- good call!", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527826324", "createdAt": "2020-11-20T16:55:12Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -54,6 +59,10 @@ public PreJoinRepartitionNode(\n     this.joiningNode = source instanceof JoiningNode\n         ? Optional.of((JoiningNode) source)\n         : Optional.empty();\n+    this.valueFormat = getLeftmostSourceNode()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjM4Nw=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTE1NDExOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo1Mjo1MVrOH1M-mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1NjozNlrOH3YCsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTIwOA==", "bodyText": "I'm not sure, but should we make this requiresRepartition() || forceRepartition? If not, we should add a comment about why forced repartitions don't move in here (instead of // Node is repartitioning already)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525549208", "createdAt": "2020-11-17T21:52:51Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n+      forceRepartition = true;\n+    }\n+\n     if (requiresRepartition()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNzYzMg==", "bodyText": "Addressed this as part of revamping the logic (see #6635 (comment)).", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527827632", "createdAt": "2020-11-20T16:56:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n+      forceRepartition = true;\n+    }\n+\n     if (requiresRepartition()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTIwOA=="}, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTE1OTUyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo1NDoyOFrOH1NB5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo1NDoyOFrOH1NB5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MDA1NQ==", "bodyText": "I know that none of this class is javadoc'd \ud83d\ude22 but I think it makes sense to tackle it a little bit at a time. Can we add some here explaining what forceRepartition does and why we might want to use it?", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525550055", "createdAt": "2020-11-17T21:54:28Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTE2ODYxOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo1NzowMlrOH1NHOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1NzozNVrOH3YFxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA==", "bodyText": "not your code: it bothers me a little that there's nothing \"requiring\" that this is called. can we have buildStream() throw an exception if setKeyFormat was never set? this will make sure that we don't refactor the code and lose this call somewhere in the refactor", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525551418", "createdAt": "2020-11-17T21:57:02Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNzMyMQ==", "bodyText": "That's because it wasn't required that this method be called previously :) I've revamped the logic here so it's now required, as that was the major point of confusion when reading this code as well. Also added the check you suggested.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527827321", "createdAt": "2020-11-20T16:56:17Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA=="}, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyODQyMA==", "bodyText": "Good call on challenging this, BTW. There was a bug where we weren't always forcing repartitions for upstream joins with SR-enableld key formats in multi-joins. I've fixed the bug and also added multi-join QTTs to cover this.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527828420", "createdAt": "2020-11-20T16:57:35Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA=="}, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTE3MzkxOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo1ODozOVrOH1NKfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMTozMDo1N1rOH1SSPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA==", "bodyText": "super nit: (usually better to have the easy things first in chained ands)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && repartitionNotNeeded(ImmutableList.of(keyExpression))\n          \n          \n            \n                    && !forceRepartition\n          \n          \n            \n                    && !forceRepartition\n          \n          \n            \n                    && repartitionNotNeeded(ImmutableList.of(keyExpression))", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525552254", "createdAt": "2020-11-17T21:58:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMzk1MQ==", "bodyText": "\"easy\" meaning easy to grok or computationally easy to evaluate? (Already made the change, just curious about your motivations.)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525633951", "createdAt": "2020-11-18T01:24:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA=="}, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzNjE1OQ==", "bodyText": "both, but mostly the computationally easy one. I don't know by reading this code that repartitionNotNeeded is something lightweight - it might call out to some external service for all I know without digging into it. If we put the simple boolean checks first I don't really need to care", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525636159", "createdAt": "2020-11-18T01:30:57Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA=="}, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwOTU2OTMwOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1ODozMVrOH3YH4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1ODozMVrOH3YH4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyODk2Mw==", "bodyText": "This test will not succeed until #6647 is merged.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527828963", "createdAt": "2020-11-20T16:58:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,649 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-stream key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},\n+        {\"topic\": \"s2\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-JOINTHIS-0000000016-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-OUTEROTHER-0000000017-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"stream-table key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}},\n+        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KafkaTopic_Right-Reduce-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-Materialize-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"table-table - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T1 (ID BIGINT PRIMARY KEY, NAME varchar) WITH (kafka_topic='t1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ID BIGINT PRIMARY KEY, F1 varchar) WITH (kafka_topic='t2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE TABLE OUTPUT as SELECT T1.id, name, f1 FROM T1 left join T2 on T1.id = T2.id;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t1\", \"key\": 0, \"value\": {\"NAME\": \"zero\"}},\n+        {\"topic\": \"t2\", \"key\": 0, \"value\": {\"F1\": \"blah\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"NAME\": \"zero\", \"F1\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"NAME\": \"zero\", \"F1\": \"blah\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"table\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-LeftSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-RightSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-KafkaTopic_Left-Reduce-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-KafkaTopic_Right-Reduce-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-LeftSourceKeyed-Materialize-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-RightSourceKeyed-Materialize-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"table-table - SR-enabled key format - with nulls\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ed3260b9310b700a408029ebe8727ffc0f3409"}, "originalPosition": 377}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDA3MzY0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MjoxOFrOH3c42A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MjoxOFrOH3c42A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzAzMg==", "bodyText": "\ud83d\ude02 pah. what a useless condition.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527907032", "createdAt": "2020-11-20T18:52:18Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -140,15 +144,18 @@ public SchemaKTable(\n     );\n   }\n \n+  @SuppressFBWarnings(\"UC_USELESS_CONDITION\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDA3NzI4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MzozNVrOH3c7TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MzozNVrOH3c7TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzY2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (repartitionNotNeeded(ImmutableList.of(keyExpression)) && !forceRepartition) {\n          \n          \n            \n                if (!forceRepartition && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n          \n      \n    \n    \n  \n\nnit: pet peeve of mine \ud83d\ude08", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527907660", "createdAt": "2020-11-20T18:53:35Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -140,15 +144,18 @@ public SchemaKTable(\n     );\n   }\n \n+  @SuppressFBWarnings(\"UC_USELESS_CONDITION\")\n   @SuppressWarnings(\"unchecked\")\n   @Override\n-  public SchemaKStream<Struct> selectKey(\n+  public SchemaKTable<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n-    if (repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n-      return (SchemaKStream<Struct>) this;\n+    if (repartitionNotNeeded(ImmutableList.of(keyExpression)) && !forceRepartition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2428, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}