{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNjcyOTky", "number": 4278, "title": "feat: expression support in JOINs", "bodyText": "fixes #4130\nDescription\nThis PR introduces the ability to do arbitrary expressions in join conditions as long as on each side of the equality exactly one join source is used, and both join sources are represented. As an added bonus, this feature actually removes more code than it adds!\nTo implement this, I simply removed all repartition logic from the JoinNode and instead added a repartition step (reusing the recently introduced RepartitionNode) to each of the source nodes. This path is always hit, if no repartition is required then the repartition node simply returns the same source as was passed into it. Now, the JoinNode always joins on the keys of its input.\nReview Guide\nTo review, I recommend first looking at the Analyzer which has been simplified just to check the condition outlined above. Then, look at the LogicalPlanner and finally at the JoinNode.\nTesting done\n\nUpdated unit tests\nUpdated all the QTT tests that failed when expressions were present in the join criteria\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-01-11T00:35:16Z", "url": "https://github.com/confluentinc/ksql/pull/4278", "merged": true, "mergeCommit": {"oid": "2d0bfe8c860c63a71fda07a986d93f659e9ccc97"}, "closed": true, "closedAt": "2020-01-15T00:18:05Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6BFtugH2gAyMzYxNjcyOTkyOjY4NDk2YmZiNmI1MWM2MDFiZjE4ODkzOTNmZmNiMWI2MDM4OGE0NWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6aPuvgFqTM0MjkyMjU2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/68496bfb6b51c601bf1889393ffcb1b60388a45b", "committedDate": "2020-01-13T18:58:41Z", "message": "feat: expression support in JOINs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "803478148f634e16c9fbb0f8efb21a48b111b2d7", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/803478148f634e16c9fbb0f8efb21a48b111b2d7", "committedDate": "2020-01-11T00:31:13Z", "message": "feat: expression support in JOINs"}, "afterCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/68496bfb6b51c601bf1889393ffcb1b60388a45b", "committedDate": "2020-01-13T18:58:41Z", "message": "feat: expression support in JOINs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjI3MDg4", "url": "https://github.com/confluentinc/ksql/pull/4278#pullrequestreview-342227088", "createdAt": "2020-01-14T00:25:53Z", "commit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMDoyNTo1M1rOFdI6yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMDo0NzoyN1rOFdJO-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA5OTE0Nw==", "bodyText": "Each step in the logical plan should have a unique node id, so we should pass in some prefix for that here and use it in buildRepartitionNode.", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366099147", "createdAt": "2020-01-14T00:25:53Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -286,10 +286,11 @@ private PlanNode buildSourceNode() {\n         new PlanNodeId(\"Join\"),\n         analysis.getSelectExpressions(),\n         joinInfo.get().getType(),\n-        leftSourceNode,\n-        rightSourceNode,\n-        joinInfo.get().getLeftJoinField(),\n-        joinInfo.get().getRightJoinField(),\n+        // it is always safe to build the repartition node - this operation will be\n+        // a no-op if a repartition is not required. if the source is a table, and\n+        // a repartition is needed, then an exception will be thrown\n+        buildRepartitionNode(leftSourceNode, joinInfo.get().getLeftJoinExpression()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMDQ0MA==", "bodyText": "I'm not sure adding repartition nodes in the logical plan is the right way to go here. IMO the transformation performed by the nodes in the logical plan should correspond closely to the semantics of the corresponding transformation in the query, e.g.\nRepartitionNode implements PARTITION BY\nProjectNode implements SELECT <ITEMS>\nFilterNode implements WHERE <expr>\nI see two problems in this particular case:\n\n\nThe semantics of the repartition for the join might be different from the semantics of the repartition needed to perform a PARTITION BY. A PARTITION BY transforms the schema in a very specific way that may not make sense here. It's kind of hard to give a concrete example since we're still deciding on PARTITION BY semantics. But one example might be adding default column names for the new key columns (depending on the semantics we choose for it). If PARTITION BY semantics support adding columns in the PARTITION BY, those columns should get some generated name. But it wouldn't make sense to add those columns for the repartition done here.\n\n\nThe repartition here is really an implementation detail of the join. One place that comes to mind where this might come up down the line: we've discussed changing the join semantics to preserve the original key of the left side. The current behavior is really exposing implementation details in our query semantics. If we did that it would be awkward to have the original rekey in these repartition nodes and the post-join rekey in JoinNode", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366100440", "createdAt": "2020-01-14T00:30:55Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -286,10 +286,11 @@ private PlanNode buildSourceNode() {\n         new PlanNodeId(\"Join\"),\n         analysis.getSelectExpressions(),\n         joinInfo.get().getType(),\n-        leftSourceNode,\n-        rightSourceNode,\n-        joinInfo.get().getLeftJoinField(),\n-        joinInfo.get().getRightJoinField(),\n+        // it is always safe to build the repartition node - this operation will be\n+        // a no-op if a repartition is not required. if the source is a table, and\n+        // a repartition is needed, then an exception will be thrown\n+        buildRepartitionNode(leftSourceNode, joinInfo.get().getLeftJoinExpression()),\n+        buildRepartitionNode(rightSourceNode, joinInfo.get().getRightJoinExpression()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMDk2Ng==", "bodyText": "We should just do this in SchemaKTable rather than checking the type here.", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366100966", "createdAt": "2020-01-14T00:33:10Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -334,6 +334,13 @@ KeyField findKeyField(final List<SelectExpression> selectExpressions) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n+    if (this instanceof SchemaKTable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMTQxMA==", "bodyText": "nit: we should rename this type to something more specific (maybe ColumnReferenceResolver?)", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366101410", "createdAt": "2020-01-14T00:35:02Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -48,17 +55,27 @@\n     this.sourceSchemas = Objects.requireNonNull(sourceSchemas, \"sourceSchemas\");\n   }\n \n-  void analyzeExpression(final Expression expression, final boolean allowWindowMetaFields) {\n-    final Visitor visitor = new Visitor(allowWindowMetaFields);\n+  Set<ColumnRef> analyzeExpression(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMTk2OQ==", "bodyText": "You can use a TraversalExpressionVisitor here, which implements most of the traversal stuff for you", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366101969", "createdAt": "2020-01-14T00:37:25Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -48,17 +55,27 @@\n     this.sourceSchemas = Objects.requireNonNull(sourceSchemas, \"sourceSchemas\");\n   }\n \n-  void analyzeExpression(final Expression expression, final boolean allowWindowMetaFields) {\n-    final Visitor visitor = new Visitor(allowWindowMetaFields);\n+  Set<ColumnRef> analyzeExpression(\n+      final Expression expression,\n+      final boolean allowWindowMetaFields\n+  ) {\n+    final Set<ColumnRef> referencedColumns = new HashSet<>();\n+    final Visitor visitor = new Visitor(allowWindowMetaFields, referencedColumns);\n     visitor.process(expression, null);\n+    return referencedColumns;\n   }\n \n   private final class Visitor extends VisitParentExpressionVisitor<Object, Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMjQ3OA==", "bodyText": "If the column is not qualified, don't you need to check that it belongs to exactly one source, and include that source in the stream? If we are assuming all the columns are qualified then we should throw if the source is empty.", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366102478", "createdAt": "2020-01-14T00:39:22Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -349,28 +349,66 @@ protected AstNode visitJoin(final Join node, final Void context) {\n         );\n       }\n \n-      final ColumnRef leftJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          left.getAlias(),\n-          left.getDataSource().getSchema()\n-      );\n+      final Set<ColumnRef> colsUsedInLeft = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getLeft(), false);\n+      final Set<ColumnRef> colsUsedInRight = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getRight(), false);\n \n-      final ColumnRef rightJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          right.getAlias(),\n-          right.getDataSource().getSchema()\n-      );\n+      final SourceName leftSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getLeft(), comparisonExpression, colsUsedInLeft);\n+      final SourceName rightSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getRight(), comparisonExpression, colsUsedInRight);\n+\n+      final boolean flipped = leftSourceName.equals(right.getAlias());\n+      if (!validJoin(flipped, left.getAlias(), right.getAlias(), leftSourceName, rightSourceName)) {\n+        throw new KsqlException(\n+            \"Each side of the join must reference exactly one source and not the same source. \"\n+                + \"Left side references \" + leftSourceName\n+                + \" and right references \" + rightSourceName\n+        );\n+      }\n \n       analysis.setJoin(new JoinInfo(\n-          leftJoinField,\n-          rightJoinField,\n+          flipped ? comparisonExpression.getRight() : comparisonExpression.getLeft(),\n+          flipped ? comparisonExpression.getLeft() : comparisonExpression.getRight(),\n           joinType,\n           node.getWithinExpression()\n       ));\n \n       return null;\n     }\n \n+    private boolean validJoin(\n+        final boolean flipped,\n+        final SourceName leftName,\n+        final SourceName rightName,\n+        final SourceName leftExpressionSource,\n+        final SourceName rightExpressionSource\n+    ) {\n+      final boolean validLeft = flipped || leftExpressionSource.equals(leftName);\n+      final boolean validRight = (flipped && rightExpressionSource.equals(leftName))\n+              || (!flipped && rightExpressionSource.equals(rightName));\n+      return validLeft && validRight;\n+    }\n+\n+    private SourceName getOnlySourceForJoin(\n+        final Expression exp,\n+        final ComparisonExpression join,\n+        final Set<ColumnRef> columnRefs\n+    ) {\n+      try {\n+        return columnRefs.stream()\n+            .map(ColumnRef::source)\n+            .filter(Optional::isPresent)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwNDMxNA==", "bodyText": "if flipped is true, this doesn't check that the left expression source is the right data source. Maybe would be simpler to write as:\nfinal Set<SourceName> sourcesInCondition = ImmutableSet.of(leftExpressionSource, rightExpressionSource);\nreturn sourcesInCondition.contains(leftName) && sourcesInCondition.contains(rightName);", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366104314", "createdAt": "2020-01-14T00:47:27Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -349,28 +349,66 @@ protected AstNode visitJoin(final Join node, final Void context) {\n         );\n       }\n \n-      final ColumnRef leftJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          left.getAlias(),\n-          left.getDataSource().getSchema()\n-      );\n+      final Set<ColumnRef> colsUsedInLeft = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getLeft(), false);\n+      final Set<ColumnRef> colsUsedInRight = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getRight(), false);\n \n-      final ColumnRef rightJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          right.getAlias(),\n-          right.getDataSource().getSchema()\n-      );\n+      final SourceName leftSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getLeft(), comparisonExpression, colsUsedInLeft);\n+      final SourceName rightSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getRight(), comparisonExpression, colsUsedInRight);\n+\n+      final boolean flipped = leftSourceName.equals(right.getAlias());\n+      if (!validJoin(flipped, left.getAlias(), right.getAlias(), leftSourceName, rightSourceName)) {\n+        throw new KsqlException(\n+            \"Each side of the join must reference exactly one source and not the same source. \"\n+                + \"Left side references \" + leftSourceName\n+                + \" and right references \" + rightSourceName\n+        );\n+      }\n \n       analysis.setJoin(new JoinInfo(\n-          leftJoinField,\n-          rightJoinField,\n+          flipped ? comparisonExpression.getRight() : comparisonExpression.getLeft(),\n+          flipped ? comparisonExpression.getLeft() : comparisonExpression.getRight(),\n           joinType,\n           node.getWithinExpression()\n       ));\n \n       return null;\n     }\n \n+    private boolean validJoin(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "164130cdfde616b4ddeccdfc5800bfc45b552d49", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/164130cdfde616b4ddeccdfc5800bfc45b552d49", "committedDate": "2020-01-14T21:36:39Z", "message": "fix: rohans requested changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTIyNTYz", "url": "https://github.com/confluentinc/ksql/pull/4278#pullrequestreview-342922563", "createdAt": "2020-01-15T00:17:15Z", "commit": {"oid": "164130cdfde616b4ddeccdfc5800bfc45b552d49"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 75, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}