{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5OTQxMzQ4", "number": 5200, "title": "feat(client): Java client with push + pull query support", "bodyText": "Description\nStill in the process of adding more test coverage but the bulk of the changes and functional tests are here.\nTo review, start with Client.java and the associated interfaces. Then look at the implementations, starting with ClientImpl.java. Unit/functional tests with example usage are in ClientTest.java.\nAdditional test coverage to come (potentially in follow-up PRs) include tests for:\n\nTLS / mutual auth / basic auth\npush query with limit clause\ndecimal and complex types in result schema\n\nImplementation for the insert stream methods will be a separate PR. Docs will come later as well.\nTesting done\nManual + unit tests.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-04-28T07:43:29Z", "url": "https://github.com/confluentinc/ksql/pull/5200", "merged": true, "mergeCommit": {"oid": "280ef0ca8aa02693db1427ece08cd7863abed98d"}, "closed": true, "closedAt": "2020-05-09T06:40:15Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcb-3duAH2gAyNDA5OTQxMzQ4OjQ2MWMwMGFlYzdlNjMzZThkZDBhNmZjOGMzODY1ZTY1OWUzNjM2ZGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgBLvJgFqTQwODc3OTM2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/461c00aec7e633e8dd0a6fc8c3865e659e3636df", "committedDate": "2020-04-28T07:36:44Z", "message": "feat: java client push/pull query support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNTgwMTIx", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-401580121", "createdAt": "2020-04-28T07:48:10Z", "commit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzo0ODoxMFrOGNHM1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzo0ODoxMFrOGNHM1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ==", "bodyText": "I'd originally wanted to add similar methods for getting decimals but that requires either:\n\nparsing the schema to find the precision and scale\nasking the caller to specify precision and scale in the getter\n\nand neither seems great. Is it worth updating the endpoint to return the schema in a more structured form? Feels maybe like overkill.\nI also considered adding getter methods for arrays (lists) and maps but I'm not sure how valuable those methods would be without parsing the schema for specific subtypes.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416402645", "createdAt": "2020-04-28T07:48:10Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNzQyNTI1", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-401742525", "createdAt": "2020-04-28T11:27:21Z", "commit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "state": "COMMENTED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMToyNzoyMVrOGNPbPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjoyNzozN1rOGNReag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzNzQwNg==", "bodyText": "This is ok for now. But before we ship I think it's important that we don't depend on any ksqlDB server side stuff - otherwise a whole load of dependencies will be pulled into the client jar, which will it hard to use by users.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416537406", "createdAt": "2020-04-28T11:27:21Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/pom.xml", "diffHunk": "@@ -0,0 +1,89 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright 2020 Confluent Inc.\n+  ~\n+  ~ Licensed under the Confluent Community License (the \"License\"); you may not use\n+  ~ this file except in compliance with the License.  You may obtain a copy of the\n+  ~ License at\n+  ~\n+  ~ http://www.confluent.io/confluent-community-license\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+  ~ WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations under the License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+\n+    <parent>\n+        <groupId>io.confluent.ksql</groupId>\n+        <artifactId>ksqldb-parent</artifactId>\n+        <version>6.0.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>ksqldb-api-client</artifactId>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA==", "bodyText": "I notice this method is not used in tests. I think it's better to use the interface method to create a client than directly instantiating ClientImpl. This enables us to change the implementation more easily without breaking clients. We should consider hiding the constructor of ClientImpl (e.g. making package protected or private and indirecting through a factory)", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416538464", "createdAt": "2020-04-28T11:29:25Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+\n+  Publisher<InsertAck> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+\n+  void close();\n+\n+  static Client create(ClientOptions clientOptions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA==", "bodyText": "Maybe also expose the Vert.x HttpClientOptions? There are probably other settings (e.g. pool size) that users might want to tweak.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416539568", "createdAt": "2020-04-28T11:31:34Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/ClientOptions.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+public interface ClientOptions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MDAxNA==", "bodyText": "I know the docs are going to be completed at a later date, but this is also used for pull query.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416540014", "createdAt": "2020-04-28T11:32:21Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/QueryResult.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * The result of a streaming (push) query. Records may be consumed by either subscribing to the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MTQwMQ==", "bodyText": "I don't think most users care too muchabout the precision of a decimal. I think we should just return a BigDecimal for a DECIMAL column with whatever scale and precision is appropriate for the value. This is what JDBC does btw https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getBigDecimal(int)", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416541401", "createdAt": "2020-04-28T11:35:00Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MTY1Mw==", "bodyText": "For a struct - we can just return that as a JsonObject.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416541653", "createdAt": "2020-04-28T11:35:28Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MzE0Mg==", "bodyText": "In general, I don't think many users will care about schema either. In the vast majority of cases the back end schema will be well known and fixed, and the developer will know this when issuing queries and doing stuff with the results. Very rarely will be a front end be coding against a completely dynamic and unknown back end.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416543142", "createdAt": "2020-04-28T11:38:04Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MzkzNQ==", "bodyText": "I'd also add a version of create that takes a Vertx instance. This allows the client to use any existing Vert.x the user might already be using in their app, thus alllowing thread pools to be reused etc.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416543935", "createdAt": "2020-04-28T11:39:36Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+\n+  Publisher<InsertAck> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+\n+  void close();\n+\n+  static Client create(ClientOptions clientOptions) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDQwMQ==", "bodyText": "The stream methods can also be used for pull queries :)\nNot all pull queries results are small enough to be collected as a set of rows in memory. For large pull queries you might want to stream, and say, straight out to a file on disk.\nSo the distinction between streaming or not, is not really about pull vs push queries it's more about the number of rows returned.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416550401", "createdAt": "2020-04-28T11:51:22Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDUyNQ==", "bodyText": "As above comment", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416550525", "createdAt": "2020-04-28T11:51:35Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MTI1MQ==", "bodyText": "BTW this is the reason I named the methods \"streamQuery\" not \"executePushQuery\" :)", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416551251", "createdAt": "2020-04-28T11:52:51Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDQwMQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjI0NQ==", "bodyText": "I think whether auth is used is configured on the client options, if so then all this stuff probably doesn't need to be computed on each request.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416552245", "createdAt": "2020-04-28T11:54:39Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjU5MA==", "bodyText": "Do we really need a separate method for this?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416552590", "createdAt": "2020-04-28T11:55:18Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()\n+        + \":\"\n+        + clientOptions.getBasicAuthPassword();\n+    final String base64creds =\n+        Base64.getEncoder().encodeToString(creds.getBytes(Charset.defaultCharset()));\n+    return request.putHeader(AUTHORIZATION.toString(), \"Basic \" + base64creds);\n+  }\n+\n+  private static void handleRequestException(final Throwable t, final CompletableFuture<?> cf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjkzOA==", "bodyText": "I'm thinking maybe we need to set the exception handler on the recordParser too and connect it to the CF?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416552938", "createdAt": "2020-04-28T11:55:59Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()\n+        + \":\"\n+        + clientOptions.getBasicAuthPassword();\n+    final String base64creds =\n+        Base64.getEncoder().encodeToString(creds.getBytes(Charset.defaultCharset()));\n+    return request.putHeader(AUTHORIZATION.toString(), \"Basic \" + base64creds);\n+  }\n+\n+  private static void handleRequestException(final Throwable t, final CompletableFuture<?> cf) {\n+    cf.completeExceptionally(t);\n+  }\n+\n+  private static <T> void handleResponse(\n+      final HttpClientResponse response,\n+      final CompletableFuture<T> cf,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier) {\n+    if (response.statusCode() == OK.code()) {\n+      final RecordParser recordParser = RecordParser.newDelimited(\"\\n\", response);\n+      final QueryResponseHandler<T> responseHandler =\n+          responseHandlerSupplier.get(Vertx.currentContext(), recordParser, cf);\n+\n+      recordParser.handler(responseHandler::handleBodyBuffer);\n+      recordParser.endHandler(responseHandler::handleBodyEnd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw==", "bodyText": "I'm not a fan of initialising config strings to empty strings. Imho null is a better way of determining whether they have been set or not.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416553807", "createdAt": "2020-04-28T11:57:28Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientOptionsImpl.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.ClientOptions;\n+import java.util.Objects;\n+\n+public class ClientOptionsImpl implements ClientOptions {\n+\n+  private String host = \"localhost\";\n+  private int port = 8088;\n+  private boolean useTls = false;\n+  private boolean useClientAuth = false;\n+  private boolean useBasicAuth = false;\n+  private String trustStorePath = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NDA4Mw==", "bodyText": "what is this method used for?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416554083", "createdAt": "2020-04-28T11:58:00Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientOptionsImpl.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.ClientOptions;\n+import java.util.Objects;\n+\n+public class ClientOptionsImpl implements ClientOptions {\n+\n+  private String host = \"localhost\";\n+  private int port = 8088;\n+  private boolean useTls = false;\n+  private boolean useClientAuth = false;\n+  private boolean useBasicAuth = false;\n+  private String trustStorePath = \"\";\n+  private String trustStorePassword = \"\";\n+  private String keyStorePath = \"\";\n+  private String keyStorePassword = \"\";\n+  private String basicAuthUsername = \"\";\n+  private String basicAuthPassword = \"\";\n+\n+  public ClientOptionsImpl() {\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n+  private ClientOptionsImpl(\n+      // CHECKSTYLE_RULES.ON: ParameterNumberCheck\n+      final String host, final int port,\n+      final boolean useTls, final boolean useClientAuth, final boolean useBasicAuth,\n+      final String trustStorePath, final String trustStorePassword,\n+      final String keyStorePath, final String keyStorePassword,\n+      final String basicAuthUsername, final String basicAuthPassword) {\n+    this.host = Objects.requireNonNull(host);\n+    this.port = port;\n+    this.useTls = useTls;\n+    this.useClientAuth = useClientAuth;\n+    this.useBasicAuth = useBasicAuth;\n+    this.trustStorePath = Objects.requireNonNull(trustStorePath);\n+    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);\n+    this.keyStorePath = Objects.requireNonNull(keyStorePath);\n+    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);\n+    this.basicAuthUsername = Objects.requireNonNull(basicAuthUsername);\n+    this.basicAuthPassword = Objects.requireNonNull(basicAuthPassword);\n+  }\n+\n+  @Override\n+  public ClientOptions setHost(final String host) {\n+    this.host = Objects.requireNonNull(host);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setPort(final int port) {\n+    this.port = port;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setUseTls(final boolean useTls) {\n+    this.useTls = useTls;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setUseClientAuth(final boolean useClientAuth) {\n+    this.useClientAuth = useClientAuth;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setTrustStore(final String trustStorePath) {\n+    this.trustStorePath = Objects.requireNonNull(trustStorePath);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setTrustStorePassword(final String trustStorePassword) {\n+    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setKeyStore(final String keyStorePath) {\n+    this.keyStorePath = Objects.requireNonNull(keyStorePath);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setKeyStorePassword(final String keyStorePassword) {\n+    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setBasicAuthCredentials(final String username, final String password) {\n+    Objects.requireNonNull(username);\n+    Objects.requireNonNull(password);\n+\n+    this.useBasicAuth = true;\n+    this.basicAuthUsername = username;\n+    this.basicAuthPassword = password;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions unsetBasicAuthCredentials() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjMyNw==", "bodyText": "Most probably shouldn't be synchronized otherwise it will block if polling is occurring at same time.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416556327", "createdAt": "2020-04-28T12:02:04Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BaseSubscriber;\n+import io.vertx.core.Context;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscription;\n+\n+public class PollableSubscriber extends BaseSubscriber<Row> {\n+\n+  private static final int REQUEST_BATCH_SIZE = 100;\n+  // 100ms in ns\n+  private static final long MAX_POLL_NANOS = TimeUnit.MILLISECONDS.toNanos(100);\n+\n+  private final BlockingQueue<Row> queue = new LinkedBlockingQueue<>();\n+  private int tokens;\n+  private Throwable error;\n+  private volatile boolean closed;\n+\n+  public PollableSubscriber(final Context context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  protected void afterSubscribe(final Subscription subscription) {\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  protected void handleValue(final Row row) {\n+    queue.add(row);\n+  }\n+\n+  @Override\n+  protected synchronized void handleError(final Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjQwNA==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416556404", "createdAt": "2020-04-28T12:02:12Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BaseSubscriber;\n+import io.vertx.core.Context;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscription;\n+\n+public class PollableSubscriber extends BaseSubscriber<Row> {\n+\n+  private static final int REQUEST_BATCH_SIZE = 100;\n+  // 100ms in ns\n+  private static final long MAX_POLL_NANOS = TimeUnit.MILLISECONDS.toNanos(100);\n+\n+  private final BlockingQueue<Row> queue = new LinkedBlockingQueue<>();\n+  private int tokens;\n+  private Throwable error;\n+  private volatile boolean closed;\n+\n+  public PollableSubscriber(final Context context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  protected void afterSubscribe(final Subscription subscription) {\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  protected void handleValue(final Row row) {\n+    queue.add(row);\n+  }\n+\n+  @Override\n+  protected synchronized void handleError(final Throwable t) {\n+    System.out.println(\"pollable subscriber encountered error: \" + t);\n+    error = t;\n+  }\n+\n+  @Override\n+  protected synchronized void handleComplete() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NzI0Mw==", "bodyText": "I'd probably not name this PullQueryResponseHandler as pull queries can also be executed via the streaming API, and theoretically you could use this for push queries too.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416557243", "createdAt": "2020-04-28T12:03:49Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PullQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PullQueryResponseHandler extends QueryResponseHandler<List<Row>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODAwMg==", "bodyText": "It might be worth adding a check here to make sure there aren't too many rows. E.g. somewhat might use this with a non terminating push query and it ends up exhausting all memory on the client. Once more than N rows are obtained throw an exception and abort.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416558002", "createdAt": "2020-04-28T12:05:13Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PullQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PullQueryResponseHandler extends QueryResponseHandler<List<Row>> {\n+\n+  private final List<Row> rows;\n+  private List<String> columnNames;\n+  private List<String> columnTypes;\n+\n+  PullQueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<List<Row>> cf) {\n+    super(context, recordParser, cf);\n+    this.rows = new ArrayList<>();\n+  }\n+\n+  @Override\n+  protected void handleMetadata(final QueryResponseMetadata queryResponseMetadata) {\n+    if (queryResponseMetadata.queryId != null && !queryResponseMetadata.queryId.isEmpty()) {\n+      cf.completeExceptionally(\n+          new KsqlRestClientException(\"Expecting pull query but was push query\"));\n+    }\n+\n+    columnNames = queryResponseMetadata.columnNames;\n+    columnTypes = queryResponseMetadata.columnTypes;\n+  }\n+\n+  @Override\n+  protected void handleRow(final Buffer buff) {\n+    final JsonArray values = new JsonArray(buff);\n+    rows.add(new RowImpl(columnNames, columnTypes, values));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODMwOQ==", "bodyText": "Again, naming. This could be used for pull queries too. Maybe StreamingQueryResponseHandler would be better?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416558309", "createdAt": "2020-04-28T12:05:46Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PushQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PushQueryResponseHandler extends QueryResponseHandler<QueryResult> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODk0Nw==", "bodyText": "Maybe a checkContext here just to be sure?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416558947", "createdAt": "2020-04-28T12:06:50Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PushQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PushQueryResponseHandler extends QueryResponseHandler<QueryResult> {\n+\n+  private QueryResultImpl queryResult;\n+  private boolean paused;\n+\n+  PushQueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<QueryResult> cf) {\n+    super(context, recordParser, cf);\n+  }\n+\n+  @Override\n+  protected void handleMetadata(final QueryResponseMetadata queryResponseMetadata) {\n+    if (queryResponseMetadata.queryId == null || queryResponseMetadata.queryId.isEmpty()) {\n+      cf.completeExceptionally(\n+          new KsqlRestClientException(\"Expecting push query but was pull query\"));\n+      return;\n+    }\n+\n+    this.queryResult = new QueryResultImpl(context, queryResponseMetadata.queryId,\n+        Collections.unmodifiableList(queryResponseMetadata.columnNames),\n+        Collections.unmodifiableList(queryResponseMetadata.columnTypes));\n+    cf.complete(queryResult);\n+  }\n+\n+  @Override\n+  protected void handleRow(final Buffer buff) {\n+    if (queryResult == null) {\n+      throw new IllegalStateException(\"handleRow called before metadata processed\");\n+    }\n+\n+    final JsonArray values = new JsonArray(buff);\n+    final Row row = new RowImpl(queryResult.columnNames(), queryResult.columnTypes(), values);\n+    final boolean full = queryResult.accept(row);\n+    if (full && !paused) {\n+      recordParser.pause();\n+      queryResult.drainHandler(this::publisherReceptive);\n+      paused = true;\n+    }\n+  }\n+\n+  @Override\n+  protected void handleBodyEnd() {\n+  }\n+\n+  private void publisherReceptive() {\n+    paused = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MDU2Mg==", "bodyText": "Probably don't want to register this every time. And registering modules on the singleton DatabindCodec object mapper will affect any other user of Vert.x in the same process, so probably don't want to do that.\nI'd suggest we maintain our own static ObjectMapper in the ClientImpl and use that for all encoding/decoding if possible.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416560562", "createdAt": "2020-04-28T12:09:53Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.util.VertxUtils;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.jackson.DatabindCodec;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.concurrent.CompletableFuture;\n+\n+abstract class QueryResponseHandler<T> {\n+\n+  protected final Context context;\n+  protected final RecordParser recordParser;\n+  protected final CompletableFuture<T> cf;\n+  protected boolean hasReadArguments;\n+\n+  QueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<T> cf) {\n+    this.context = context;\n+    this.recordParser = recordParser;\n+    this.cf = cf;\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    checkContext();\n+    if (!hasReadArguments) {\n+      handleArgs(buff);\n+    } else {\n+      handleRow(buff);\n+    }\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    checkContext();\n+    handleBodyEnd();\n+  }\n+\n+  protected abstract void handleBodyEnd();\n+\n+  protected abstract void handleMetadata(final QueryResponseMetadata queryResponseMetadata);\n+\n+  protected abstract void handleRow(final Buffer buff);\n+\n+  private void handleArgs(final Buffer buff) {\n+    hasReadArguments = true;\n+\n+    final QueryResponseMetadata queryResponseMetadata;\n+    final ObjectMapper objectMapper = DatabindCodec.mapper();\n+    objectMapper.registerModule(new GuavaModule());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MjcwNg==", "bodyText": "Probably be better to take the monitor after the check if polling, otherwise if polling, the method won't be executed and the user won't see the exception.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416562706", "createdAt": "2020-04-28T12:13:44Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw==", "bodyText": "Always returns false?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416563557", "createdAt": "2020-04-28T12:15:13Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;\n+    super.subscribe(subscriber);\n+  }\n+\n+  @Override\n+  public Row poll() {\n+    return poll(0, TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public synchronized Row poll(final long timeout, final TimeUnit timeUnit) {\n+    if (subscribing) {\n+      throw new IllegalStateException(\"Cannot poll if subscriber has been set\");\n+    }\n+    if (!polling) {\n+      subscribe(pollableSubscriber);\n+      subscribing = false;\n+      polling = true;\n+    }\n+    try {\n+      return pollableSubscriber.poll(timeout, timeUnit);\n+    } catch (final Throwable t) {\n+      sendError(new Exception(\"Failed to poll\", t));\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean isComplete() {\n+    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NDI5NA==", "bodyText": "valueToIndexMap is always the same for each row in a query result, so it seems inefficient to calculate it every time. Instead we could calculate it once and pass the map into the constructor of RowImpl", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416564294", "createdAt": "2020-04-28T12:16:29Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/RowImpl.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.json.JsonArray;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class RowImpl implements Row {\n+\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final List<Object> values;\n+  private final Map<String, Integer> columnNameToIndex;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RowImpl(\n+      final List<String> columnNames,\n+      final List<String> columnTypes,\n+      final JsonArray values) {\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.values = values.getList();\n+\n+    this.columnNameToIndex = valueToIndexMap(columnNames);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NTYyNw==", "bodyText": "Perhaps use a different method for this, as it's doing something different to creating a WebClient", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416565627", "createdAt": "2020-04-28T12:18:56Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NjI2OQ==", "bodyText": "This line and then one above could be replace with a cf.get() to return the result of the cf synchronously. This makes tests like this a bit easier to follow imho. cf.get() will cause exception to be thrown if it completed exceptionally.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416566269", "createdAt": "2020-04-28T12:20:05Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2Njc4Mw==", "bodyText": "Also cf.get() will block the calling thread until the cf is complete, which is more efficient than polling with assertThatEventually.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416566783", "createdAt": "2020-04-28T12:21:02Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NjI2OQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NzczNQ==", "bodyText": "Wouldn't it be simpler just to fall cf.get() rather than using a latch, and handling everything asynchronously?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416567735", "createdAt": "2020-04-28T12:22:35Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    shouldDeliver(queryResult, DEFAULT_ROWS.size());\n+  }\n+\n+  @Test\n+  public void shouldStreamQuerySync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      final Row row = queryResult.poll();\n+      assertThat(row.values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(row.columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(row.columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromStreamQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.streamQuery(\"bad query\", DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailStreamQueryOnPullQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.streamQuery(DEFAULT_PULL_QUERY),\n+        \"Expecting push query but was pull query\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+    // When\n+    final CompletableFuture<List<Row>> cf = client.executeQuery(DEFAULT_PULL_QUERY);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final List<Row> rows = cf.get();\n+\n+    // Then\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PULL_QUERY));\n+    assertThat(testEndpoints.getLastProperties().getMap(), is(Collections.emptyMap()));\n+\n+    assertThat(rows, hasSize(DEFAULT_ROWS.size()));\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      assertThat(rows.get(i).values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(rows.get(i).columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(rows.get(i).columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+\n+    assertThat(server.getQueryIDs(), hasSize(0));\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromExecuteQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.executeQuery(\"bad query\"),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailExecuteQueryOnPushQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.executeQuery(DEFAULT_PUSH_QUERY),\n+        \"Expecting pull query but was push query\"\n+    );\n+  }\n+\n+  protected Client createJavaClient() {\n+    return new ClientImpl(createJavaClientOptions(), vertx);\n+  }\n+\n+  protected ClientOptions createJavaClientOptions() {\n+    return new ClientOptionsImpl()\n+        .setHost(\"localhost\")\n+        .setPort(server.getListeners().get(0).getPort())\n+        .setUseTls(false);\n+  }\n+\n+  private void verifyPushQueryMetadata(final QueryResult queryResult) {\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PUSH_QUERY));\n+    assertThat(testEndpoints.getLastProperties(), is(BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES));\n+\n+    assertThat(queryResult.columnNames(), is(DEFAULT_COLUMN_NAMES));\n+    assertThat(queryResult.columnTypes(), is(DEFAULT_COLUMN_TYPES));\n+\n+    String queryId = queryResult.queryID();\n+    assertThat(queryId, is(notNullValue()));\n+    assertThat(server.getQueryIDs(), hasSize(1));\n+    assertThat(server.getQueryIDs().contains(new PushQueryId(queryId)), is(true));\n+  }\n+\n+  private void shouldDeliver(final Publisher<Row> publisher, final int numRows) {\n+    TestSubscriber<Row> subscriber = new TestSubscriber<Row>() {\n+      @Override\n+      public synchronized void onSubscribe(final Subscription sub) {\n+        super.onSubscribe(sub);\n+        sub.request(numRows);\n+      }\n+    };\n+    publisher.subscribe(subscriber);\n+    assertThatEventually(subscriber::getValues, hasSize(numRows));\n+    for (int i = 0; i < numRows; i++) {\n+      assertThat(subscriber.getValues().get(i).values(), equalTo(rowWithIndex(i).getList()));\n+    }\n+    assertThat(subscriber.isCompleted(), equalTo(false));\n+    assertThat(subscriber.getError(), is(nullValue()));\n+  }\n+\n+  private void assertErrorWhen(\n+      final Supplier<CompletableFuture<?>> queryRequest,\n+      final String... errorMessages\n+  ) throws Exception {\n+    // Given\n+    CountDownLatch latch = new CountDownLatch(1);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2ODMwOQ==", "bodyText": "This and the rest of the methods should be synchronized as the results will be retrieved from a different thread.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416568309", "createdAt": "2020-04-28T12:23:32Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    shouldDeliver(queryResult, DEFAULT_ROWS.size());\n+  }\n+\n+  @Test\n+  public void shouldStreamQuerySync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      final Row row = queryResult.poll();\n+      assertThat(row.values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(row.columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(row.columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromStreamQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.streamQuery(\"bad query\", DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailStreamQueryOnPullQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.streamQuery(DEFAULT_PULL_QUERY),\n+        \"Expecting push query but was pull query\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+    // When\n+    final CompletableFuture<List<Row>> cf = client.executeQuery(DEFAULT_PULL_QUERY);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final List<Row> rows = cf.get();\n+\n+    // Then\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PULL_QUERY));\n+    assertThat(testEndpoints.getLastProperties().getMap(), is(Collections.emptyMap()));\n+\n+    assertThat(rows, hasSize(DEFAULT_ROWS.size()));\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      assertThat(rows.get(i).values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(rows.get(i).columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(rows.get(i).columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+\n+    assertThat(server.getQueryIDs(), hasSize(0));\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromExecuteQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.executeQuery(\"bad query\"),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailExecuteQueryOnPushQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.executeQuery(DEFAULT_PUSH_QUERY),\n+        \"Expecting pull query but was push query\"\n+    );\n+  }\n+\n+  protected Client createJavaClient() {\n+    return new ClientImpl(createJavaClientOptions(), vertx);\n+  }\n+\n+  protected ClientOptions createJavaClientOptions() {\n+    return new ClientOptionsImpl()\n+        .setHost(\"localhost\")\n+        .setPort(server.getListeners().get(0).getPort())\n+        .setUseTls(false);\n+  }\n+\n+  private void verifyPushQueryMetadata(final QueryResult queryResult) {\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PUSH_QUERY));\n+    assertThat(testEndpoints.getLastProperties(), is(BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES));\n+\n+    assertThat(queryResult.columnNames(), is(DEFAULT_COLUMN_NAMES));\n+    assertThat(queryResult.columnTypes(), is(DEFAULT_COLUMN_TYPES));\n+\n+    String queryId = queryResult.queryID();\n+    assertThat(queryId, is(notNullValue()));\n+    assertThat(server.getQueryIDs(), hasSize(1));\n+    assertThat(server.getQueryIDs().contains(new PushQueryId(queryId)), is(true));\n+  }\n+\n+  private void shouldDeliver(final Publisher<Row> publisher, final int numRows) {\n+    TestSubscriber<Row> subscriber = new TestSubscriber<Row>() {\n+      @Override\n+      public synchronized void onSubscribe(final Subscription sub) {\n+        super.onSubscribe(sub);\n+        sub.request(numRows);\n+      }\n+    };\n+    publisher.subscribe(subscriber);\n+    assertThatEventually(subscriber::getValues, hasSize(numRows));\n+    for (int i = 0; i < numRows; i++) {\n+      assertThat(subscriber.getValues().get(i).values(), equalTo(rowWithIndex(i).getList()));\n+    }\n+    assertThat(subscriber.isCompleted(), equalTo(false));\n+    assertThat(subscriber.getError(), is(nullValue()));\n+  }\n+\n+  private void assertErrorWhen(\n+      final Supplier<CompletableFuture<?>> queryRequest,\n+      final String... errorMessages\n+  ) throws Exception {\n+    // Given\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    // When\n+    final CompletableFuture<?> cf = queryRequest.get()\n+        .exceptionally(error -> {\n+\n+          // Then\n+          assertThat(error, notNullValue());\n+          for (final String msg : errorMessages) {\n+            assertThat(error.getMessage(), containsString(msg));\n+          }\n+\n+          latch.countDown();\n+          return null;\n+        });\n+    awaitLatch(latch, cf);\n+  }\n+\n+  private static void awaitLatch(CountDownLatch latch, CompletableFuture<?> cf) throws Exception {\n+    // Log reason for any failures, else output of failed tests is uninformative\n+    cf.exceptionally(failure -> {\n+      System.out.println(\"Failure reason: \" + failure.getMessage());\n+      return null;\n+    });\n+\n+    awaitLatch(latch);\n+  }\n+\n+  private static void awaitLatch(CountDownLatch latch) throws Exception {\n+    assertThat(latch.await(2000, TimeUnit.MILLISECONDS), is(true));\n+  }\n+\n+  private static class TestSubscriber<T> implements Subscriber<T> {\n+\n+    private Subscription sub;\n+    private boolean completed;\n+    private Throwable error;\n+    private final List<T> values = new ArrayList<>();\n+\n+    public TestSubscriber() {\n+    }\n+\n+    @Override\n+    public synchronized void onSubscribe(final Subscription sub) {\n+      this.sub = sub;\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final T value) {\n+      values.add(value);\n+    }\n+\n+    @Override\n+    public synchronized void onError(final Throwable t) {\n+      this.error = t;\n+    }\n+\n+    @Override\n+    public synchronized void onComplete() {\n+      this.completed = true;\n+    }\n+\n+    public boolean isCompleted() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg==", "bodyText": "Imho I would like to see these kinds of tests conducted using the actual API and no mocks.\nAs you know I'm not a fan of fine grained unit tests and mocks as they can constrain the implementation, and often what you're testing doesn't really correspond to what the system really does thus resulting in bugs slipping through and a false sense of security.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416569806", "createdAt": "2020-04-28T12:25:53Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/QueryResultImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.Context;\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.reactivestreams.Subscriber;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class QueryResultImplTest {\n+\n+  @Mock\n+  private Context context;\n+  @Mock\n+  private Subscriber<Row> subscriber;\n+\n+  private QueryResultImpl queryResult;\n+\n+  @Before\n+  public void setUp() {\n+    queryResult = new QueryResultImpl(context, \"queryId\", Collections.emptyList(), Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void shouldNotSubscribeIfPolling() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3MDk4Ng==", "bodyText": "Again, not a fan of fine grained unit tests. I'd prefer to see the behaviour of a row tested on instance of Row interface returned from the actual API rather than the particular implementation RowImpl. If we later change the implementation these kinds of tests get very brittle and hard to refactor whereas tests that test against the interface don't.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416570986", "createdAt": "2020-04-28T12:27:37Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/RowImplTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.vertx.core.json.JsonArray;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RowImplTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNzg2OTcy", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-401786972", "createdAt": "2020-04-28T12:32:36Z", "commit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a169a04042a9650daf9286706a7deff4bffba9d", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/6a169a04042a9650daf9286706a7deff4bffba9d", "committedDate": "2020-04-28T21:42:48Z", "message": "chore: checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2c2c55911ad6b77697c31d9da6c0726511b8058", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/c2c2c55911ad6b77697c31d9da6c0726511b8058", "committedDate": "2020-04-28T22:49:22Z", "message": "chore: allow push and pull queries via both streaming and exec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec989636d680b75ef8e9f22016781a1c5acb714a", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ec989636d680b75ef8e9f22016781a1c5acb714a", "committedDate": "2020-04-28T23:20:24Z", "message": "chore: feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5771d712958007e1dbbcc5ac613b4c74ea8c02f6", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/5771d712958007e1dbbcc5ac613b4c74ea8c02f6", "committedDate": "2020-04-28T23:20:46Z", "message": "chore: allow nulls in ClientOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02fbc871e20d8493ab574d96ead47348903084f1", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/02fbc871e20d8493ab574d96ead47348903084f1", "committedDate": "2020-04-29T06:25:44Z", "message": "chore: static json mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4f7f413563fcf200c7d989dc3494b7d5943a326", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/d4f7f413563fcf200c7d989dc3494b7d5943a326", "committedDate": "2020-04-29T06:55:39Z", "message": "chore: fix synchronization in PollableSubscriber"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c59fdc456d423088d56fc425189a1deb26d1ac", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/21c59fdc456d423088d56fc425189a1deb26d1ac", "committedDate": "2020-04-29T07:05:32Z", "message": "test: clean up negative tests in ClientTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40e3582db859d97db5dd9d4a49a541bd4a1ce541", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/40e3582db859d97db5dd9d4a49a541bd4a1ce541", "committedDate": "2020-04-29T07:10:42Z", "message": "test: more ClientTest cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13722fe463ba1d19069fd722fb11ba24e9078773", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/13722fe463ba1d19069fd722fb11ba24e9078773", "committedDate": "2020-04-29T07:40:50Z", "message": "chore: creator for ClientOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "553ecf2846c2c938f8b0a3a6afdd4438afec6207", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/553ecf2846c2c938f8b0a3a6afdd4438afec6207", "committedDate": "2020-04-29T07:58:11Z", "message": "chore: don't create basic auth header on each request"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNDI1ODQ5", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-402425849", "createdAt": "2020-04-29T07:36:35Z", "commit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "state": "COMMENTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzozNjozNVrOGNzD8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyMDoxMFrOGN0dOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMTI2NA==", "bodyText": "Had a look. The main dependencies right now are:\n\nQueryResponseMetadata, which is used by QueryResponseHandler in order to deserialize the object\nBufferedPublisher, which is extended by QueryResultImpl\nBaseSubscriber, which is extended by PollableSubscriber\n\nWhat's your recommendation for removing these dependencies? I see the value in not having the client depend on any of the server modules but I also don't think it makes sense to duplicate these classes. What do you think?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417121264", "createdAt": "2020-04-29T07:36:35Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/pom.xml", "diffHunk": "@@ -0,0 +1,89 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright 2020 Confluent Inc.\n+  ~\n+  ~ Licensed under the Confluent Community License (the \"License\"); you may not use\n+  ~ this file except in compliance with the License.  You may obtain a copy of the\n+  ~ License at\n+  ~\n+  ~ http://www.confluent.io/confluent-community-license\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+  ~ WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations under the License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+\n+    <parent>\n+        <groupId>io.confluent.ksql</groupId>\n+        <artifactId>ksqldb-parent</artifactId>\n+        <version>6.0.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>ksqldb-api-client</artifactId>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzNzQwNg=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMTUyMQ==", "bodyText": "Makes sense. I'd actually meant to ask you about this before opening the PR but forgot :) Made the change.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417121521", "createdAt": "2020-04-29T07:37:06Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDQwMQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMTU4MA==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417121580", "createdAt": "2020-04-29T07:37:12Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDUyNQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMzU1OA==", "bodyText": "Good call on the motivation for using the interface method over directly instantiating ClientImpl. I've updated the tests, and also applied the analogous change to ClientOptionsImpl.\nI'm not seeing a way to make the constructor for ClientImpl package private, though. Client.java is in a different package from ClientImpl.java so if Client.java is able to instantiate ClientImpl, then ClientImpl must have a public method for instantiation, whether that's a constructor or a factory method. How do people usually work around this?\n\nI'd also add a version of create that takes a Vertx instance.\n\nDone.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417123558", "createdAt": "2020-04-29T07:41:14Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+\n+  Publisher<InsertAck> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+\n+  void close();\n+\n+  static Client create(ClientOptions clientOptions) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyNTQyNw==", "bodyText": "I'm trying to understand the expected behavior if a user provides HttpClienttOptions: will ClientOptionsImpl update the provided HttpClienttOptions according to the other fields, or will the user-provided HttpClientOptions be used directly?\nThe latter doesn't seem very user-friendly since then the user would be responsible for duplicating the work of ClientImpl in populating HttpClientOptions based on ClientOptions, but the former also seems confusing since the user would have to know which HttpClientOptions properties will be overridden and which won't.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417125427", "createdAt": "2020-04-29T07:44:58Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/ClientOptions.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+public interface ClientOptions {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyNTUwMQ==", "bodyText": "Updated.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417125501", "createdAt": "2020-04-29T07:45:08Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/QueryResult.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * The result of a streaming (push) query. Records may be consumed by either subscribing to the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MDAxNA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyOTgxNw==", "bodyText": "For a struct - we can just return that as a JsonObject.\n\nTo continue an offline discussion: we previously thought it made sense to use vanilla Java types (List, Map) instead of Vert.x types (JsonArray, JsonObject) in the client interfaces so that apps using the client don't need Vert.x as a dependency, but more recently you said maybe it makes sense to use the Vert.x types for better type safety.\nThis still feels strange to me, though. It's one thing to give users the option to provide their own Vert.x instance and/or Vert.x HttpClientOptions, but requiring the use of Vert.x types in order to use the client at all feels odd. IMO it feels fine to expose the fact that the client uses Vert.x under the hood in order to benefit users seeking more advanced use cases, but requiring the use of Vert.x for all client use cases seems unwarranted.\nA third option could be to wrap the Vert.x types but that seems like overkill.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417129817", "createdAt": "2020-04-29T07:53:01Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMjk4Mw==", "bodyText": "Good point! Fixed.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417132983", "createdAt": "2020-04-29T07:58:54Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjI0NQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzA3MQ==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417133071", "createdAt": "2020-04-29T07:59:01Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()\n+        + \":\"\n+        + clientOptions.getBasicAuthPassword();\n+    final String base64creds =\n+        Base64.getEncoder().encodeToString(creds.getBytes(Charset.defaultCharset()));\n+    return request.putHeader(AUTHORIZATION.toString(), \"Basic \" + base64creds);\n+  }\n+\n+  private static void handleRequestException(final Throwable t, final CompletableFuture<?> cf) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjU5MA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNDc1Mg==", "bodyText": "I think you're right, but I'm unsure what the exception handler should do.\nShould we fail the CompletableFuture if it hasn't already been ended? This would require synchronizing the response handler methods, which doesn't seem great.\nWhat if the CompletableFuture has already been completed, as could be the case for streamed queries? Should we close the QueryResult?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417134752", "createdAt": "2020-04-29T08:02:03Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()\n+        + \":\"\n+        + clientOptions.getBasicAuthPassword();\n+    final String base64creds =\n+        Base64.getEncoder().encodeToString(creds.getBytes(Charset.defaultCharset()));\n+    return request.putHeader(AUTHORIZATION.toString(), \"Basic \" + base64creds);\n+  }\n+\n+  private static void handleRequestException(final Throwable t, final CompletableFuture<?> cf) {\n+    cf.completeExceptionally(t);\n+  }\n+\n+  private static <T> void handleResponse(\n+      final HttpClientResponse response,\n+      final CompletableFuture<T> cf,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier) {\n+    if (response.statusCode() == OK.code()) {\n+      final RecordParser recordParser = RecordParser.newDelimited(\"\\n\", response);\n+      final QueryResponseHandler<T> responseHandler =\n+          responseHandlerSupplier.get(Vertx.currentContext(), recordParser, cf);\n+\n+      recordParser.handler(responseHandler::handleBodyBuffer);\n+      recordParser.endHandler(responseHandler::handleBodyEnd);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjkzOA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNTM1MQ==", "bodyText": "My original motivation for avoiding nulls was so the calling code wouldn't need perform null checks, but I've worked around this by updating the getter methods instead. I'm curious to know whether you think this is an improvement or not.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417135351", "createdAt": "2020-04-29T08:03:20Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientOptionsImpl.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.ClientOptions;\n+import java.util.Objects;\n+\n+public class ClientOptionsImpl implements ClientOptions {\n+\n+  private String host = \"localhost\";\n+  private int port = 8088;\n+  private boolean useTls = false;\n+  private boolean useClientAuth = false;\n+  private boolean useBasicAuth = false;\n+  private String trustStorePath = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjIzMw==", "bodyText": "I wanted to provide a way to reset useBasicAuth back to false, but as you've pointed out I don't think this was the best way to do it. I've removed this method and wrapped that functionality into setBasicAuthCredentials() instead.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136233", "createdAt": "2020-04-29T08:05:03Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientOptionsImpl.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.ClientOptions;\n+import java.util.Objects;\n+\n+public class ClientOptionsImpl implements ClientOptions {\n+\n+  private String host = \"localhost\";\n+  private int port = 8088;\n+  private boolean useTls = false;\n+  private boolean useClientAuth = false;\n+  private boolean useBasicAuth = false;\n+  private String trustStorePath = \"\";\n+  private String trustStorePassword = \"\";\n+  private String keyStorePath = \"\";\n+  private String keyStorePassword = \"\";\n+  private String basicAuthUsername = \"\";\n+  private String basicAuthPassword = \"\";\n+\n+  public ClientOptionsImpl() {\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n+  private ClientOptionsImpl(\n+      // CHECKSTYLE_RULES.ON: ParameterNumberCheck\n+      final String host, final int port,\n+      final boolean useTls, final boolean useClientAuth, final boolean useBasicAuth,\n+      final String trustStorePath, final String trustStorePassword,\n+      final String keyStorePath, final String keyStorePassword,\n+      final String basicAuthUsername, final String basicAuthPassword) {\n+    this.host = Objects.requireNonNull(host);\n+    this.port = port;\n+    this.useTls = useTls;\n+    this.useClientAuth = useClientAuth;\n+    this.useBasicAuth = useBasicAuth;\n+    this.trustStorePath = Objects.requireNonNull(trustStorePath);\n+    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);\n+    this.keyStorePath = Objects.requireNonNull(keyStorePath);\n+    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);\n+    this.basicAuthUsername = Objects.requireNonNull(basicAuthUsername);\n+    this.basicAuthPassword = Objects.requireNonNull(basicAuthPassword);\n+  }\n+\n+  @Override\n+  public ClientOptions setHost(final String host) {\n+    this.host = Objects.requireNonNull(host);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setPort(final int port) {\n+    this.port = port;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setUseTls(final boolean useTls) {\n+    this.useTls = useTls;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setUseClientAuth(final boolean useClientAuth) {\n+    this.useClientAuth = useClientAuth;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setTrustStore(final String trustStorePath) {\n+    this.trustStorePath = Objects.requireNonNull(trustStorePath);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setTrustStorePassword(final String trustStorePassword) {\n+    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setKeyStore(final String keyStorePath) {\n+    this.keyStorePath = Objects.requireNonNull(keyStorePath);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setKeyStorePassword(final String keyStorePassword) {\n+    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setBasicAuthCredentials(final String username, final String password) {\n+    Objects.requireNonNull(username);\n+    Objects.requireNonNull(password);\n+\n+    this.useBasicAuth = true;\n+    this.basicAuthUsername = username;\n+    this.basicAuthPassword = password;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions unsetBasicAuthCredentials() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NDA4Mw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjMzNw==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136337", "createdAt": "2020-04-29T08:05:14Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BaseSubscriber;\n+import io.vertx.core.Context;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscription;\n+\n+public class PollableSubscriber extends BaseSubscriber<Row> {\n+\n+  private static final int REQUEST_BATCH_SIZE = 100;\n+  // 100ms in ns\n+  private static final long MAX_POLL_NANOS = TimeUnit.MILLISECONDS.toNanos(100);\n+\n+  private final BlockingQueue<Row> queue = new LinkedBlockingQueue<>();\n+  private int tokens;\n+  private Throwable error;\n+  private volatile boolean closed;\n+\n+  public PollableSubscriber(final Context context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  protected void afterSubscribe(final Subscription subscription) {\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  protected void handleValue(final Row row) {\n+    queue.add(row);\n+  }\n+\n+  @Override\n+  protected synchronized void handleError(final Throwable t) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjMyNw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjM2Ng==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136366", "createdAt": "2020-04-29T08:05:18Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BaseSubscriber;\n+import io.vertx.core.Context;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscription;\n+\n+public class PollableSubscriber extends BaseSubscriber<Row> {\n+\n+  private static final int REQUEST_BATCH_SIZE = 100;\n+  // 100ms in ns\n+  private static final long MAX_POLL_NANOS = TimeUnit.MILLISECONDS.toNanos(100);\n+\n+  private final BlockingQueue<Row> queue = new LinkedBlockingQueue<>();\n+  private int tokens;\n+  private Throwable error;\n+  private volatile boolean closed;\n+\n+  public PollableSubscriber(final Context context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  protected void afterSubscribe(final Subscription subscription) {\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  protected void handleValue(final Row row) {\n+    queue.add(row);\n+  }\n+\n+  @Override\n+  protected synchronized void handleError(final Throwable t) {\n+    System.out.println(\"pollable subscriber encountered error: \" + t);\n+    error = t;\n+  }\n+\n+  @Override\n+  protected synchronized void handleComplete() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjQwNA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjcwMw==", "bodyText": "Renamed to ExecuteQueryResponseHandler, for consistency with the methods in the Client interface.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136703", "createdAt": "2020-04-29T08:05:58Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PullQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PullQueryResponseHandler extends QueryResponseHandler<List<Row>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NzI0Mw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzQ1NQ==", "bodyText": "What do you think is a reasonable limit? 1000? I guess we could also make this configurable via the client options.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417137455", "createdAt": "2020-04-29T08:07:21Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PullQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PullQueryResponseHandler extends QueryResponseHandler<List<Row>> {\n+\n+  private final List<Row> rows;\n+  private List<String> columnNames;\n+  private List<String> columnTypes;\n+\n+  PullQueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<List<Row>> cf) {\n+    super(context, recordParser, cf);\n+    this.rows = new ArrayList<>();\n+  }\n+\n+  @Override\n+  protected void handleMetadata(final QueryResponseMetadata queryResponseMetadata) {\n+    if (queryResponseMetadata.queryId != null && !queryResponseMetadata.queryId.isEmpty()) {\n+      cf.completeExceptionally(\n+          new KsqlRestClientException(\"Expecting pull query but was push query\"));\n+    }\n+\n+    columnNames = queryResponseMetadata.columnNames;\n+    columnTypes = queryResponseMetadata.columnTypes;\n+  }\n+\n+  @Override\n+  protected void handleRow(final Buffer buff) {\n+    final JsonArray values = new JsonArray(buff);\n+    rows.add(new RowImpl(columnNames, columnTypes, values));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODAwMg=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzk1NA==", "bodyText": "Renamed to StreamQueryResponseHandler, for consistency with the methods in the Client interface.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417137954", "createdAt": "2020-04-29T08:08:17Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PushQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PushQueryResponseHandler extends QueryResponseHandler<QueryResult> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODMwOQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzODQ5Mw==", "bodyText": "Added. I don't fully understand what the purpose of these context checks is, though. (I've seen them throughout the server code as well but haven't fully wrapped my head around them.) What exactly are we trying to prevent?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417138493", "createdAt": "2020-04-29T08:09:11Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PushQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PushQueryResponseHandler extends QueryResponseHandler<QueryResult> {\n+\n+  private QueryResultImpl queryResult;\n+  private boolean paused;\n+\n+  PushQueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<QueryResult> cf) {\n+    super(context, recordParser, cf);\n+  }\n+\n+  @Override\n+  protected void handleMetadata(final QueryResponseMetadata queryResponseMetadata) {\n+    if (queryResponseMetadata.queryId == null || queryResponseMetadata.queryId.isEmpty()) {\n+      cf.completeExceptionally(\n+          new KsqlRestClientException(\"Expecting push query but was pull query\"));\n+      return;\n+    }\n+\n+    this.queryResult = new QueryResultImpl(context, queryResponseMetadata.queryId,\n+        Collections.unmodifiableList(queryResponseMetadata.columnNames),\n+        Collections.unmodifiableList(queryResponseMetadata.columnTypes));\n+    cf.complete(queryResult);\n+  }\n+\n+  @Override\n+  protected void handleRow(final Buffer buff) {\n+    if (queryResult == null) {\n+      throw new IllegalStateException(\"handleRow called before metadata processed\");\n+    }\n+\n+    final JsonArray values = new JsonArray(buff);\n+    final Row row = new RowImpl(queryResult.columnNames(), queryResult.columnTypes(), values);\n+    final boolean full = queryResult.accept(row);\n+    if (full && !paused) {\n+      recordParser.pause();\n+      queryResult.drainHandler(this::publisherReceptive);\n+      paused = true;\n+    }\n+  }\n+\n+  @Override\n+  protected void handleBodyEnd() {\n+  }\n+\n+  private void publisherReceptive() {\n+    paused = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODk0Nw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzOTAyOQ==", "bodyText": "Done, though I've put the static ObjectMapper into a separate utility (JsonMapper) rather than in ClientImpl.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417139029", "createdAt": "2020-04-29T08:10:11Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.util.VertxUtils;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.jackson.DatabindCodec;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.concurrent.CompletableFuture;\n+\n+abstract class QueryResponseHandler<T> {\n+\n+  protected final Context context;\n+  protected final RecordParser recordParser;\n+  protected final CompletableFuture<T> cf;\n+  protected boolean hasReadArguments;\n+\n+  QueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<T> cf) {\n+    this.context = context;\n+    this.recordParser = recordParser;\n+    this.cf = cf;\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    checkContext();\n+    if (!hasReadArguments) {\n+      handleArgs(buff);\n+    } else {\n+      handleRow(buff);\n+    }\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    checkContext();\n+    handleBodyEnd();\n+  }\n+\n+  protected abstract void handleBodyEnd();\n+\n+  protected abstract void handleMetadata(final QueryResponseMetadata queryResponseMetadata);\n+\n+  protected abstract void handleRow(final Buffer buff);\n+\n+  private void handleArgs(final Buffer buff) {\n+    hasReadArguments = true;\n+\n+    final QueryResponseMetadata queryResponseMetadata;\n+    final ObjectMapper objectMapper = DatabindCodec.mapper();\n+    objectMapper.registerModule(new GuavaModule());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MDU2Mg=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzOTQ4Nw==", "bodyText": "Sorry, I'm failing to grok this comment. What does \"the monitor\" refer to?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417139487", "createdAt": "2020-04-29T08:11:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MjcwNg=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MDk3MQ==", "bodyText": "Whoops! Forgot to implement this -- thanks for the catch.\nNow that I think about it, though, I'm unclear on what the desired behavior is. Does \"complete\" mean that the underlying connection is closed, or that all rows have been read? I see that for BufferedPublisher \"complete\" means the former, as it's possible for the BufferedPublisher to be \"complete\" even if there are buffered rows that have yet to be read, but this seems a little counterintuitive.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417140971", "createdAt": "2020-04-29T08:13:59Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;\n+    super.subscribe(subscriber);\n+  }\n+\n+  @Override\n+  public Row poll() {\n+    return poll(0, TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public synchronized Row poll(final long timeout, final TimeUnit timeUnit) {\n+    if (subscribing) {\n+      throw new IllegalStateException(\"Cannot poll if subscriber has been set\");\n+    }\n+    if (!polling) {\n+      subscribe(pollableSubscriber);\n+      subscribing = false;\n+      polling = true;\n+    }\n+    try {\n+      return pollableSubscriber.poll(timeout, timeUnit);\n+    } catch (final Throwable t) {\n+      sendError(new Exception(\"Failed to poll\", t));\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean isComplete() {\n+    return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTA4OA==", "bodyText": "Done. Good point!", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417141088", "createdAt": "2020-04-29T08:14:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/RowImpl.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.json.JsonArray;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class RowImpl implements Row {\n+\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final List<Object> values;\n+  private final Map<String, Integer> columnNameToIndex;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RowImpl(\n+      final List<String> columnNames,\n+      final List<String> columnTypes,\n+      final JsonArray values) {\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.values = values.getList();\n+\n+    this.columnNameToIndex = valueToIndexMap(columnNames);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NDI5NA=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTE3OQ==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417141179", "createdAt": "2020-04-29T08:14:28Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NTYyNw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTQwMQ==", "bodyText": "Much cleaner, thanks for the suggestion! Made the changes.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417141401", "createdAt": "2020-04-29T08:14:55Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NjI2OQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjA1Mw==", "bodyText": "Updated. I do think this is cleaner, though it's a bit odd that the expected exception type is always ExecutionException since that's what's thrown when .get() is called on a future that completes exceptionally. Added comments inline to avoid confusion.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417142053", "createdAt": "2020-04-29T08:16:16Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    shouldDeliver(queryResult, DEFAULT_ROWS.size());\n+  }\n+\n+  @Test\n+  public void shouldStreamQuerySync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      final Row row = queryResult.poll();\n+      assertThat(row.values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(row.columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(row.columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromStreamQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.streamQuery(\"bad query\", DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailStreamQueryOnPullQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.streamQuery(DEFAULT_PULL_QUERY),\n+        \"Expecting push query but was pull query\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+    // When\n+    final CompletableFuture<List<Row>> cf = client.executeQuery(DEFAULT_PULL_QUERY);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final List<Row> rows = cf.get();\n+\n+    // Then\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PULL_QUERY));\n+    assertThat(testEndpoints.getLastProperties().getMap(), is(Collections.emptyMap()));\n+\n+    assertThat(rows, hasSize(DEFAULT_ROWS.size()));\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      assertThat(rows.get(i).values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(rows.get(i).columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(rows.get(i).columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+\n+    assertThat(server.getQueryIDs(), hasSize(0));\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromExecuteQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.executeQuery(\"bad query\"),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailExecuteQueryOnPushQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.executeQuery(DEFAULT_PUSH_QUERY),\n+        \"Expecting pull query but was push query\"\n+    );\n+  }\n+\n+  protected Client createJavaClient() {\n+    return new ClientImpl(createJavaClientOptions(), vertx);\n+  }\n+\n+  protected ClientOptions createJavaClientOptions() {\n+    return new ClientOptionsImpl()\n+        .setHost(\"localhost\")\n+        .setPort(server.getListeners().get(0).getPort())\n+        .setUseTls(false);\n+  }\n+\n+  private void verifyPushQueryMetadata(final QueryResult queryResult) {\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PUSH_QUERY));\n+    assertThat(testEndpoints.getLastProperties(), is(BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES));\n+\n+    assertThat(queryResult.columnNames(), is(DEFAULT_COLUMN_NAMES));\n+    assertThat(queryResult.columnTypes(), is(DEFAULT_COLUMN_TYPES));\n+\n+    String queryId = queryResult.queryID();\n+    assertThat(queryId, is(notNullValue()));\n+    assertThat(server.getQueryIDs(), hasSize(1));\n+    assertThat(server.getQueryIDs().contains(new PushQueryId(queryId)), is(true));\n+  }\n+\n+  private void shouldDeliver(final Publisher<Row> publisher, final int numRows) {\n+    TestSubscriber<Row> subscriber = new TestSubscriber<Row>() {\n+      @Override\n+      public synchronized void onSubscribe(final Subscription sub) {\n+        super.onSubscribe(sub);\n+        sub.request(numRows);\n+      }\n+    };\n+    publisher.subscribe(subscriber);\n+    assertThatEventually(subscriber::getValues, hasSize(numRows));\n+    for (int i = 0; i < numRows; i++) {\n+      assertThat(subscriber.getValues().get(i).values(), equalTo(rowWithIndex(i).getList()));\n+    }\n+    assertThat(subscriber.isCompleted(), equalTo(false));\n+    assertThat(subscriber.getError(), is(nullValue()));\n+  }\n+\n+  private void assertErrorWhen(\n+      final Supplier<CompletableFuture<?>> queryRequest,\n+      final String... errorMessages\n+  ) throws Exception {\n+    // Given\n+    CountDownLatch latch = new CountDownLatch(1);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NzczNQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjEyOA==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417142128", "createdAt": "2020-04-29T08:16:25Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    shouldDeliver(queryResult, DEFAULT_ROWS.size());\n+  }\n+\n+  @Test\n+  public void shouldStreamQuerySync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      final Row row = queryResult.poll();\n+      assertThat(row.values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(row.columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(row.columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromStreamQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.streamQuery(\"bad query\", DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailStreamQueryOnPullQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.streamQuery(DEFAULT_PULL_QUERY),\n+        \"Expecting push query but was pull query\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+    // When\n+    final CompletableFuture<List<Row>> cf = client.executeQuery(DEFAULT_PULL_QUERY);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final List<Row> rows = cf.get();\n+\n+    // Then\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PULL_QUERY));\n+    assertThat(testEndpoints.getLastProperties().getMap(), is(Collections.emptyMap()));\n+\n+    assertThat(rows, hasSize(DEFAULT_ROWS.size()));\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      assertThat(rows.get(i).values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(rows.get(i).columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(rows.get(i).columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+\n+    assertThat(server.getQueryIDs(), hasSize(0));\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromExecuteQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.executeQuery(\"bad query\"),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailExecuteQueryOnPushQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.executeQuery(DEFAULT_PUSH_QUERY),\n+        \"Expecting pull query but was push query\"\n+    );\n+  }\n+\n+  protected Client createJavaClient() {\n+    return new ClientImpl(createJavaClientOptions(), vertx);\n+  }\n+\n+  protected ClientOptions createJavaClientOptions() {\n+    return new ClientOptionsImpl()\n+        .setHost(\"localhost\")\n+        .setPort(server.getListeners().get(0).getPort())\n+        .setUseTls(false);\n+  }\n+\n+  private void verifyPushQueryMetadata(final QueryResult queryResult) {\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PUSH_QUERY));\n+    assertThat(testEndpoints.getLastProperties(), is(BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES));\n+\n+    assertThat(queryResult.columnNames(), is(DEFAULT_COLUMN_NAMES));\n+    assertThat(queryResult.columnTypes(), is(DEFAULT_COLUMN_TYPES));\n+\n+    String queryId = queryResult.queryID();\n+    assertThat(queryId, is(notNullValue()));\n+    assertThat(server.getQueryIDs(), hasSize(1));\n+    assertThat(server.getQueryIDs().contains(new PushQueryId(queryId)), is(true));\n+  }\n+\n+  private void shouldDeliver(final Publisher<Row> publisher, final int numRows) {\n+    TestSubscriber<Row> subscriber = new TestSubscriber<Row>() {\n+      @Override\n+      public synchronized void onSubscribe(final Subscription sub) {\n+        super.onSubscribe(sub);\n+        sub.request(numRows);\n+      }\n+    };\n+    publisher.subscribe(subscriber);\n+    assertThatEventually(subscriber::getValues, hasSize(numRows));\n+    for (int i = 0; i < numRows; i++) {\n+      assertThat(subscriber.getValues().get(i).values(), equalTo(rowWithIndex(i).getList()));\n+    }\n+    assertThat(subscriber.isCompleted(), equalTo(false));\n+    assertThat(subscriber.getError(), is(nullValue()));\n+  }\n+\n+  private void assertErrorWhen(\n+      final Supplier<CompletableFuture<?>> queryRequest,\n+      final String... errorMessages\n+  ) throws Exception {\n+    // Given\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    // When\n+    final CompletableFuture<?> cf = queryRequest.get()\n+        .exceptionally(error -> {\n+\n+          // Then\n+          assertThat(error, notNullValue());\n+          for (final String msg : errorMessages) {\n+            assertThat(error.getMessage(), containsString(msg));\n+          }\n+\n+          latch.countDown();\n+          return null;\n+        });\n+    awaitLatch(latch, cf);\n+  }\n+\n+  private static void awaitLatch(CountDownLatch latch, CompletableFuture<?> cf) throws Exception {\n+    // Log reason for any failures, else output of failed tests is uninformative\n+    cf.exceptionally(failure -> {\n+      System.out.println(\"Failure reason: \" + failure.getMessage());\n+      return null;\n+    });\n+\n+    awaitLatch(latch);\n+  }\n+\n+  private static void awaitLatch(CountDownLatch latch) throws Exception {\n+    assertThat(latch.await(2000, TimeUnit.MILLISECONDS), is(true));\n+  }\n+\n+  private static class TestSubscriber<T> implements Subscriber<T> {\n+\n+    private Subscription sub;\n+    private boolean completed;\n+    private Throwable error;\n+    private final List<T> values = new ArrayList<>();\n+\n+    public TestSubscriber() {\n+    }\n+\n+    @Override\n+    public synchronized void onSubscribe(final Subscription sub) {\n+      this.sub = sub;\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final T value) {\n+      values.add(value);\n+    }\n+\n+    @Override\n+    public synchronized void onError(final Throwable t) {\n+      this.error = t;\n+    }\n+\n+    @Override\n+    public synchronized void onComplete() {\n+      this.completed = true;\n+    }\n+\n+    public boolean isCompleted() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2ODMwOQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NDA1MA==", "bodyText": "Sure, I'll add equivalent tests to ClientTest as part of revamping / improving test coverage. My vote is to leave these unit tests in place, though, until we see them become brittle. I think it's useful to be able to scan a test file and understand the key pieces of functionality for a class without having to dig through integration tests. Though I guess Java docs on the class/interface itself should serve this purpose in most cases, so maybe that's not a good reason...", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417144050", "createdAt": "2020-04-29T08:20:01Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/QueryResultImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.Context;\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.reactivestreams.Subscriber;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class QueryResultImplTest {\n+\n+  @Mock\n+  private Context context;\n+  @Mock\n+  private Subscriber<Row> subscriber;\n+\n+  private QueryResultImpl queryResult;\n+\n+  @Before\n+  public void setUp() {\n+    queryResult = new QueryResultImpl(context, \"queryId\", Collections.emptyList(), Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void shouldNotSubscribeIfPolling() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NDEyMA==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417144120", "createdAt": "2020-04-29T08:20:10Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/RowImplTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.vertx.core.json.JsonArray;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RowImplTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3MDk4Ng=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c58782c7180fc30987d72cca62aa2195a82737aa", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/c58782c7180fc30987d72cca62aa2195a82737aa", "committedDate": "2020-05-03T20:28:56Z", "message": "fix: basic auth"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1073dbbdbd9557cb04c488ffa89aac4eb542df6e", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/1073dbbdbd9557cb04c488ffa89aac4eb542df6e", "committedDate": "2020-05-04T06:36:41Z", "message": "chore: handle record parser exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f990c9346bc00f934c88fee56e7965121a8f791", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/0f990c9346bc00f934c88fee56e7965121a8f791", "committedDate": "2020-05-04T07:05:42Z", "message": "fix: synchronization in QueryResultImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "904476714df0a29fc17e6cf8ebf38f3e898105f8", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/904476714df0a29fc17e6cf8ebf38f3e898105f8", "committedDate": "2020-05-09T00:13:33Z", "message": "feat: tls tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ad66e85a9aa2ba6f4b00e9f87625b7b164860e7", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/8ad66e85a9aa2ba6f4b00e9f87625b7b164860e7", "committedDate": "2020-05-09T00:13:33Z", "message": "chore: checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dff2ffbf0b715d722df53f148e9cad7d9c17aca5", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/dff2ffbf0b715d722df53f148e9cad7d9c17aca5", "committedDate": "2020-05-09T00:13:33Z", "message": "fix: implement isComplete() on QueryResult"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ac08f6a52421c86b838d5d5488ef87f32240d7b", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/1ac08f6a52421c86b838d5d5488ef87f32240d7b", "committedDate": "2020-05-09T00:28:58Z", "message": "chore: limit number of rows that may be returned from executeQuery()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTkzMTE2", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-408593116", "createdAt": "2020-05-09T00:42:50Z", "commit": {"oid": "0f990c9346bc00f934c88fee56e7965121a8f791"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDo0Mjo1MFrOGS3OfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDo1MzoxN1rOGS3Tww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMjM4MA==", "bodyText": "As discussed in KLIP-26, I plan to introduce types that wrap the Vert.x types. Stand by for a follow-up PR with this change.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422432380", "createdAt": "2020-05-09T00:42:50Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzU5MA==", "bodyText": "Update: going to add these additional tests in a follow-up PR.\n\nAnd as long as you won't be upset if I end up deleting them after spending an hour trying to refactor them if the implementation changes ;)\n\nFine by me ;)", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422433590", "createdAt": "2020-05-09T00:52:10Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/QueryResultImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.Context;\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.reactivestreams.Subscriber;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class QueryResultImplTest {\n+\n+  @Mock\n+  private Context context;\n+  @Mock\n+  private Subscriber<Row> subscriber;\n+\n+  private QueryResultImpl queryResult;\n+\n+  @Before\n+  public void setUp() {\n+    queryResult = new QueryResultImpl(context, \"queryId\", Collections.emptyList(), Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void shouldNotSubscribeIfPolling() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzczMQ==", "bodyText": "Got'cha. I've renamed a couple internal variables in BufferedPublisher to better reflect this. Thanks for the clarification!", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422433731", "createdAt": "2020-05-09T00:53:17Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;\n+    super.subscribe(subscriber);\n+  }\n+\n+  @Override\n+  public Row poll() {\n+    return poll(0, TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public synchronized Row poll(final long timeout, final TimeUnit timeUnit) {\n+    if (subscribing) {\n+      throw new IllegalStateException(\"Cannot poll if subscriber has been set\");\n+    }\n+    if (!polling) {\n+      subscribe(pollableSubscriber);\n+      subscribing = false;\n+      polling = true;\n+    }\n+    try {\n+      return pollableSubscriber.poll(timeout, timeUnit);\n+    } catch (final Throwable t) {\n+      sendError(new Exception(\"Failed to poll\", t));\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean isComplete() {\n+    return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw=="}, "originalCommit": {"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTk1NTI0", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-408595524", "createdAt": "2020-05-09T01:01:32Z", "commit": {"oid": "1ac08f6a52421c86b838d5d5488ef87f32240d7b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMTowMTozM1rOGS3YCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMTowMTozM1rOGS3YCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzNDgyNg==", "bodyText": "These additional TLS options were needed to get the tests working. In a follow-up PR they'll either be removed in favor of exposing Vert.x HttpClientOptions (pending discussion in #5200 (comment)) or I'll refactor all the TLS options into a separate interface in order to clean up this one.", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422434826", "createdAt": "2020-05-09T01:01:33Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/ClientOptions.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setVerifyHost(boolean verifyHost);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ac08f6a52421c86b838d5d5488ef87f32240d7b"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbdfcec226ac806a5b112353e85ecc7fb3445b5c", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/dbdfcec226ac806a5b112353e85ecc7fb3445b5c", "committedDate": "2020-05-09T04:31:23Z", "message": "Merge branch 'master' into java-client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb5ac44de13c569fd327bcc6731f56ec30d2d7eb", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/bb5ac44de13c569fd327bcc6731f56ec30d2d7eb", "committedDate": "2020-05-09T05:48:40Z", "message": "chore: findbugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Nzc5MzYw", "url": "https://github.com/confluentinc/ksql/pull/5200#pullrequestreview-408779360", "createdAt": "2020-05-10T20:34:23Z", "commit": {"oid": "bb5ac44de13c569fd327bcc6731f56ec30d2d7eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMDozNDoyM1rOGTHXSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMDozNDoyM1rOGTHXSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY5Njc3OA==", "bodyText": "@vcrfxia As mentioned on the KLIP: why do we not use Duration instead?", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422696778", "createdAt": "2020-05-10T20:34:23Z", "author": {"login": "mjsax"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/QueryResult.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb5ac44de13c569fd327bcc6731f56ec30d2d7eb"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4801, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}