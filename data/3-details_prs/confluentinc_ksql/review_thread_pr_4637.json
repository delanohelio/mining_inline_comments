{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMjU0MjQz", "number": 4637, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxMTo1MFrODjPhmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNjo1MFrODjPo9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjgxMTE1OnYy", "diffSide": "RIGHT", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxMTo1MFrOFu8XoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMToxMjo1NVrOFvOTfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzkwNQ==", "bodyText": "let's javadoc this? hypothetically it could be useful in the future for pluggable schemas to leverage this class", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r384767905", "createdAt": "2020-02-26T21:11:50Z", "author": {"login": "agavra"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2MTc1OA==", "bodyText": "added", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r385061758", "createdAt": "2020-02-27T11:12:55Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzkwNQ=="}, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjgxODQzOnYy", "diffSide": "RIGHT", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNDoxNVrOFu8cAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMToxMzozNlrOFvOU1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTAyNw==", "bodyText": "nit: @Override here and below", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r384769027", "createdAt": "2020-02-26T21:14:15Z", "author": {"login": "agavra"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonFormat.java", "diffHunk": "@@ -18,43 +18,32 @@\n import io.confluent.connect.json.JsonSchemaData;\n import io.confluent.kafka.schemaregistry.ParsedSchema;\n import io.confluent.kafka.schemaregistry.json.JsonSchema;\n-import io.confluent.ksql.serde.Format;\n import io.confluent.ksql.serde.FormatInfo;\n import io.confluent.ksql.serde.KsqlSerdeFactory;\n+import io.confluent.ksql.serde.connect.ConnectFormat;\n import org.apache.kafka.connect.data.Schema;\n \n-public class JsonFormat implements Format {\n+public class JsonFormat extends ConnectFormat {\n \n   public static final String NAME = JsonSchema.TYPE;\n \n-  private JsonSchemaData jsonData;\n-\n-  public JsonFormat() {\n-    this.jsonData = new JsonSchemaData();\n-  }\n+  private final JsonSchemaData jsonData = new JsonSchemaData();\n \n   @Override\n   public String name() {\n     return NAME;\n   }\n \n   @Override\n-  public boolean supportsSchemaInference() {\n-    return true;\n+  public KsqlSerdeFactory getSerdeFactory(final FormatInfo info) {\n+    return new KsqlJsonSerdeFactory();\n   }\n \n-  @Override\n-  public Schema toConnectSchema(final ParsedSchema schema) {\n+  protected Schema toConnectSchema(final ParsedSchema schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2MjEwMg==", "bodyText": "added", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r385062102", "createdAt": "2020-02-27T11:13:36Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonFormat.java", "diffHunk": "@@ -18,43 +18,32 @@\n import io.confluent.connect.json.JsonSchemaData;\n import io.confluent.kafka.schemaregistry.ParsedSchema;\n import io.confluent.kafka.schemaregistry.json.JsonSchema;\n-import io.confluent.ksql.serde.Format;\n import io.confluent.ksql.serde.FormatInfo;\n import io.confluent.ksql.serde.KsqlSerdeFactory;\n+import io.confluent.ksql.serde.connect.ConnectFormat;\n import org.apache.kafka.connect.data.Schema;\n \n-public class JsonFormat implements Format {\n+public class JsonFormat extends ConnectFormat {\n \n   public static final String NAME = JsonSchema.TYPE;\n \n-  private JsonSchemaData jsonData;\n-\n-  public JsonFormat() {\n-    this.jsonData = new JsonSchemaData();\n-  }\n+  private final JsonSchemaData jsonData = new JsonSchemaData();\n \n   @Override\n   public String name() {\n     return NAME;\n   }\n \n   @Override\n-  public boolean supportsSchemaInference() {\n-    return true;\n+  public KsqlSerdeFactory getSerdeFactory(final FormatInfo info) {\n+    return new KsqlJsonSerdeFactory();\n   }\n \n-  @Override\n-  public Schema toConnectSchema(final ParsedSchema schema) {\n+  protected Schema toConnectSchema(final ParsedSchema schema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTAyNw=="}, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjgyMjc2OnYy", "diffSide": "RIGHT", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNToxNVrOFu8ejg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMzoxMDoxMVrOFvRkOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTY3OA==", "bodyText": "this seems like it doesn't belong in prod code?", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r384769678", "createdAt": "2020-02-26T21:15:15Z", "author": {"login": "agavra"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {\n+\n+  private final Function<Schema, Schema> toKsqlTransformer;\n+\n+  public ConnectFormat() {\n+    this(new ConnectSchemaTranslator()::toKsqlSchema);\n+  }\n+\n+  @VisibleForTesting\n+  ConnectFormat(final Function<Schema, Schema> toKsqlTransformer) {\n+    this.toKsqlTransformer = Objects.requireNonNull(toKsqlTransformer, \"toKsqlTransformer\");\n+  }\n+\n+  @Override\n+  public boolean supportsSchemaInference() {\n+    return true;\n+  }\n+\n+  @Override\n+  public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n+    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+\n+    return connectSchema.fields().stream()\n+        .map(ConnectFormat::toColumn)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public ParsedSchema toParsedSchema(final List<SimpleColumn> columns) {\n+    final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n+    columns.forEach(col -> schemaBuilder.field(\n+        col.ref().name(),\n+        SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n+    );\n+\n+    final Schema connectSchema = ensureNamed(schemaBuilder.build());\n+    return fromConnectSchema(connectSchema);\n+  }\n+\n+  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+\n+  protected abstract ParsedSchema fromConnectSchema(Schema schema);\n+\n+  private static SimpleColumn toColumn(final Field field) {\n+    final ColumnName name = ColumnName.of(field.name());\n+    final SqlType type = SchemaConverters.connectToSqlConverter().toSqlType(field.schema());\n+    return new ConnectColumn(name, type);\n+  }\n+\n+  private static Schema ensureNamed(final Schema schema) {\n+    final SchemaBuilder builder;\n+    switch (schema.type()) {\n+      case BYTES:\n+        DecimalUtil.requireDecimal(schema);\n+        builder = DecimalUtil.builder(schema);\n+        break;\n+      case ARRAY:\n+        builder = SchemaBuilder.array(ensureNamed(schema.valueSchema()));\n+        break;\n+      case MAP:\n+        builder = SchemaBuilder.map(\n+            Schema.STRING_SCHEMA,\n+            ensureNamed(schema.valueSchema())\n+        );\n+        break;\n+      case STRUCT:\n+        builder = SchemaBuilder.struct();\n+        if (schema.name() == null) {\n+          builder.name(\"TestSchema\" + UUID.randomUUID().toString().replace(\"-\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2MzY1NQ==", "bodyText": "I agree. However, I've not added it, only moved it.  It was in TestCaseBuilderUtil.addNames().\nIt's a bit of a pain, because KSQL types don't support naming, only Connect Schemas do. However, some formats, (PB & Avro), require structs to be named.\nThis method is only called by the testing framework. Admittedly, moving this here was a bit lazy of me. Let me take a look into doing it a better way.", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r385063655", "createdAt": "2020-02-27T11:16:48Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {\n+\n+  private final Function<Schema, Schema> toKsqlTransformer;\n+\n+  public ConnectFormat() {\n+    this(new ConnectSchemaTranslator()::toKsqlSchema);\n+  }\n+\n+  @VisibleForTesting\n+  ConnectFormat(final Function<Schema, Schema> toKsqlTransformer) {\n+    this.toKsqlTransformer = Objects.requireNonNull(toKsqlTransformer, \"toKsqlTransformer\");\n+  }\n+\n+  @Override\n+  public boolean supportsSchemaInference() {\n+    return true;\n+  }\n+\n+  @Override\n+  public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n+    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+\n+    return connectSchema.fields().stream()\n+        .map(ConnectFormat::toColumn)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public ParsedSchema toParsedSchema(final List<SimpleColumn> columns) {\n+    final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n+    columns.forEach(col -> schemaBuilder.field(\n+        col.ref().name(),\n+        SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n+    );\n+\n+    final Schema connectSchema = ensureNamed(schemaBuilder.build());\n+    return fromConnectSchema(connectSchema);\n+  }\n+\n+  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+\n+  protected abstract ParsedSchema fromConnectSchema(Schema schema);\n+\n+  private static SimpleColumn toColumn(final Field field) {\n+    final ColumnName name = ColumnName.of(field.name());\n+    final SqlType type = SchemaConverters.connectToSqlConverter().toSqlType(field.schema());\n+    return new ConnectColumn(name, type);\n+  }\n+\n+  private static Schema ensureNamed(final Schema schema) {\n+    final SchemaBuilder builder;\n+    switch (schema.type()) {\n+      case BYTES:\n+        DecimalUtil.requireDecimal(schema);\n+        builder = DecimalUtil.builder(schema);\n+        break;\n+      case ARRAY:\n+        builder = SchemaBuilder.array(ensureNamed(schema.valueSchema()));\n+        break;\n+      case MAP:\n+        builder = SchemaBuilder.map(\n+            Schema.STRING_SCHEMA,\n+            ensureNamed(schema.valueSchema())\n+        );\n+        break;\n+      case STRUCT:\n+        builder = SchemaBuilder.struct();\n+        if (schema.name() == null) {\n+          builder.name(\"TestSchema\" + UUID.randomUUID().toString().replace(\"-\", \"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTY3OA=="}, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExNTE5Mg==", "bodyText": "Found a way to remove this.", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r385115192", "createdAt": "2020-02-27T13:10:11Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {\n+\n+  private final Function<Schema, Schema> toKsqlTransformer;\n+\n+  public ConnectFormat() {\n+    this(new ConnectSchemaTranslator()::toKsqlSchema);\n+  }\n+\n+  @VisibleForTesting\n+  ConnectFormat(final Function<Schema, Schema> toKsqlTransformer) {\n+    this.toKsqlTransformer = Objects.requireNonNull(toKsqlTransformer, \"toKsqlTransformer\");\n+  }\n+\n+  @Override\n+  public boolean supportsSchemaInference() {\n+    return true;\n+  }\n+\n+  @Override\n+  public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n+    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+\n+    return connectSchema.fields().stream()\n+        .map(ConnectFormat::toColumn)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public ParsedSchema toParsedSchema(final List<SimpleColumn> columns) {\n+    final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n+    columns.forEach(col -> schemaBuilder.field(\n+        col.ref().name(),\n+        SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n+    );\n+\n+    final Schema connectSchema = ensureNamed(schemaBuilder.build());\n+    return fromConnectSchema(connectSchema);\n+  }\n+\n+  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+\n+  protected abstract ParsedSchema fromConnectSchema(Schema schema);\n+\n+  private static SimpleColumn toColumn(final Field field) {\n+    final ColumnName name = ColumnName.of(field.name());\n+    final SqlType type = SchemaConverters.connectToSqlConverter().toSqlType(field.schema());\n+    return new ConnectColumn(name, type);\n+  }\n+\n+  private static Schema ensureNamed(final Schema schema) {\n+    final SchemaBuilder builder;\n+    switch (schema.type()) {\n+      case BYTES:\n+        DecimalUtil.requireDecimal(schema);\n+        builder = DecimalUtil.builder(schema);\n+        break;\n+      case ARRAY:\n+        builder = SchemaBuilder.array(ensureNamed(schema.valueSchema()));\n+        break;\n+      case MAP:\n+        builder = SchemaBuilder.map(\n+            Schema.STRING_SCHEMA,\n+            ensureNamed(schema.valueSchema())\n+        );\n+        break;\n+      case STRUCT:\n+        builder = SchemaBuilder.struct();\n+        if (schema.name() == null) {\n+          builder.name(\"TestSchema\" + UUID.randomUUID().toString().replace(\"-\", \"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTY3OA=="}, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjgyOTk3OnYy", "diffSide": "RIGHT", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNjo1MFrOFu8ifA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMToxODowNFrOFvOc_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDY4NA==", "bodyText": "previously we weren't doing this, why do we need to do it here?", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r384770684", "createdAt": "2020-02-26T21:16:50Z", "author": {"login": "agavra"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {\n+\n+  private final Function<Schema, Schema> toKsqlTransformer;\n+\n+  public ConnectFormat() {\n+    this(new ConnectSchemaTranslator()::toKsqlSchema);\n+  }\n+\n+  @VisibleForTesting\n+  ConnectFormat(final Function<Schema, Schema> toKsqlTransformer) {\n+    this.toKsqlTransformer = Objects.requireNonNull(toKsqlTransformer, \"toKsqlTransformer\");\n+  }\n+\n+  @Override\n+  public boolean supportsSchemaInference() {\n+    return true;\n+  }\n+\n+  @Override\n+  public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n+    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+\n+    return connectSchema.fields().stream()\n+        .map(ConnectFormat::toColumn)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public ParsedSchema toParsedSchema(final List<SimpleColumn> columns) {\n+    final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n+    columns.forEach(col -> schemaBuilder.field(\n+        col.ref().name(),\n+        SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n+    );\n+\n+    final Schema connectSchema = ensureNamed(schemaBuilder.build());\n+    return fromConnectSchema(connectSchema);\n+  }\n+\n+  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+\n+  protected abstract ParsedSchema fromConnectSchema(Schema schema);\n+\n+  private static SimpleColumn toColumn(final Field field) {\n+    final ColumnName name = ColumnName.of(field.name());\n+    final SqlType type = SchemaConverters.connectToSqlConverter().toSqlType(field.schema());\n+    return new ConnectColumn(name, type);\n+  }\n+\n+  private static Schema ensureNamed(final Schema schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2NDE4OQ==", "bodyText": "We were. This was a cut&paste from TestCaseBuilderUtil.addNames()", "url": "https://github.com/confluentinc/ksql/pull/4637#discussion_r385064189", "createdAt": "2020-02-27T11:18:04Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.connect;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.SchemaConverters;\n+import io.confluent.ksql.schema.ksql.SimpleColumn;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.util.DecimalUtil;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+\n+public abstract class ConnectFormat implements Format {\n+\n+  private final Function<Schema, Schema> toKsqlTransformer;\n+\n+  public ConnectFormat() {\n+    this(new ConnectSchemaTranslator()::toKsqlSchema);\n+  }\n+\n+  @VisibleForTesting\n+  ConnectFormat(final Function<Schema, Schema> toKsqlTransformer) {\n+    this.toKsqlTransformer = Objects.requireNonNull(toKsqlTransformer, \"toKsqlTransformer\");\n+  }\n+\n+  @Override\n+  public boolean supportsSchemaInference() {\n+    return true;\n+  }\n+\n+  @Override\n+  public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n+    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+\n+    return connectSchema.fields().stream()\n+        .map(ConnectFormat::toColumn)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public ParsedSchema toParsedSchema(final List<SimpleColumn> columns) {\n+    final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n+    columns.forEach(col -> schemaBuilder.field(\n+        col.ref().name(),\n+        SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n+    );\n+\n+    final Schema connectSchema = ensureNamed(schemaBuilder.build());\n+    return fromConnectSchema(connectSchema);\n+  }\n+\n+  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+\n+  protected abstract ParsedSchema fromConnectSchema(Schema schema);\n+\n+  private static SimpleColumn toColumn(final Field field) {\n+    final ColumnName name = ColumnName.of(field.name());\n+    final SqlType type = SchemaConverters.connectToSqlConverter().toSqlType(field.schema());\n+    return new ConnectColumn(name, type);\n+  }\n+\n+  private static Schema ensureNamed(final Schema schema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDY4NA=="}, "originalCommit": {"oid": "6cbd8c557315b20694efbcc51f6db12cb42c22fa"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2011, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}