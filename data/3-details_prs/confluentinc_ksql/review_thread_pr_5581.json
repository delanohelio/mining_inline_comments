{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDUxOTY3", "number": 5581, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNTowM1rOEE2zaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0Mzo1NlrOEE28HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI3NjU2OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNTowM1rOGivfbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNTowM1rOGivfbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4Mjg2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n          \n          \n            \n            ksqlDB ships with a lightweight Java client that enables sending requests easily to a ksqlDB server", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439082862", "createdAt": "2020-06-11T21:35:03Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI3OTQ1OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNjoxNVrOGivhQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNjoxNVrOGivhQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzMzMA==", "bodyText": "Generally, we don't want to make promises about future features in docs, but It's probably fine in this case.", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439083330", "createdAt": "2020-06-11T21:36:15Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n+from within your Java application, as an alternative to using the [REST API](../api.md).\n+The client currently supports pull and push queries as well as inserting new rows of data into existing ksqlDB streams.\n+Soon the client will also support persistent queries and admin operations such as listing streams, tables, and topics. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI4Mzc4OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNzo0NVrOGivjxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTozNzo0NVrOGivjxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4Mzk3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Consequently, the client should only be used with ksqlDB deployments on version 0.10.0 or newer.\n          \n          \n            \n            The client is compatible only with ksqlDB deployments that are on version 0.10.0 or later.", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439083972", "createdAt": "2020-06-11T21:37:45Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n+from within your Java application, as an alternative to using the [REST API](../api.md).\n+The client currently supports pull and push queries as well as inserting new rows of data into existing ksqlDB streams.\n+Soon the client will also support persistent queries and admin operations such as listing streams, tables, and topics. \n+\n+!!! tip\n+    [View the Java client API documentation](api/index.html)\n+\n+The client sends requests to the recently added HTTP2 server endpoints: pull and push queries are served by\n+the [`/query-stream` endpoint](TODO), and inserts are served by the [`/inserts-stream` endpoint](TODO).\n+Consequently, the client should only be used with ksqlDB deployments on version 0.10.0 or newer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI5MzA0OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0MToyNlrOGivpPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0MToyNlrOGivpPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTM3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.\n          \n          \n            \n            If `poll()` is called with no arguments, it blocks until a new row becomes available or the query is terminated.", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439085373", "createdAt": "2020-06-11T21:41:26Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n+from within your Java application, as an alternative to using the [REST API](../api.md).\n+The client currently supports pull and push queries as well as inserting new rows of data into existing ksqlDB streams.\n+Soon the client will also support persistent queries and admin operations such as listing streams, tables, and topics. \n+\n+!!! tip\n+    [View the Java client API documentation](api/index.html)\n+\n+The client sends requests to the recently added HTTP2 server endpoints: pull and push queries are served by\n+the [`/query-stream` endpoint](TODO), and inserts are served by the [`/inserts-stream` endpoint](TODO).\n+Consequently, the client should only be used with ksqlDB deployments on version 0.10.0 or newer.\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(String[] args) {\n+    ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method enables client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #streamQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+You can use this method to issue both push and pull queries, but the usage pattern is better for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records asynchronously, create a [Reactive Streams](http://www.reactive-streams.org/) subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+\n+    // Request the first row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onNext(Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+\n+    // Request the next row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onError(Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Use the Java client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI5NDU1OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0MjowNlrOGivqNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0MjowNlrOGivqNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTYyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n          \n          \n            \n            For non-terminating push queries, use [the `streamQuery()` method](./stream-query.md) instead.", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439085620", "createdAt": "2020-06-11T21:42:06Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n+from within your Java application, as an alternative to using the [REST API](../api.md).\n+The client currently supports pull and push queries as well as inserting new rows of data into existing ksqlDB streams.\n+Soon the client will also support persistent queries and admin operations such as listing streams, tables, and topics. \n+\n+!!! tip\n+    [View the Java client API documentation](api/index.html)\n+\n+The client sends requests to the recently added HTTP2 server endpoints: pull and push queries are served by\n+the [`/query-stream` endpoint](TODO), and inserts are served by the [`/inserts-stream` endpoint](TODO).\n+Consequently, the client should only be used with ksqlDB deployments on version 0.10.0 or newer.\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(String[] args) {\n+    ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method enables client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #streamQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+You can use this method to issue both push and pull queries, but the usage pattern is better for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records asynchronously, create a [Reactive Streams](http://www.reactive-streams.org/) subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+\n+    // Request the first row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onNext(Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+\n+    // Request the next row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onError(Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Use the Java client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()`, which causes `poll()` to return `null` if no new rows are received by the time the duration has elapsed.\n+For more information, see the [API reference](TODO).\n+\n+```java\n+StreamedQueryResult streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method enables client apps to receive query results as a single batch\n+that's returned when the query completes.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #executeQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries and for terminating push queries, for example, queries that have a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI5NjMyOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0Mjo0OFrOGivrXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0Mjo0OFrOGivrXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And here's an analogous example for terminating a push query issued by using the `executeQuery()` method:\n          \n          \n            \n            Here's an analogous example for terminating a push query issued by using the `executeQuery()` method:", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439085917", "createdAt": "2020-06-11T21:42:48Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n+from within your Java application, as an alternative to using the [REST API](../api.md).\n+The client currently supports pull and push queries as well as inserting new rows of data into existing ksqlDB streams.\n+Soon the client will also support persistent queries and admin operations such as listing streams, tables, and topics. \n+\n+!!! tip\n+    [View the Java client API documentation](api/index.html)\n+\n+The client sends requests to the recently added HTTP2 server endpoints: pull and push queries are served by\n+the [`/query-stream` endpoint](TODO), and inserts are served by the [`/inserts-stream` endpoint](TODO).\n+Consequently, the client should only be used with ksqlDB deployments on version 0.10.0 or newer.\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(String[] args) {\n+    ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method enables client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #streamQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+You can use this method to issue both push and pull queries, but the usage pattern is better for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records asynchronously, create a [Reactive Streams](http://www.reactive-streams.org/) subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+\n+    // Request the first row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onNext(Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+\n+    // Request the next row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onError(Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Use the Java client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()`, which causes `poll()` to return `null` if no new rows are received by the time the duration has elapsed.\n+For more information, see the [API reference](TODO).\n+\n+```java\n+StreamedQueryResult streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method enables client apps to receive query results as a single batch\n+that's returned when the query completes.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #executeQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries and for terminating push queries, for example, queries that have a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+// Wait for query result\n+List<Row> resultRows = batchedQueryResult.get();\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method enables client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when the client issues push queries,\n+by using either the [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md) methods.\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued by using the `streamQuery()` method:\n+\n+```java\n+String pushQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES;\";\n+StreamedQueryResult streamedQueryResult = client.streamQuery(pushQuery).get();\n+\n+String queryId = streamedQueryResult.queryID();\n+client.terminatePushQuery(queryId).get();\n+```\n+\n+And here's an analogous example for terminating a push query issued by using the `executeQuery()` method:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI5ODg0OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0Mzo1NlrOGivtCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTo0Mzo1NlrOGivtCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NjM0NA==", "bodyText": "These are great!", "url": "https://github.com/confluentinc/ksql/pull/5581#discussion_r439086344", "createdAt": "2020-06-11T21:43:56Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,473 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+keywords: ksqlDB, java, client\n+---\n+\n+ksqlDB ships with a lightweight Java client that allows you to easily send requests to a ksqlDB server\n+from within your Java application, as an alternative to using the [REST API](../api.md).\n+The client currently supports pull and push queries as well as inserting new rows of data into existing ksqlDB streams.\n+Soon the client will also support persistent queries and admin operations such as listing streams, tables, and topics. \n+\n+!!! tip\n+    [View the Java client API documentation](api/index.html)\n+\n+The client sends requests to the recently added HTTP2 server endpoints: pull and push queries are served by\n+the [`/query-stream` endpoint](TODO), and inserts are served by the [`/inserts-stream` endpoint](TODO).\n+Consequently, the client should only be used with ksqlDB deployments on version 0.10.0 or newer.\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(String[] args) {\n+    ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method enables client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #streamQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+You can use this method to issue both push and pull queries, but the usage pattern is better for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records asynchronously, create a [Reactive Streams](http://www.reactive-streams.org/) subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+\n+    // Request the first row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onNext(Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+\n+    // Request the next row\n+    subscription.request(1);\n+  }\n+\n+  @Override\n+  public synchronized void onError(Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Use the Java client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()`, which causes `poll()` to return `null` if no new rows are received by the time the duration has elapsed.\n+For more information, see the [API reference](TODO).\n+\n+```java\n+StreamedQueryResult streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method enables client apps to receive query results as a single batch\n+that's returned when the query completes.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * <p>By default, push queries issued via this method return results starting from the beginning\n+   * of the stream or table. To override this behavior, use the method\n+   * {@link #executeQuery(String, Map)} to pass in the query property {@code auto.offset.reset}\n+   * with value set to {@code latest}.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries and for terminating push queries, for example, queries that have a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+// Wait for query result\n+List<Row> resultRows = batchedQueryResult.get();\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method enables client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when the client issues push queries,\n+by using either the [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md) methods.\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued by using the `streamQuery()` method:\n+\n+```java\n+String pushQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES;\";\n+StreamedQueryResult streamedQueryResult = client.streamQuery(pushQuery).get();\n+\n+String queryId = streamedQueryResult.queryID();\n+client.terminatePushQuery(queryId).get();\n+```\n+\n+And here's an analogous example for terminating a push query issued by using the `executeQuery()` method:\n+\n+```java\n+String pushQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+BatchedQueryResult batchedQueryResult = client.executeQuery(pushQuery);\n+\n+String queryId = batchedQueryResult.queryID().get();\n+client.terminatePushQuery(queryId).get();\n+```\n+\n+Insert a new row into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------\n+\n+Client apps can insert new rows of data into existing ksqlDB streams by using the `insertInto()` method.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Inserts a row into a ksqlDB stream.\n+   *\n+   * <p>The {@code CompletableFuture} will be failed if a non-200 response is received from the\n+   * server, or if the server encounters an error while processing the insertion.\n+   *\n+   * @param streamName name of the target stream\n+   * @param row the row to insert. Keys are column names and values are column values.\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, KsqlObject row);\n+  \n+  ...\n+  \n+}\n+```\n+\n+Rows for insertion are represented as `KsqlObject` instances. A `KsqlObject` represents a map of strings\n+(in this case, column names) to values (column values).\n+\n+### Example Usage ###\n+\n+Here's an example of using the client to insert a new row into an existing stream `ORDERS`\n+with schema (ORDER_ID BIGINT, PRODUCT_ID VARCHAR, USER_ID VARCHAR).\n+\n+```java\n+KsqlObject row = new KsqlObject()\n+    .put(\"ROWKEY\", \"k1\")\n+    .put(\"ORDER_ID\", 12345678L)\n+    .put(\"PRODUCT_ID\", \"UAC-222-19234\")\n+    .put(\"USER_ID\", \"User_321\");\n+\n+client.insertInto(\"ORDERS\", row).get();\n+```\n+\n+Tutorial Examples", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e91103f9b04fadd8d389c3f676a63ed538f2936"}, "originalPosition": 374}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3368, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}