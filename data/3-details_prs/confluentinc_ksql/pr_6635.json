{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNjgzNjYx", "number": 6635, "title": "chore: force repartition on joins with SR-enabled key formats", "bodyText": "Description\nFixes #6332\nThis PR forces repartitions on both sources of joins with SR-enabled key formats. This is in order to ensure that the same Schema Registry schema is used on both sides of the join, so the user will not experience unexpected join misses due to logically equivalent data being sent to different topic partitions because the serialized bytes differ (due to differences in schema or schema ID). By forcing repartitions, the schema generated by ksqlDB is used for data on both sides of the join, which is consistent given logical schema, key format, key format properties, and key serde features, all of which are verified to be the same on both sides of the join, else the join is rejected.\nIn order to support stream-table and table-table joins, this PR adds support for repartitioning tables. This functionality is hidden from the user (users still see the same error message indicating that ksqlDB does not support repartitioning tables) and is purely used for this internal use case of enabling joins with SR-enabled key formats.\nThis approach of forcing repartitions on both sides of the join is not resource-efficient for two main reasons:\n\nThe repartition happens even if it's not strictly necessary (e.g., if there was already another repartition upstream of the join). We can enhance the join logic to avoid this in a subsequent PR if desired.\nTable repartitions currently introduce an extra state store and changelog topic (there are two rather than one) because we need to pass in custom serdes in the toTable() call, which requires passing in a Materialized object, which results in an extra state store. I don't know of a way around this at this time.\n\nTesting done\nQTT + manual.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-11-17T20:23:11Z", "url": "https://github.com/confluentinc/ksql/pull/6635", "merged": true, "mergeCommit": {"oid": "67f13f3d7e48569b208d8cd5760f561aacb23848"}, "closed": true, "closedAt": "2020-11-20T22:17:10Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddfVhMAH2gAyNTIyNjgzNjYxOmFlZDc4YjEyZjg5MWRiOTEzMDZhOTgwNjNjMmRlNjEwNWRiYjhmZDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdedJpkgH2gAyNTIyNjgzNjYxOmM5Y2IyZDcwODI0ODhiYjE1ZTkzNzNlNmMwMTAxYTI3NWI3ZjM5Y2M=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aed78b12f891db91306a98063c2de6105dbb8fd5", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/aed78b12f891db91306a98063c2de6105dbb8fd5", "committedDate": "2020-11-17T20:11:36Z", "message": "chore: force repartition on joins with SR-enabled key formats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb94de41dea36011e32c043df8776fcc096bf681", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/cb94de41dea36011e32c043df8776fcc096bf681", "committedDate": "2020-11-17T20:12:05Z", "message": "refactor: move common methods to new util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/c0d83466c7b0beb4fe259c933f43698516f37baf", "committedDate": "2020-11-17T20:12:06Z", "message": "chore: historic plans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgxNDk4", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532781498", "createdAt": "2020-11-17T20:25:15Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNToxNVrOH1JtOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNToxNVrOH1JtOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NTYwOA==", "bodyText": "If we want to fix the first inefficiency mentioned in the PR description (that we currently force repartitions even if not strictly necessary), this is the bit of logic that would be updated.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525495608", "createdAt": "2020-11-17T20:25:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgyMDA3", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532782007", "createdAt": "2020-11-17T20:25:57Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNTo1N1rOH1JwiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNTo1N1rOH1JwiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjQ1Nw==", "bodyText": "This PR does not add support for joining on windowed sources with SR-enableld key formats. This will be a follow-up PR.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525496457", "createdAt": "2020-11-17T20:25:57Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgyNTUx", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532782551", "createdAt": "2020-11-17T20:26:40Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNjo0MFrOH1J0VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNjo0MFrOH1J0VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NzQyOQ==", "bodyText": "This test is identical to shouldNotRepartitionIfSameKeyField above, so the duplicate has been removed.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525497429", "createdAt": "2020-11-17T20:26:40Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKStreamTest.java", "diffHunk": "@@ -146,31 +143,39 @@ public void shouldBuildSchemaForSelect() {\n   @Test\n   public void shouldNotRepartitionIfSameKeyField() {\n     // Given:\n-    final PlanNode logicalPlan = givenInitialKStreamOf(\n+    givenInitialKStreamOf(\n         \"SELECT col0, col2, col3 FROM test1 PARTITION BY col0 EMIT CHANGES;\");\n-    final UserRepartitionNode repartitionNode = (UserRepartitionNode) logicalPlan.getSources().get(0).getSources().get(0);\n \n     // When:\n     final SchemaKStream<?> result = initialSchemaKStream\n-        .selectKey(repartitionNode.getPartitionBy(), Optional.empty(), childContextStacker);\n+        .selectKey(valueFormat.getFormatInfo(), new UnqualifiedColumnReferenceExp(ColumnName.of(\"COL0\")), Optional.empty(), childContextStacker, false);\n \n     // Then:\n     assertThat(result, is(initialSchemaKStream));\n   }\n \n   @Test\n-  public void shouldNotRepartitionIfRowkey() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgzMzIx", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532783321", "createdAt": "2020-11-17T20:27:44Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNzo0NFrOH1J5iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNzo0NFrOH1J5iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5ODc2MA==", "bodyText": "The test immediately above this one has the same name. I've renamed this one to indicate the difference and avoid confusion.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525498760", "createdAt": "2020-11-17T20:27:44Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -442,11 +442,14 @@\n       \"post\": {\n         \"sources\": [\n           {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"T_ID BIGINT KEY, NAME STRING, VALUE BIGINT, F1 STRING, F2 BIGINT\"}\n-        ]\n+        ],\n+        \"topics\": {\n+          \"blacklist\": \".*-repartition\"\n+        }\n       }\n     },\n     {\n-      \"name\": \"stream stream left join\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgzOTE2", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532783916", "createdAt": "2020-11-17T20:28:33Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyODozM1rOH1J9fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyODozM1rOH1J9fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5OTc3Mg==", "bodyText": "This is an example of the fact that we have two changelog topics here when we really only want to have one :(", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525499772", "createdAt": "2020-11-17T20:28:33Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},\n+        {\"topic\": \"s2\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-JOINTHIS-0000000016-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-OUTEROTHER-0000000017-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"stream-table key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}},\n+        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KafkaTopic_Right-Reduce-changelog\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzg1MTYz", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532785163", "createdAt": "2020-11-17T20:30:18Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMDoxOFrOH1KFrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMDoxOFrOH1KFrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwMTg3MA==", "bodyText": "Ideally this topic would be named _confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition (or similar) to indicate that it's the repartition topic on the left side of the join, but this would be a breaking change and I'm not sure it's worth the confusion it will save. (The reason it's unambiguous prior to this PR is because for stream-table joins, only the stream side (left side) would ever be repartitioned, but that's no longer true with this PR.)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525501870", "createdAt": "2020-11-17T20:30:18Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},\n+        {\"topic\": \"s2\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-JOINTHIS-0000000016-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-OUTEROTHER-0000000017-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"stream-table key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}},\n+        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-repartition\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 250}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzg2ODQ4", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532786848", "createdAt": "2020-11-17T20:32:37Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMjozN1rOH1KQNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozMjozN1rOH1KQNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNDU2Ng==", "bodyText": "I've tried to implement this new plan step in a generic way so that it can also support user table repartitions in the future, rather than baking in assumptions such as the fact that today the logical schema (and key format) never change when this step is called, as the step is only used to enable a specific join use case. However, there's no testing for the more general table rekey functionality, so maybe it's more misleading to have the step appear general, and we should be failing if any of these assumptions are violated instead?", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525504566", "createdAt": "2020-11-17T20:32:37Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSelectKeyBuilder.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.materialization.MaterializationInfo;\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.execution.plan.KeySerdeFactory;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+public final class TableSelectKeyBuilder {\n+\n+  private TableSelectKeyBuilder() {\n+  }\n+\n+  public static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory\n+  ) {\n+    return build(\n+        table,\n+        selectKey,\n+        queryBuilder,\n+        materializedFactory,\n+        PartitionByParamsFactory::build\n+    );\n+  }\n+\n+  @VisibleForTesting\n+  static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory,\n+      final PartitionByParamsBuilder paramsBuilder\n+  ) {\n+    final LogicalSchema sourceSchema = table.getSchema();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/8638a61007a3707f297f8ae428b9cf16216df202", "committedDate": "2020-11-17T20:46:22Z", "message": "chore: findbugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ad4ed3bc52af2183627a784c9feb24543245f24e", "committedDate": "2020-11-17T21:37:20Z", "message": "chore: fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzkyNjQ0", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-532792644", "createdAt": "2020-11-17T20:38:24Z", "commit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDozODoyNFrOH1KhOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo1ODozOVrOH1NKfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwODkyMg==", "bodyText": "might be good to link this to a GH issue and place the issue inline", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525508922", "createdAt": "2020-11-17T20:38:24Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NTYwOA=="}, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMDk0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"\n          \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on windowed Schema-Registry-enabled key formats \"", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525510940", "createdAt": "2020-11-17T20:41:16Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMTk5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"\n          \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on windowed Schema-Registry-enabled key formats \"", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525511994", "createdAt": "2020-11-17T20:43:30Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -157,10 +162,46 @@ public SchemaKTable(\n           + \"a join, joins on tables with multiple columns is not yet supported.\");\n     }\n \n-    throw new UnsupportedOperationException(\"Cannot repartition a TABLE source. \"\n-        + \"If this is a join, make sure that the criteria uses the TABLE's key column \"\n-        + Iterables.getOnlyElement(schema.key()).name().text() + \" instead of \"\n-        + keyExpression);\n+    // Table repartitioning is only supported for internal use in enabling joins\n+    if (!forceRepartition) {\n+      throw new UnsupportedOperationException(\"Cannot repartition a TABLE source. \"\n+          + \"If this is a join, make sure that the criteria uses the TABLE's key column \"\n+          + Iterables.getOnlyElement(schema.key()).name().text() + \" instead of \"\n+          + keyExpression);\n+    }\n+\n+    if (keyFormat.isWindowed()) {\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNTc2Mw==", "bodyText": "did this topic always exist and now we're just adding it to the postcondition?", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525515763", "createdAt": "2020-11-17T20:50:23Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2171,6 +2210,11 @@\n               \"keyFormat\" : {\"format\" : \"DELIMITED\"},\n               \"valueFormat\" : {\"format\" : \"JSON\"}\n             },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzMxMg==", "bodyText": "we might want to introduce a pre-topics node here so that we have control over the actual schema in schema registry. I think we also have the ability to ensure the schema at the end. It would be good to have both of these in the test to make sure we don't accidentally create a backwards incompatible change if/when we optimize away unnecessary repartitions\nI think it also makes sense to add tests for:\n\nschemas are identical, should repartition anyway\nschemas are logically identical but physically different\nschemas are logically different, should fail (in table-table joins anyway)\n\nAlso we should make sure what happens when we have an SR-enabled value format as well (I don't imagine anything should go wrong, but it makes sure that when we piped through the value format in the table select key we don't mess things up)\n\n\ud83d\ude82\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n          \n          \n            \n                  \"name\": \"stream-stream key-to-key - SR-enabled key format\",", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525517312", "createdAt": "2020-11-17T20:53:12Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMDIxNA==", "bodyText": "I think we might want to add the following tests:\n\nselect both keys in the output (use AS_VALUE)\nentirely null values (and then joining post-tombstone)\ntest full outer joins\nnegative test for windowed sources join", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525520214", "createdAt": "2020-11-17T20:58:37Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,159 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-steam key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTE4Mw==", "bodyText": "+1 nice refactor, can you add short javadoc? otherwise \"utils\" can be dumping ground for misc things", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525521183", "createdAt": "2020-11-17T21:00:23Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/MaterializationUtil.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.SchemaNotSupportedException;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.plan.ExecutionStep;\n+import io.confluent.ksql.execution.plan.Formats;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+final class MaterializationUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTk0NA==", "bodyText": "I think it's fine to implement it generically, we should have tests that fail if a user tries to repartition a table so I think that covers that this isn't being used for evil", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525521944", "createdAt": "2020-11-17T21:01:39Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSelectKeyBuilder.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.materialization.MaterializationInfo;\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.execution.plan.KeySerdeFactory;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+public final class TableSelectKeyBuilder {\n+\n+  private TableSelectKeyBuilder() {\n+  }\n+\n+  public static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory\n+  ) {\n+    return build(\n+        table,\n+        selectKey,\n+        queryBuilder,\n+        materializedFactory,\n+        PartitionByParamsFactory::build\n+    );\n+  }\n+\n+  @VisibleForTesting\n+  static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory,\n+      final PartitionByParamsBuilder paramsBuilder\n+  ) {\n+    final LogicalSchema sourceSchema = table.getSchema();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNDU2Ng=="}, "originalCommit": {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjM4Nw==", "bodyText": "we might want to move this into JoiningNode so that we can leverage it both here and in JoinNode#getValueFormatForSource (that way, we can ensure that they line up - if for some reason we decide to switch JoinNode to use the right most value format, we won't have to make that change here too)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525526387", "createdAt": "2020-11-17T21:10:15Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -54,6 +59,10 @@ public PreJoinRepartitionNode(\n     this.joiningNode = source instanceof JoiningNode\n         ? Optional.of((JoiningNode) source)\n         : Optional.empty();\n+    this.valueFormat = getLeftmostSourceNode()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTIwOA==", "bodyText": "I'm not sure, but should we make this requiresRepartition() || forceRepartition? If not, we should add a comment about why forced repartitions don't move in here (instead of // Node is repartitioning already)", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525549208", "createdAt": "2020-11-17T21:52:51Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n+      forceRepartition = true;\n+    }\n+\n     if (requiresRepartition()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MDA1NQ==", "bodyText": "I know that none of this class is javadoc'd \ud83d\ude22 but I think it makes sense to tackle it a little bit at a time. Can we add some here explaining what forceRepartition does and why we might want to use it?", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525550055", "createdAt": "2020-11-17T21:54:28Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8638a61007a3707f297f8ae428b9cf16216df202"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA==", "bodyText": "not your code: it bothers me a little that there's nothing \"requiring\" that this is called. can we have buildStream() throw an exception if setKeyFormat was never set? this will make sure that we don't refactor the code and lose this call somewhere in the refactor", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525551418", "createdAt": "2020-11-17T21:57:02Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA==", "bodyText": "super nit: (usually better to have the easy things first in chained ands)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && repartitionNotNeeded(ImmutableList.of(keyExpression))\n          \n          \n            \n                    && !forceRepartition\n          \n          \n            \n                    && !forceRepartition\n          \n          \n            \n                    && repartitionNotNeeded(ImmutableList.of(keyExpression))", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525552254", "createdAt": "2020-11-17T21:58:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94bef771f8d6c954065709e609a203f20437dfff", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/94bef771f8d6c954065709e609a203f20437dfff", "committedDate": "2020-11-18T00:57:57Z", "message": "chore: fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "755de3bb18a7f7e6854c8fc99e6e0ab92c19eeb2", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/755de3bb18a7f7e6854c8fc99e6e0ab92c19eeb2", "committedDate": "2020-11-18T01:15:16Z", "message": "chore: tweak error message, rename qtts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a13511a0e9714fe3d4842f1b448c6d6e9e9fcb8", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/3a13511a0e9714fe3d4842f1b448c6d6e9e9fcb8", "committedDate": "2020-11-18T19:09:28Z", "message": "test: additional qtt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12bf73f07a4975f08182f23b0d608103b1809e2c", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/12bf73f07a4975f08182f23b0d608103b1809e2c", "committedDate": "2020-11-18T23:22:07Z", "message": "test: add table-table join test with nulls (not passing)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "062e9ac7bb74a9043458d38f260003cb281e59ab", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/062e9ac7bb74a9043458d38f260003cb281e59ab", "committedDate": "2020-11-18T23:33:14Z", "message": "Merge branch 'master' into join-force-repartition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa5050e78d1e9967e5b07d68f4c1003278220949", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/fa5050e78d1e9967e5b07d68f4c1003278220949", "committedDate": "2020-11-20T03:06:23Z", "message": "chore: feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4ed3260b9310b700a408029ebe8727ffc0f3409", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/e4ed3260b9310b700a408029ebe8727ffc0f3409", "committedDate": "2020-11-20T16:51:52Z", "message": "fix: require key format to always be set"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjA2NTY5", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-535606569", "createdAt": "2020-11-20T16:58:31Z", "commit": {"oid": "e4ed3260b9310b700a408029ebe8727ffc0f3409"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1ODozMVrOH3YH4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo1ODozMVrOH3YH4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyODk2Mw==", "bodyText": "This test will not succeed until #6647 is merged.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527828963", "createdAt": "2020-11-20T16:58:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -2298,6 +2342,649 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Incompatible key formats. `T1` has KAFKA while `T2` has DELIMITED.\\nCorrect the key format by creating a copy of the table with the correct key format. For example:\\n\\tCREATE TABLE T_COPY\\n\\t WITH (KEY_FORMAT = <required format>, <other key format config>)\\n\\t AS SELECT * FROM T;\"\n       }\n+    },\n+    {\n+      \"name\": \"stream-stream key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ID INT KEY, FOO INT) WITH (kafka_topic='s1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S2 (ID INT KEY, VAL STRING) WITH (kafka_topic='s2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S1.ID, S2.VAL FROM S1 LEFT OUTER JOIN S2 WITHIN 10 SECONDS ON S1.ID = S2.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"s1\", \"key\": 10, \"value\": {\"foo\": 22}},\n+        {\"topic\": \"s2\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-left-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-right-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-JOINTHIS-0000000016-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KSTREAM-OUTEROTHER-0000000017-store-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"stream-table key-to-key - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}},\n+        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-Join-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-KafkaTopic_Right-Reduce-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-Materialize-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"table-table - SR-enabled key format\",\n+      \"statements\": [\n+        \"CREATE TABLE T1 (ID BIGINT PRIMARY KEY, NAME varchar) WITH (kafka_topic='t1', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ID BIGINT PRIMARY KEY, F1 varchar) WITH (kafka_topic='t2', key_format='AVRO', value_format='JSON');\",\n+        \"CREATE TABLE OUTPUT as SELECT T1.id, name, f1 FROM T1 left join T2 on T1.id = T2.id;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"t1\", \"key\": 0, \"value\": {\"NAME\": \"zero\"}},\n+        {\"topic\": \"t2\", \"key\": 0, \"value\": {\"F1\": \"blah\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"NAME\": \"zero\", \"F1\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"NAME\": \"zero\", \"F1\": \"blah\"}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"table\", \"keyFormat\": {\"format\": \"AVRO\"}}\n+        ],\n+        \"topics\" : {\n+          \"topics\" : [\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-LeftSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-RightSourceKeyed-SelectKey-Repartition-repartition\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-KafkaTopic_Left-Reduce-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-KafkaTopic_Right-Reduce-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-LeftSourceKeyed-Materialize-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            },\n+            {\n+              \"name\" : \"_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-RightSourceKeyed-Materialize-changelog\",\n+              \"keyFormat\" : {\"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"]},\n+              \"valueFormat\" : {\"format\" : \"JSON\"}\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"name\": \"table-table - SR-enabled key format - with nulls\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ed3260b9310b700a408029ebe8727ffc0f3409"}, "originalPosition": 377}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/a7bcc091088d0e3c10eda30e9cd87edeb68fe96a", "committedDate": "2020-11-20T18:29:32Z", "message": "chore: minor cleanup to internal repartition topic names"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1Njk0Nzgw", "url": "https://github.com/confluentinc/ksql/pull/6635#pullrequestreview-535694780", "createdAt": "2020-11-20T18:52:18Z", "commit": {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MjoxOFrOH3c42A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MzozNVrOH3c7TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzAzMg==", "bodyText": "\ud83d\ude02 pah. what a useless condition.", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527907032", "createdAt": "2020-11-20T18:52:18Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -140,15 +144,18 @@ public SchemaKTable(\n     );\n   }\n \n+  @SuppressFBWarnings(\"UC_USELESS_CONDITION\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzY2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (repartitionNotNeeded(ImmutableList.of(keyExpression)) && !forceRepartition) {\n          \n          \n            \n                if (!forceRepartition && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n          \n      \n    \n    \n  \n\nnit: pet peeve of mine \ud83d\ude08", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527907660", "createdAt": "2020-11-20T18:53:35Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -140,15 +144,18 @@ public SchemaKTable(\n     );\n   }\n \n+  @SuppressFBWarnings(\"UC_USELESS_CONDITION\")\n   @SuppressWarnings(\"unchecked\")\n   @Override\n-  public SchemaKStream<Struct> selectKey(\n+  public SchemaKTable<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n-    if (repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n-      return (SchemaKStream<Struct>) this;\n+    if (repartitionNotNeeded(ImmutableList.of(keyExpression)) && !forceRepartition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffd1293ea8c171a07661ec768e9935ded552ca8c", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ffd1293ea8c171a07661ec768e9935ded552ca8c", "committedDate": "2020-11-20T20:12:08Z", "message": "chore: almog's pet peeve ;o"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9cb2d7082488bb15e9373e6c0101a275b7f39cc", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/c9cb2d7082488bb15e9373e6c0101a275b7f39cc", "committedDate": "2020-11-20T20:12:45Z", "message": "Merge branch 'master' into join-force-repartition"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4546, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}