{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3NDA1OTAy", "number": 5886, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMToxOTo0N1rOESj95g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzowOTozN1rOESlv2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODk5MTEwOnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMToxOTo0N1rOG3z_aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMToyNDozNlrOG30IQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3NjY4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            UDFs, see the struct section of the [wow to create a user-defined\n          \n          \n            \n            UDFs, see the struct section of the [how to create a user-defined", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461176680", "createdAt": "2020-07-27T21:19:47Z", "author": {"login": "JimGalasyn"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:\n+\n+```sql\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k1', 1, 'x');\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k2', 2, 'y');\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k3', 3, 'z');\n+```\n+\n+Issue a push query to select the rows. The relevant identifiers are\n+again surrounded with backticks:\n+\n+```sql\n+select `a`, `B`, c from `s2` emit changes;\n+```\n+\n+Your output should resemble the following. Notice the casing of the\n+headers that ksqlDB prints:\n+\n+```\n++----------------------------------------+----------------------------------------+----------------------------------------+\n+|a                                       |B                                       |C                                       |\n++----------------------------------------+----------------------------------------+----------------------------------------+\n+|k1                                      |1                                       |x                                       |\n+|k2                                      |2                                       |y                                       |\n+|k3                                      |3                                       |z                                       |\n+```\n+\n+\n+## User-defined functions\n+\n+Another area where casing is important is user-defined functions\n+(UDFs) that work with struct parameters. This is the case whenever you\n+use a UDF that either receives an incoming struct or returns a custom\n+struct. Any references to struct fields must exactly match the casing\n+ksqlDB expects. ksqlDB will reject any UDF invocations that do not\n+match it.\n+\n+Here is a quick example of using backticks in a UDF that returns a\n+custom struct. The first two fields override the default behavior. The\n+last uses the default casing. That means that when you work with the\n+data returned from the UDF in ksqlDB, all select statements must use\n+this exact casing. For more information on working with structs in\n+UDFs, see the struct section of the [wow to create a user-defined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a869ae3b87626998d84d5641f96f5853173893f3"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3ODk0Ng==", "bodyText": "wow \ud83d\ude0d", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461178946", "createdAt": "2020-07-27T21:24:36Z", "author": {"login": "MichaelDrogalis"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:\n+\n+```sql\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k1', 1, 'x');\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k2', 2, 'y');\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k3', 3, 'z');\n+```\n+\n+Issue a push query to select the rows. The relevant identifiers are\n+again surrounded with backticks:\n+\n+```sql\n+select `a`, `B`, c from `s2` emit changes;\n+```\n+\n+Your output should resemble the following. Notice the casing of the\n+headers that ksqlDB prints:\n+\n+```\n++----------------------------------------+----------------------------------------+----------------------------------------+\n+|a                                       |B                                       |C                                       |\n++----------------------------------------+----------------------------------------+----------------------------------------+\n+|k1                                      |1                                       |x                                       |\n+|k2                                      |2                                       |y                                       |\n+|k3                                      |3                                       |z                                       |\n+```\n+\n+\n+## User-defined functions\n+\n+Another area where casing is important is user-defined functions\n+(UDFs) that work with struct parameters. This is the case whenever you\n+use a UDF that either receives an incoming struct or returns a custom\n+struct. Any references to struct fields must exactly match the casing\n+ksqlDB expects. ksqlDB will reject any UDF invocations that do not\n+match it.\n+\n+Here is a quick example of using backticks in a UDF that returns a\n+custom struct. The first two fields override the default behavior. The\n+last uses the default casing. That means that when you work with the\n+data returned from the UDF in ksqlDB, all select statements must use\n+this exact casing. For more information on working with structs in\n+UDFs, see the struct section of the [wow to create a user-defined", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3NjY4MA=="}, "originalCommit": {"oid": "a869ae3b87626998d84d5641f96f5853173893f3"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTAxOTE2OnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMToyODo1OVrOG30Qpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzowMDowMlrOG32hTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTA5NQ==", "bodyText": "unless it's all uppercase \ud83d\ude02 you could reference B without quotes. might be good to have an example with mixed case (`Dog`)", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461181095", "createdAt": "2020-07-27T21:28:59Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MjkwOA==", "bodyText": "also if you have `B` and `b` as two different fields, b would resolve to `B` and `b` would resolve to `b` (correctly)", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461182908", "createdAt": "2020-07-27T21:32:47Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTA5NQ=="}, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxODEyNg==", "bodyText": "I think I covered this without making it too confusing. See what you think.", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461218126", "createdAt": "2020-07-27T23:00:02Z", "author": {"login": "MichaelDrogalis"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTA5NQ=="}, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTAyMDc3OnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMToyOToyNlrOG30RnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMjo1OToyN1rOG32gcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTM0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            INSERT INTO `s2` (`a`, `B`, c) VALUES ('k2', 2, 'y');\n          \n          \n            \n            INSERT INTO `s2` (`a`, `B`, C) VALUES ('k2', 2, 'y');\n          \n      \n    \n    \n  \n\nto illustrate that unquoted cols are case-insensitive", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461181340", "createdAt": "2020-07-27T21:29:26Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:\n+\n+```sql\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k1', 1, 'x');\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k2', 2, 'y');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxNzkwNg==", "bodyText": "Good suggestion. Handled it differently in the last patch.", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461217906", "createdAt": "2020-07-27T22:59:27Z", "author": {"login": "MichaelDrogalis"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR\n+) WITH (\n+    kafka_topic = 's2',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+Insert some rows into `s2`. Notice how you need to use backticks each\n+time to reference a field that doesn't have the default casing:\n+\n+```sql\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k1', 1, 'x');\n+INSERT INTO `s2` (`a`, `B`, c) VALUES ('k2', 2, 'y');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTM0MA=="}, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTAyNDIzOnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMTozMDozOVrOG30TuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMjo1Nzo0OFrOG32eEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTg4MQ==", "bodyText": "might be good to have a struct example where the fields in the struct are cased (and link it to the example below)", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461181881", "createdAt": "2020-07-27T21:30:39Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxNzI5OA==", "bodyText": "Great call.", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461217298", "createdAt": "2020-07-27T22:57:48Z", "author": {"login": "MichaelDrogalis"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,103 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    `c` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and two of the column names,\n+`a` and `B`. `c` receives the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `a` VARCHAR KEY,\n+    `B` INT,\n+    c VARCHAR", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTg4MQ=="}, "originalCommit": {"oid": "dbbf7847a52dc1db604085e746556a8c68edbb93"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTI4MDM0OnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzowODozMFrOG32s9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzowODozMFrOG32s9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMTExMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            this behavior, `quz` is declared without backticks to demonstrate\n          \n          \n            \n            this behavior, `qux` is declared without backticks to demonstrate", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461221111", "createdAt": "2020-07-27T23:08:30Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,134 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and column names. To contrast\n+this behavior, `quz` is declared without backticks to demonstrate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "612b51ba08b7c5be57fb4a8dabb3af8803052b67"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTI4MjgzOnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzowOTozN1rOG32uZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTo0MjoxMlrOG4S1pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMTQ3OQ==", "bodyText": "out of interest, where did you come up with these? \ud83d\ude02", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461221479", "createdAt": "2020-07-27T23:09:37Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,134 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and column names. To contrast\n+this behavior, `quz` is declared without backticks to demonstrate\n+the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR,\n+    `grault` STRUCT<\n+        `Corge` VARCHAR,\n+        `garply` INT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "612b51ba08b7c5be57fb4a8dabb3af8803052b67"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMjQ5Mw==", "bodyText": "elementary, my dear Watson: https://en.wikipedia.org/wiki/Metasyntactic_variable", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461222493", "createdAt": "2020-07-27T23:12:43Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,134 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and column names. To contrast\n+this behavior, `quz` is declared without backticks to demonstrate\n+the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR,\n+    `grault` STRUCT<\n+        `Corge` VARCHAR,\n+        `garply` INT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMTQ3OQ=="}, "originalCommit": {"oid": "612b51ba08b7c5be57fb4a8dabb3af8803052b67"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMzIzOA==", "bodyText": "we should add franz to our standard canon of metasyntactic variables", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461223238", "createdAt": "2020-07-27T23:15:02Z", "author": {"login": "agavra"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,134 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and column names. To contrast\n+this behavior, `quz` is declared without backticks to demonstrate\n+the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR,\n+    `grault` STRUCT<\n+        `Corge` VARCHAR,\n+        `garply` INT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMTQ3OQ=="}, "originalCommit": {"oid": "612b51ba08b7c5be57fb4a8dabb3af8803052b67"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4MjA4Nw==", "bodyText": "Hah, you found it. :) I ran out of names and googled \"foo bar baz qux\" and clicked the first link. Glad there's more, my choices would have been terrible. \ud83d\ude02", "url": "https://github.com/confluentinc/ksql/pull/5886#discussion_r461682087", "createdAt": "2020-07-28T15:42:12Z", "author": {"login": "MichaelDrogalis"}, "path": "docs/how-to-guides/control-the-case-of-identifiers.md", "diffHunk": "@@ -0,0 +1,134 @@\n+# How to control the case of identifiers\n+\n+## Context\n+\n+You have identifiers, like row names, that will be used outside of\n+ksqlDB. You want to control the exact casing (capitalization) of how\n+they are represented to make them consumable by downstream\n+programs. Because ksqlDB uppercases all identifiers by default, you\n+need to use backticks to preserve the desired casing.\n+\n+## In action\n+\n+```sql\n+CREATE STREAM `s1` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR\n+) WITH (\n+    kafka_topic = 's1',\n+    partitions = 1,\n+    value_format = 'avro'\n+);\n+```\n+\n+## Backticks\n+\n+Begin by telling ksqlDB to start all queries from the earliest point\n+in each topic.\n+\n+```sql\n+SET 'auto.offset.reset' = 'earliest';\n+```\n+\n+Declare a new stream named `s2`. In this example, you override\n+ksqlDB's default behavior to uppercase all identifiers. Use backticks\n+to control the casing of the stream name and column names. To contrast\n+this behavior, `quz` is declared without backticks to demonstrate\n+the default behavior of uppercasing.\n+\n+```sql\n+CREATE STREAM `s2` (\n+    `foo` VARCHAR KEY,\n+    `BAR` INT,\n+    `Baz` VARCHAR,\n+    `grault` STRUCT<\n+        `Corge` VARCHAR,\n+        `garply` INT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyMTQ3OQ=="}, "originalCommit": {"oid": "612b51ba08b7c5be57fb4a8dabb3af8803052b67"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2995, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}