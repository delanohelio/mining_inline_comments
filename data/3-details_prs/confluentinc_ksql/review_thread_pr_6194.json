{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MjM2NDMz", "number": 6194, "reviewThreads": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMTowNzowNVrOEi6UQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo1MjowNlrOElq0gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQyNDk3OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMTowNzowNVrOHQ_Xow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyODo1N1rOHRTz4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzUwNw==", "bodyText": "This test (and also \"unsupported format\" below) currently does not pass in QTT even though it works if you actually spin up a server. This is because QTT does not run the RequestValidator, which is where the check is currently performed. I looked into adding the RequestValidator into QTT but it's not clear to me whether this is possible / the correct thing to do.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577507", "createdAt": "2020-09-13T21:07:05Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMjQxNg==", "bodyText": "If we move the check, (see comments above), we can solve this issue.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487912416", "createdAt": "2020-09-14T13:28:57Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzUwNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQyNTI3OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMTowNzoxOVrOHQ_XxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzoyMDo0MlrOHTOrDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA==", "bodyText": "PlannedTestsUpToDateTest currently fails because of two changes:\n\nthe removal of the create or replace feature flag from this properties blacklist, as this adds a field into the plan\nthe additional of the DefaultFormatInjector in this PR, which injects KEY_FORMAT into CS/CT statements where only VALUE_FORMAT has been explicitly provided, which is currently all tests.\n\nI think these two changes are acceptable, and therefore the way to fix the test is to regenerate test plans, but I'm curious to hear what others think, especially regarding whether it makes sense to inject key/value formats into CS/CT statements that don't explicitly provide them. Note that this behavior is inline with the DefaultSchemaInjector injecting schemas into statements for which schema inference is performed.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577540", "createdAt": "2020-09-13T21:07:19Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "diffHunk": "@@ -50,7 +50,7 @@ public static boolean isNotExcluded(final TestCase testCase) {\n     // Place temporary logic here to exclude test cases based on feature flags, etc.\n     return !(boolean) testCase\n         .properties()\n-        .getOrDefault(KsqlConfig.KSQL_CREATE_OR_REPLACE_ENABLED, false);\n+        .getOrDefault(KsqlConfig.KSQL_KEY_FORMAT_ENABLED, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMDM4OA==", "bodyText": "I've leave the removal of the KSQL_CREATE_OR_REPLACE_ENABLED to another PR. It's not related to this PR.  You could just ping Almog to have him remove it.\nDefaultFormatInjector should, (as I've noted above), do nothing if the feature flag is not set.  Hence no plans should need to change.  In general, if you find you need to generate a new set of plans before the feature flag is removed... something is wrong! ;)", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487910388", "createdAt": "2020-09-14T13:26:25Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "diffHunk": "@@ -50,7 +50,7 @@ public static boolean isNotExcluded(final TestCase testCase) {\n     // Place temporary logic here to exclude test cases based on feature flags, etc.\n     return !(boolean) testCase\n         .properties()\n-        .getOrDefault(KsqlConfig.KSQL_CREATE_OR_REPLACE_ENABLED, false);\n+        .getOrDefault(KsqlConfig.KSQL_KEY_FORMAT_ENABLED, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyNTM5MQ==", "bodyText": "I've leave the removal of the KSQL_CREATE_OR_REPLACE_ENABLED to another PR. It's not related to this PR.\n\nTurns out the removal of this feature flag does not affect whether the existing historic plans are up to date or not, as the newly added orReplace flag is optional and inferred to be false if not present.\n\nDefaultFormatInjector should, (as I've noted above), do nothing if the feature flag is not set. Hence no plans should need to change. In general, if you find you need to generate a new set of plans before the feature flag is removed... something is wrong! ;)\n\nSee #6194 (comment) for why the injector is still adding KEY_FORMAT even if the feature flag is not set.\nIn light of this, I've gone with the approach we discussed offline of updating KsqlPlanV1 to not include the statementText in comparisons, as we decided this was the lesser evil compared to either generating new plans or rewriting the existing ones.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489925391", "createdAt": "2020-09-17T03:20:42Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "diffHunk": "@@ -50,7 +50,7 @@ public static boolean isNotExcluded(final TestCase testCase) {\n     // Place temporary logic here to exclude test cases based on feature flags, etc.\n     return !(boolean) testCase\n         .properties()\n-        .getOrDefault(KsqlConfig.KSQL_CREATE_OR_REPLACE_ENABLED, false);\n+        .getOrDefault(KsqlConfig.KSQL_KEY_FORMAT_ENABLED, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQyNjE4OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMTowODo0MVrOHQ_YMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDowMDoyOVrOHRV0gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzY0OQ==", "bodyText": "This is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577649", "createdAt": "2020-09-13T21:08:41Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -197,7 +200,11 @@ private static Topic createTopicFromStatement(\n \n         if (isCsOrCT(stmt)) {\n           final PreparedStatement<?> prepare = parser.prepare(stmt, metaStore);\n-          topics.add(extractTopic.apply(prepare));\n+          final ConfiguredStatement<?> configured =\n+              ConfiguredStatement.of(prepare, Collections.emptyMap(), ksqlConfig);\n+          // TODO: cleaner way to handle this?\n+          final ConfiguredStatement<?> withFormats = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NTM0NQ==", "bodyText": "Welcome to the mess of the testing tool!\nYou're approach is generally correct - we need your injector in QTT to do its thing, so unfortunately, this means adding it to QTT, given QTT doesn't currently just use the default Injectors class, (not sure it actually can... not something I'm that familiar with - @agavra  may have more context).\nFor background: this bit of code is attempting to extract the topic info from the statement.  Later in TestExecutorUtil we run the statement for real.  Ideally, we don't want to have to add your injector to both places.  That's just making the code worse.\nMaybe an OK approach would be to have a common method (probably in TestExecutorUtil), that knows how to prepare the statement, with the correct injectors.  You add your injector there, and have both places call that method.\nNot ideal, but....", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487945345", "createdAt": "2020-09-14T14:00:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -197,7 +200,11 @@ private static Topic createTopicFromStatement(\n \n         if (isCsOrCT(stmt)) {\n           final PreparedStatement<?> prepare = parser.prepare(stmt, metaStore);\n-          topics.add(extractTopic.apply(prepare));\n+          final ConfiguredStatement<?> configured =\n+              ConfiguredStatement.of(prepare, Collections.emptyMap(), ksqlConfig);\n+          // TODO: cleaner way to handle this?\n+          final ConfiguredStatement<?> withFormats = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzY0OQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQyNjgwOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMTowOToyNVrOHQ_Yfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDowMDo0OFrOHRV11g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzcyNw==", "bodyText": "Same as above: this is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577727", "createdAt": "2020-09-13T21:09:25Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -438,10 +439,13 @@ public ConfiguredKsqlPlan next() {\n         return Optional.empty();\n       }\n \n+      // TODO: cleaner way to handle this?\n+      final ConfiguredStatement<?> withFormats =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NTY4Ng==", "bodyText": "See aboive.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487945686", "createdAt": "2020-09-14T14:00:48Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -438,10 +439,13 @@ public ConfiguredKsqlPlan next() {\n         return Optional.empty();\n       }\n \n+      // TODO: cleaner way to handle this?\n+      final ConfiguredStatement<?> withFormats =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzcyNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQyODA0OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMToxMDo0MVrOHQ_ZDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDowMTo0MlrOHRV5mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3Nzg2OQ==", "bodyText": "Same problem as with the QTT framework above: this is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577869", "createdAt": "2020-09-13T21:10:41Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -210,9 +211,11 @@ private void execute(final ParsedStatement parsedStatement) {\n       return;\n     }\n \n+    // TODO: what's a cleaner way around this failure?\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NjY0OQ==", "bodyText": "@agavra is probably the best person to comment here...", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487946649", "createdAt": "2020-09-14T14:01:42Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -210,9 +211,11 @@ private void execute(final ParsedStatement parsedStatement) {\n       return;\n     }\n \n+    // TODO: what's a cleaner way around this failure?\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3Nzg2OQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQyOTM0OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMToxMjozMVrOHQ_ZuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjo1NTo0M1rOHSeMfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA==", "bodyText": "Is the RequestValidator the right place to perform this validation? This felt more correct to me than either the executor or the DefaultFormatInjector, but given that neither QTT nor YATT calls the RequestValidator, I'm no longer sure.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487578040", "createdAt": "2020-09-13T21:12:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NzY4MQ==", "bodyText": "This doesn't look like the right place to me.  RequestValidator doesn't look to be called in headless mode.\nHow about putting a check at the top of EngineExecutor.plan(ConfiguredStatement<?> statement)?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487897681", "createdAt": "2020-09-14T13:08:14Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzMTEzMg==", "bodyText": "Ah, good call on the RequestValidator not being called in headless mode! Moved to the check into EngineExecutor (as you've suggested) instead.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489131132", "createdAt": "2020-09-16T02:55:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjQ0MTYzOnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/properties/with/CommonCreateConfigs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNToxOFrOHRRntw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNToxOFrOHRRntw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NjUzNQ==", "bodyText": "nit: lets get these moved up a line so they're next to VALUE_FORMAT_PROPERTY.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487876535", "createdAt": "2020-09-14T12:35:18Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/properties/with/CommonCreateConfigs.java", "diffHunk": "@@ -39,13 +39,14 @@\n   public static final String VALUE_AVRO_SCHEMA_FULL_NAME = \"VALUE_AVRO_SCHEMA_FULL_NAME\";\n   public static final String VALUE_FORMAT_PROPERTY = \"VALUE_FORMAT\";\n   public static final String WRAP_SINGLE_VALUE = \"WRAP_SINGLE_VALUE\";\n+  public static final String KEY_FORMAT_PROPERTY = \"KEY_FORMAT\";\n+  public static final String FORMAT_PROPERTY = \"FORMAT\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjQ4NTA4OnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0NTo1NVrOHRSBMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0NTo1NVrOHRSBMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzA1OA==", "bodyText": "FORMAT and KEY_FORMAT are equally valid in CREATE AS statements, so this check is also needed in CreateSourceAsProperties class.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487883058", "createdAt": "2020-09-14T12:45:55Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjQ5NjAwOnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo0ODoyMVrOHRSHdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzowMDo1OVrOHTN7qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NDY2Mw==", "bodyText": "Having these throw if the property is not set smells to me.  Better to have them return an Optional, meaning the optionality of the property is baked into the type system.\nThis would also decouple this class from DefaultFormatInjector, meaning you could remove all the comments about DefaultFormatInjector.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487884663", "createdAt": "2020-09-14T12:48:21Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxMzI1Nw==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489913257", "createdAt": "2020-09-17T03:00:59Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NDY2Mw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUyMTc0OnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NDoxM1rOHRSWYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjoxMDoyOVrOHSddiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4ODQ4Mw==", "bodyText": "Nothing wrong with the code above, but how about the following to remove some duplicate calls and code:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * This method may be called before the DefaultFormatInjector has run, in which case a\n          \n          \n            \n               * key format may not be present.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getKeyFormatName() {\n          \n          \n            \n                final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n          \n          \n            \n                    ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n          \n          \n            \n                    : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n          \n          \n            \n                return Optional.ofNullable(keyFormat);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n               * This method may be called before the DefaultFormatInjector has run, in which case a\n          \n          \n            \n               * value format may not be present.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getValueFormatName() {\n          \n          \n            \n                final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n          \n          \n            \n                    ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n          \n          \n            \n                    : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n          \n          \n            \n                return Optional.ofNullable(valueFormat);\n          \n          \n            \n              }\n          \n          \n            \n              /**\n          \n          \n            \n               * The key format name, if supplied explicitly.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getKeyFormatName() {\n          \n          \n            \n                final String keyFormat = getFormatName()\n          \n          \n            \n                   .orElse(props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY));\n          \n          \n            \n                return Optional.ofNullable(keyFormat);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n               * The value format name, if supplied explicitly.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getValueFormatName() {\n          \n          \n            \n                final String valueFormat = getFormatName()\n          \n          \n            \n                  .orElse(props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY));\n          \n          \n            \n                return Optional.ofNullable(valueFormat);\n          \n          \n            \n              }\n          \n          \n            \n              \n          \n          \n            \n              private Optional<String> getFormatName() {\n          \n          \n            \n                 return Optional.ofNullable(props.getString(CommonCreateConfigs.FORMAT_PROPERTY));\n          \n          \n            \n              }", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487888483", "createdAt": "2020-09-14T12:54:13Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExOTExNQ==", "bodyText": "Much nicer! Thanks for the tip.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489119115", "createdAt": "2020-09-16T02:10:29Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4ODQ4Mw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUyODYyOnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NTozN1rOHRSaZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMjo0ODoyMVrOHT8Feg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTUwOQ==", "bodyText": "Add unit test / QTT test to cover the situation where FORMAT is supplied.  (Looks like this code would fail as its setting KEY_FORMAT and VALUE_FORMAT, but not clearing FORMAT if its provided.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487889509", "createdAt": "2020-09-14T12:55:37Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -182,6 +238,14 @@ public CreateSourceProperties withPartitionsAndReplicas(\n     return new CreateSourceProperties(originals, durationParser);\n   }\n \n+  public CreateSourceProperties withFormats(final String keyFormat, final String valueFormat) {\n+    final Map<String, Literal> originals = props.copyOfOriginalLiterals();\n+    originals.put(CommonCreateConfigs.KEY_FORMAT_PROPERTY, new StringLiteral(keyFormat));\n+    originals.put(CommonCreateConfigs.VALUE_FORMAT_PROPERTY, new StringLiteral(valueFormat));\n+\n+    return new CreateSourceProperties(originals, durationParser);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY2OTQzNA==", "bodyText": "There are already QTTs for this. Are there specific cases you'd additionally like to see?\nThe injector is a no-op if FORMAT is supplied, since the injector returns if both a key and value format are present. As a consequence, this method is never called if FORMAT is supplied. If it feels more \"correct\" to clear FORMAT in this method I can do that but it's not necessary the way the code is set up today.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490669434", "createdAt": "2020-09-18T02:48:21Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -182,6 +238,14 @@ public CreateSourceProperties withPartitionsAndReplicas(\n     return new CreateSourceProperties(originals, durationParser);\n   }\n \n+  public CreateSourceProperties withFormats(final String keyFormat, final String valueFormat) {\n+    final Map<String, Literal> originals = props.copyOfOriginalLiterals();\n+    originals.put(CommonCreateConfigs.KEY_FORMAT_PROPERTY, new StringLiteral(keyFormat));\n+    originals.put(CommonCreateConfigs.VALUE_FORMAT_PROPERTY, new StringLiteral(valueFormat));\n+\n+    return new CreateSourceProperties(originals, durationParser);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTUwOQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUzMDczOnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/PropertiesConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NjowNFrOHRSbrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1NjowNFrOHRSbrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTgzNw==", "bodyText": "PropertiesConfig is meant to be a general purpose class, not specific to CreateSourceAsProperties and CreateSourceProperties. So while it makes sense to have general purpose code in there to handle timestamps, (validateDateTimeFormat), it probably doesn't make sense to have code in their for handle key & value formats.  That's probably best defined somewhere else. Maybe CommonCreateConfigs could have a utility method?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487889837", "createdAt": "2020-09-14T12:56:04Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/PropertiesConfig.java", "diffHunk": "@@ -69,6 +69,28 @@ public String toString() {\n     return new HashMap<>(originalLiterals);\n   }\n \n+  void validateKeyValueFormats(\n+      final String keyFormatConfig,\n+      final String valueFormatConfig,\n+      final String formatConfig\n+  ) {\n+    final Object value = originals().get(formatConfig);\n+    if (value == null) {\n+      return;\n+    }\n+\n+    if (originals().get(keyFormatConfig) != null) {\n+      throw new KsqlException(\"Cannot supply both '\" + keyFormatConfig + \"' and '\"\n+          + formatConfig + \"' properties. Did you mean to use '\" + valueFormatConfig\n+          + \"' instead of '\" + formatConfig + \"'?\");\n+    }\n+    if (originals().get(valueFormatConfig) != null) {\n+      throw new KsqlException(\"Cannot supply both '\" + valueFormatConfig + \"' and '\"\n+          + formatConfig + \"' properties. Did you mean to use '\" + keyFormatConfig\n+          + \"' instead of '\" + formatConfig + \"'?\");\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjUzNDkzOnYy", "diffSide": "LEFT", "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1Njo1OVrOHRSeCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMToyMDozMVrOHSsK5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg==", "bodyText": "This test class needs shouldThrowIfKeyFormatAndFormatProvided and shouldThrowIfValueFormatAndFormatProvided tests as well.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487890442", "createdAt": "2020-09-14T12:56:59Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "diffHunk": "@@ -391,22 +391,6 @@ public void shouldFailIfNoKafkaTopicName() {\n     assertThat(e.getMessage(), containsString(\"Missing required property \\\"KAFKA_TOPIC\\\" which has no default value.\"));\n   }\n \n-  @Test\n-  public void shouldFailIfNoValueFormat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNDI3NQ==", "bodyText": "Not sure what this comment is getting at. shouldThrowIfKeyFormatAndFormatProvided and shouldThrowIfValueFormatAndFormatProvided were already added to this file (with those exact names). Did you mean that CreateSourceAsPropertiesTest would need these tests as well, once the analogous validation was added to CreateAsSelectProperties? If so, this is done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489124275", "createdAt": "2020-09-16T02:29:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "diffHunk": "@@ -391,22 +391,6 @@ public void shouldFailIfNoKafkaTopicName() {\n     assertThat(e.getMessage(), containsString(\"Missing required property \\\"KAFKA_TOPIC\\\" which has no default value.\"));\n   }\n \n-  @Test\n-  public void shouldFailIfNoValueFormat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MDEwMg==", "bodyText": "Yeah, that's what I meant :D", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489360102", "createdAt": "2020-09-16T11:20:31Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "diffHunk": "@@ -391,22 +391,6 @@ public void shouldFailIfNoKafkaTopicName() {\n     assertThat(e.getMessage(), containsString(\"Missing required property \\\"KAFKA_TOPIC\\\" which has no default value.\"));\n   }\n \n-  @Test\n-  public void shouldFailIfNoValueFormat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU0Mjg3OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/logging/processing/ProcessingLogServerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1ODo0NVrOHRSiuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1ODo0NVrOHRSiuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTY0Mw==", "bodyText": "nice catch!", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487891643", "createdAt": "2020-09-14T12:58:45Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/logging/processing/ProcessingLogServerUtils.java", "diffHunk": "@@ -78,20 +78,24 @@ public static String processingLogStreamCreateStatement(\n   ) {\n     return processingLogStreamCreateStatement(\n         config.getString(ProcessingLogConfig.STREAM_NAME),\n-        getTopicName(config, ksqlConfig)\n+        getTopicName(config, ksqlConfig),\n+        ksqlConfig.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU0Mzk3OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1OTowM1rOHRSjaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjo1OTowM1rOHRSjaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTgxOQ==", "bodyText": "Likewise, nice catch!", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487891819", "createdAt": "2020-09-14T12:59:03Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -881,7 +881,11 @@ private void registerCommandTopic() {\n \n     final String createCmd = \"CREATE STREAM \" + COMMANDS_STREAM_NAME\n         + \" (STATEMENT STRING)\"\n-        + \" WITH(VALUE_FORMAT='JSON', KAFKA_TOPIC='\" + commandTopic + \"');\";\n+        + \" WITH(\"\n+        + (ksqlConfigNoPort.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+            ? \"KEY_FORMAT='KAFKA' \"\n+            : \"\")\n+        + \"VALUE_FORMAT='JSON', KAFKA_TOPIC='\" + commandTopic + \"');\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjU5MTIzOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzowOTo1N1rOHRS_ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMzowNjo1NlrOHSeXwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5ODk4MQ==", "bodyText": "Personally, I'd remove this bit from the JavaDocs (avoids the chance of it getting missed when the feature flag is removed).  And anyway, I don't think the injector needs to validate and throw the format properties. That only needs doing in one place.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487898981", "createdAt": "2020-09-14T13:09:57Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzNDAxNw==", "bodyText": "Removed the Javadoc. See #6194 (comment) for discussion on why I still think it makes sense for this validation to be in the injector.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489134017", "createdAt": "2020-09-16T03:06:56Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5ODk4MQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYwNDg4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxMzowN1rOHRTHvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMjo0MToxMlrOHVOBSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw==", "bodyText": "generally better to move code into functions to make the code much easier to read at a higher level, making this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              @Override\n          \n          \n            \n              public <T extends Statement> ConfiguredStatement<T> inject(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (statement.getStatement() instanceof CreateSource) {\n          \n          \n            \n                  final ConfiguredStatement<CreateSource> createStatement =\n          \n          \n            \n                      (ConfiguredStatement<CreateSource>) statement;\n          \n          \n            \n            \n          \n          \n            \n                  if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n          \n          \n            \n                    throwIfKeyFormatDisabled(createStatement);\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  try {\n          \n          \n            \n                    return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n          \n          \n            \n                  } catch (final KsqlStatementException e) {\n          \n          \n            \n                    throw e;\n          \n          \n            \n                  } catch (final KsqlException e) {\n          \n          \n            \n                    throw new KsqlStatementException(\n          \n          \n            \n                        ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                        statement.getStatementText(),\n          \n          \n            \n                        e.getCause());\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (statement.getStatement() instanceof CreateAsSelect) {\n          \n          \n            \n                  final ConfiguredStatement<CreateAsSelect> createAsSelect =\n          \n          \n            \n                      (ConfiguredStatement<CreateAsSelect>) statement;\n          \n          \n            \n            \n          \n          \n            \n                  if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n          \n          \n            \n                    throwIfKeyFormatDisabled(createAsSelect);\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              @Override\n          \n          \n            \n              public <T extends Statement> ConfiguredStatement<T> inject(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (featureFlagNotEnabled(statement)) {\n          \n          \n            \n                   return statement;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                if (statement.getStatement() instanceof CreateSource) {\n          \n          \n            \n                  return handleCreateSource((ConfiguredStatement<CreateSource>)statement);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (statement.getStatement() instanceof CreateAsSelect) {\n          \n          \n            \n                   return handleCreateSourceAs((ConfiguredStatement<CreateAsSelect>)statement);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nThis also limits the scope of the disabling of the unchecked warnings to only the bits of code that do this and it's clear that code is first checking the type.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487901117", "createdAt": "2020-09-14T13:13:07Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyMjgwNw==", "bodyText": "I've incorporated the meta-point in this comment as best I could but the result isn't as clean as in your example since I can't figure out what the method signature of handleCreateSource() in this example would be. In order to return the result directly the return type would need to be ConfiguredStatement<T> but the helper method wouldn't know what T is if the input param has type ConfiguredStatement<CreateSource>. As a result, I wasn't able to isolate the unchecked warning beyond where it's at currently.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489122807", "createdAt": "2020-09-16T02:23:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MjA1Mw==", "bodyText": "something like:\n@SupressWarning({\"unchecked\", \"rawType\"})\nprivate <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n    final ConfiguredStatement<CreateSource> statement\n  ) {\n\n  ...\n\n  // Safe to cast as we _know_ `T` is `CreateSource`.\n  return (ConfiguredStatement)result;\n}\nBut it's not a biggie.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489362053", "createdAt": "2020-09-16T11:24:31Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY2OTk5NA==", "bodyText": "Done, except there's still an unchecked cast warning on the main inject() method since checking that statement.getStatement() instanceof CreateSource isn't enough to guarantee a clean cast for (ConfiguredStatement<CreateSource>) statement. Am I missing something?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490669994", "createdAt": "2020-09-18T02:50:22Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAxMTg0OQ==", "bodyText": "I guess you could do:\n@SupressWarning({\"unchecked\", \"rawType\"})\nprivate <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n    final ConfiguredStatement<T> statement\n  ) {\n  if (!statement.getStatement() instance of CreateSource) {\n     throw new IllegalArgumentException(something);\n  }\n  ...\n\n  return (ConfiguredStatement)result;\n}", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492011849", "createdAt": "2020-09-21T12:41:12Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYxNTE1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNToyOFrOHRTN8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozNzozM1rOHVfp6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA==", "bodyText": "I think these can be removed. EngineExecutor.plan should be the only place you need to throw if key format is provided (or set to something other than KAFKA).\nI think all that is needed here is for inject to do nothing if the feature flag is not set.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487902704", "createdAt": "2020-09-14T13:15:28Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTgyMg==", "bodyText": "As discussed offline, this injector can't be a direct pass-through if the feature flag is not enabled because we still need to validate that VALUE_FORMAT is explicitly provided in this case, and I think it also makes sense to throw if KEY_FORMAT is supplied here rather than forcing downstream code to handle that. As discussed, I've cleaned up the feature flag handling logic in this class to only check the flag in one place so it's much more readable now.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129822", "createdAt": "2020-09-16T02:51:07Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MzgxOQ==", "bodyText": "As discussed offline, this injector can't be a direct pass-through if the feature flag is not enabled because we still need to validate that VALUE_FORMAT is explicitly provided in this case\n\nAgreed.\n\nand I think it also makes sense to throw if KEY_FORMAT is supplied here rather than forcing downstream code to handle that.\n\nI don't think we gain anything from checking here, if we're already checking in EngineExecutor.plan.  It feels like an unnecessary check.\nBut it's no biggie, and having not played with the code, I may just be wrong ;)", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489363819", "createdAt": "2020-09-16T11:28:06Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyMTc5NQ==", "bodyText": "Ah, just remembered (rediscovered) the problem I ran into when I originally wanted the injector to be a pass-through if the feature flag isn't enabled: if the downstream (engine) code is updated to expect the statement contains a key format, and the injector doesn't add a key format because the feature flag is not enabled, then we fail downstream.\nOther options include:\n\nhave the downstream code check the feature flag and default to KAFKA if the key format isn't present. This is undesirable because we'll be checking the feature flag in a bunch of different places. Even if we create a util method for it, we'll be adding a bunch of code for passing KsqlConfig into the util method which will be removed once the feature flag is removed, and doesn't seem worth the effort as a result.\nhave CreateSourceProperties consume the feature flag and default to KAFKA if not set. This faces the same problem of CreateSourceProperties needing access to KsqlConfig which feels wrong.\n\nThe downside of having the injector always inject key format if not present, regardless of feature flag, is that when the feature flag is not set, users will still start seeing KEY_FORMAT appear in their statements which may be confusing. IMO this still seems less bad than the other options. WDYT?\n\nI don't think we gain anything from checking here, if we're already checking in EngineExecutor.plan. It feels like an unnecessary check.\n\nThe engine checks whether the key format is supported. This check is for whether the key format is supplied at all, and throws even if a valid (supported) key format is supplied, since users shouldn't be trying to supply key formats if the feature flag is not enabled. If we'd rather we can remove this check and allow users to supply KEY_FORMAT='KAFKA' even if the feature flag is not enabled. (My original reason for disallowing this was in an attempt to preserve the pre-feature flag behavior, but that's now been broken by the required change above.)", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489921795", "createdAt": "2020-09-17T03:14:51Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAxNDQ3MA==", "bodyText": "IMO this still seems less bad than the other options. WDYT?\n\nSounds good.\n\nIf we'd rather we can remove this check and allow users to supply KEY_FORMAT='KAFKA' even if the feature flag is not enabled.\n\nI think it makes total sense. If we allow KEY_FORMAT='KAFKA' then its no longer a big weird that users will see KEY_FORMAT in their statements when ksqlDB displays them back to them.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492014470", "createdAt": "2020-09-21T12:44:24Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMDc3OA==", "bodyText": "Cool. I've updated the PR to allow the use of KEY_FORMAT and FORMAT even when the feature flag is not enabled.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492300778", "createdAt": "2020-09-21T19:37:33Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYxNjQzOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNTo0M1rOHRTOpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjo1MToxNFrOHSeHcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg4Ng==", "bodyText": "I think these can be removed. EngineExecutor.plan should be the only place you need to throw if key format is provided (or set to something other than KAFKA).\nI think all that is needed here is for inject to do nothing if the feature flag is not set.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487902886", "createdAt": "2020-09-14T13:15:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTg0Mw==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129843", "createdAt": "2020-09-16T02:51:14Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg4Ng=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYzNDE2OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxOTo1NFrOHRTZiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjo1MToyOVrOHSeH0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTY3NQ==", "bodyText": "This can go if you just early out of the inject method whenever the feature flag is not set.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487905675", "createdAt": "2020-09-14T13:19:54Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTkzNg==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129936", "createdAt": "2020-09-16T02:51:29Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTY3NQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjYzODY1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMDo1MFrOHRTcNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMDo1MFrOHRTcNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjM1OA==", "bodyText": "nit: unnecessary brackets:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n          \n          \n            \n                    && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487906358", "createdAt": "2020-09-14T13:20:50Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjY0MzMyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMTo1MFrOHRTe8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMTo1MFrOHRTe8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzA1OQ==", "bodyText": "You don't need T, so this can just become:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static <T extends Statement> KsqlConfig getConfig(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n          \n          \n            \n              }\n          \n          \n            \n              private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n          \n          \n            \n                return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n          \n          \n            \n              }", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487907059", "createdAt": "2020-09-14T13:21:50Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static <T extends Statement> KsqlConfig getConfig(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjY0NTA4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMjoxNFrOHRTgFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMjoxNFrOHRTgFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzM0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static <T extends Statement> void throwIfKeyFormatDisabled(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              private static void throwIfKeyFormatDisabled(final ConfiguredStatement<?> statement", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487907349", "createdAt": "2020-09-14T13:22:14Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static <T extends Statement> KsqlConfig getConfig(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static <T extends Statement> void throwIfKeyFormatDisabled(\n+      final ConfiguredStatement<T> statement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjY4Nzg3OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozMDo0MVrOHRT5QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozMDo0MVrOHRT5QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzc5Mg==", "bodyText": "In the interest of keeping tests succinct:\n\ninput and output are not required when expectedException is provided.\ntopics is generally not needed, (and defo not needed in these cases). It's only needed if you want to set up the topic (Schema) before the test runs.\n\nCan you update this and other tests please?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487913792", "createdAt": "2020-09-14T13:30:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjY5Mzk3OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozMToyN1rOHRT8rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMjo1OTo0MFrOHVO1_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDY3MA==", "bodyText": "Would be nice if this message said key format...", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487914670", "createdAt": "2020-09-14T13:31:27Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyNjI4Mw==", "bodyText": "This error is thrown by FormatFactory. We could pipe in information about whether the format being created is a key or value format in order to improve this error message but it's not clear to me how worthwhile this is. Thoughts?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489926283", "createdAt": "2020-09-17T03:22:05Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDY3MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNTM0MQ==", "bodyText": "I guess if we validate the config on start up, so that the user sees an explicit error message such as:\nInvalid format: FOO set in config ksql.persistence.key.format.default\n\n... or similar, then statements will only fail if the user explicitly supplies an invalid format in the statement, meaning the source of the error should be obvious!", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492025341", "createdAt": "2020-09-21T12:59:40Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDY3MA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjcxNDE2OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozNDoxNlrOHRUIUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMDoxMjozMFrOHWKopA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA==", "bodyText": "You can add a post check to ensure the source in the meta store has the right key format:\n\"post\": {\n        \"sources\": [\n          {\n            \"name\": \"OUTPUT\",\n            \"type\": \"stream\",\n            \"keyFormat\": {\"format\": \"KAFKA\"},\n            \"schema\": \"`K` BIGINT KEY, `ID` BIGINT, `VALUE` BIGINT\"\n          }\n        ]\n      }\n\nMore details on the model of the QTT tests can be found in the module's README.md", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487917648", "createdAt": "2020-09-14T13:34:16Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyODQ5Nw==", "bodyText": "Interesting that the \"sources\" post condition only allows specification of key format and not value format. I think it makes sense to check both so I've used the \"topics\" post condition for now instead. The README says the \"partitions\" field of the \"topics\" post condition is optional but the test fails if I don't provide it. Two things to investigate, will do so after addressing the remaining comments on the meat on this PR.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489128497", "createdAt": "2020-09-16T02:45:47Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NTQ4OQ==", "bodyText": "Personally, I'd stick with sources and potentially raise another PR to enhance the QTT to test the value format.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489365489", "createdAt": "2020-09-16T11:31:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MDMwMw==", "bodyText": "As discussed offline, I'm OK with this but I prefer to make the change in a follow-up PR.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490670303", "createdAt": "2020-09-18T02:51:33Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNTc5NQ==", "bodyText": "Can we at least get the keyFormat bit in this PR?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492025795", "createdAt": "2020-09-21T13:00:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5OTUxNQ==", "bodyText": "The new QTTs in this PR already check key format (and value format) via the \"topics\" block in the post-conditions, so we should be set. A future PR will add support for value format to the \"sources\" block in the post-conditions check, and update these tests.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492299515", "createdAt": "2020-09-21T19:35:10Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwNDk2NA==", "bodyText": "#6273", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r493004964", "createdAt": "2020-09-22T20:12:30Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzY0OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjcyMjA4OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozNToxOVrOHRUM0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozNToxOVrOHRUM0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxODgwMA==", "bodyText": "Maybe add in defaults in the properties, so the test proves the config is ignored when the user supplies it in the sstatement?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487918800", "createdAt": "2020-09-14T13:35:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjcyODkyOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozNjoxN1rOHRUQ0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjozMDoxNlrOHSdy-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxOTgyNw==", "bodyText": "Why is this complaining about the key format being AVRO...? Shoudln't this be JSON?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487919827", "createdAt": "2020-09-14T13:36:17Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNDYwMA==", "bodyText": "Yup, good catch. The test wasn't running previously for the reason given above. Fixed now.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489124600", "createdAt": "2020-09-16T02:30:16Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxOTgyNw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjczNjY4OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozNzoxN1rOHRUU2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzoyMjoyNFrOHTOvRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyMDg1OA==", "bodyText": "Might be nice if this message said something about the fact that FORMAT sets both key and value format. So they should either set just FORMAT or both key and value.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487920858", "createdAt": "2020-09-14T13:37:17Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key format and format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', key_format='KAFKA', format='KAFKA');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Cannot supply both 'KEY_FORMAT' and 'FORMAT' properties. Did you mean to use 'VALUE_FORMAT' instead of 'FORMAT'?\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyNjQ2OA==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489926468", "createdAt": "2020-09-17T03:22:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -17,6 +17,265 @@\n       },\n       \"inputs\": [],\n       \"outputs\": []\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='KAFKA');\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"KAFKA\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and optional value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"unsupported key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='AVRO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key and value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON', key_format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"optional key and explicit value format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"value\": {\"FOO\": 10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"value\": {\"FOO\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicit format\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo STRING) WITH (kafka_topic='input', format='KAFKA');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"input\": [{\"topic\": \"input\", \"key\": \"foo\", \"value\": \"bar\"}],\n+      \"output\": [{\"topic\": \"OUTPUT\", \"key\": \"foo\", \"value\": \"bar\"}]\n+    },\n+    {\n+      \"name\": \"unsupported format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', format='JSON');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The key format 'AVRO' is not currently supported.\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"invalid format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', format='FOO');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      },\n+      \"inputs\": [],\n+      \"outputs\": []\n+    },\n+    {\n+      \"name\": \"explicit key format and format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic', key_format='KAFKA', format='KAFKA');\"\n+      ],\n+      \"properties\": {\n+        \"ksql.persistence.default.format.value\": \"JSON\",\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"format\": \"JSON\"\n+        }\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Cannot supply both 'KEY_FORMAT' and 'FORMAT' properties. Did you mean to use 'VALUE_FORMAT' instead of 'FORMAT'?\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyMDg1OA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1Mjc1ODgwOnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo0MDoyN1rOHRUh6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzowMTo1NFrOHVO7Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw==", "bodyText": "I actually think having the getValueFormat is too tightly coupling this properties class to FormatFactory.  It would be better if these weren't coupled IMHO.\nI'm happy for you to leave this for another day. But if you have the time, rather than adding a new getKeyFormat method, maybe you could just remove the getValueFormat method and move the FormatFactory call inline.  Then rename getValueFormatInfo to just getValueFormat.\nAlso, getValueFormatProperties shouldn't be public.  It's just API bloat. Better callers just call getValueFormat().getProperties().", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487924203", "createdAt": "2020-09-14T13:40:27Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "diffHunk": "@@ -69,8 +69,12 @@ private CreateSourceAsProperties(final Map<String, Literal> originals) {\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n   }\n \n+  public Optional<Format> getKeyFormat() {\n+    return getKeyFormatInfo().map(FormatFactory::of);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyOTg2MQ==", "bodyText": "I'm happy for you to leave this for another day. But if you have the time, rather than adding a new getKeyFormat method, maybe you could just remove the getValueFormat method and move the FormatFactory call inline. Then rename getValueFormatInfo to just getValueFormat.\n\nDone.\n\nAlso, getValueFormatProperties shouldn't be public. It's just API bloat. Better callers just call getValueFormat().getProperties().\n\ngetValueFormat() returns an Optional which may be empty, whereas there are uses of getValueFormatProperties() even if getValueFormat() is empty, for example: \n  \n    \n      ksql/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java\n    \n    \n        Lines 177 to 179\n      in\n      0f04061\n    \n    \n    \n    \n\n        \n          \n           // overwrite any inheritable properties if they were explicitly \n        \n\n        \n          \n           // specified in the statement \n        \n\n        \n          \n           sourceProperties.putAll(sink.getProperties().getFormatProperties());", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489929861", "createdAt": "2020-09-17T03:27:53Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "diffHunk": "@@ -69,8 +69,12 @@ private CreateSourceAsProperties(final Map<String, Literal> originals) {\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n   }\n \n+  public Optional<Format> getKeyFormat() {\n+    return getKeyFormatInfo().map(FormatFactory::of);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNjY3MQ==", "bodyText": "Agree that getValueFormatProperties should be public.  We'll have to ensure you can, for example, set the delimiter char even when the value/key format is not declared, but coming from system properties.  I wouldn't be surprised if there are already bugs in this area.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492026671", "createdAt": "2020-09-21T13:01:54Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "diffHunk": "@@ -69,8 +69,12 @@ private CreateSourceAsProperties(final Map<String, Literal> originals) {\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n   }\n \n+  public Optional<Format> getKeyFormat() {\n+    return getKeyFormatInfo().map(FormatFactory::of);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1Mjc3NDM1OnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo0Mjo0MVrOHRUq_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzoyODozNlrOHTO9yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNjUyNA==", "bodyText": "As for the other properties class - can we inline these please and rename getKeyFormatInfo -> getKeyFormat etc?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487926524", "createdAt": "2020-09-14T13:42:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(\n+        CommonCreateConfigs.KEY_FORMAT_PROPERTY,\n+        CommonCreateConfigs.VALUE_FORMAT_PROPERTY,\n+        CommonCreateConfigs.FORMAT_PROPERTY\n+    );\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n     validateWindowInfo();\n   }\n \n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public Format getKeyFormat() {\n+    return FormatFactory.of(getKeyFormatInfo());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMDE4Ng==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489930186", "createdAt": "2020-09-17T03:28:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(\n+        CommonCreateConfigs.KEY_FORMAT_PROPERTY,\n+        CommonCreateConfigs.VALUE_FORMAT_PROPERTY,\n+        CommonCreateConfigs.FORMAT_PROPERTY\n+    );\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n     validateWindowInfo();\n   }\n \n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public Format getKeyFormat() {\n+    return FormatFactory.of(getKeyFormatInfo());\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNjUyNA=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1Mjc3OTEwOnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo0MzoxOVrOHRUtpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzozNzowNVrOHTPRgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNzIwNg==", "bodyText": "These feel like API bloat to me. Calls can just call getKeyFormat().getName() or similar.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487927206", "createdAt": "2020-09-14T13:43:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzNTIzMw==", "bodyText": "This didn't work previously when one of the methods returned an Optional while the other didn't, but it's now possible and I've removed this method accordingly.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489935233", "createdAt": "2020-09-17T03:37:05Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNzIwNg=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjgwOTI2OnYy", "diffSide": "RIGHT", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo0NzozM1rOHRU-bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMTo0MFrOHVfeLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw==", "bodyText": "I wouldn't worry about having this on the interface. In time, all key formats will be supported.  It's ok to just hard code the check in one place, rejecting any key formats we don't support yet.  Then once we're done, all will be supported and that bit of code can be removed.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487931503", "createdAt": "2020-09-14T13:47:33Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNDAyMg==", "bodyText": "As above, remove this from the interface.  A format shouldn't know if its supported by the engine as a value or key format, it should know about itself.  It's the engine that knows what it does and does not support as a key format.  (Think about this interface soon being a 'user defined format' interface... we wouldn't expect implementers to say if its supported as a key format or not.)", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492034022", "createdAt": "2020-09-21T13:13:53Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2MjI1OA==", "bodyText": "Just replace it with a Util class method.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492062258", "createdAt": "2020-09-21T13:52:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Nzc3Mg==", "bodyText": "Makes sense -- done.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492297772", "createdAt": "2020-09-21T19:31:40Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjgyMDAyOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo0OTowN1rOHRVEuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMzozNDoyNVrOHTPLIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMzExNQ==", "bodyText": "Hummm.... lot of changes in this class, but no test changes to match!  If it possible to extend some of the YATT tests themselves to set the feature flag and defaults configs and/or set KEY_FORMAT?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487933115", "createdAt": "2020-09-14T13:49:07Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -60,41 +61,50 @@\n   static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n       .add(new SourceProperty(\n           DataSource::getSchema,\n-          cs -> cs.getElements().toLogicalSchema(),\n+          (cs, cfg) -> cs.getElements().toLogicalSchema(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMzYwMw==", "bodyText": "Added tests to ensure that YATT is properly verifying KEY_FORMAT of sources, and that FORMAT behaves as expected too. Didn't add tests to check that default format values are picked up from the config since there are already QTT tests for that, and I don't see the value of duplication here.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489933603", "createdAt": "2020-09-17T03:34:25Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -60,41 +61,50 @@\n   static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n       .add(new SourceProperty(\n           DataSource::getSchema,\n-          cs -> cs.getElements().toLogicalSchema(),\n+          (cs, cfg) -> cs.getElements().toLogicalSchema(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMzExNQ=="}, "originalCommit": {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MDE4NzA4OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMjo1ODozNlrOHT8PdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMDo0NTo1NVrOHU8-GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA==", "bodyText": "Yuck :[\nThis is needed because statements read from the command topic aren't passed through injectors, yet the engine expects key formats to be present which is not the case for pre-execution-plan statements.\nRather than using the injector here, we could create the KsqlConfig and fill in the default, or we could hard-code the Kafka format, all of which are effectively equivalent.\nIs this sufficient reason to not use an injector in order to populate the default from the config? I don't think so but this is really gross.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490671988", "createdAt": "2020-09-18T02:58:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -310,8 +311,9 @@ private String executeDdlStatement(final PreparedStatement<?> statement, final C\n     final KsqlConfig mergedConfig = buildMergedConfig(command);\n     final ConfiguredStatement<?> configured =\n         ConfiguredStatement.of(statement, command.getOverwriteProperties(), mergedConfig);\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg0Nzg5OA==", "bodyText": "I'm confused.... while the SQL text in the plan in the command topic might not have the key format set, historical plans will have the key format set in both any ddlCommand and any queryPlan. As the idea is that the SQL text in the plan is just to display back to the user, and it's ok for the SQL we should back to not include the change, I don't think we need this injector here.\nSnippet of example serializer plan, show ddl and dml key formats of KAFKA:\n{\n    \"@type\" : \"ksqlPlanV1\",\n    \"statementText\" : \"CREATE STREAM OUTPUT AS SELECT\\n  INPUT.ID ID,\\n  ARRAY_MAX(INPUT.BOOL_ARRAY) BOOL_MAX,\\n  ARRAY_MAX(INPUT.INT_ARRAY) INT_MAX,\\n  ARRAY_MAX(INPUT.BIGINT_ARRAY) BIGINT_MAX,\\n  ARRAY_MAX(INPUT.DOUBLE_ARRAY) DOUBLE_MAX,\\n  ARRAY_MAX(INPUT.STRING_ARRAY) STRING_MAX,\\n  ARRAY_MAX(INPUT.DECIMAL_ARRAY) DECIMAL_MAX\\nFROM INPUT INPUT\\nEMIT CHANGES\",\n    \"ddlCommand\" : {\n      \"@type\" : \"createStreamV1\",\n      \"sourceName\" : \"OUTPUT\",\n      \"schema\" : \"`ID` STRING KEY, `BOOL_MAX` BOOLEAN, `INT_MAX` INTEGER, `BIGINT_MAX` BIGINT, `DOUBLE_MAX` DOUBLE, `STRING_MAX` STRING, `DECIMAL_MAX` DECIMAL(2, 1)\",\n      \"topicName\" : \"OUTPUT\",\n      \"formats\" : {\n        \"keyFormat\" : {\n          \"format\" : \"KAFKA\"\n        },\n        \"valueFormat\" : {\n          \"format\" : \"JSON\"\n        }\n      }\n    },\n    \"queryPlan\" : {\n      \"sources\" : [ \"INPUT\" ],\n      \"sink\" : \"OUTPUT\",\n      \"physicalPlan\" : {\n        \"@type\" : \"streamSinkV1\",\n        \"properties\" : {\n          \"queryContext\" : \"OUTPUT\"\n        },\n        \"source\" : {\n          \"@type\" : \"streamSelectV1\",\n          \"properties\" : {\n            \"queryContext\" : \"Project\"\n          },\n          \"source\" : {\n            \"@type\" : \"streamSourceV1\",\n            \"properties\" : {\n              \"queryContext\" : \"KsqlTopic/Source\"\n            },\n            \"topicName\" : \"test_topic\",\n            \"formats\" : {\n              \"keyFormat\" : {\n                \"format\" : \"KAFKA\"\n              },\n              \"valueFormat\" : {\n                \"format\" : \"JSON\"\n              }\n            },\n            \"sourceSchema\" : \"`ID` STRING KEY, `BOOL_ARRAY` ARRAY<BOOLEAN>, `INT_ARRAY` ARRAY<INTEGER>, `BIGINT_ARRAY` ARRAY<BIGINT>, `DOUBLE_ARRAY` ARRAY<DOUBLE>, `STRING_ARRAY` ARRAY<STRING>, `DECIMAL_ARRAY` ARRAY<DECIMAL(2, 1)>\"\n          },\n          \"keyColumnNames\" : [ \"ID\" ],\n          \"selectExpressions\" : [ \"ARRAY_MAX(BOOL_ARRAY) AS BOOL_MAX\", \"ARRAY_MAX(INT_ARRAY) AS INT_MAX\", \"ARRAY_MAX(BIGINT_ARRAY) AS BIGINT_MAX\", \"ARRAY_MAX(DOUBLE_ARRAY) AS DOUBLE_MAX\", \"ARRAY_MAX(STRING_ARRAY) AS STRING_MAX\", \"ARRAY_MAX(DECIMAL_ARRAY) AS DECIMAL_MAX\" ]\n        },\n        \"formats\" : {\n          \"keyFormat\" : {\n            \"format\" : \"KAFKA\"\n          },\n          \"valueFormat\" : {\n            \"format\" : \"JSON\"\n          }\n        },\n        \"topicName\" : \"OUTPUT\"\n      },\n      \"queryId\" : \"CSAS_OUTPUT_0\"\n    }\n  }\n}", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490847898", "createdAt": "2020-09-18T10:17:44Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -310,8 +311,9 @@ private String executeDdlStatement(final PreparedStatement<?> statement, final C\n     final KsqlConfig mergedConfig = buildMergedConfig(command);\n     final ConfiguredStatement<?> configured =\n         ConfiguredStatement.of(statement, command.getOverwriteProperties(), mergedConfig);\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA=="}, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MTUxOA==", "bodyText": "This code path is only hit for statements read from the command topic that do not contain query plans (i.e., those that were written to the command topic before query plans were introduced). These statements also do not contain KEY_FORMAT in their statement text, also by virtue of being old.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490981518", "createdAt": "2020-09-18T14:18:01Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -310,8 +311,9 @@ private String executeDdlStatement(final PreparedStatement<?> statement, final C\n     final KsqlConfig mergedConfig = buildMergedConfig(command);\n     final ConfiguredStatement<?> configured =\n         ConfiguredStatement.of(statement, command.getOverwriteProperties(), mergedConfig);\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA=="}, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTczMjUwNA==", "bodyText": "Removed this code path in #6257, so this is no longer a concern.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r491732504", "createdAt": "2020-09-20T20:45:55Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -310,8 +311,9 @@ private String executeDdlStatement(final PreparedStatement<?> statement, final C\n     final KsqlConfig mergedConfig = buildMergedConfig(command);\n     final ConfiguredStatement<?> configured =\n         ConfiguredStatement.of(statement, command.getOverwriteProperties(), mergedConfig);\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA=="}, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MDE5MzIxOnYy", "diffSide": "LEFT", "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMzowMjowOVrOHT8S0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMjoxNTo1M1rOHU9fJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3Mjg0OQ==", "bodyText": "Unless the feature flag is enabled, this test fails if this check is present since the statement in the response contains KEY_FORMAT whereas the original statement text does not. Once we enable the feature flag by default, and the test is updated to include KEY_FORMAT in the request, this can be added back in. Same for the other changes in this file.\nIf desirable, we can add a version of these tests with the feature flag enabled and the statementText response check present, but I'm not sure how much value we gain from these particular checks so that doesn't seem worth it.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490672849", "createdAt": "2020-09-18T03:02:09Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "diffHunk": "@@ -15,7 +15,7 @@\n         {\"topic\": \"test_topic\", \"timestamp\": 1234, \"key\": \"key\", \"value\": {\"ID\": 10}}\n       ],\n       \"responses\": [\n-        {\"admin\": {\"@type\": \"currentStatus\", \"statementText\": \"{STATEMENT}\"}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5NzU2Ng==", "bodyText": "Another issue caused by use regenerating the SQL :(\nThe more I think about this, the less I think we need the injector.  The query plan is generated from a combination of the statement and the config, so we have all the information we need to build the plan without injecting the key format. Do that, and all these concerns go away.\nI've knocked together a quick example of what I mean in a draft PR, so take a look: #6254.\nI think this is a cleaner design, and doesn't suffer from the issues you're running into.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490897566", "createdAt": "2020-09-18T11:53:25Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "diffHunk": "@@ -15,7 +15,7 @@\n         {\"topic\": \"test_topic\", \"timestamp\": 1234, \"key\": \"key\", \"value\": {\"ID\": 10}}\n       ],\n       \"responses\": [\n-        {\"admin\": {\"@type\": \"currentStatus\", \"statementText\": \"{STATEMENT}\"}}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3Mjg0OQ=="}, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc0MDk2NQ==", "bodyText": "As discussed in #6254 and offline, we're going to keep the injector since it makes sense for the engine to require key and value formats are present (on CS/CT statements), similar to how it requires schemas be present. As a convenience, however, ksqlDB has a mechanism that allows users to not need to explicitly supply schemas and key/value formats in some cases (schema inference, and via default key/value format configs). These conveniences are handled before the statement enters the engine, which is the role of the injectors. By populating default formats once upfront, the various places in the engine (and in later injectors) that require key and value formats to be present do not each have to handle filling in defaults from the config.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r491740965", "createdAt": "2020-09-20T22:15:53Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "diffHunk": "@@ -15,7 +15,7 @@\n         {\"topic\": \"test_topic\", \"timestamp\": 1234, \"key\": \"key\", \"value\": {\"ID\": 10}}\n       ],\n       \"responses\": [\n-        {\"admin\": {\"@type\": \"currentStatus\", \"statementText\": \"{STATEMENT}\"}}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3Mjg0OQ=="}, "originalCommit": {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTEzNzA0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzowNzoyN1rOHVPHww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMzoyN1rOHVfhoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ==", "bodyText": "You're calling throwOnUnsupportedKeyFormat from within the plan method's try/catch block already, so I don't think you need this try/catch, just let the exception bubble up.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492029891", "createdAt": "2020-09-21T13:07:27Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -342,6 +349,36 @@ private static void throwOnNonExecutableStatement(final ConfiguredStatement<?> s\n     }\n   }\n \n+  private static void throwOnUnsupportedKeyFormat(final ConfiguredStatement<?> statement) {\n+    try {\n+      if (statement.getStatement() instanceof CreateSource) {\n+        final CreateSource createSource = (CreateSource) statement.getStatement();\n+        throwOnUnsupportedKeyFormat(\n+            SourcePropertiesUtil.getKeyFormat(createSource.getProperties()));\n+      }\n+\n+      if (statement.getStatement() instanceof CreateAsSelect) {\n+        final CreateAsSelect createAsSelect = (CreateAsSelect) statement.getStatement();\n+        createAsSelect.getProperties().getKeyFormat()\n+            .ifPresent(EngineExecutor::throwOnUnsupportedKeyFormat);\n+      }\n+    } catch (KsqlStatementException e) {\n+      throw e;\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMTMzNA==", "bodyText": "And for the record... ErrorMessageUtil... yuck!!!! I'd avoid using this class. It's one that should be shot in the head at some point.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492031334", "createdAt": "2020-09-21T13:09:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -342,6 +349,36 @@ private static void throwOnNonExecutableStatement(final ConfiguredStatement<?> s\n     }\n   }\n \n+  private static void throwOnUnsupportedKeyFormat(final ConfiguredStatement<?> statement) {\n+    try {\n+      if (statement.getStatement() instanceof CreateSource) {\n+        final CreateSource createSource = (CreateSource) statement.getStatement();\n+        throwOnUnsupportedKeyFormat(\n+            SourcePropertiesUtil.getKeyFormat(createSource.getProperties()));\n+      }\n+\n+      if (statement.getStatement() instanceof CreateAsSelect) {\n+        final CreateAsSelect createAsSelect = (CreateAsSelect) statement.getStatement();\n+        createAsSelect.getProperties().getKeyFormat()\n+            .ifPresent(EngineExecutor::throwOnUnsupportedKeyFormat);\n+      }\n+    } catch (KsqlStatementException e) {\n+      throw e;\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODY1Nw==", "bodyText": "You're calling throwOnUnsupportedKeyFormat from within the plan method's try/catch block already, so I don't think you need this try/catch, just let the exception bubble up.\n\nGood call. Made the change.\n\nAnd for the record... ErrorMessageUtil... yuck!!!! I'd avoid using this class. It's one that should be shot in the head at some point.\n\nMy use of ErrorMessageUtil was just copy-pasta from other parts of the code but I'm curious what your gripe with it is. Is it not useful to reveal the chain of causation to the user?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492298657", "createdAt": "2020-09-21T19:33:27Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -342,6 +349,36 @@ private static void throwOnNonExecutableStatement(final ConfiguredStatement<?> s\n     }\n   }\n \n+  private static void throwOnUnsupportedKeyFormat(final ConfiguredStatement<?> statement) {\n+    try {\n+      if (statement.getStatement() instanceof CreateSource) {\n+        final CreateSource createSource = (CreateSource) statement.getStatement();\n+        throwOnUnsupportedKeyFormat(\n+            SourcePropertiesUtil.getKeyFormat(createSource.getProperties()));\n+      }\n+\n+      if (statement.getStatement() instanceof CreateAsSelect) {\n+        final CreateAsSelect createAsSelect = (CreateAsSelect) statement.getStatement();\n+        createAsSelect.getProperties().getKeyFormat()\n+            .ifPresent(EngineExecutor::throwOnUnsupportedKeyFormat);\n+      }\n+    } catch (KsqlStatementException e) {\n+      throw e;\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTE1NjgzOnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/SourcePropertiesUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxMjowNVrOHVPTbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxMjowNVrOHVPTbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMjg3Ng==", "bodyText": "I'd suggest putting some java docs on here explaining that the DefaultFormatInjector ensures that the formats are always present, i.e. tie up the code that avoids the Illegal state exception from being thrown with this code.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492032876", "createdAt": "2020-09-21T13:12:05Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/SourcePropertiesUtil.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.properties.with;\n+\n+import io.confluent.ksql.serde.FormatInfo;\n+\n+public final class SourcePropertiesUtil {\n+\n+  private SourcePropertiesUtil() {\n+  }\n+\n+  public static FormatInfo getKeyFormat(final CreateSourceProperties properties) {\n+    return properties.getKeyFormat()\n+        .orElseThrow(() -> new IllegalStateException(\"Key format not present\"));\n+  }\n+\n+  public static FormatInfo getValueFormat(final CreateSourceProperties properties) {\n+    return properties.getValueFormat()\n+        .orElseThrow(() -> new IllegalStateException(\"Value format not present\"));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTE3MDY0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxNToyNVrOHVPb9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMToxNVrOHVfdXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNTA2MA==", "bodyText": "As discussed above, let's only throw if non KAFKA.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492035060", "createdAt": "2020-09-21T13:15:25Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NzU2Ng==", "bodyText": "As discussed offline, this check to throw if KEY_FORMAT or FORMAT was provided without the feature flag enabled has been removed entirely. The engine is responsible for validating the provided format, in the context of the feature flag.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492297566", "createdAt": "2020-09-21T19:31:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNTA2MA=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTE4NTI0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxODo1NlrOHVPk_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOTo1NFrOHVfanA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNzM3Mg==", "bodyText": "nit:\nRather than having a method throwKeyFormatDisabled  that always throws an exception, I'd suggest having a keyFormatDisabledException method that creates the exception:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (createStatement.getProperties().getKeyFormat().isPresent()) {\n          \n          \n            \n                    throwKeyFormatDisabled(statement.getStatementText());\n          \n          \n            \n                  }\n          \n          \n            \n                  if (createStatement.getProperties().getKeyFormat().isPresent()) {\n          \n          \n            \n                    throw keyFormatDisabledException(statement.getStatementText());\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nThe benefit, is that it's easier to grok as you know by looking at the code that an exception is always thrown, without having to go check another function. This pattern can also avoid compiler issues, e.g. warnings and errors about code paths not initializing variables.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492037372", "createdAt": "2020-09-21T13:18:56Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Njg2MA==", "bodyText": "Cool tip! I'm sold.\nUnfortunately these methods were removed as part of the change to allow the use of KEY_FORMAT and FORMAT even if the feature flag is disabled so we won't be able to realize the shinier v2 of this code ;o", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492296860", "createdAt": "2020-09-21T19:29:54Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNzM3Mg=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTIwMTQ5OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoyMjo0MVrOHVPu3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyODowMVrOHVfW0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzOTkwMg==", "bodyText": "As discussed above, the following avoids the need for casting and suppressing warnings in the calling function:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n          \n          \n            \n                  final ConfiguredStatement<CreateSource> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                try {\n          \n          \n            \n                  // Safe to cast as we know `T` is `CreateSource`\n          \n          \n            \n                  return (ConfiguredStatement<T>)\n          \n          \n            \n                      injectForCreateStatement(statement).orElse(statement);\n          \n          \n            \n                } catch (final KsqlStatementException e) {\n          \n          \n            \n                  throw e;\n          \n          \n            \n                } catch (final KsqlException e) {\n          \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (!(statement.getStatement() instanceOf CreateSource) {\n          \n          \n            \n                   throw new IllegalArgumentException(\"blah\");\n          \n          \n            \n                }\n          \n          \n            \n                try {\n          \n          \n            \n                  // Safe to cast as we know `T` is `CreateSource`\n          \n          \n            \n                  return (ConfiguredStatement<T>)\n          \n          \n            \n                      injectForCreateStatement(statement).orElse(statement);\n          \n          \n            \n                } catch (final KsqlStatementException e) {\n          \n          \n            \n                  throw e;\n          \n          \n            \n                } catch (final KsqlException e) {\n          \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nIf you don't link the double checking of types and loss of type safety, then stick with what you have. No biggie.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492039902", "createdAt": "2020-09-21T13:22:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTg5MA==", "bodyText": "Not convinced this is noticeably better. Will leave it as is.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492295890", "createdAt": "2020-09-21T19:28:01Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzOTkwMg=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTI0NjgzOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzozMjo0MlrOHVQLDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNzozMVrOHVfVsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzExNg==", "bodyText": "nit:  this code is correct and works.  However, just a suggestion in terms of the pattern...\nThis code separates the validation from the access.  You first validate the state is what you need, then you access the state.  This works well until someone comes along and changes one side without realizing they should update the other.\nI'd suggest a better pattern is to access the state and validate what you extract. This makes it much harder for someone to come along and miss something, e.g.\nprivate Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n      final ConfiguredStatement<CreateSource> original\n  ) {\n   ....\n \n   final KsqlConfig config = getConfig(original);\n\n    final CreateSourceProperties injectedProps = properties.withFormats(\n        keyFormat.map(FormatInfo::getFormat).orElseGet(() -> getDefaultKeyFormat(config)),\n        valueFormat.map(FormatInfo::getFormat).orElseGet(() -> getDefaultValueFormat(config))\n    );\n\n    ...\n }\n\n private String getDefaultKeyFormat(final KsqlConfig config) {\n     final String format = config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG);\n    if (format == null) {\n        throw new KsqlException(\"Statement is missing the '\"\n          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n          + \"Either provide one or set a default via the '\"\n          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n    }\n\n    return format;\n }\n\n // Same pattern for getDefaultValueFormat\nHere, both the accessing and validating of the default key format is done in one place: the getDefaultKeyFormat method.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492047116", "createdAt": "2020-09-21T13:32:42Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTYwMQ==", "bodyText": "Great tip! Made the change, will also keep this in mind for the future.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492295601", "createdAt": "2020-09-21T19:27:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzExNg=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTI3NDQwOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzozODoyMFrOHVQbmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzozODoyMFrOHVQbmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MTM1Mw==", "bodyText": "Avoid use of ErrorMessageUtil... it's nasty.  How about just:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                  throw new KsqlStatementException(e.getMessage(), statement.getStatementText(), e);", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492051353", "createdAt": "2020-09-21T13:38:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTI4NTMxOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/topic/TopicFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0MDozMlrOHVQiGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0MDozMlrOHVQiGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MzAxNw==", "bodyText": "nit: Pull SourcePropertiesUtil.getKeyFormat(properties) out in to a variable?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492053017", "createdAt": "2020-09-21T13:40:32Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/topic/TopicFactory.java", "diffHunk": "@@ -37,13 +36,16 @@ public static KsqlTopic create(final CreateSourceProperties properties) {\n     final Optional<WindowType> windowType = properties.getWindowType();\n     final Optional<Duration> windowSize = properties.getWindowSize();\n \n+\n     final KeyFormat keyFormat = windowType\n         .map(type -> KeyFormat\n-            .windowed(FormatInfo.of(FormatFactory.KAFKA.name()), WindowInfo.of(type, windowSize)))\n+            .windowed(\n+                SourcePropertiesUtil.getKeyFormat(properties),\n+                WindowInfo.of(type, windowSize)))\n         .orElseGet(() -> KeyFormat\n-            .nonWindowed(FormatInfo.of(FormatFactory.KAFKA.name())));\n+            .nonWindowed(SourcePropertiesUtil.getKeyFormat(properties)));\n \n-    final ValueFormat valueFormat = ValueFormat.of(properties.getFormatInfo());\n+    final ValueFormat valueFormat = ValueFormat.of(SourcePropertiesUtil.getValueFormat(properties));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTMwMjc1OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0NDowNVrOHVQseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0NDowNVrOHVQseQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NTY3Mw==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Injector statementInjector;\n          \n          \n            \n              private Injector formatInjector;", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492055673", "createdAt": "2020-09-21T13:44:05Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -108,6 +110,7 @@\n   private ServiceContext serviceContext;\n   private KsqlEngine engine;\n   private KsqlConfig config;\n+  private Injector statementInjector;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTMwNjE5OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0NDo0M1rOHVQuWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNjoxM1rOHVfTCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NjE1NA==", "bodyText": "Todo: allow... right?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492056154", "createdAt": "2020-09-21T13:44:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -1,22 +1,276 @@\n {\n   \"tests\": [\n     {\n-      \"name\": \"invalid format name\",\n+      \"name\": \"invalid value format\",\n       \"statements\": [\n         \"CREATE STREAM TEST WITH (kafka_topic='test_topic', value_format='FOO');\"\n       ],\n-      \"topics\": [\n-        {\n-          \"name\": \"test_topic\",\n-          \"format\": \"JSON\"\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      }\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      }\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      }\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDkyMA==", "bodyText": "Yup, now that we allow the use of KEY_FORMAT and FORMAT even when the feature flag is disabled I've removed these tests and also removed the explicit enabling of the feature flag from a couple other (otherwise redundant) tests in this file, and added historic plans for them accordingly.", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492294920", "createdAt": "2020-09-21T19:26:13Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/formats.json", "diffHunk": "@@ -1,22 +1,276 @@\n {\n   \"tests\": [\n     {\n-      \"name\": \"invalid format name\",\n+      \"name\": \"invalid value format\",\n       \"statements\": [\n         \"CREATE STREAM TEST WITH (kafka_topic='test_topic', value_format='FOO');\"\n       ],\n-      \"topics\": [\n-        {\n-          \"name\": \"test_topic\",\n-          \"format\": \"JSON\"\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"Unknown format: FOO\"\n+      }\n+    },\n+    {\n+      \"name\": \"missing value format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST WITH (kafka_topic='test_topic');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.parser.exception.ParseFailedException\",\n+        \"message\": \"Failed to prepare statement: Missing required property \\\"VALUE_FORMAT\\\" which has no default value.\"\n+      }\n+    },\n+    {\n+      \"name\": \"key format without feature flag\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (foo VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON', key_format='KAFKA');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The use of 'KEY_FORMAT' and 'FORMAT' is disabled, as this feature is under development.\"\n+      }\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NjE1NA=="}, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTMyNzk2OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0ODo1N1rOHVQ7Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo0ODo1N1rOHVQ7Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1OTQzNQ==", "bodyText": "We shouldn't really be removing this.. it's testing the API is returning the correct statement text with the response.\nTricky...", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492059435", "createdAt": "2020-09-21T13:48:57Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/insert-values.json", "diffHunk": "@@ -15,7 +15,7 @@\n         {\"topic\": \"test_topic\", \"timestamp\": 1234, \"key\": \"key\", \"value\": {\"ID\": 10}}\n       ],\n       \"responses\": [\n-        {\"admin\": {\"@type\": \"currentStatus\", \"statementText\": \"{STATEMENT}\"}}\n+        {\"admin\": {\"@type\": \"currentStatus\"}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTM0MzM4OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlServerMain.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo1MjowNlrOHVREVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzo1MjowNlrOHVREVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2MTc4MQ==", "bodyText": "You upper-case here, but not elsewhere in the code when accessing the property.  Maybe just move the uppercasing into fromName?", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492061781", "createdAt": "2020-09-21T13:52:06Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlServerMain.java", "diffHunk": "@@ -101,6 +102,47 @@ void tryStartApp() throws Exception {\n     }\n   }\n \n+  private static void validateConfig(final KsqlConfig config) {\n+    validateStateDir(config);\n+    validateDefaultTopicFormats(config);\n+  }\n+\n+  private static void validateStateDir(final KsqlConfig config) {\n+    final String streamsStateDirPath = config.getKsqlStreamConfigProps().getOrDefault(\n+        StreamsConfig.STATE_DIR_CONFIG,\n+        StreamsConfig.configDef().defaultValues().get(StreamsConfig.STATE_DIR_CONFIG)).toString();\n+    enforceStreamStateDirAvailability(new File(streamsStateDirPath));\n+  }\n+\n+  @VisibleForTesting\n+  static void validateDefaultTopicFormats(final KsqlConfig config) {\n+    validateTopicFormat(config, KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG, \"key\");\n+    validateTopicFormat(config, KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG, \"value\");\n+  }\n+\n+  private static void validateTopicFormat(\n+      final KsqlConfig config,\n+      final String configName,\n+      final String type\n+  ) {\n+    final String formatName = config.getString(configName);\n+    if (formatName == null) {\n+      return;\n+    }\n+\n+    final Format format;\n+    try {\n+      format = FormatFactory.fromName(formatName.toUpperCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2779, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}