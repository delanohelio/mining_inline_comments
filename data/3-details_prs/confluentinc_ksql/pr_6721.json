{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNzQ2NDA5", "number": 6721, "title": "docs: klip-42 - Schema Migrations Tool", "bodyText": "Description\nKLIP for the new schema migrations tool.\nTesting done\nDescribe the testing strategy. Unit and integration tests are expected for any behavior changes.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-12-04T19:41:51Z", "url": "https://github.com/confluentinc/ksql/pull/6721", "merged": true, "mergeCommit": {"oid": "1eb971ffbb103942e79937a3e2b76c867e383d7c"}, "closed": true, "closedAt": "2020-12-14T22:27:53Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdi9FZjAH2gAyNTMyNzQ2NDA5OmU2YWIxZmYzNzZmYjM4OWYwNGQ3M2MwN2Y1YWJhZjZhOGNhYjAwMjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmz9T4gFqTU1Mzk4ODQxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/e6ab1ff376fb389f04d73c07f5abaf6a8cab0022", "committedDate": "2020-12-04T19:40:46Z", "message": "docs: klip-42 - Schema Migrations Tool"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzY2NTAw", "url": "https://github.com/confluentinc/ksql/pull/6721#pullrequestreview-545366500", "createdAt": "2020-12-04T23:43:25Z", "commit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo0MzoyNlrOH_mKqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo0OToxOVrOH_mRLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0NzY1OA==", "bodyText": "Is squashing (periodically combining all previous migrations into one) out of scope? I don't think it needs to be a v1 thing, but this is historically important because over time, the value of having all migrations around diminishes.", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r536447658", "createdAt": "2020-12-04T23:43:26Z", "author": {"login": "MichaelDrogalis"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0ODQ2Ng==", "bodyText": "One other thing that I think would be really useful would be producing a consolidated view of all the statements in one file. Rails, and I think Django, do this so you can see what is going on in one place. This consolidated view is typically checked into version control, and is always treated as read-only. @derekjn had some ideas about how this relates to or could be subsumed by supporting schema dumping.", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r536448466", "createdAt": "2020-12-04T23:46:16Z", "author": {"login": "MichaelDrogalis"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0ODc3Mg==", "bodyText": "Is there any ceremony around the description, or can it be whatever? It looks like that is how you make those nice printouts when you migrate?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r536448772", "createdAt": "2020-12-04T23:47:21Z", "author": {"login": "MichaelDrogalis"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`\n+```sql\n+DROP TABLE users;\n+```\n+\n+The user runs the migration tool on the ksqlDB cluster. The tool detects the cluster has version 2, so it executes only the undo file for version 2.  \n+It then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations undo\n+Current version of schema: 2\n+Undoing migration of schema to version 2 - Add users\n+```\n+\n+The `undo` action will only revert the previous change. It will not attempt to undo all applied migrations.\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) or undo (`U`) file.\n+The `Version` is the version number used for the schema. For minor versions, such as `1.1`, an underscore is required (i.e. `1_1`)\n+The `Description` is just a name or description of the new migration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0OTAyMg==", "bodyText": "Is it worthwhile to support these as Docker environment variables, as we do with our general server configuration?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r536449022", "createdAt": "2020-12-04T23:48:16Z", "author": {"login": "MichaelDrogalis"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`\n+```sql\n+DROP TABLE users;\n+```\n+\n+The user runs the migration tool on the ksqlDB cluster. The tool detects the cluster has version 2, so it executes only the undo file for version 2.  \n+It then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations undo\n+Current version of schema: 2\n+Undoing migration of schema to version 2 - Add users\n+```\n+\n+The `undo` action will only revert the previous change. It will not attempt to undo all applied migrations.\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) or undo (`U`) file.\n+The `Version` is the version number used for the schema. For minor versions, such as `1.1`, an underscore is required (i.e. `1_1`)\n+The `Description` is just a name or description of the new migration.\n+\n+i.e.\n+```\n+- V1__Initial_setup.sql    # a new version to migrate (v1)\n+- U1__Initial_setup.sql    # rollback v1 schema\n+- V2__Add_users.sql        # a new version to migrate (v2)\n+- U2__Add_users.sql        # rollback v2 schema\n+- V2_1__Fix_topic_name.sql # A new version to migrate (v2.1)\n+- U2_1__Fix_topic_name.sql # rollback v2.1 schema\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recomendation in the ksqlDB documents.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  initialize   Initializes the schema version table\n+\n+  apply ( all | next | until <target> )\n+  \n+              Migrates a schema to new available schema versions (default: next)\n+              \n+              If 'all' is specified, then it migrates all newer versions available\n+              If 'next' is specified, then it migrates only the next available version\n+              If 'until <target>' is specified, then it migrates all available versions before <target>\n+  \n+  undo ( all | last | until <target> )\n+  \n+              Rollbacks a schema to the previous schema version (default: last)\n+              \n+              If 'all' is specified, then it rollbacks all previous versions\n+              If 'last' is specified, then it rollbacks the previous version\n+              If 'until <target>' is specified, then it rollbacks all previous versions after <target>\n+  \n+  info        Displays information about the current and available migrations\n+  \n+  baseline    Sets the current schema to the specified version\n+  \n+              This is useful when production environments already have a schema unversioned. This sets\n+              the baseline from where to start applying migrations (i.e. kqsl-migrations baseline 1 'Current State')\n+  \n+  clean       Cleans the schema metadata objects                \n+  \n+  validate    Validate applied migrations against local files\n+  \n+              Compares local files checksum against the current metadata checksums to check for migrations files that have changed.\n+              This tells the user that their schema might be not valid against their local files.\n+  \n+Options\n+  -c, --config-file  Specifies a configuration file\n+ \n+  -h, --help         Shows this help  \n+    \n+```\n+\n+### Configurations\n+\n+The tool will support a configuration file where all details for the server and tool migrations will be set. The following\n+are the basic configurations that the tool should support.\n+\n+Example of `ksql-migrations.properties`\n+```\n+# Server URL and authentication", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0OTMyNg==", "bodyText": "What would happen if multiple CI servers tried to migrate against the same cluster at the same time? Put differently, what sort of race conditions can happen?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r536449326", "createdAt": "2020-12-04T23:49:19Z", "author": {"login": "MichaelDrogalis"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`\n+```sql\n+DROP TABLE users;\n+```\n+\n+The user runs the migration tool on the ksqlDB cluster. The tool detects the cluster has version 2, so it executes only the undo file for version 2.  \n+It then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations undo\n+Current version of schema: 2\n+Undoing migration of schema to version 2 - Add users\n+```\n+\n+The `undo` action will only revert the previous change. It will not attempt to undo all applied migrations.\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) or undo (`U`) file.\n+The `Version` is the version number used for the schema. For minor versions, such as `1.1`, an underscore is required (i.e. `1_1`)\n+The `Description` is just a name or description of the new migration.\n+\n+i.e.\n+```\n+- V1__Initial_setup.sql    # a new version to migrate (v1)\n+- U1__Initial_setup.sql    # rollback v1 schema\n+- V2__Add_users.sql        # a new version to migrate (v2)\n+- U2__Add_users.sql        # rollback v2 schema\n+- V2_1__Fix_topic_name.sql # A new version to migrate (v2.1)\n+- U2_1__Fix_topic_name.sql # rollback v2.1 schema\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recomendation in the ksqlDB documents.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  initialize   Initializes the schema version table\n+\n+  apply ( all | next | until <target> )\n+  \n+              Migrates a schema to new available schema versions (default: next)\n+              \n+              If 'all' is specified, then it migrates all newer versions available\n+              If 'next' is specified, then it migrates only the next available version\n+              If 'until <target>' is specified, then it migrates all available versions before <target>\n+  \n+  undo ( all | last | until <target> )\n+  \n+              Rollbacks a schema to the previous schema version (default: last)\n+              \n+              If 'all' is specified, then it rollbacks all previous versions\n+              If 'last' is specified, then it rollbacks the previous version\n+              If 'until <target>' is specified, then it rollbacks all previous versions after <target>\n+  \n+  info        Displays information about the current and available migrations\n+  \n+  baseline    Sets the current schema to the specified version\n+  \n+              This is useful when production environments already have a schema unversioned. This sets\n+              the baseline from where to start applying migrations (i.e. kqsl-migrations baseline 1 'Current State')\n+  \n+  clean       Cleans the schema metadata objects                \n+  \n+  validate    Validate applied migrations against local files\n+  \n+              Compares local files checksum against the current metadata checksums to check for migrations files that have changed.\n+              This tells the user that their schema might be not valid against their local files.\n+  \n+Options\n+  -c, --config-file  Specifies a configuration file\n+ \n+  -h, --help         Shows this help  \n+    \n+```\n+\n+### Configurations\n+\n+The tool will support a configuration file where all details for the server and tool migrations will be set. The following\n+are the basic configurations that the tool should support.\n+\n+Example of `ksql-migrations.properties`\n+```\n+# Server URL and authentication\n+ksql.server.url='http://localhost:8080'\n+ksql.username='user1'\n+ksql.password='pass1'\n+\n+# Migrations details\n+ksql.migrations.stream.name='migration_events'\n+ksql.migrations.table.name='schema_version'\n+```\n+\n+Note: The command line options and other configurations will also be defined during the implementation.\n+\n+### Questions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 410}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MjkxMzc3", "url": "https://github.com/confluentinc/ksql/pull/6721#pullrequestreview-546291377", "createdAt": "2020-12-07T16:01:17Z", "commit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjowMToxN1rOIAt4HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjoyNzowMVrOIAvHrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYyMjU1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `U2_Add_users.sql`\n          \n          \n            \n            `U2__Add_users.sql`", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r537622556", "createdAt": "2020-12-07T16:01:17Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYzMTE2Ng==", "bodyText": "I would expect that it would apply all migrations up to and including the target. I noticed this is also the behavior of dbgeni.", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r537631166", "createdAt": "2020-12-07T16:11:57Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`\n+```sql\n+DROP TABLE users;\n+```\n+\n+The user runs the migration tool on the ksqlDB cluster. The tool detects the cluster has version 2, so it executes only the undo file for version 2.  \n+It then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations undo\n+Current version of schema: 2\n+Undoing migration of schema to version 2 - Add users\n+```\n+\n+The `undo` action will only revert the previous change. It will not attempt to undo all applied migrations.\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) or undo (`U`) file.\n+The `Version` is the version number used for the schema. For minor versions, such as `1.1`, an underscore is required (i.e. `1_1`)\n+The `Description` is just a name or description of the new migration.\n+\n+i.e.\n+```\n+- V1__Initial_setup.sql    # a new version to migrate (v1)\n+- U1__Initial_setup.sql    # rollback v1 schema\n+- V2__Add_users.sql        # a new version to migrate (v2)\n+- U2__Add_users.sql        # rollback v2 schema\n+- V2_1__Fix_topic_name.sql # A new version to migrate (v2.1)\n+- U2_1__Fix_topic_name.sql # rollback v2.1 schema\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recomendation in the ksqlDB documents.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  initialize   Initializes the schema version table\n+\n+  apply ( all | next | until <target> )\n+  \n+              Migrates a schema to new available schema versions (default: next)\n+              \n+              If 'all' is specified, then it migrates all newer versions available\n+              If 'next' is specified, then it migrates only the next available version\n+              If 'until <target>' is specified, then it migrates all available versions before <target>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYzMTk4Mw==", "bodyText": "Can we consider previous instead? I think this mirrors apply's next option better, personally.", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r537631983", "createdAt": "2020-12-07T16:13:03Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`\n+```sql\n+DROP TABLE users;\n+```\n+\n+The user runs the migration tool on the ksqlDB cluster. The tool detects the cluster has version 2, so it executes only the undo file for version 2.  \n+It then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations undo\n+Current version of schema: 2\n+Undoing migration of schema to version 2 - Add users\n+```\n+\n+The `undo` action will only revert the previous change. It will not attempt to undo all applied migrations.\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) or undo (`U`) file.\n+The `Version` is the version number used for the schema. For minor versions, such as `1.1`, an underscore is required (i.e. `1_1`)\n+The `Description` is just a name or description of the new migration.\n+\n+i.e.\n+```\n+- V1__Initial_setup.sql    # a new version to migrate (v1)\n+- U1__Initial_setup.sql    # rollback v1 schema\n+- V2__Add_users.sql        # a new version to migrate (v2)\n+- U2__Add_users.sql        # rollback v2 schema\n+- V2_1__Fix_topic_name.sql # A new version to migrate (v2.1)\n+- U2_1__Fix_topic_name.sql # rollback v2.1 schema\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recomendation in the ksqlDB documents.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  initialize   Initializes the schema version table\n+\n+  apply ( all | next | until <target> )\n+  \n+              Migrates a schema to new available schema versions (default: next)\n+              \n+              If 'all' is specified, then it migrates all newer versions available\n+              If 'next' is specified, then it migrates only the next available version\n+              If 'until <target>' is specified, then it migrates all available versions before <target>\n+  \n+  undo ( all | last | until <target> )\n+  \n+              Rollbacks a schema to the previous schema version (default: last)\n+              \n+              If 'all' is specified, then it rollbacks all previous versions\n+              If 'last' is specified, then it rollbacks the previous version", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0MDcyMw==", "bodyText": "How feasible would it be to support variables / --define as a ksql-migrate CLI option?\nLet's say I want to apply the same migration in dev and prod, but the topic names I use are different between environments. If I could specify kafka_topic='${topicName}' in my migration, I could reuse the migration with ksql-migrate apply -d topicName=dev-mytopic.", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r537640723", "createdAt": "2020-12-07T16:24:18Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied or undone.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `undoable` column specifies if the migration can be undone or not. This requires an undoable migration file (See `Undo migrations`).\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied (migrated or undone). This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state, \n+    latest_by_offset(undoable) AS undoable, \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | undoable | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | No       | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | No       | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+When undo changes happen, the query will first get the current schema version to undo. Apply the revert operations, then set `CURRENT` to\n+the previous migrated version. In this case, it will look at the `previous` column in `SCHEMA_VERSION`, then use a pull query to get information\n+about the previous migration.\n+```sql\n+SELECT * FROM SCHEMA_VERSION WHERE version_key = '<previous>';\n+```\n+\n+And set the new `CURRENT` in the `MIGRATION_EVENTS` to update the current schema version.\n+\n+### Undo migrations\n+\n+Undo a previous migration is necessary in the application lifecycle. A user sometimes want to revert the changes of an application because of a bug found in it.\n+This also requires the database schema to be reverted or rollback to the previous version.\n+\n+The migrations tool allows users to revert changes. Note that undo is considered a forward migration. A new migration file is required which contains\n+the SQL operations to revert the changes of a previous migration. The file in this case should contain the `U` prefix with the version number of the migration to rollback.\n+\n+For instance, let's undo the migration version 2 applied before. The migration file used before was named `V2__Add_users.sql`. For the undo file, we should add the `U` prefix.\n+\n+`U2_Add_users.sql`\n+```sql\n+DROP TABLE users;\n+```\n+\n+The user runs the migration tool on the ksqlDB cluster. The tool detects the cluster has version 2, so it executes only the undo file for version 2.  \n+It then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations undo\n+Current version of schema: 2\n+Undoing migration of schema to version 2 - Add users\n+```\n+\n+The `undo` action will only revert the previous change. It will not attempt to undo all applied migrations.\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) or undo (`U`) file.\n+The `Version` is the version number used for the schema. For minor versions, such as `1.1`, an underscore is required (i.e. `1_1`)\n+The `Description` is just a name or description of the new migration.\n+\n+i.e.\n+```\n+- V1__Initial_setup.sql    # a new version to migrate (v1)\n+- U1__Initial_setup.sql    # rollback v1 schema\n+- V2__Add_users.sql        # a new version to migrate (v2)\n+- U2__Add_users.sql        # rollback v2 schema\n+- V2_1__Fix_topic_name.sql # A new version to migrate (v2.1)\n+- U2_1__Fix_topic_name.sql # rollback v2.1 schema\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recomendation in the ksqlDB documents.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  initialize   Initializes the schema version table\n+\n+  apply ( all | next | until <target> )\n+  \n+              Migrates a schema to new available schema versions (default: next)\n+              \n+              If 'all' is specified, then it migrates all newer versions available\n+              If 'next' is specified, then it migrates only the next available version\n+              If 'until <target>' is specified, then it migrates all available versions before <target>\n+  \n+  undo ( all | last | until <target> )\n+  \n+              Rollbacks a schema to the previous schema version (default: last)\n+              \n+              If 'all' is specified, then it rollbacks all previous versions\n+              If 'last' is specified, then it rollbacks the previous version\n+              If 'until <target>' is specified, then it rollbacks all previous versions after <target>\n+  \n+  info        Displays information about the current and available migrations\n+  \n+  baseline    Sets the current schema to the specified version\n+  \n+              This is useful when production environments already have a schema unversioned. This sets\n+              the baseline from where to start applying migrations (i.e. kqsl-migrations baseline 1 'Current State')\n+  \n+  clean       Cleans the schema metadata objects                \n+  \n+  validate    Validate applied migrations against local files\n+  \n+              Compares local files checksum against the current metadata checksums to check for migrations files that have changed.\n+              This tells the user that their schema might be not valid against their local files.\n+  \n+Options\n+  -c, --config-file  Specifies a configuration file\n+ \n+  -h, --help         Shows this help  \n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0MjkyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.\n          \n          \n            \n            The `version_key` column has the version of the migration applied or undone. Special values of the `version_key`, `CURRENT` and `LATEST`, will be reserved for internal purposes.", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r537642924", "createdAt": "2020-12-07T16:27:01Z", "author": {"login": "colinhicks"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## What is in scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Rollback migrated schemas to previous versions\n+    - Version control ksqlDB schema\n+\n+* Provide a test plan that validates the new tool will meet the product requirements\n+\n+\n+## What is not in scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated or dry-runs executions`\n+\n+    A dry-run requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V1__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V2__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,\n+  undoable     BOOLEAN,\n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Other keys `CURRENT` and `LATEST` will be reserved for internal purposes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6ab1ff376fb389f04d73c07f5abaf6a8cab0022"}, "originalPosition": 210}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ea065a55fa3e58f996af20f9dc1aa3f6313753c", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/3ea065a55fa3e58f996af20f9dc1aa3f6313753c", "committedDate": "2020-12-07T18:12:43Z", "message": "chore: address PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e172944f818f53135de579144895372291a54a59", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/e172944f818f53135de579144895372291a54a59", "committedDate": "2020-12-07T21:38:39Z", "message": "chore: add '--define' parameters to migrations tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee3551315470b1c97ef82ba8737a8aa8fcbc26f5", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/ee3551315470b1c97ef82ba8737a8aa8fcbc26f5", "committedDate": "2020-12-11T20:51:10Z", "message": "chore: remove 'undoable' field from schema metadata\n\nThe 'undoable' field will be derived from the migration files. This\nfield is not needed in the stream object."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53bd8898107b89b3e4af8bebcc01a60ac9a27d9e", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/53bd8898107b89b3e4af8bebcc01a60ac9a27d9e", "committedDate": "2020-12-11T21:27:29Z", "message": "chore: add Directory structure section"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNzE1MzY5", "url": "https://github.com/confluentinc/ksql/pull/6721#pullrequestreview-551715369", "createdAt": "2020-12-14T17:49:54Z", "commit": {"oid": "ed219807bfb6f4765b5efb553a019273f2eab71e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNzo0OTo1NFrOIFcrJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNzo0OTo1NFrOIFcrJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU4MzU5MA==", "bodyText": "sumlation\n\nTypo", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r542583590", "createdAt": "2020-12-14T17:49:54Z", "author": {"login": "derekjn"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.16 |\n+**Status**: _In Discussion_ |\n+**Discussion**: https://github.com/confluentinc/ksql/pull/6721\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## In scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Dry-run operations to verify what migrations will be applied without altering the cluster\n+    - Version control ksqlDB schema\n+\n+\n+## Out of scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated executions`\n+\n+    A sumlation requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed219807bfb6f4765b5efb553a019273f2eab71e"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNzE2MjA1", "url": "https://github.com/confluentinc/ksql/pull/6721#pullrequestreview-551716205", "createdAt": "2020-12-14T17:50:21Z", "commit": {"oid": "ed219807bfb6f4765b5efb553a019273f2eab71e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed219807bfb6f4765b5efb553a019273f2eab71e", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/ed219807bfb6f4765b5efb553a019273f2eab71e", "committedDate": "2020-12-14T16:07:39Z", "message": "chore: Update KLIP with Derek's feedback\n\n- Use integer versions instead of decimal verions\n- Add undo as future work\n- Add dry-run support"}, "afterCommit": {"oid": "f7572bc7bec4b0c1acd00955f35cb5eec5e5e87f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f7572bc7bec4b0c1acd00955f35cb5eec5e5e87f", "committedDate": "2020-12-14T20:03:39Z", "message": "chore: Update KLIP with Derek's feedback\n\n- Use integer versions instead of decimal verions\n- Add undo as future work\n- Add dry-run support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/7bc5875896c0206574e096c0ead808b5a87caa89", "committedDate": "2020-12-14T20:04:20Z", "message": "chore: Update KLIP with Derek's feedback\n\n- Use integer versions instead of decimal verions\n- Add undo as future work\n- Add dry-run support"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7572bc7bec4b0c1acd00955f35cb5eec5e5e87f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f7572bc7bec4b0c1acd00955f35cb5eec5e5e87f", "committedDate": "2020-12-14T20:03:39Z", "message": "chore: Update KLIP with Derek's feedback\n\n- Use integer versions instead of decimal verions\n- Add undo as future work\n- Add dry-run support"}, "afterCommit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/7bc5875896c0206574e096c0ead808b5a87caa89", "committedDate": "2020-12-14T20:04:20Z", "message": "chore: Update KLIP with Derek's feedback\n\n- Use integer versions instead of decimal verions\n- Add undo as future work\n- Add dry-run support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzOTg4NDEx", "url": "https://github.com/confluentinc/ksql/pull/6721#pullrequestreview-553988411", "createdAt": "2020-12-16T18:53:51Z", "commit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxODo1Mzo1MVrOIHURIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOToxNjoxMlrOIHVH_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0MzAxMQ==", "bodyText": "at the moment, pull queries don't give us any consistency guarantees. if we query at different times and different replicas we may get not-up-to-date information. is that problematic for this design?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r544543011", "createdAt": "2020-12-16T18:53:51Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.16 |\n+**Status**: _Design Approved_ |\n+**Discussion**: https://github.com/confluentinc/ksql/pull/6721\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## In scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Dry-run operations to verify what migrations will be applied without altering the cluster\n+    - Version control ksqlDB schema\n+\n+\n+## Out of scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated executions`\n+\n+    A simulation requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+* Squash several migration files into one\n+\n+  This is a very important functionality users may want to use. Over time, users may have several small migration files that can be squashed\n+  into one single file. However, this functionality gets out of scope for the migrations tool. It is easier to write a ksqlDB metastore tool\n+  that exports the cluster metadata to a SQL file, then use this SQL file as a replacement for the user migrations scripts.\n+\n+## Future work\n+\n+* `Undo migrated schemas to previous versions`\n+\n+  ksqlDB has a few statements that support undo, and some of them are limited. The first version for migrations will not support this feature.\n+  Detailed information about undo is explained in the document for future reference. Also, the schema metadata (See Schema metadata) needs to\n+  be prepared with future undo operations.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V000001__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V000002__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+All migration files will support only integer versions (no decimal versions). Integer versions are easier to sort when are found in the file name. Also, there are\n+too few cases that require decimal versioning (i.e. `1.1`) in schema changes. We don't expect users to use decimal versions on ksqlDB migrations.\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,  \n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Special values of the `version_key`, `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including future work for undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NTUwOQ==", "bodyText": "these will be output every time, right? so the actual stream would also have this after the first event with both of them pointing to 1?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r544545509", "createdAt": "2020-12-16T18:57:24Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.16 |\n+**Status**: _Design Approved_ |\n+**Discussion**: https://github.com/confluentinc/ksql/pull/6721\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## In scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Dry-run operations to verify what migrations will be applied without altering the cluster\n+    - Version control ksqlDB schema\n+\n+\n+## Out of scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated executions`\n+\n+    A simulation requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+* Squash several migration files into one\n+\n+  This is a very important functionality users may want to use. Over time, users may have several small migration files that can be squashed\n+  into one single file. However, this functionality gets out of scope for the migrations tool. It is easier to write a ksqlDB metastore tool\n+  that exports the cluster metadata to a SQL file, then use this SQL file as a replacement for the user migrations scripts.\n+\n+## Future work\n+\n+* `Undo migrated schemas to previous versions`\n+\n+  ksqlDB has a few statements that support undo, and some of them are limited. The first version for migrations will not support this feature.\n+  Detailed information about undo is explained in the document for future reference. Also, the schema metadata (See Schema metadata) needs to\n+  be prepared with future undo operations.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V000001__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V000002__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+All migration files will support only integer versions (no decimal versions). Integer versions are easier to sort when are found in the file name. Also, there are\n+too few cases that require decimal versioning (i.e. `1.1`) in schema changes. We don't expect users to use decimal versions on ksqlDB migrations.\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,  \n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Special values of the `version_key`, `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including future work for undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied. This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+*Note:*\n+The below schema is designed so we support undo operations in the future. When an undo happens, the `CURRENT` key will point to the previous version found.\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state,     \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NjcyNQ==", "bodyText": "which two files?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r544546725", "createdAt": "2020-12-16T18:59:13Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.16 |\n+**Status**: _Design Approved_ |\n+**Discussion**: https://github.com/confluentinc/ksql/pull/6721\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## In scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Dry-run operations to verify what migrations will be applied without altering the cluster\n+    - Version control ksqlDB schema\n+\n+\n+## Out of scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated executions`\n+\n+    A simulation requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+* Squash several migration files into one\n+\n+  This is a very important functionality users may want to use. Over time, users may have several small migration files that can be squashed\n+  into one single file. However, this functionality gets out of scope for the migrations tool. It is easier to write a ksqlDB metastore tool\n+  that exports the cluster metadata to a SQL file, then use this SQL file as a replacement for the user migrations scripts.\n+\n+## Future work\n+\n+* `Undo migrated schemas to previous versions`\n+\n+  ksqlDB has a few statements that support undo, and some of them are limited. The first version for migrations will not support this feature.\n+  Detailed information about undo is explained in the document for future reference. Also, the schema metadata (See Schema metadata) needs to\n+  be prepared with future undo operations.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V000001__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V000002__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+All migration files will support only integer versions (no decimal versions). Integer versions are easier to sort when are found in the file name. Also, there are\n+too few cases that require decimal versioning (i.e. `1.1`) in schema changes. We don't expect users to use decimal versions on ksqlDB migrations.\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,  \n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Special values of the `version_key`, `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including future work for undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied. This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+*Note:*\n+The below schema is designed so we support undo operations in the future. When an undo happens, the `CURRENT` key will point to the previous version found.\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state,     \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) file. The prefix is used so that we can add other operations in the future, such as undo operations.\n+The `Version` is the version number used for the schema. Versions will not support decimal versions. Integers with 6 digits are used.\n+The `Description` is a name or description of the new migration. Description uses underscores (automatically replaced by spaces at runtime) or spaces separated the words.\n+\n+i.e.\n+```\n+- V000001__Initial_setup.sql    # a new version to migrate (v1) with name 'Initial setup'\n+- V000002__Add_users.sql        # a new version to migrate (v2) with name 'Add users'\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recommendation in the ksqlDB documents.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0ODUxOA==", "bodyText": "what happens if the user tries to initialize twice? I assume we should detect and fail?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r544548518", "createdAt": "2020-12-16T19:01:56Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.16 |\n+**Status**: _Design Approved_ |\n+**Discussion**: https://github.com/confluentinc/ksql/pull/6721\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## In scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Dry-run operations to verify what migrations will be applied without altering the cluster\n+    - Version control ksqlDB schema\n+\n+\n+## Out of scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated executions`\n+\n+    A simulation requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+* Squash several migration files into one\n+\n+  This is a very important functionality users may want to use. Over time, users may have several small migration files that can be squashed\n+  into one single file. However, this functionality gets out of scope for the migrations tool. It is easier to write a ksqlDB metastore tool\n+  that exports the cluster metadata to a SQL file, then use this SQL file as a replacement for the user migrations scripts.\n+\n+## Future work\n+\n+* `Undo migrated schemas to previous versions`\n+\n+  ksqlDB has a few statements that support undo, and some of them are limited. The first version for migrations will not support this feature.\n+  Detailed information about undo is explained in the document for future reference. Also, the schema metadata (See Schema metadata) needs to\n+  be prepared with future undo operations.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V000001__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V000002__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+All migration files will support only integer versions (no decimal versions). Integer versions are easier to sort when are found in the file name. Also, there are\n+too few cases that require decimal versioning (i.e. `1.1`) in schema changes. We don't expect users to use decimal versions on ksqlDB migrations.\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,  \n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Special values of the `version_key`, `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including future work for undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied. This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+*Note:*\n+The below schema is designed so we support undo operations in the future. When an undo happens, the `CURRENT` key will point to the previous version found.\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state,     \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) file. The prefix is used so that we can add other operations in the future, such as undo operations.\n+The `Version` is the version number used for the schema. Versions will not support decimal versions. Integers with 6 digits are used.\n+The `Description` is a name or description of the new migration. Description uses underscores (automatically replaced by spaces at runtime) or spaces separated the words.\n+\n+i.e.\n+```\n+- V000001__Initial_setup.sql    # a new version to migrate (v1) with name 'Initial setup'\n+- V000002__Add_users.sql        # a new version to migrate (v2) with name 'Add users'\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recommendation in the ksqlDB documents.\n+\n+### Dry-runs\n+\n+A dry-run for ksqlDB migrations will only verify what migrations will be applied in the cluster. It will not attempt to execute or simulate any migration statement found in the files. This\n+feature will allow users to test that migration files have the right version and description names as well as know what migrations will be applied in a determined cluster.\n+\n+### Directory structure\n+\n+The migrations tool will use following directory structure:\n+\n+<migrations-project-dir>\n+|\n+|- ksql-migrations.properties\n+|- migrations/\n+\n+When the migrations tool is executed, it will look at the `migrations` directory (by default) for SQL migration files to execute. This directory can be modified in the  \n+configuration file or command line parameters.\n+\n+If the `ksql-migrations.properties` exist in the root directory, then it will use the configuration provided by the file.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  new  <project-path>  Creates a new migrations project, directory structure and config file.\n+\n+  initialize   Initializes the schema version table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU1NzA1NQ==", "bodyText": "do you have a description of how these integrations would look like? is that in-scope here or is that something that each developer would integrate on their own?", "url": "https://github.com/confluentinc/ksql/pull/6721#discussion_r544557055", "createdAt": "2020-12-16T19:16:12Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-42-schema-migrations-tool.md", "diffHunk": "@@ -0,0 +1,442 @@\n+# KLIP 42 - Schema Migrations Tool\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.16 |\n+**Status**: _Design Approved_ |\n+**Discussion**: https://github.com/confluentinc/ksql/pull/6721\n+\n+**tl;dr:** _New tool to provide ksqlDB users for easy and automated schema migrations for their\n+           ksqlDB environments. This allows users to version control their ksqlDB schema; recreate\n+           their schema from scratch; and migrate their current schema to newer versions._\n+\n+## Motivation and background\n+\n+Schema migrations (also database migrations) refers to the process of performing updates or rollbacks on a database schema to a\n+newer or older schema version. This practice is pretty common in any application lifecycle. Users use a version control for their\n+applications which allow them to know if an application requires an upgrade or rolling back a buggy change. The same is necessary\n+with a database schema. Users look for ways to version control schema changes along the application lifecycle.\n+\n+Existing tools exist to perform schema migrations on any database (MySQL, Postgres, Oracle, etc). These tools allow users to\n+version the database schema, then automate the process to easily upgrade the schema to a newer version. If a schema is buggy,\n+then users can rollback to the previous schema version. One more reason for using these tools is the integration with any\n+CI/CD system, which allows users to test and verify a schema upgrade will work as expected.\n+\n+You can learn more about these existing tools:\n+- [Flyway](https://flywaydb.org/)\n+- [Liquibase](https://www.liquibase.org/)\n+- [DBGeni](http://dbgeni.appsintheopen.com/index.html)\n+\n+ksqlDB requires the same kind of integration with CI/CD systems and automation to deploy ksqlDB schema changes in any environment.\n+Some tools, like `Flyway`, support plugins to integrate schema migrations with a different non-supported database. However, our\n+syntax is exclusively to ksqlDB; tools require JDBC support; and tools have several features that we cannot support\n+(i.e. transactions & databases); so this integration becomes complex or unsupported. For that reason, ksqlDB must have its own\n+schema migrations tool to provide the same migrations benefits to users who want to easily deploy and automate ksqlDB schema\n+changes in all their ksqlDB environments.\n+\n+These benefits include:\n+- Version the ksqlDB schema environments\n+- Integrate ksqlDB schema changes with CI/CD environments\n+- Simplify schema evolution changes across different environments\n+\n+This KLIP proposes a new tool for schema migrations. You will learn about the design aspects of the tool, and the features\n+to support for a basic schema migration process.\n+\n+## In scope\n+\n+* Discuss design details for a new tool that provides schema migrations support for ksqlDB\n+\n+    Basic features to support:\n+    - New CLI and API that can easily integrate with CI/CD environments\n+    - Apply migrations on any ksqlDB environments\n+    - Dry-run operations to verify what migrations will be applied without altering the cluster\n+    - Version control ksqlDB schema\n+\n+\n+## Out of scope\n+\n+* Some features found in existing migrations tools won't be supported\n+\n+  - `Execute entire migrations in a single transaction`\n+\n+    ksqlDB has support for a transactional metastore. However, this is limited to DDL statements that are persisted in the\n+    Command topic. But DML statements, such as INSERT, write directly to the topic and do not work with transactions. This disallows\n+    our tool to provide of a transaction support for the whole migration process. Also, DDL statements may create or delete topics,\n+    which falls in the non-transactional process.\n+\n+  - `Support for simulated executions`\n+\n+    A simulation requires the tool to know the current state of the ksqlDB schema before attempting to verify the new migrations scripts. This\n+    requires a ksqlDB metastore exporting tool to work. Also, to make this simulation 100% safe, the tool requires a dummy Kafka and SR\n+    environment that can validate issues with topics and SR subjects names, as well as security restrictions.\n+\n+  - `Other features, such as repeatable migrations and callbacks`\n+\n+    Not required for a basic migration.\n+\n+* Do performance analysis on migrations\n+\n+  In other DBs, there are operations that take too much time to complete. Such is the case of ALTER statements, which can add/remove columns\n+  that would take time to complete on large tables. ksqlDB operations are quick unless an issue with the ksqlDB environment affects\n+  these executions.\n+\n+* Squash several migration files into one\n+\n+  This is a very important functionality users may want to use. Over time, users may have several small migration files that can be squashed\n+  into one single file. However, this functionality gets out of scope for the migrations tool. It is easier to write a ksqlDB metastore tool\n+  that exports the cluster metadata to a SQL file, then use this SQL file as a replacement for the user migrations scripts.\n+\n+## Future work\n+\n+* `Undo migrated schemas to previous versions`\n+\n+  ksqlDB has a few statements that support undo, and some of them are limited. The first version for migrations will not support this feature.\n+  Detailed information about undo is explained in the document for future reference. Also, the schema metadata (See Schema metadata) needs to\n+  be prepared with future undo operations.\n+\n+## Value/Return\n+\n+Users will be able to integrate ksqlDB upgrades testing with any CI/CD environments of their choice. This is a huge benefit for users who want\n+to automate ksqlDB upgrades with their application lifecycle.\n+\n+Also, a new tool will let users to easily automate schema evolution and migrations changes. They will be able to deploy new schema changes in\n+all their environments (Prod, QA, Devel, etc).\n+\n+## Public APIS\n+\n+- No changes on current public APIs\n+- A new Java API for Java developers\n+\n+  This seems important. However, it is in consideration if supporting a Java API is necessary.\n+\n+## Design\n+\n+I'm going to adopt `Flyway` and `DBGeni` tool syntax and behavior to design the ksqlDB migrations tool. Users will define a new migration in an SQL\n+script. This new SQL script describes the changes to do to migrate the cluster from state A to state B. Then run the migration from the\n+command line to apply the new state in the ksqlDB cluster. Users can also run this migration automatically as part of the build process and/or\n+testing in a CI/CD environment.\n+\n+For instance, the following example creates a new file that setups the initial state of the cluster.\n+\n+`V000001__Initial_setup.sql`\n+```sql\n+CREATE STREAM pageviews (\n+    user_id INTEGER KEY, \n+    url STRING, \n+    status INTEGER\n+) WITH (\n+    KAFKA_TOPIC='pageviews', \n+    VALUE_FORMAT='JSON'    \n+);\n+\n+CREATE TABLE pageviews_metrics AS\n+ SELECT url, COUNT(*) AS num_views\n+  FROM pageviews\n+  GROUP BY url\n+  EMIT CHANGES;\n+```\n+\n+The user runs the migration tool on a specific ksqlDB cluster. The tool updates the cluster by running the SQL statements from the above file.\n+Then sets the state of the cluster to version 1.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: << Empty Schema >>\n+Migrating schema to version 1 - Initial setup\n+```\n+\n+Later, the user needs new changes on the cluster. All previous migrations files are immutable. So, any changes on the cluster require a new migration\n+file (or SQL script). Let's create one to create the users table.\n+\n+`V000002__Add_users.sql`\n+```sql\n+CREATE TABLE users (\n+   ID BIGINT PRIMARY KEY, \n+   STRING NAME, \n+   ADDRESS ADDRESS_TYPE\n+ ) WITH (\n+   KAFKA_TOPIC='users', \n+   VALUE_FORMAT='JSON' \n+ );\n+```\n+\n+The user runs the migration tool on the same ksqlDB cluster. The tool detects the cluster has already version 1, so it executes only the newer version 2 migration\n+file. It then sets the state of the cluster to version 2.\n+\n+```shell script\n+$ ksql-migrations apply\n+Current version of schema: 1\n+Migrating schema to version 2 - Add users\n+```\n+\n+All migration files will support only integer versions (no decimal versions). Integer versions are easier to sort when are found in the file name. Also, there are\n+too few cases that require decimal versioning (i.e. `1.1`) in schema changes. We don't expect users to use decimal versions on ksqlDB migrations.\n+\n+The benefit of this tool is that it detects the required updates to execute in the ksqlDB cluster. So, users don't need to know which SQL statements need to perform\n+to update the cluster. It also makes it easy to work with multiple clusters. Say that you have devel, stag and prod clusters. The tool will manage and track the version\n+of these clusters and apply the right SQL operations.\n+\n+To be able to do that, the tool will use a metadata stream and table that contains the current schema version and all executed updates.\n+\n+### Schema metadata\n+\n+Each ksqlDB cluster requires metadata objects where to track the current schema state. This is not only useful for the tool to know the migrations files to apply, but also for\n+users who can quickly verify if the cluster requires changes to fix a schema bug or add a major/minor improvement for their applications.\n+\n+The tool creates two metadata objects, a stream and table. automatically during the first migration; or when the user runs the tool with a parameter to initialize it.\n+\n+i.e.\n+```\n+$ ksql-migrations initialize\n+Schema metadata initialized successfully\n+```\n+\n+Due to some query limitations (lack of ORDER BY clause and pull queries working only on materialized views) in ksqlDB, the metadata will be stored in two places;  \n+One stream (MIGRATION_EVENTS) and one table (SCHEMA_VERSION).\n+\n+The stream and table require topics unique for the cluster. In this case, these topics names will use the same convention as the processing log. It's not going\n+to be an internal topic because it will be a user topic. The topic name is: `{clusterID}ksql_{StreamOrTableName}`.\n+\n+The user can specify a different name for the SCHEMA_VERSION table. This can be done through the tool configuration file. See `Configurations` for more details.\n+\n+The `MIGRATION_EVENTS` stream will keep track of every migration change (including undo changes). This will contain the history of changes the user has done. Also, this stream\n+will contain a key to the current version of the schema (specified as `CURRENT` version). Every time a new migration or undo happens, the tool will insert a new event with the\n+`CURRENT` key pointing to the current version.\n+\n+This is the `CREATE` statement for the `MIGRATION_EVENTS` stream:\n+```sql\n+CREATE STREAM migration_events (\n+  version_key  STRING KEY,\n+  version      STRING,\n+  name         STRING,\n+  state        STRING,  \n+  checksum     STRING,\n+  started_on   STRING,\n+  completed_on STRING,\n+  previous     STRING\n+) WITH (  \n+  KAFKA_TOPIC='default_ksql_migration_events',\n+  VALUE_FORMAT='JSON',\n+  PARTITIONS=1,\n+  REPLICAS=1\n+);\n+```\n+\n+The `version_key` column has the version of the migration applied or undone. Special values of the `version_key`, `CURRENT` and `LATEST` will be reserved for internal purposes.\n+The `version` column has the version of the migration applied.\n+The `name` column has the name of the migration.\n+The `state` column has the state of the migration process. It can be any of `Pending`, `Running`, `Migrated`, `Error`, `Undone`.\n+The `checksum` column has the MD5 checksum of the migration file. It is used to validate the schema migrations with the local files.\n+The `started_on` column has the date and time when the migration started.\n+The `completed_on` column has the date and time when the migration finished.\n+The `previous` column has the previous version applied.\n+\n+The `SCHEMA_VERSION` table will also keep track of every migration change (including future work for undo changes), but with the difference that being a table the tool will see quickly if a schema\n+version has been migrated or undone. It will also give us a quick view of the `CURRENT` state of the schema. The major advantage is that the tool will use pull queries in this materialized\n+view to get the `CURRENT` state of the cluster.\n+\n+There is another reserved key `LATEST` that will point to the latest change applied. This will be used by the tool to stream all changes up to the row that `LATEST` points, and stop.\n+The `ksql-migrations info` command will use this to display information about the migrations that have been applied or undone. I cannot stream the `MIGRATION_EVENTS` or `SCHEMA_VERSION` directly because\n+the tool does not know when to stop.\n+\n+*Note:*\n+The below schema is designed so we support undo operations in the future. When an undo happens, the `CURRENT` key will point to the previous version found.\n+\n+This is the `CREATE` statement for the `SCHEMA_VERSION` table:\n+```sql\n+CREATE TABLE schema_version\n+  WITH (\n+    KAFKA_TOPIC='default_ksql_schema_version',\n+    VALUE_FORMAT='JSON',\n+    PARTITIONS=1\n+  )\n+  AS SELECT \n+    version_key, \n+    latest_by_offset(version) as version, \n+    latest_by_offset(name) AS name, \n+    latest_by_offset(state) AS state,     \n+    latest_by_offset(checksum) AS checksum, \n+    latest_by_offset(started_on) AS started_on, \n+    latest_by_offset(completed_on) AS completed_on, \n+    latest_by_offset(previous) AS previous\n+  FROM migration_events \n+  GROUP BY version_key;\n+```\n+\n+The following are the outputs that we'll see on each stream and table, and how the tool will figure out the current schema version using pull queries.\n+\n+The `MIGRATION_EVENTS` stream output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Migrated | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The `SCHEMA_VERSION` table output:\n+```shell script\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| version_key | version | name          | state    | checksum   | started_on          | completed_on        | previous |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+| 1           | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| 2           | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n+| CURRENT     | 1       | Initial setup | Migrated | <MD5-sum>  | 12-01-2020 03:48:00 | 12-01-2020 03:48:05 | null     |\n+| LATEST      | 2       | Add users     | Undone   | <MD5-sum>  | 12-03-2020 10:34:30 | 12-03-2020 10:34:34 | 1        |\n++-------------+---------+---------------+----------+------------+---------------------+---------------------+----------+\n+```\n+\n+The tool will later use pull queries to identify the current state of the system:\n+```sql\n+SELECT version, state, previous FROM SCHEMA_VERSION WHERE version_key = 'CURRENT'; \n+```\n+\n+\n+### Naming convention\n+\n+Hope you have noticed the naming rules I followed in the previous examples for naming the migration files. Having a naming convention for files is necessary\n+for the tool to detect what migration to apply or revert. Naming files are easier than creating configurations or command parameters to specify the same info.\n+\n+The migration files follow the same `Flyway` naming convention.\n+`(Prefix)(Version)__(Description).sql`\n+\n+The `Prefix` specifies whether the file is a new migration (`V`) file. The prefix is used so that we can add other operations in the future, such as undo operations.\n+The `Version` is the version number used for the schema. Versions will not support decimal versions. Integers with 6 digits are used.\n+The `Description` is a name or description of the new migration. Description uses underscores (automatically replaced by spaces at runtime) or spaces separated the words.\n+\n+i.e.\n+```\n+- V000001__Initial_setup.sql    # a new version to migrate (v1) with name 'Initial setup'\n+- V000002__Add_users.sql        # a new version to migrate (v2) with name 'Add users'\n+```\n+\n+It is recommended the user creates these two files on any new migration. The tool will not enforce that. We need specify this recommendation in the ksqlDB documents.\n+\n+### Dry-runs\n+\n+A dry-run for ksqlDB migrations will only verify what migrations will be applied in the cluster. It will not attempt to execute or simulate any migration statement found in the files. This\n+feature will allow users to test that migration files have the right version and description names as well as know what migrations will be applied in a determined cluster.\n+\n+### Directory structure\n+\n+The migrations tool will use following directory structure:\n+\n+<migrations-project-dir>\n+|\n+|- ksql-migrations.properties\n+|- migrations/\n+\n+When the migrations tool is executed, it will look at the `migrations` directory (by default) for SQL migration files to execute. This directory can be modified in the  \n+configuration file or command line parameters.\n+\n+If the `ksql-migrations.properties` exist in the root directory, then it will use the configuration provided by the file.\n+\n+### Command Syntax\n+\n+Finally, let's look at the rest of the command parameters that will exist to facilitate schema migrations.\n+\n+```shell script\n+Usage:\n+  ksql-migrations [options] commands\n+  \n+Commands\n+  new  <project-path>  Creates a new migrations project, directory structure and config file.\n+\n+  initialize   Initializes the schema version table\n+  \n+  create [-v <version>] <desc> \n+  \n+                 Create a pair of migration files with <desc> as description.\n+                 Optional: Use the <version> to specify the version to use.\n+   \n+                 This will created a pair of empty migration files based\n+                 on the next schema version.\n+               \n+                 i.e.                  \n+                   $ ksql-migrations create add_users \n+                   Created V000002__Add_users.sql\n+\n+  apply ( all | next | until <target> )\n+  \n+              Migrates a schema to new available schema versions (default: all)\n+              \n+              If 'all' is specified, then it migrates all newer versions available\n+              If 'next' is specified, then it migrates only the next available version\n+              If 'until <target>' is specified, then it migrates all available versions before <target>\n+  \n+  info        Displays information about the current and available migrations\n+  \n+  baseline    Sets the current schema to the specified version\n+  \n+              This is useful when production environments already have a schema unversioned. This sets\n+              the baseline from where to start applying migrations (i.e. kqsl-migrations baseline 1 'Current State')\n+  \n+  clean       Cleans the schema metadata objects                \n+  \n+  validate    Validate applied migrations against local files\n+  \n+              Compares local files checksum against the current metadata checksums to check for migrations files that have changed.\n+              This tells the user that their schema might be not valid against their local files.\n+  \n+Options\n+  -c, --config-file  Specifies a configuration file\n+  \n+  -d, --define       Define variables for the client session (equivalent to the DEFINE statement).\n+  \n+  --dry-run          Simulates what migrations will be applied in the cluster. Dry-runs do not execute or simulate each migration\n+                     statement. Only displays the schema updates that may take place in the cluster without modifying the cluster.\n+ \n+  -h, --help         Shows this help  \n+    \n+```\n+\n+### Configurations\n+\n+The tool will support a configuration file where all details for the server and tool migrations will be set. The following\n+are the basic configurations that the tool should support.\n+\n+Example of `ksql-migrations.properties`\n+```\n+# Server URL and authentication\n+ksql.server.url='http://localhost:8080'\n+ksql.username='user1'\n+ksql.password='pass1'\n+\n+# Migrations details\n+ksql.migrations.streamName='migration_events'\n+ksql.migrations.tableName='schema_version'\n+ksql.migrations.createSchemas='true'\n+```\n+\n+Note: The command line options and other configurations will also be defined during the implementation.\n+\n+## Test plan\n+\n+- Verify positive and negative forward migrations\n+- Verify integration with Github and Jenkins", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bc5875896c0206574e096c0ead808b5a87caa89"}, "originalPosition": 419}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4571, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}