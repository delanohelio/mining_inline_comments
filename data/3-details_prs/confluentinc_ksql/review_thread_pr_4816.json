{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjA1MTI0", "number": 4816, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowMTo1M1rODpnoEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoyMToyMlrODpoCWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTY3NDQxOnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowMTo1NFrOF46S-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowMToxMFrOF5PVlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA==", "bodyText": "clearly this happens somewhere, but I'm not sure where, don't we need to remove the paritionByCol if it existed in the value?", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395219704", "createdAt": "2020-03-19T18:01:54Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1OTcyMw==", "bodyText": "No, we don't need to remove it, cos we need it there.\nConsider:\nA => B, C\nAnd applying PARTITION BY B.\nThe final schema should be:\nB => C, A\nHowever, during processing we copy the key columns into the value, hence the source schema is:\nA => B, C, A\nWhen we repartition this becomes:\nB => B, C, A\nNotice, no need to change the value!\nHowever, if PARTITION BY UDF(B), then:\nA => B, C\nBecomes:\nKSQL_COL_0 => B, C, A\nWhich during processing is actually:\nA => B, C, A\nBecoming\nKSQL_COL_0 => B, C, A, KSQL_COL_0.\nThis would all likely be a lot clearer if we had a LogicalSchema and a ProcessingSchema type, but ... that would be a lot of work!", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395559723", "createdAt": "2020-03-20T10:50:55Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NDQzNw==", "bodyText": "I've added Java docs to cover this.", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395564437", "createdAt": "2020-03-20T11:01:10Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTY4Mzc3OnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowNDozNVrOF46ZPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo0NjowMFrOF5O6MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMTMwOA==", "bodyText": "we might already have been doing this, but why do we filter out null keys and values?\n\nEDIT: just saw #4823", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395221308", "createdAt": "2020-03-19T18:04:35Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());\n+\n+    if (!partitionByCol.isPresent()) {\n+      // New key column added, copy in to value schema:\n+      builder.valueColumn(newKeyName, keyType);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  private static Optional<Column> getPartitionByCol(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy\n+  ) {\n+    if (!(partitionBy instanceof ColumnReferenceExp)) {\n+      return Optional.empty();\n+    }\n+\n+    final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+    final Column column = sourceSchema\n+        .findValueColumn(columnName)\n+        .orElseThrow(() -> new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+    return Optional.of(column);\n+  }\n+\n+  private static PartitionByParams buildMapper(\n+      final LogicalSchema resultSchema,\n+      final Optional<Column> partitionByCol,\n+      final Function<GenericRow, Object> evaluator\n+  ) {\n+    // If partitioning by something other than an existing column, then a new key will have\n+    // been synthesized. This new key must be appended to the value to make it available for\n+    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n+    final boolean appendNewKey = !partitionByCol.isPresent();\n+\n+    final KeyBuilder keyBuilder = StructKeyUtil.keyBuilder(resultSchema);\n+\n+    final BiPredicate<Struct, GenericRow> predicate = (k, v) -> {\n+      if (v == null) {\n+        return false;\n+      }\n+\n+      return evaluator.apply(v) != null;\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1NzQyNQ==", "bodyText": "Yeah, this was existing functionality copied across, but thought exactly the same when I was moving it. Hence #4823", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395557425", "createdAt": "2020-03-20T10:46:00Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());\n+\n+    if (!partitionByCol.isPresent()) {\n+      // New key column added, copy in to value schema:\n+      builder.valueColumn(newKeyName, keyType);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  private static Optional<Column> getPartitionByCol(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy\n+  ) {\n+    if (!(partitionBy instanceof ColumnReferenceExp)) {\n+      return Optional.empty();\n+    }\n+\n+    final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+    final Column column = sourceSchema\n+        .findValueColumn(columnName)\n+        .orElseThrow(() -> new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+    return Optional.of(column);\n+  }\n+\n+  private static PartitionByParams buildMapper(\n+      final LogicalSchema resultSchema,\n+      final Optional<Column> partitionByCol,\n+      final Function<GenericRow, Object> evaluator\n+  ) {\n+    // If partitioning by something other than an existing column, then a new key will have\n+    // been synthesized. This new key must be appended to the value to make it available for\n+    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n+    final boolean appendNewKey = !partitionByCol.isPresent();\n+\n+    final KeyBuilder keyBuilder = StructKeyUtil.keyBuilder(resultSchema);\n+\n+    final BiPredicate<Struct, GenericRow> predicate = (k, v) -> {\n+      if (v == null) {\n+        return false;\n+      }\n+\n+      return evaluator.apply(v) != null;\n+    };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMTMwOA=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTY5MjEyOnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowNjo1OFrOF46emg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo0Njo1NFrOF5O7tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMjY4Mg==", "bodyText": "I thought we should never get to the situation where a key and value column have the same name? (or is this now temporarily possible during the partition by step? that seems not ideal)", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395222682", "createdAt": "2020-03-19T18:06:58Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "diffHunk": "@@ -75,7 +79,7 @@\n \n   private static final LogicalSchema RESULT_SCHEMA = LogicalSchema.builder()\n       .withRowTime()\n-      .keyColumn(SchemaUtil.ROWKEY_NAME, SqlTypes.BIGINT)\n+      .keyColumn(ColumnName.of(\"BOI\"), SqlTypes.BIGINT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1NzgxMg==", "bodyText": "The key and rowkey columns are copied into the value... so yes, we always have duplicates in the schema used during processing...", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395557812", "createdAt": "2020-03-20T10:46:54Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "diffHunk": "@@ -75,7 +79,7 @@\n \n   private static final LogicalSchema RESULT_SCHEMA = LogicalSchema.builder()\n       .withRowTime()\n-      .keyColumn(SchemaUtil.ROWKEY_NAME, SqlTypes.BIGINT)\n+      .keyColumn(ColumnName.of(\"BOI\"), SqlTypes.BIGINT)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMjY4Mg=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTcxNzk3OnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxNDozNlrOF46vfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowNToxMlrOF5PdEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzAwNQ==", "bodyText": "I feel like we should generate the name of the partition by column during the AstSanitizer step (just as we do for other expressions without column names). Unfortunately that probably requires supporting column names in PARTITION BY - is that something that's on your radar? This isn't a blocker for this PR, but I want to make sure we have a path forward that's backwards compatible.\nThis change might be hard to implement in the future - we generate KSQL_COL_x based on the location of the column, not the number of previous generated columns, so the algorithms wouldn't necessarily line up. Is this nextGeneratedColumnAlias specified anywhere in the serialized plan?", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395227005", "createdAt": "2020-03-19T18:14:36Z", "author": {"login": "agavra"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -61,4 +70,42 @@ public static ColumnName generatedJoinColumnAlias(\n   public static boolean isAggregate(final ColumnName name) {\n     return name.text().startsWith(AGGREGATE_COLUMN_PREFIX);\n   }\n+\n+  /**\n+   * Determines the next unique column alias.\n+   *\n+   * <p>Finds any existing {@code KSQL_COL_x} column names in the supplied {@code sourceSchema} to\n+   * ensure the returned generated column name is unique.\n+   *\n+   * @param sourceSchema the source schema.\n+   * @return a column name in the form {@code KSQL_COL_x} which does not clash with source schema.\n+   */\n+  public static ColumnName nextGeneratedColumnAlias(final LogicalSchema sourceSchema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NjM1NQ==", "bodyText": "Aliasing in PARTITION BY is definitely on my radar: #4813.  I was hoping you may be able to pick that one up!\nAnd yes, once this is done we can make this call from AstSanitizer\n\nThis change might be hard to implement in the future - we generate KSQL_COL_x based on the location of the column, not the number of previous generated columns, so the algorithms wouldn't necessarily line up.\n\nWith #4827 we actually generate the index based on other column names.\n\nIs this nextGeneratedColumnAlias specified anywhere in the serialized plan?\n\nThe sink schema is in the serialized plan.", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395566355", "createdAt": "2020-03-20T11:05:12Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -61,4 +70,42 @@ public static ColumnName generatedJoinColumnAlias(\n   public static boolean isAggregate(final ColumnName name) {\n     return name.text().startsWith(AGGREGATE_COLUMN_PREFIX);\n   }\n+\n+  /**\n+   * Determines the next unique column alias.\n+   *\n+   * <p>Finds any existing {@code KSQL_COL_x} column names in the supplied {@code sourceSchema} to\n+   * ensure the returned generated column name is unique.\n+   *\n+   * @param sourceSchema the source schema.\n+   * @return a column name in the form {@code KSQL_COL_x} which does not clash with source schema.\n+   */\n+  public static ColumnName nextGeneratedColumnAlias(final LogicalSchema sourceSchema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzAwNQ=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTczNTYzOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxOTozOVrOF4663w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowNzozMlrOF5PhfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyOTkxOQ==", "bodyText": "can we add a test here to partition by an expression?", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395229919", "createdAt": "2020-03-19T18:19:39Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1,5 +1,121 @@\n {\n   \"tests\": [\n+    {\n+      \"name\": \"only key column - select star\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NzQ4NA==", "bodyText": "Good catch!", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395567484", "createdAt": "2020-03-20T11:07:32Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1,5 +1,121 @@\n {\n   \"tests\": [\n+    {\n+      \"name\": \"only key column - select star\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyOTkxOQ=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTc0MTY5OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/test/resources/ksql-plan-schema/schema.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoyMToyMlrOF46-2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowOTowNFrOF5PkXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIzMDkzOQ==", "bodyText": "will we be able to change this in the future or will we always have a V2 stuck in there? that seems like it might be motivation to go down the boolean path...", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395230939", "createdAt": "2020-03-19T18:21:22Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/resources/ksql-plan-schema/schema.json", "diffHunk": "@@ -427,6 +429,28 @@\n       \"title\" : \"streamSelectKeyV1\",\n       \"required\" : [ \"@type\", \"properties\", \"source\", \"keyExpression\" ]\n     },\n+    \"StreamSelectKey\" : {\n+      \"type\" : \"object\",\n+      \"additionalProperties\" : false,\n+      \"properties\" : {\n+        \"@type\" : {\n+          \"type\" : \"string\",\n+          \"enum\" : [ \"streamSelectKeyV2\" ],\n+          \"default\" : \"streamSelectKeyV2\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2ODIyMQ==", "bodyText": "The whole point of Rohan's command topic work was to allow different versions of steps!  The pre-existing version is called StreamSelectKeyV1: all the step names have the version appended....", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395568221", "createdAt": "2020-03-20T11:09:04Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/test/resources/ksql-plan-schema/schema.json", "diffHunk": "@@ -427,6 +429,28 @@\n       \"title\" : \"streamSelectKeyV1\",\n       \"required\" : [ \"@type\", \"properties\", \"source\", \"keyExpression\" ]\n     },\n+    \"StreamSelectKey\" : {\n+      \"type\" : \"object\",\n+      \"additionalProperties\" : false,\n+      \"properties\" : {\n+        \"@type\" : {\n+          \"type\" : \"string\",\n+          \"enum\" : [ \"streamSelectKeyV2\" ],\n+          \"default\" : \"streamSelectKeyV2\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIzMDkzOQ=="}, "originalCommit": {"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3788, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}