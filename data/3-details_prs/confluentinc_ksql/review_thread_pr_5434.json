{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwOTQ2NDUw", "number": 5434, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1MjozOFrOD--o_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozNTozNlrOD-_fWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY0NjA0OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1MjozOFrOGZaEUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToxMDoxMlrOGZaqBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NDY3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ---\n          \n          \n            \n            keywords: ksqlDB, java, client\n          \n          \n            \n            ---", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429294674", "createdAt": "2020-05-22T14:52:38Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNDMyNg==", "bodyText": "And other relevant keywords.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429304326", "createdAt": "2020-05-22T15:10:12Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NDY3NA=="}, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY1MDUwOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDowMFrOGZaHTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDowMFrOGZaHTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NTQzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `streamQuery()` method allows client apps to receive query results one row at a time,\n          \n          \n            \n            The `streamQuery()` method enables client apps to receive query results one row at a time,", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429295436", "createdAt": "2020-05-22T14:54:00Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY1MzY4OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDo1NVrOGZaJVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDo1NVrOGZaJVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NTk1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n          \n          \n            \n            You can use this method to issue both push and pull queries, but the usage pattern is better for push queries.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429295956", "createdAt": "2020-05-22T14:54:55Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY1NjE2OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NTozNVrOGZaK3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NTozNVrOGZaK3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NjM0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n          \n          \n            \n            To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429296348", "createdAt": "2020-05-22T14:55:35Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY2MDE5OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1Njo0NlrOGZaNeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1Njo0NlrOGZaNeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NzAxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n          \n          \n            \n            To consume records asynchronously, create a [Reactive Streams](http://www.reactive-streams.org/) subscriber to receive query result rows:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429297016", "createdAt": "2020-05-22T14:56:46Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY2Mjc1OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NzozM1rOGZaPEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NzozM1rOGZaPEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NzQyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, use the client to send the query result to the server and stream results to the subscriber:\n          \n          \n            \n            Use the Java client to send the query result to the server and stream results to the subscriber:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429297427", "createdAt": "2020-05-22T14:57:33Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY2NTkyOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODoyNlrOGZaRHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODoyNlrOGZaRHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5Nzk0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n          \n          \n            \n            If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429297949", "createdAt": "2020-05-22T14:58:26Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY2Njk4OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODo0N1rOGZaR0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODo0N1rOGZaR0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5ODEzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n          \n          \n            \n            You can also pass a `Duration` argument to `poll()`, which causes `poll()` to return `null` if no new rows are received by the time the duration has elapsed.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429298130", "createdAt": "2020-05-22T14:58:47Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY2ODk5OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OToxOFrOGZaTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OToxOFrOGZaTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5ODQ0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See [the API reference](TODO) for more.\n          \n          \n            \n            For more information, see the [API reference](TODO).", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429298449", "createdAt": "2020-05-22T14:59:18Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY3MDcxOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OTo0NlrOGZaUOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OTo0NlrOGZaUOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5ODc0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `executeQuery()` method allows client apps to receive query results as a single batch,\n          \n          \n            \n            The `executeQuery()` method enables client apps to receive query results as a single batch", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429298746", "createdAt": "2020-05-22T14:59:46Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY3MjczOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMDoxOVrOGZaVlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMDoxOVrOGZaVlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5OTA5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            returned once the query has completed.\n          \n          \n            \n            that's returned when the query completes.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429299093", "createdAt": "2020-05-22T15:00:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY3NTk1OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMToxOVrOGZaXww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMToxOVrOGZaXww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5OTY1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n          \n          \n            \n            This method is suitable for both pull queries and for terminating push queries, for example, queries that have a `LIMIT` clause.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429299651", "createdAt": "2020-05-22T15:01:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY3ODU3OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjowOVrOGZaZfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjowOVrOGZaZfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDA5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n          \n          \n            \n            Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300095", "createdAt": "2020-05-22T15:02:09Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4MDA2OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjozN1rOGZaaeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjozN1rOGZaaeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDM0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n          \n          \n            \n            To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300344", "createdAt": "2020-05-22T15:02:37Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4MTM3OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzowNVrOGZabZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzowNVrOGZabZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDU4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `terminatePushQuery()` method allows client apps to terminate push queries.\n          \n          \n            \n            The `terminatePushQuery()` method enables client apps to terminate push queries.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300583", "createdAt": "2020-05-22T15:03:05Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4MzM2OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzo0OVrOGZacyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzo0OVrOGZacyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDkzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The query ID is obtained from the query result response object when push queries are issued via the client,\n          \n          \n            \n            The query ID is obtained from the query result response object when the client issues push queries,", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300936", "createdAt": "2020-05-22T15:03:49Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4NDY5OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDoxOVrOGZadtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDoxOVrOGZadtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTE3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n          \n          \n            \n            by using either the [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md) methods.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301173", "createdAt": "2020-05-22T15:04:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4NjU0OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDo1M1rOGZae5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDoxNTo1OVrOGcXBmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTQ3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here's an example of terminating a push query issued via `streamQuery()`:\n          \n          \n            \n            Here's an example of terminating a push query issued by using the `streamQuery()` method:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301476", "createdAt": "2020-05-22T15:04:53Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjUyOA==", "bodyText": "Out of curiosity, why the preference for \"a push query issued by using the streamQuery() method\" rather than \"a push query issued using the streamQuery() method\"? I've currently updated to the latter but can easily switch to your original suggestion instead. (Can't quite pin it but the extra \"by\" reads weirdly to me, haha)", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429526528", "createdAt": "2020-05-23T08:20:56Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTQ3Ng=="}, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5MDU1Mw==", "bodyText": "I think strictly speaking (grammatically) Jim is right... (?)\nI.e. it seems more natural for me to say \"a push query issued by using the..\" or \"a push query issued while using the...\" It seems to me it needs some word in there.\nHaving said that.... it probably doesn't matter a great deal ;)\nhttps://forum.wordreference.com/threads/relative-pronouns-omitting-relative-pronoun-not-relative-adverb.282370/", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r432390553", "createdAt": "2020-05-29T10:15:59Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTQ3Ng=="}, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4Nzk1OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNToyMFrOGZaf3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwODoyMTowNFrOGZoOCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTcyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And here's an analogous example for terminating a push query issued via `executeQuery()`:\n          \n          \n            \n            And here's an analogous example for terminating a push query issued by using the `executeQuery()` method:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301724", "createdAt": "2020-05-22T15:05:20Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjUzNw==", "bodyText": "Ditto", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429526537", "createdAt": "2020-05-23T08:21:04Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTcyNA=="}, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzY4OTA5OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNTo0M1rOGZagnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNTo0M1rOGZagnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTkxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Client apps can insert rows of data into existing ksqlDB streams via the `insertInto()` method.\n          \n          \n            \n            Client apps can insert rows of data into existing ksqlDB streams by using the `insertInto()` method.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301916", "createdAt": "2020-05-22T15:05:43Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final String queryId;\n+try {\n+  queryId = batchedQueryResult.queryID().get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+try {\n+  client.terminatePushQuery(queryId).get();\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+Insert a batch of rows into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------------\n+\n+Client apps can insert rows of data into existing ksqlDB streams via the `insertInto()` method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzcwODQ3OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToxMTo0MFrOGZas6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToxMTo0MFrOGZas6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTA2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n          \n          \n            \n            Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429305067", "createdAt": "2020-05-22T15:11:40Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mzc3MjgxOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozMToxMlrOGZbVpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowMToxM1rOGa4qAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTQ5Mw==", "bodyText": "Would need to call subscription.request(n) here", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429315493", "createdAt": "2020-05-22T15:31:12Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDQxNg==", "bodyText": "Had it below but it makes more sense to have it here. Good call.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r430844416", "createdAt": "2020-05-27T04:01:13Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTQ5Mw=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mzc3MzMyOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozMToyMFrOGZbV9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzozMTo1OVrOGb_kpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ==", "bodyText": "And again here", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429315575", "createdAt": "2020-05-22T15:31:20Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTk2NQ==", "bodyText": "We can consider providing a simple Subscriber class (like our BaseSubscriber) that does the requests for you to make things a bit simpler.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429315965", "createdAt": "2020-05-22T15:32:08Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDg2Mg==", "bodyText": "We can consider providing a simple Subscriber class (like our BaseSubscriber) that does the requests for you to make things a bit simpler.\n\nThis makes sense. I was thinking we'd want to provide something similar for the Publisher in order to make the streaming INSERT INTO method more easily usable. Do you think it's critical this makes it into 0.10.0 or are we okay with it in 0.11.0 instead?", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r430844862", "createdAt": "2020-05-27T04:03:16Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODY4OA==", "bodyText": "Would we want to include the same Vert.x context checking logic in our BaseSubscriber in the one provided by the client?", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r430848688", "createdAt": "2020-05-27T04:21:44Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwNjMxMA==", "bodyText": "I think 0.11.0 is ok.\nI don't think we'd want the context checking as we can't be sure what threads the user would use the subscriber from.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r432006310", "createdAt": "2020-05-28T17:31:59Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mzc3ODI3OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozMzowOVrOGZbZZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwOTozNzozN1rOGdEjMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjQ1NA==", "bodyText": "I would avoid the try.. catch here - it doesn't really add anything to the understanding and clutters the example.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429316454", "createdAt": "2020-05-22T15:33:09Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTU3OQ==", "bodyText": "I agree it clutters the example but I think it's useful to have a fully fleshed out example that users can copy-paste from. @colinhicks and @MichaelDrogalis mentioned adding to the use case tutorials with examples of how to run tutorial commands from the client instead of the API. Maybe once we do that we can remove the try-catch's here?\nWould be curious to hear what @JimGalasyn understands is standard for docs like these -- do we value readability over copy-paste-ability?", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r430845579", "createdAt": "2020-05-27T04:06:39Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjQ1NA=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk4OTU2Mw==", "bodyText": "My 2c: Docs should always be optimised for clarity and readibility and we should avoid anything that detracts from the intention of the example. Otherwise we risk turning off users and giving the impression the API is harder to use than it really is.\nEven without try...catch the example is copy and pastable - any Java dev knows they need to handle any checked exceptions.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r431989563", "createdAt": "2020-05-28T17:03:33Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjQ1NA=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNjQzMw==", "bodyText": "Also let's lose the finals please :)", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r433136433", "createdAt": "2020-06-01T09:37:37Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjQ1NA=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mzc4MDkxOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozNDowNlrOGZbbUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowNjo0N1rOGa4urg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjk0Ng==", "bodyText": "Again, try...catch doesn't add much.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429316946", "createdAt": "2020-05-22T15:34:06Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTYxNA==", "bodyText": "As above.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r430845614", "createdAt": "2020-05-27T04:06:47Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjk0Ng=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mzc4NTIwOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-clients/java-client.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozNTozNlrOGZbeLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzozMDoxOVrOGb_g5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNzY3Nw==", "bodyText": "I think some examples showing how futures can be composed here would be great - that's really the point of using futures in the first place.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429317677", "createdAt": "2020-05-22T15:35:36Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final String queryId;\n+try {\n+  queryId = batchedQueryResult.queryID().get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+try {\n+  client.terminatePushQuery(queryId).get();\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+Insert a new row into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------\n+\n+Client apps can insert new rows of data into existing ksqlDB streams via the `insertInto()` method.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Inserts a row into a ksqlDB stream.\n+   *\n+   * <p>The {@code CompletableFuture} will be failed if a non-200 response is received from the\n+   * server, or if the server encounters an error while processing the insertion.\n+   *\n+   * @param streamName name of the target stream\n+   * @param row the row to insert. Keys are column names and values are column values.\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, KsqlObject row);\n+  \n+  ...\n+  \n+}\n+```\n+\n+Rows for insertion are represented as `KsqlObject` instances. A `KsqlObject` represents a map of strings\n+(in this case, column names) to values (column values).\n+\n+### Example Usage ###\n+\n+Here's an example of using the client to insert a new row into an existing stream `ORDERS`\n+with schema (ORDER_ID BIGINT, PRODUCT_ID VARCHAR, USER_ID VARCHAR).\n+\n+```java\n+final Row row = new KsqlObject()\n+    .put(\"ROWKEY\", \"k1\")\n+    .put(\"ORDER_ID\", 12345678L)\n+    .put(\"PRODUCT_ID\", \"UAC-222-19234\")\n+    .put(\"USER_ID\", \"User_321\"));\n+\n+try {\n+  client.insertInto(\"ORDERS\", row).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTg4OQ==", "bodyText": "What kind of composition did you have in mind? Composing multiple insertInto() requests, or something else?", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r430845889", "createdAt": "2020-05-27T04:08:06Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final String queryId;\n+try {\n+  queryId = batchedQueryResult.queryID().get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+try {\n+  client.terminatePushQuery(queryId).get();\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+Insert a new row into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------\n+\n+Client apps can insert new rows of data into existing ksqlDB streams via the `insertInto()` method.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Inserts a row into a ksqlDB stream.\n+   *\n+   * <p>The {@code CompletableFuture} will be failed if a non-200 response is received from the\n+   * server, or if the server encounters an error while processing the insertion.\n+   *\n+   * @param streamName name of the target stream\n+   * @param row the row to insert. Keys are column names and values are column values.\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, KsqlObject row);\n+  \n+  ...\n+  \n+}\n+```\n+\n+Rows for insertion are represented as `KsqlObject` instances. A `KsqlObject` represents a map of strings\n+(in this case, column names) to values (column values).\n+\n+### Example Usage ###\n+\n+Here's an example of using the client to insert a new row into an existing stream `ORDERS`\n+with schema (ORDER_ID BIGINT, PRODUCT_ID VARCHAR, USER_ID VARCHAR).\n+\n+```java\n+final Row row = new KsqlObject()\n+    .put(\"ROWKEY\", \"k1\")\n+    .put(\"ORDER_ID\", 12345678L)\n+    .put(\"PRODUCT_ID\", \"UAC-222-19234\")\n+    .put(\"USER_ID\", \"User_321\"));\n+\n+try {\n+  client.insertInto(\"ORDERS\", row).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNzY3Nw=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwNTM0OA==", "bodyText": "Could be anything really - e..g. executing a query then inserting some rows into a stream for each result, or inserting into a database.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r432005348", "createdAt": "2020-05-28T17:30:19Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final String queryId;\n+try {\n+  queryId = batchedQueryResult.queryID().get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+try {\n+  client.terminatePushQuery(queryId).get();\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+Insert a new row into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------\n+\n+Client apps can insert new rows of data into existing ksqlDB streams via the `insertInto()` method.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Inserts a row into a ksqlDB stream.\n+   *\n+   * <p>The {@code CompletableFuture} will be failed if a non-200 response is received from the\n+   * server, or if the server encounters an error while processing the insertion.\n+   *\n+   * @param streamName name of the target stream\n+   * @param row the row to insert. Keys are column names and values are column values.\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, KsqlObject row);\n+  \n+  ...\n+  \n+}\n+```\n+\n+Rows for insertion are represented as `KsqlObject` instances. A `KsqlObject` represents a map of strings\n+(in this case, column names) to values (column values).\n+\n+### Example Usage ###\n+\n+Here's an example of using the client to insert a new row into an existing stream `ORDERS`\n+with schema (ORDER_ID BIGINT, PRODUCT_ID VARCHAR, USER_ID VARCHAR).\n+\n+```java\n+final Row row = new KsqlObject()\n+    .put(\"ROWKEY\", \"k1\")\n+    .put(\"ORDER_ID\", 12345678L)\n+    .put(\"PRODUCT_ID\", \"UAC-222-19234\")\n+    .put(\"USER_ID\", \"User_321\"));\n+\n+try {\n+  client.insertInto(\"ORDERS\", row).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNzY3Nw=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 381}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3481, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}