{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NTcyNzgy", "number": 6504, "title": "feat: support variable substitution in SQL statements", "bodyText": "Description\nThis is part of KLIP-38 - Variable Substitution\nIt implements variable substitution on SQL statements, both the Server-side and CLI-side. Variables are referenced in statements with the ${} characters. For instance:\nFor the CLI-side, the scope is per-session. The following example will create the s1 stream that reads from topic t1.\nksql> define topicName = 't1';\nksql> define streamName = 's1';\nksql> create stream ${streamName} with (kafka_topic='${topicName}');\n\nFor the server-side, the variable scope is seen per-request. The following example will create the s1 stream that reads from topic t1.\nRequest 1 will create stream s1 from topic t1:\n{ \n  statement: \"\n    define topicName = 't1';\n    create stream s1 with (kafka_topic='${topicName}');\n  \"\n}\n\nRequest 2 will FAIL because ${topicName} is not a valid topic name\n{ \n  statement: \"\n    create stream s1 with (kafka_topic='${topicName}');\n  \"\n}\n\nVariable substitution can be enabled or disabled with the ksql.variable.substitution.enable configuration. It can be set in the ksql-server.properties or can be overridden from the CLI. By default is true.\nImplementation:\nA new VariableSubstitutor class is created that replaces variables wrapped in ${} from a parsed statement (ParsedStatement). This VarialbeSubstitutor is called from the CLI to replace variables before sending to the Server; and from the KsqlEngine.prepare() too in case there are variables defined in the KSQL request.\nDuring the CLI session, variables are substituted before sending the request to the Server. I initially thought of sending the DEFINE statements, but it was more work to identify the variables and create a new request with them. Doing it in the CLI saves some time on parsing.\nI didn't do the substitution in the AstBuilder because there were several places I needed to change to provide substitution. If a new syntax was added in the future, the developer would have to know about variables and call the right visit or ParserUtil methods to get the variables substituted. Also, I needed to rewrite the statement text, which required more work in the builder for doing that. Having a simple VariableSubstitutor that returns the replaced statement text was simple.\nBecause substitution happens by replacing text, I had to make sure of escape the single-quote characters to avoid using variables for SQL injection. The escape is done in the ParserUtil when called by the VariableSubstitutor.\nTesting done\nAdded unit tests\nVerified manually\nksql> show streams;\n\n Stream Name         | Kafka Topic                 | Key Format | Value Format | Windowed \n------------------------------------------------------------------------------------------\n KSQL_PROCESSING_LOG | default_ksql_processing_log | KAFKA      | JSON         | false    \n------------------------------------------------------------------------------------------\nksql> define topicName = 't1';\nksql> define streamName = 's1';\nksql> create stream ${streamName} (id int) with (kafka_topic='${topicName}', value_format='json', replicas=1, partitions=1);\n\n Message        \n----------------\n Stream created \n----------------\nsql> show streams;\n\n Stream Name         | Kafka Topic                 | Key Format | Value Format | Windowed \n------------------------------------------------------------------------------------------\n KSQL_PROCESSING_LOG | default_ksql_processing_log | KAFKA      | JSON         | false    \n S1                  | t1                          | KAFKA      | JSON         | false    \n------------------------------------------------------------------------------------------\n\nServer side\n$ curl -X \"POST\" \"http://localhost:8088/ksql\" \\\n>      -H \"Accept: application/vnd.ksql.v1+json\" \\\n>      -d $'{\n>   \"ksql\": \"define topicName = \\'t1\\';define streamName = \\'s3\\';create stream ${streamName} (id int) with (kafka_topic=\\'${topicName}\\', value_format=\\'json\\');\",\n>   \"streamsProperties\": {}\n> }' | jq .\n[\n  {\n    \"@type\": \"currentStatus\",\n    \"statementText\": \"CREATE STREAM S3 (ID INTEGER) WITH (KAFKA_TOPIC='t1', KEY_FORMAT='KAFKA', VALUE_FORMAT='JSON');\",\n    \"commandId\": \"stream/`S3`/create\",\n    \"commandStatus\": {\n      \"status\": \"SUCCESS\",\n      \"message\": \"Stream created\",\n      \"queryId\": null\n    },\n    \"commandSequenceNumber\": 36,\n    \"warnings\": []\n  }\n]\n\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-10-22T21:37:21Z", "url": "https://github.com/confluentinc/ksql/pull/6504", "merged": true, "mergeCommit": {"oid": "e185c1fcf86821f5024e51736a77c6f2876fb9ab"}, "closed": true, "closedAt": "2020-10-27T20:25:05Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVXdRXABqjM5MTQyMjY5NzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdWg58IgFqTUxNzMzMzMzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ce288573a3c45ff0e39b6c3afe543f3a6105ff6", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/9ce288573a3c45ff0e39b6c3afe543f3a6105ff6", "committedDate": "2020-10-22T19:50:22Z", "message": "feat: add config to enable/disable variable substitution"}, "afterCommit": {"oid": "9d64a3d41eb6fe31cf38728cfdc7297be8f4d0e5", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/9d64a3d41eb6fe31cf38728cfdc7297be8f4d0e5", "committedDate": "2020-10-23T14:28:47Z", "message": "chore: suppress warnings in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTU5NTk5", "url": "https://github.com/confluentinc/ksql/pull/6504#pullrequestreview-517159599", "createdAt": "2020-10-26T20:42:53Z", "commit": {"oid": "87ae8139fd5be5696e545d42cfa4f69fedeee40b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0Mjo1M1rOHohl9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0Mjo1M1rOHohl9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTQ3Nw==", "bodyText": "The text is a bit confusing. You mean: \"Identifier names cannot start with '@' and may only contain alphanumeric values and '_'. \"", "url": "https://github.com/confluentinc/ksql/pull/6504#discussion_r512255477", "createdAt": "2020-10-26T20:42:53Z", "author": {"login": "vpapavas"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/VariableSubstitutor.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser;\n+\n+import static io.confluent.ksql.util.ParserUtil.getLocation;\n+import static io.confluent.ksql.util.ParserUtil.isQuoted;\n+import static io.confluent.ksql.util.ParserUtil.sanitize;\n+import static io.confluent.ksql.util.ParserUtil.unquote;\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import java.math.BigDecimal;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.commons.text.StringSubstitutor;\n+\n+public final class VariableSubstitutor {\n+  private VariableSubstitutor() {\n+  }\n+\n+  private static final Pattern VALID_IDENTIFIER_NAMES = Pattern.compile(\"[A-Za-z_][A-Za-z0-9_@]*\");\n+  public static final String PREFIX = \"${\";\n+  public static final String SUFFIX = \"}\";\n+\n+  static class VariablesLookup {\n+    public static Set<String> lookup(final String text) {\n+      final Set<String> variables = new HashSet<>();\n+\n+      // Used only to lookup for variables\n+      final StringSubstitutor substr = new StringSubstitutor(key -> {\n+        variables.add(key);\n+        return null;\n+      });\n+\n+      substr.setVariablePrefix(PREFIX);\n+      substr.setVariableSuffix(SUFFIX);\n+      substr.replace(text); // Nothing is replaced. It just lookups for variables.\n+\n+      return variables;\n+    }\n+  }\n+\n+  public static String substitute(\n+      final KsqlParser.ParsedStatement parsedStatement,\n+      final Map<String, String> valueMap\n+  ) {\n+    final String statementText = parsedStatement.getStatementText();\n+    final SqlSubstitutorVisitor visitor = new SqlSubstitutorVisitor(statementText, valueMap);\n+    return visitor.replace(parsedStatement.getStatement());\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: ClassDataAbstractionCoupling\n+  private static final class SqlSubstitutorVisitor extends SqlBaseBaseVisitor<Void> {\n+    // CHECKSTYLE_RULES.ON: ClassDataAbstractionCoupling\n+\n+    private final String statementText;\n+    private final Map<String, String> valueMap;\n+\n+    // Contains sanitized values for variable substitution\n+    private Map<String, String> sanitizedValueMap;\n+\n+    SqlSubstitutorVisitor(final String statementText, final Map<String, String> valueMap) {\n+      this.statementText = requireNonNull(statementText, \"statementText\");\n+      this.valueMap = requireNonNull(valueMap, \"valueMap\");\n+      this.sanitizedValueMap = new HashMap<>(valueMap.size());\n+    }\n+\n+    public String replace(final SqlBaseParser.SingleStatementContext singleStatementContext) {\n+      // walk the statement tree to validate and sanitize variables\n+      visit(singleStatementContext);\n+\n+      // replace all variables with sanitized values\n+      return StringSubstitutor.replace(statementText, sanitizedValueMap);\n+    }\n+\n+    @Override\n+    public Void visitStringLiteral(final SqlBaseParser.StringLiteralContext context) {\n+      final String text = unquote(context.getText(), \"\\'\");\n+      for (String variableName : VariablesLookup.lookup(text)) {\n+        if (valueMap.containsKey(variableName)) {\n+          sanitizedValueMap.putIfAbsent(variableName, sanitize(valueMap.get(variableName)));\n+        }\n+      }\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitVariableLiteral(final SqlBaseParser.VariableLiteralContext context) {\n+      final String variableRef = context.getText();\n+      final String variableName = unwrap(variableRef);\n+      final String variableValue = valueMap.getOrDefault(variableName, variableRef);\n+\n+      throwIfInvalidLiteral(variableValue, getLocation(context));\n+      sanitizedValueMap.putIfAbsent(variableName, sanitize(variableValue));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitVariableIdentifier(final SqlBaseParser.VariableIdentifierContext context) {\n+      final String variableRef = context.getText();\n+      final String variableName = unwrap(variableRef);\n+      final String variableValue = valueMap.getOrDefault(variableName, variableRef);\n+\n+      throwIfInvalidIdentifier(variableValue, getLocation(context));\n+      sanitizedValueMap.putIfAbsent(variableName, variableValue);\n+      return null;\n+    }\n+\n+    private String getIdentifierText(final String value) {\n+      final char firstChar = value.charAt(0);\n+      final char lastChar = value.charAt(value.length() - 1);\n+\n+      if (firstChar == '\"' && lastChar == '\"') {\n+        return unquote(value, \"\\\"\");\n+      } else if (firstChar == '`' && lastChar == '`') {\n+        return unquote(value, \"`\");\n+      } else {\n+        return value;\n+      }\n+    }\n+\n+    static String unwrap(final String value) {\n+      return value.substring(PREFIX.length(), value.length() - SUFFIX.length());\n+    }\n+\n+    private void throwIfInvalidIdentifier(\n+        final String value,\n+        final Optional<NodeLocation> location\n+    ) {\n+      final String identifierText = getIdentifierText(value);\n+\n+      if (!VALID_IDENTIFIER_NAMES.matcher(identifierText).matches()) {\n+        throw new ParseFailedException(\n+            \"Illegal argument at \" + location.map(NodeLocation::toString).orElse(\"?\")\n+                + \". Identifier names may only contain alphanumeric values, '_' \"\n+                + \"or not starting with '@'. Got: '\" + value + \"'\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87ae8139fd5be5696e545d42cfa4f69fedeee40b"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTYxMTkx", "url": "https://github.com/confluentinc/ksql/pull/6504#pullrequestreview-517161191", "createdAt": "2020-10-26T20:45:12Z", "commit": {"oid": "87ae8139fd5be5696e545d42cfa4f69fedeee40b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0NToxMlrOHohq9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0NToxMlrOHohq9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1Njc1OA==", "bodyText": "This works (identifying sql injection) because variable names must not contain spaces, etc? Basically, only alphanumeric and '_'?", "url": "https://github.com/confluentinc/ksql/pull/6504#discussion_r512256758", "createdAt": "2020-10-26T20:45:12Z", "author": {"login": "vpapavas"}, "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/VariableSubstitutorTest.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package io.confluent.ksql.parser;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertThrows;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.util.Pair;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class VariableSubstitutorTest {\n+  private static final KsqlParser KSQL_PARSER = new DefaultKsqlParser();\n+\n+  @Test\n+  public void shouldSubstituteVariableOnDescribe() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"identifier\", \"_id_\");\n+      put(\"quotedIdentifier\", \"\\\"_id_\\\"\");\n+      put(\"backQuotedIdentifier\", \"`_id_`\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // DESCRIBE\n+        Pair.of(\"DESCRIBE ${identifier};\", \"DESCRIBE _id_;\"),\n+        Pair.of(\"DESCRIBE ${quotedIdentifier};\", \"DESCRIBE \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE ${backQuotedIdentifier};\", \"DESCRIBE `_id_`;\"),\n+\n+        // DESCRIBE EXTENDED\n+        Pair.of(\"DESCRIBE EXTENDED ${identifier};\", \"DESCRIBE EXTENDED _id_;\"),\n+        Pair.of(\"DESCRIBE EXTENDED ${quotedIdentifier};\", \"DESCRIBE EXTENDED \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE EXTENDED ${backQuotedIdentifier};\", \"DESCRIBE EXTENDED `_id_`;\"),\n+\n+        // DESCRIBE FUNCTION\n+        Pair.of(\"DESCRIBE FUNCTION ${identifier};\", \"DESCRIBE FUNCTION _id_;\"),\n+        Pair.of(\"DESCRIBE FUNCTION ${quotedIdentifier};\", \"DESCRIBE FUNCTION \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE FUNCTION ${backQuotedIdentifier};\", \"DESCRIBE FUNCTION `_id_`;\"),\n+\n+        // DESCRIBE CONNECTOR\n+        Pair.of(\"DESCRIBE CONNECTOR ${identifier};\", \"DESCRIBE CONNECTOR _id_;\"),\n+        Pair.of(\"DESCRIBE CONNECTOR ${quotedIdentifier};\", \"DESCRIBE CONNECTOR \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE CONNECTOR ${backQuotedIdentifier};\", \"DESCRIBE CONNECTOR `_id_`;\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldThrowOnDescribeWhenInvalidVariables() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      // Attempts to use a keyword\n+      put(\"identifier\", \"EXTENDED _id_\");\n+      put(\"quotedIdentifier\", \"EXTENDED \\\"_id_\\\"\");\n+      put(\"backQuotedIdentifier\", \"EXTENDED `_id_`\");\n+      put(\"singleQuoteIdentifier\", \"EXTENDED '_id_'\");\n+\n+      // Attempts to use a keyword inside quotes\n+      put(\"quotedIdentifier2\", \"\\\"EXTENDED _id_\\\"\");\n+      put(\"backQuotedIdentifier2\", \"`EXTENDED _id_`\");\n+      put(\"singleQuoteIdentifier2\", \"'EXTENDED _id_'\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // DESCRIBE\n+        Pair.of(\"DESCRIBE ${identifier};\", \"Got: 'EXTENDED _id_'\"),\n+        Pair.of(\"DESCRIBE ${quotedIdentifier};\", \"Got: 'EXTENDED \\\"_id_\\\"'\"),\n+        Pair.of(\"DESCRIBE ${backQuotedIdentifier};\", \"Got: 'EXTENDED `_id_`'\"),\n+        Pair.of(\"DESCRIBE ${singleQuoteIdentifier};\", \"Got: 'EXTENDED '_id_''\"),\n+        Pair.of(\"DESCRIBE ${quotedIdentifier2};\", \"Got: '\\\"EXTENDED _id_\\\"'\"),\n+        Pair.of(\"DESCRIBE ${backQuotedIdentifier2};\", \"Got: '`EXTENDED _id_`'\"),\n+        Pair.of(\"DESCRIBE ${singleQuoteIdentifier2};\", \"Got: ''EXTENDED _id_''\")\n+    );\n+\n+    assertThrowOnInvalidVariables(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldSubstituteVariableOnInsert() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"identifier\", \"_id_\");\n+      put(\"num\", \"1\");\n+      put(\"dec\", \"0.32\");\n+      put(\"bool\", \"false\");\n+      put(\"str\", \"'john'\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // INSERT VALUES\n+        Pair.of(\"INSERT INTO ${identifier} VALUES (${num}, ${bool}, ${dec}, ${str});\",\n+            \"INSERT INTO _id_ VALUES (1, false, 0.32, 'john');\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldSubstituteVariableOnCreate() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"identifier\", \"_id_\");\n+      put(\"quotedIdentifier\", \"\\\"_id_\\\"\");\n+      put(\"backQuotedIdentifier\", \"`_id_`\");\n+      put(\"topicName\", \"'name1'\");\n+      put(\"replicas\", \"3\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // CREATE STREAM\n+        Pair.of(\"CREATE STREAM ${identifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM _id_ WITH (kafka_topic='name1', replicas=3);\"),\n+\n+        Pair.of(\"CREATE STREAM ${quotedIdentifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM \\\"_id_\\\" WITH (kafka_topic='name1', replicas=3);\"),\n+\n+        Pair.of(\"CREATE STREAM ${backQuotedIdentifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM `_id_` WITH (kafka_topic='name1', replicas=3);\"),\n+\n+        Pair.of(\"CREATE STREAM ${backQuotedIdentifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM `_id_` WITH (kafka_topic='name1', replicas=3);\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldSanitizeStatements() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"escapeQuote\", \"'t1', value_format='AVRO'\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // CREATE\n+        Pair.of(\"CREATE STREAM s1 WITH (kafka_topic=${escapeQuote});\",\n+            \"CREATE STREAM s1 WITH (kafka_topic='t1'', value_format=''AVRO');\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldThrowOnSQLInjection() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87ae8139fd5be5696e545d42cfa4f69fedeee40b"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b47ee3ad2d08e59aa815cae352cb6a6c05f63e2", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/2b47ee3ad2d08e59aa815cae352cb6a6c05f63e2", "committedDate": "2020-10-26T21:19:57Z", "message": "feat: substitute variables in SQL statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6616f11e767c95106cc10663bade3eaa11f45ef0", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/6616f11e767c95106cc10663bade3eaa11f45ef0", "committedDate": "2020-10-26T21:19:57Z", "message": "feat: add config to enable/disable variable substitution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a8274d698a9dd8e6ef938024a4dcc9c093e7519", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/2a8274d698a9dd8e6ef938024a4dcc9c093e7519", "committedDate": "2020-10-26T21:19:57Z", "message": "chore: suppress warnings in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "739bf262663f15c1d611f1604c99c0d1a032da29", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/739bf262663f15c1d611f1604c99c0d1a032da29", "committedDate": "2020-10-26T21:19:57Z", "message": "chore: apply Vicky's feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "87ae8139fd5be5696e545d42cfa4f69fedeee40b", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/87ae8139fd5be5696e545d42cfa4f69fedeee40b", "committedDate": "2020-10-26T14:21:06Z", "message": "Merge branch 'master' into sql_variable_subst"}, "afterCommit": {"oid": "739bf262663f15c1d611f1604c99c0d1a032da29", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/739bf262663f15c1d611f1604c99c0d1a032da29", "committedDate": "2020-10-26T21:19:57Z", "message": "chore: apply Vicky's feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MzMzMzM5", "url": "https://github.com/confluentinc/ksql/pull/6504#pullrequestreview-517333339", "createdAt": "2020-10-27T04:03:49Z", "commit": {"oid": "739bf262663f15c1d611f1604c99c0d1a032da29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4588, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}