{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTYzNDc4", "number": 4563, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo1Mjo1MFrODg0BrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo1Mjo1MFrODg0BrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzMzNDIwOnYy", "diffSide": "RIGHT", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSerdeUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo1Mjo1MFrOFrOT7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTowMDo1NFrOFrOlgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2NzU2NA==", "bodyText": "Seems to only be used in tests... is it needed?", "url": "https://github.com/confluentinc/ksql/pull/4563#discussion_r380867564", "createdAt": "2020-02-18T18:52:50Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSerdeUtils.java", "diffHunk": "@@ -23,14 +23,66 @@\n import io.confluent.ksql.schema.connect.SchemaWalker.Visitor;\n import io.confluent.ksql.schema.ksql.PersistenceSchema;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Schema.Type;\n \n final class JsonSerdeUtils {\n \n+  // the JsonSchemaConverter adds a magic NULL byte and 4 bytes for the\n+  // schema ID at the start of the message\n+  private static final int SIZE_OF_SR_PREFIX = Byte.BYTES + Integer.BYTES;\n+\n   private JsonSerdeUtils() {\n   }\n \n+  /**\n+   * Convert JSON serialized with {@link io.confluent.connect.json.JsonSchemaConverter}\n+   * to standard JSON serialization.\n+   *\n+   * @param json the bytes representing the serialized JSON\n+   * @return the serialized form with the magic byte and schemaID, or {@code json}\n+   *         if it was not serialized with a magic byte to begin with\n+   */\n+  static byte[] removeMagicAndSchemaId(@Nullable final byte[] json) {\n+    if (!hasMagicByte(json)) {\n+      return json;\n+    }\n+\n+    final byte[] out = new byte[json.length - SIZE_OF_SR_PREFIX];\n+    System.arraycopy(json, SIZE_OF_SR_PREFIX, out, 0, json.length - SIZE_OF_SR_PREFIX);\n+    return out;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ea41af51945a20c1d808e08e086ea7fcc3d672"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg3MjA2NA==", "bodyText": "it was, now it's not, it will be again when we introduce JSON_SR format so I will keep it in for now \ud83d\ude02", "url": "https://github.com/confluentinc/ksql/pull/4563#discussion_r380872064", "createdAt": "2020-02-18T19:00:54Z", "author": {"login": "agavra"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSerdeUtils.java", "diffHunk": "@@ -23,14 +23,66 @@\n import io.confluent.ksql.schema.connect.SchemaWalker.Visitor;\n import io.confluent.ksql.schema.ksql.PersistenceSchema;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Schema.Type;\n \n final class JsonSerdeUtils {\n \n+  // the JsonSchemaConverter adds a magic NULL byte and 4 bytes for the\n+  // schema ID at the start of the message\n+  private static final int SIZE_OF_SR_PREFIX = Byte.BYTES + Integer.BYTES;\n+\n   private JsonSerdeUtils() {\n   }\n \n+  /**\n+   * Convert JSON serialized with {@link io.confluent.connect.json.JsonSchemaConverter}\n+   * to standard JSON serialization.\n+   *\n+   * @param json the bytes representing the serialized JSON\n+   * @return the serialized form with the magic byte and schemaID, or {@code json}\n+   *         if it was not serialized with a magic byte to begin with\n+   */\n+  static byte[] removeMagicAndSchemaId(@Nullable final byte[] json) {\n+    if (!hasMagicByte(json)) {\n+      return json;\n+    }\n+\n+    final byte[] out = new byte[json.length - SIZE_OF_SR_PREFIX];\n+    System.arraycopy(json, SIZE_OF_SR_PREFIX, out, 0, json.length - SIZE_OF_SR_PREFIX);\n+    return out;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2NzU2NA=="}, "originalCommit": {"oid": "18ea41af51945a20c1d808e08e086ea7fcc3d672"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2169, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}