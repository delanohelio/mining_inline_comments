{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3Mjk1NTgx", "number": 5661, "title": "docs: KLIP-30 - Lambda Functions", "bodyText": "This KLIP proposes support for lambda functions. Lambda functions would be used in conjunction with an invocation function that tells ksqlDB how to apply them to the input. For example,\nSELECT transform_array(arr, s => UCASE(s)) FROM stream EMIT CHANGES;\nThis invocation of transform_array would return a transformed array containing uppercased strings.\nHuge thanks to @blueedgenick, who recently proposed this idea!", "createdAt": "2020-06-19T21:06:21Z", "url": "https://github.com/confluentinc/ksql/pull/5661", "merged": true, "mergeCommit": {"oid": "353615adc87f3a3a2187d8feb553593c81bf7f1b"}, "closed": true, "closedAt": "2020-10-08T22:14:29Z", "author": {"login": "derekjn"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcs5QBFAH2gAyNDM3Mjk1NTgxOjhjYjIzZWZmMWQ0MmIzYWFhNTY0MWFhYWQwNjU2YjY4NzU3ZTUyMjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQpBxaAFqTUwNTE5OTk1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8cb23eff1d42b3aaa5641aaad0656b68757e5229", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/8cb23eff1d42b3aaa5641aaad0656b68757e5229", "committedDate": "2020-06-19T20:40:50Z", "message": "KLIP-30 - Lambda Functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2982bf48af52bbac003f975aed7c76fe9c63241e", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/2982bf48af52bbac003f975aed7c76fe9c63241e", "committedDate": "2020-06-19T20:44:13Z", "message": "Add metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6513e7370f4ba8f348c07cf91485d7f9d1cbec66", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/6513e7370f4ba8f348c07cf91485d7f9d1cbec66", "committedDate": "2020-06-19T20:45:00Z", "message": "Add metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48ffc6e3102cd283bb902f30ea1fb08ee5c5b2c3", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/48ffc6e3102cd283bb902f30ea1fb08ee5c5b2c3", "committedDate": "2020-06-19T20:45:41Z", "message": "KLIP-30"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc19d178448c4d4c53877fc8938d0fe1c094d7d2", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/cc19d178448c4d4c53877fc8938d0fe1c094d7d2", "committedDate": "2020-06-19T20:46:19Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f18df722ab3a2e877b8eaf08f23676ecd869981", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/6f18df722ab3a2e877b8eaf08f23676ecd869981", "committedDate": "2020-06-19T21:03:25Z", "message": "Minor edits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad3ac5a97f4f4cec9f694b415b62ffb30f8b524b", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/ad3ac5a97f4f4cec9f694b415b62ffb30f8b524b", "committedDate": "2020-06-19T21:12:03Z", "message": "Link to discussion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bbe12595069c1e794fb2e5bf7b55d7530e5625f", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/3bbe12595069c1e794fb2e5bf7b55d7530e5625f", "committedDate": "2020-06-19T21:13:33Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b84e6b585d12d6e7ca8fcf5c1675f821372dea15", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/b84e6b585d12d6e7ca8fcf5c1675f821372dea15", "committedDate": "2020-06-19T21:14:22Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c678a6b5975ddae30997f8bd62f5a1f4fb24989", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/0c678a6b5975ddae30997f8bd62f5a1f4fb24989", "committedDate": "2020-06-19T21:15:29Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ab675cd93a5f2766919546d07e883920637182a", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/5ab675cd93a5f2766919546d07e883920637182a", "committedDate": "2020-06-19T21:22:10Z", "message": "Link to discussion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c7e54e58f35a2af0ebd0a02e3817e71707a6574", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/5c7e54e58f35a2af0ebd0a02e3817e71707a6574", "committedDate": "2020-06-19T21:24:03Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03adda0a9b1c78e2fcb9e83018d248f06a11d32e", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/03adda0a9b1c78e2fcb9e83018d248f06a11d32e", "committedDate": "2020-06-19T21:25:34Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1c5d550d2a5f8beb51f21fc5172ba01ca67ab2f", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/c1c5d550d2a5f8beb51f21fc5172ba01ca67ab2f", "committedDate": "2020-06-19T21:27:18Z", "message": "Link to section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9828aa8f36bb42a5a0260f2f82ebb67c920d8a63", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/9828aa8f36bb42a5a0260f2f82ebb67c920d8a63", "committedDate": "2020-06-19T21:47:24Z", "message": "Clarify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "473551fad0b84f9fa8f85dc6ade5cec7cec4b7b2", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/473551fad0b84f9fa8f85dc6ade5cec7cec4b7b2", "committedDate": "2020-06-19T21:59:36Z", "message": "Add open question"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca19c1c1a8230cb5cad347e898eccc4dcef1214a", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/ca19c1c1a8230cb5cad347e898eccc4dcef1214a", "committedDate": "2020-06-19T23:15:10Z", "message": "Add to description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/985af883bd4af67f58da20976bd56a9ff8d0b1a5", "committedDate": "2020-06-19T23:20:17Z", "message": "Add to description"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0Mzc5NjE1", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-434379615", "createdAt": "2020-06-19T23:30:41Z", "commit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMzozMDo0MlrOGmjR6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMzozMDo0MlrOGmjR6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NzA5Ng==", "bodyText": "This seems a little complex for something you could implement as reduce_array(arr, (x, y) => x + y).  How do you imagine this being used with reduce_* functions?  This seems like it would be a separate replacement  for functional reduce, with labmdas implemented a little differently.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443077096", "createdAt": "2020-06-19T23:30:42Z", "author": {"login": "AlanConfluent"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDUwOTE0", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-434450914", "createdAt": "2020-06-20T20:08:23Z", "commit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDowODoyM1rOGmoIUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDowODoyM1rOGmoIUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjU2MQ==", "bodyText": "Above you state: Aggregates should not be allowed -- seems to be a contradiction?", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156561", "createdAt": "2020-06-20T20:08:23Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDUwOTQ2", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-434450946", "createdAt": "2020-06-20T20:09:19Z", "commit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDowOToxOVrOGmoIeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDowOToxOVrOGmoIeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwMQ==", "bodyText": "Are we sure, that allowing multiple return values does not cause problems?", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156601", "createdAt": "2020-06-20T20:09:19Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDUxMTM5", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-434451139", "createdAt": "2020-06-20T20:13:10Z", "commit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDoxMzoxMFrOGmoJUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDoxMzoxMFrOGmoJUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjgxNw==", "bodyText": "This might be a good idea.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156817", "createdAt": "2020-06-20T20:13:10Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`\n+\n+If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**\n+\n+**4. Should we extend ksqlDB's UDF interface to allow users to write their own lambda invocation functions?**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDUxMjcz", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-434451273", "createdAt": "2020-06-20T20:15:59Z", "commit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDoxNTo1OVrOGmoJ6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDoxNTo1OVrOGmoJ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1Njk2OA==", "bodyText": "I guess lambdas make sense for any \"collection\" data type. For scalar types, they seem useless because instead of writing (x,y) => x + y and apply it to two integers, one can just use the expression x + y of the lambda directly.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156968", "createdAt": "2020-06-20T20:15:59Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`\n+\n+If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23f6262511f90de5345ead91fa1f8ebea6ff1289", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/23f6262511f90de5345ead91fa1f8ebea6ff1289", "committedDate": "2020-06-20T21:20:18Z", "message": "Close open question (1)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4ecd6c81cec7e5e2f8548f2d408facf4e198b15", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/c4ecd6c81cec7e5e2f8548f2d408facf4e198b15", "committedDate": "2020-06-22T15:54:56Z", "message": "Replace transform_map with transform_keys/transform_values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba4ced49d953632e1edaf65eabb1383bfabb853d", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/ba4ced49d953632e1edaf65eabb1383bfabb853d", "committedDate": "2020-06-22T17:58:17Z", "message": "Clarify restriction around aggregate calls within lambda functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/5f5f44e4d3da2d19574970598eff41352ceec6cd", "committedDate": "2020-06-22T19:22:42Z", "message": "Use v instead of k"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MjExMzM1", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-436211335", "createdAt": "2020-06-23T22:47:26Z", "commit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjo0NzoyN1rOGn9KCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowMjo1MVrOGn9dxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTY0MA==", "bodyText": "just some thoughts about the implementation - we'd need to be able to determine the output type (in this case, y) in order to know the type of the output. Given that y is just a SQL expression and that we know the input types, we should be able to infer this. I'm wondering if there's ever a time when it's not possible to infer but I don't think that'll be the case", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444549640", "createdAt": "2020-06-23T22:47:27Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MTc5MA==", "bodyText": "I think we're missing a section here on how these functions would be defined (likely as UDFs) in the ksql code base. Perhaps we'd be looking at something like:\n@UdfDescription(name=\"transform_array\", description=\"...\") \npublic class TransformArray {\n  \n  @Udf\n  public <S, T> List<T> transform(List<S> array, Function<S, T> valueTransform) {\n    ...\n  }\n}\nSince these lambda functions mostly make sense in the context of collections, we need to make sure that we support generics as above (I think we do)", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444551790", "createdAt": "2020-06-23T22:53:57Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MjgxOA==", "bodyText": "This doesn't really make sense to me from a functional programming perspective. A lambda is stateless, how can it have an aggregation inside of it? The canonical solution to aggregate a list in functional programming is to use reduce and I think diverging from that would just confuse things, not simplify.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444552818", "createdAt": "2020-06-23T22:57:10Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mzc2OQ==", "bodyText": "I think another valuable question is if we should support lambdas in UDAFs. For example we could have COUNTIF(col, x -> shouldKeep) (so essentially flipping this open question upside down \ud83d\ude02 )", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444553769", "createdAt": "2020-06-23T22:59:57Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw==", "bodyText": "it should be from my perspective!", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444554487", "createdAt": "2020-06-23T23:02:10Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDY5NQ==", "bodyText": "ah, see my comment above - I was thinking that we'd implement this as a UDF ourselves \ud83d\ude02 kill two birds with one UDF", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444554695", "createdAt": "2020-06-23T23:02:51Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**\n+\n+**4. Should we extend ksqlDB's UDF interface to allow users to write their own lambda invocation functions?**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "committedDate": "2020-06-23T23:27:16Z", "message": "Close open question (4)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzcyMTIy", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-436772122", "createdAt": "2020-06-24T15:40:00Z", "commit": {"oid": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNTo0MDowMVrOGoX-jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjoyNDoyNFrOGs0lAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4OTA2OQ==", "bodyText": "I don't think there'd be any issues reusing -> and if we encountered any during development we could switch to =>.\nIs there any other SQL systems that support lambda functions?  If so, what syntax do they use?\nI did a quick google search, and aside from the AWS lambda noise, the only think lambda + SQL that I managed to find was https://openproceedings.org/2019/conf/edbt/EDBT19_paper_3.pdf, which I've never heard of and uses a strange \u03bb(a, b) (a * b) syntax.\nAs you say, we use -> for field access, and I think this is pretty none-standard.  For example, Postgres uses a . to access a custom types field.  If this is a standard pattern for accessing fields in custom types, then we may want to consider switching anyway, following a period of supporting both -> and . for field access.\nI'm not strongly suggesting we do any of this - just highlighting it's an option.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444989069", "createdAt": "2020-06-24T15:40:01Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NDQ2Mg==", "bodyText": "There'll defo be cases where the sql type of the expression is unknown or ambiguous:\n\nAnything returning null would be unknown, e.g. a user wanting to create a copy of an array where all the elements are null:  transform_array(arry, x => null)\nAnything accepting a literal may be ambiguous(ish), e.g. INT vs BIGINT,\n\nThat said, requiring users to CAST nulls seems pretty acceptable, and the same goes for literals that don't auto-convert to the type the user wants e.g. CAST(20 AS BIGINT).\nSo I think all we need is test cases for the null cases to ensure the user gets a meaningful error and not something confusing or an NPE.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449644462", "createdAt": "2020-07-03T15:57:45Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTY0MA=="}, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTE1Nw==", "bodyText": "What about a transform_map method that allows the user to convert both keys and values together, e.g.\ntransform_map(map, (k, v) => newKey, (k, v) => newValue)\nSo it takes two lambda, but each lambda only returns a single value (to keep things simple).  Definitely worth passing the both key and value to each lambda.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449645157", "createdAt": "2020-07-03T16:00:02Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0OTUyMg==", "bodyText": "Would it not be possible to allow users to build their own UDAFs from lambdas by just providing a few build-in UDAFs called udaf:\n-- Simple type:\n-- col0: the input to aggregate\n-- initial: initial agg value.\n-- (col0, agg) => agg: the lambda that takes the current value and aggregate and calcs a new agg.\nudaf(col0, initial, (col0, agg) => agg)\n\n-- Extended to support different intermediate schema:\n-- col0: the input to aggregate\n-- initial: initial agg value.\n-- (col0, m) => m: updates aggregate (with intermediate schema)\n-- m => f, converts intermediate schema to final schema.\nudaf(col0, initial, (col0, m) => m, m => f)\n\n-- Session windows need a merge function too, so we'd need a session variant:\n-- as above, plus:\n-- (f1, f2) => merged: merge two sessions together\nudaf(col0, initial, (col0, m) => m, (m1, m2) => merged, m => f)\n\nI think just these few udafs would allow users to build custom aggregators using CASE statements for flow control, and build-in functions and operators.\nWe can extend the above with multiple parameter variants:\nudaf(col0, initial, (col0, agg) => agg)\nudaf(col0, col1, initial, (col0, col1, agg) => agg)\nudaf(col0, col2, col3, initial, (col0, col1, col3, agg) => agg)\n... etc.\n\nOf course, to do this we'd first need to do this: https://github.com/confluentinc/ksql/projects/4 (which I'm trying to get prioritized, as its a blocker for a lot of UDAF improvements).", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449649522", "createdAt": "2020-07-03T16:15:04Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mzc2OQ=="}, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDU5Ng==", "bodyText": "I don't think it works for STRUCT given the disparate field types.  I don't think SQL can express how to handle the different types.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449650596", "createdAt": "2020-07-03T16:18:54Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`\n+\n+If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1Njk2OA=="}, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTUxMQ==", "bodyText": "How about some flatMap style transforms?  Not sure what's the best SQLy name, but something where the lambda can return zero or more elements. For want of a better name 'flatmap_array(array, e => e[])`.\nThis is basically lambdas for table functions.\nThis could be used, for example, to convert ARRAY<ARRAY<INT>> into ARRAY<INT> with flatmap_array(array. e => e).\nUsers can then build more complex UDTFs using CASE for flow and our functions and operators.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449651511", "createdAt": "2020-07-03T16:22:31Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTk3MA==", "bodyText": "What are you thinking @agavra?  Breaking changes to the UDF framework or engine internals?  Feels like this would only be a breaking change for the former.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449651970", "createdAt": "2020-07-03T16:24:24Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw=="}, "originalCommit": {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0afaea73f3204220c9e372369d956abb493a298", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/b0afaea73f3204220c9e372369d956abb493a298", "committedDate": "2020-07-06T17:35:15Z", "message": "Add transform_map invocation function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTkxOTIy", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-486991922", "createdAt": "2020-09-11T17:28:26Z", "commit": {"oid": "b0afaea73f3204220c9e372369d956abb493a298"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzoyODoyNlrOHQnjoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzozMToxOVrOHQnpXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NzM2MQ==", "bodyText": "For functions that may result in ambiguous types of new_k, new_v e.g. such that KSQL cannot infer the new schema field types, would we require users to specify the return value types in their lambda function? If yes, how we would enforce this?", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r487187361", "createdAt": "2020-09-11T17:28:26Z", "author": {"login": "guozhangwang"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `transform_map(map, (k, v) => new_k, (k, v) => new_v)` - Applies the given lambda functions to the keys and values of the input `Map`, respectively. A new `Map` containing the transformed keys and values is returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0afaea73f3204220c9e372369d956abb493a298"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4ODAwOA==", "bodyText": "Could you elaborate a bit why reduce would be allowed but other sum/count/avg etc would not? I think implementation wise they would be the same. And if we are concerned about inferring the return data type the other transform_map would already have this problem anyways.", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r487188008", "createdAt": "2020-09-11T17:29:42Z", "author": {"login": "guozhangwang"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjU2MQ=="}, "originalCommit": {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4ODgyOA==", "bodyText": "If we allow own lambda invocation functions, how that would impact our existing new query creation process? Would that require an extra step of loading user jars e.g.?", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r487188828", "createdAt": "2020-09-11T17:31:19Z", "author": {"login": "guozhangwang"}, "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `transform_map(map, (k, v) => new_k, (k, v) => new_v)` - Applies the given lambda functions to the keys and values of the input `Map`, respectively. A new `Map` containing the transformed keys and values is returned.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**\n+\n+~~**4. Should we extend ksqlDB's UDF interface to allow users to write their own lambda invocation functions?**~~", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0afaea73f3204220c9e372369d956abb493a298"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1406e554cc313663619843996509ca4df52562ba", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/1406e554cc313663619843996509ca4df52562ba", "committedDate": "2020-10-08T20:54:37Z", "message": "Use UDF interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0764d53b46e337e1a92c3dc377d6161688423ea", "author": {"user": {"login": "derekjn", "name": "Derek Nelson"}}, "url": "https://github.com/confluentinc/ksql/commit/c0764d53b46e337e1a92c3dc377d6161688423ea", "committedDate": "2020-10-08T20:58:19Z", "message": "Merge master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MTk5OTU4", "url": "https://github.com/confluentinc/ksql/pull/5661#pullrequestreview-505199958", "createdAt": "2020-10-08T22:08:04Z", "commit": {"oid": "c0764d53b46e337e1a92c3dc377d6161688423ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 245, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}