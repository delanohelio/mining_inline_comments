{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NjAwNDg3", "number": 5775, "title": "feat(client): support DDL/DML statements in Java client", "bodyText": "Description\nFixes #5584\nJavadocs for the new methods are included in this PR. Usage docs will come in a follow-up PR.\nTesting done\nUnit + integration tests.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-07-07T19:08:30Z", "url": "https://github.com/confluentinc/ksql/pull/5775", "merged": true, "mergeCommit": {"oid": "53ca76f5c7198ed471b2e6ef19b595888c991b7f"}, "closed": true, "closedAt": "2020-07-15T01:03:14Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyphlOgH2gAyNDQ1NjAwNDg3OjhlODY1MGQ5NmU3NjBlOTFhN2UyYjUxYzEwNTAyYjAzNTFiM2IyNGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0uC1CAH2gAyNDQ1NjAwNDg3OjBjNWE4N2ZhNjZjMDJiY2MzMTQ4MDQ5Mjk5MDQyODg3ZmIyMmNiNzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8e8650d96e760e91a7e2b51c10502b0351b3b24d", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/8e8650d96e760e91a7e2b51c10502b0351b3b24d", "committedDate": "2020-07-07T17:45:05Z", "message": "feat(client): support DDL/DML statements in Java client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361d5df9e2a33f6b4f8cc49d1390f604d3ed0eef", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/361d5df9e2a33f6b4f8cc49d1390f604d3ed0eef", "committedDate": "2020-07-07T18:41:48Z", "message": "chore: validate number of statements upfront"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/1d5177914a837ad3f7251052e25aad2516337cf1", "committedDate": "2020-07-07T18:53:52Z", "message": "docs: javadocs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTc0MDAx", "url": "https://github.com/confluentinc/ksql/pull/5775#pullrequestreview-444174001", "createdAt": "2020-07-07T19:08:57Z", "commit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowODo1N1rOGuL7ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowODo1N1rOGuL7ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ==", "bodyText": "I considered having a return type to contain the command sequence number here, rather than returning void. The command seqeunce number could be useful in the future, since it could be used to ensure that subsequent requests (transient queries, admin operations, etc.) are not executed until the necessary streams/tables have been created, but this is advanced usage that is not currently supported by the client, so exposing the command sequence number right now is not useful. Is it worth introducing an empty return type, e.g., ExecuteStatementResult as a placeholder, in case we want to expose the command sequence number in the future? Not sure how confusion from having an empty return type now trades off against potentially updating the API in a backwards-incompatible way in the future.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r451083171", "createdAt": "2020-07-07T19:08:57Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.\n+   *\n+   * <p>Each request should contain exactly one statement. Requests that contain multiple statements\n+   * will be rejected by the client, in the form of failing the {@code CompletableFuture}, and the\n+   * request will not be sent to the server.\n+   *\n+   * <p>The {@code CompletableFuture} is completed once a response is received from the server.\n+   * Note that the actual execution of the submitted statement is asynchronous, so the statement\n+   * may not have been executed by the time the {@code CompletableFuture} is completed.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql the request to be executed\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> executeStatement(String sql);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTc0MTEw", "url": "https://github.com/confluentinc/ksql/pull/5775#pullrequestreview-444174110", "createdAt": "2020-07-07T19:09:06Z", "commit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowOTowNlrOGuL7_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowOTowNlrOGuL7_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg==", "bodyText": "As explained in the javadocs, the CompletableFuture is completed once the server accepts the statement. The actual statement execution is async, so the statement likely will not have been executed by the time the future is complete. Hopefully this is not too confusing to users.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r451083262", "createdAt": "2020-07-07T19:09:06Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.\n+   *\n+   * <p>Each request should contain exactly one statement. Requests that contain multiple statements\n+   * will be rejected by the client, in the form of failing the {@code CompletableFuture}, and the\n+   * request will not be sent to the server.\n+   *\n+   * <p>The {@code CompletableFuture} is completed once a response is received from the server.\n+   * Note that the actual execution of the submitted statement is asynchronous, so the statement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTc0MzYz", "url": "https://github.com/confluentinc/ksql/pull/5775#pullrequestreview-444174363", "createdAt": "2020-07-07T19:09:28Z", "commit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowOToyOFrOGuL8vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowOToyOFrOGuL8vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzQ1Mw==", "bodyText": "I considered introducing separate methods specific for terminating persistent queries and dropping streams/tables, but decided the additional complexity wasn't worth the minor benefit. Happy to hear other opinions on this, though.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r451083453", "createdAt": "2020-07-07T19:09:28Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzQ4OTIw", "url": "https://github.com/confluentinc/ksql/pull/5775#pullrequestreview-447348920", "createdAt": "2020-07-13T15:17:11Z", "commit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxNzoxMVrOGwtQKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTo0Mzo0N1rOGwufiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNjI0OQ==", "bodyText": "I'm curious why we don't complete the CompletableFuture when the statement has been executed? I think that would be more intuitive for the user.\nIs there any other way for the user to know when the statements has been executed? I'm thinking of use cases where they want to create a stream then start sending messages to it. Before sending the messages they need to know it's been created.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453726249", "createdAt": "2020-07-13T15:17:11Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.\n+   *\n+   * <p>Each request should contain exactly one statement. Requests that contain multiple statements\n+   * will be rejected by the client, in the form of failing the {@code CompletableFuture}, and the\n+   * request will not be sent to the server.\n+   *\n+   * <p>The {@code CompletableFuture} is completed once a response is received from the server.\n+   * Note that the actual execution of the submitted statement is asynchronous, so the statement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg=="}, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyODE3OA==", "bodyText": "If we don't complete the future until the command has been executed then I don't think we need a command sequence number. It seems perhaps that the command sequence number on the REST API is a workaround as there's no way to get a callback on completion with REST. But with a proper future I think we can implement it in a nicer way :)", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453728178", "createdAt": "2020-07-13T15:19:46Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.\n+   *\n+   * <p>Each request should contain exactly one statement. Requests that contain multiple statements\n+   * will be rejected by the client, in the form of failing the {@code CompletableFuture}, and the\n+   * request will not be sent to the server.\n+   *\n+   * <p>The {@code CompletableFuture} is completed once a response is received from the server.\n+   * Note that the actual execution of the submitted statement is asynchronous, so the statement\n+   * may not have been executed by the time the {@code CompletableFuture} is completed.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql the request to be executed\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> executeStatement(String sql);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ=="}, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMjMwMg==", "bodyText": "Just a sanity check probably best to check if the optional value is present before calling get(). (Same with below too)", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453732302", "createdAt": "2020-07-13T15:25:28Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/AdminResponseHandlers.java", "diffHunk": "@@ -35,10 +35,119 @@ private AdminResponseHandlers() {\n   static void handleListStreamsResponse(\n       final JsonObject streamsListEntity,\n       final CompletableFuture<List<StreamInfo>> cf\n+  ) {\n+    try {\n+      cf.complete(getListStreamsResponse(streamsListEntity).get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTMzNw==", "bodyText": "Do we really want to swallow the exception here? It might make sense to propagate the exception to the completable future in the calling method.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453735337", "createdAt": "2020-07-13T15:29:53Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/AdminResponseHandlers.java", "diffHunk": "@@ -47,18 +156,22 @@ static void handleListStreamsResponse(\n           .collect(Collectors.toList())\n       );\n     } catch (Exception e) {\n-      cf.completeExceptionally(new IllegalStateException(\n-          \"Unexpected server response format. Response: \" + streamsListEntity));\n+      return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczODYyNA==", "bodyText": "Not a big deal but is it really worth putting this method in its own class? Might be simpler to just have the method in the class where it's used.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453738624", "createdAt": "2020-07-13T15:34:36Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/DdlDmlRequestValidators.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.exception.KsqlClientException;\n+import java.util.concurrent.CompletableFuture;\n+\n+final class DdlDmlRequestValidators {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0NjU2OA==", "bodyText": "This seems fair enough, but another way of doing this would be to check the sql the user passes to executeStatement, if it's not one of the allowed commands we can reject it before sending to the server. Would just need to trim and lower case the string, then check for string prefix.", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453746568", "createdAt": "2020-07-13T15:43:47Z", "author": {"login": "purplefox"}, "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/DdlDmlResponseHandlers.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.exception.KsqlClientException;\n+import io.vertx.core.json.JsonObject;\n+import java.util.concurrent.CompletableFuture;\n+\n+final class DdlDmlResponseHandlers {\n+\n+  public static final String EXECUTE_STATEMENT_REQUEST_ACCEPTED_DOC =\n+      \"The ksqlDB server accepted the statement issued via executeStatement(), but the response \"\n+      + \"received is of an unexpected format. \";\n+  public static final String EXECUTE_STATEMENT_USAGE_DOC = \"The executeStatement() method is only \"\n+      + \"for 'CREATE', 'CREATE ... AS SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS \"\n+      + \"SELECT' statements. \";\n+\n+  private DdlDmlResponseHandlers() {\n+  }\n+\n+  static void handleExecuteStatementResponse(\n+      final JsonObject ksqlEntity,\n+      final CompletableFuture<Void> cf\n+  ) {\n+    if (!isCommandStatusEntity(ksqlEntity)) {\n+      handleUnexpectedEntity(ksqlEntity, cf);\n+      return;\n+    }\n+\n+    cf.complete(null);\n+  }\n+\n+  static RuntimeException handleUnexpectedNumResponseEntities(final int numEntities) {\n+    if (numEntities == 0) {\n+      return new KsqlClientException(EXECUTE_STATEMENT_REQUEST_ACCEPTED_DOC\n+          + EXECUTE_STATEMENT_USAGE_DOC);\n+    }\n+\n+    throw new IllegalStateException(\n+        \"Unexpected number of entities in server response: \" + numEntities);\n+  }\n+\n+  private static boolean isCommandStatusEntity(final JsonObject ksqlEntity) {\n+    return ksqlEntity.getString(\"commandId\") != null\n+        && ksqlEntity.getJsonObject(\"commandStatus\") != null;\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: CyclomaticComplexity\n+  private static void handleUnexpectedEntity(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c5a87fa66c02bcc3148049299042887fb22cb75", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/0c5a87fa66c02bcc3148049299042887fb22cb75", "committedDate": "2020-07-14T04:08:52Z", "message": "chore: switch try-catch to if-else"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4813, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}