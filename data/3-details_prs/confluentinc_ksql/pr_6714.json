{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMzQ5MzI4", "number": 6714, "title": "fix: Removes orphaned topics from transient queries", "bodyText": "Description\nFixes #4009\nWhen a server is uncleanly shutdown or killed, it may leave orphaned topics from transient queries.  This PR attempts to clean up these topic when the server starts up.\nThis is accomplished by writing transient query application ids to disk of the local node.  This ensures that any topics are only attempted to be deleted by one node, the one that created it.  The data isn't durable in that a node can shutdown and not restart, potentially leaving state uncleaned up.\nTesting done\nDescribe the testing strategy. Unit and integration tests are expected for any behavior changes.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-12-02T23:17:03Z", "url": "https://github.com/confluentinc/ksql/pull/6714", "merged": true, "mergeCommit": {"oid": "06d6e3e7b6aafa659de5273af1244987d3f9b3ab"}, "closed": true, "closedAt": "2020-12-10T23:37:03Z", "author": {"login": "AlanConfluent"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkOcSwgH2gAyNTMxMzQ5MzI4OmE0YzcyZTU5ZTgyNmUzZmJlMzgwMzM2MWFjOTZmMDc3N2E0OTJlNzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdk7BE4gH2gAyNTMxMzQ5MzI4OjQ4NDQ4NGE0YTAyNDZlOTU3MDY5N2I3NGIwYjYzMTk2NDlmODQ4Yzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a4c72e59e826e3fbe3803361ac96f0777a492e70", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/a4c72e59e826e3fbe3803361ac96f0777a492e70", "committedDate": "2020-12-08T18:28:05Z", "message": "fix: Removes orphaned topics from transient queries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7fa9ea8bf96bf5e205580c64808365bfad49e1", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/ac7fa9ea8bf96bf5e205580c64808365bfad49e1", "committedDate": "2020-12-08T18:28:05Z", "message": "Catch exception while listing topic names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00285af9ecaa61e241f95d272d0b057cf265a9b5", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/00285af9ecaa61e241f95d272d0b057cf265a9b5", "committedDate": "2020-12-08T19:11:50Z", "message": "Writes transient queries to disk so they can be cleaned up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c572b5ae2feb8f9c344158fd373d1c4ff339e2b", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/0c572b5ae2feb8f9c344158fd373d1c4ff339e2b", "committedDate": "2020-12-08T19:14:02Z", "message": "Lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "committedDate": "2020-12-08T19:17:56Z", "message": "Lint again"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d6f964fbe25c1a86258c0fe21deca16cff45a12", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/5d6f964fbe25c1a86258c0fe21deca16cff45a12", "committedDate": "2020-12-08T04:15:10Z", "message": "Lint"}, "afterCommit": {"oid": "c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "committedDate": "2020-12-08T19:17:56Z", "message": "Lint again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/a9a671b9a2201de213f794a849c71be56a3a4140", "committedDate": "2020-12-08T20:21:38Z", "message": "Fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTI4OTcz", "url": "https://github.com/confluentinc/ksql/pull/6714#pullrequestreview-547528973", "createdAt": "2020-12-08T18:50:47Z", "commit": {"oid": "5d6f964fbe25c1a86258c0fe21deca16cff45a12"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxODo1MDo0N1rOIBwuCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoxMjo0NVrOIB4ldA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNzcwNA==", "bodyText": "should we be using startsWith? I thought that in cloud we prefix all the topics with things other than just the transient application id. contains might be a safer bet either way", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538717704", "createdAt": "2020-12-08T18:50:47Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();\n+    } catch (KafkaResponseGetFailedException e) {\n+      LOG.error(\"Couldn't fetch topic names\", e);\n+      return;\n+    }\n+    // Find any transient query topics\n+    final Set<String> orphanedQueryApplicationIds = topicNames.stream()\n+        .map(topicName -> queryApplicationIds.stream().filter(topicName::startsWith).findFirst())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d6f964fbe25c1a86258c0fe21deca16cff45a12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxOTU5Mg==", "bodyText": "if I recall, this is actually a somewhat expensive metadata operation (though we may want to confirm with Kafka experts) if we'll be calling it regularly. Should we flip the semantics (i.e. check whether a topic corresponding to an orphaned query exists) instead of the other way around?", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538719592", "createdAt": "2020-12-08T18:53:24Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d6f964fbe25c1a86258c0fe21deca16cff45a12"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgyNTMwMA==", "bodyText": "Maybe I'm missing something, but shouldn't this filter out any that are currently running? otherwise won't we delete topics for queries that are running?\nEDIT: I noticed that what's passed in is only ever the orphaned queryIDs. Can we javadoc this method to explain that?", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538825300", "createdAt": "2020-12-08T21:36:25Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();\n+    } catch (KafkaResponseGetFailedException e) {\n+      LOG.error(\"Couldn't fetch topic names\", e);\n+      return;\n+    }\n+    // Find any transient query topics\n+    final Set<String> orphanedQueryApplicationIds = topicNames.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgyNjY3Nw==", "bodyText": "nit: can we follow given/when/then convention? (it's basically already there but without the comments)", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538826677", "createdAt": "2020-12-08T21:38:53Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/OrphanedTransientQueryCleanerTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableSet;\n+import io.confluent.ksql.engine.QueryCleanupService.QueryCleanupTask;\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OrphanedTransientQueryCleanerTest {\n+  private static final String TOPIC1\n+      = \"_confluent-ksql-default_transient_932097300573686369_1606940079718\"\n+      + \"-Aggregate-GroupBy-repartition\";\n+  private static final String TOPIC2\n+      = \"_confluent-ksql-default_transient_932097300573686369_1606940079718\"\n+      + \"-Aggregate-Aggregate-Materialize-changelog\";\n+  private static final String TOPIC3\n+      = \"_confluent-ksql-default_transient_123497300573686369_1606940012345\"\n+      + \"-Aggregate-Aggregate-Materialize-changelog\";\n+\n+  private static final String BAD_TOPIC_NAME\n+      = \"_confluent-ksql-default_node0_transient_bad\";\n+\n+  private static final String APP_ID_1\n+      = \"_confluent-ksql-default_transient_932097300573686369_1606940079718\";\n+  private static final String APP_ID_2\n+      = \"_confluent-ksql-default_transient_123497300573686369_1606940012345\";\n+\n+  @Mock\n+  private QueryCleanupService queryCleanupService;\n+  @Mock\n+  private ServiceContext serviceContext;\n+  @Mock\n+  private KafkaTopicClient topicClient;\n+  @Captor\n+  private ArgumentCaptor<QueryCleanupTask> taskCaptor;\n+\n+  private OrphanedTransientQueryCleaner cleaner;\n+\n+  @Before\n+  public void setUp() {\n+    when(serviceContext.getTopicClient()).thenReturn(topicClient);\n+    cleaner = new OrphanedTransientQueryCleaner(queryCleanupService);\n+  }\n+\n+  @Test\n+  public void shouldCleanup_allApplicationIds() {\n+    when(topicClient.listTopicNames()).thenReturn(ImmutableSet.of(TOPIC1, TOPIC2, TOPIC3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzODM1Mw==", "bodyText": "do you think it makes sense to make this an interface with JsonSubTypes so that we can handle a union of lots of different types of LocalCommands (see ExecutionStep for example) or is that overkill?", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538838353", "createdAt": "2020-12-08T21:58:35Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommand.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A command which is executed locally and possibly requiring cleanup next time the server is\n+ * restarted.\n+ */\n+public class LocalCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzOTMyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());\n          \n          \n            \n                  throw new KsqlServerException(\"Bad local commands directory \" + directory.getAbsolutePath() + \". Please check your configuration for \" + KsqlConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG);", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538839325", "createdAt": "2020-12-08T22:00:13Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommands.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.server.LocalCommand.Type;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlServerException;\n+import io.confluent.ksql.util.TransientQueryMetadata;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents commands that are issued to this node only (therefore not written to the command\n+ * topic), and might require additional cleanup later.  An example is a transient query.\n+ * These commands are stored locally on disk so that we can do any cleanup required, next time\n+ * the server restarts. This is only appropriate for best effort tasks since the data isn't durable\n+ * (since a node might leave and never rejoin the cluster).\n+ */\n+public class LocalCommands implements Closeable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCommands.class);\n+\n+  static final String LOCAL_COMMANDS_FILE_SUFFIX = \".cmds\";\n+  static final String LOCAL_COMMANDS_PROCESSED_SUFFIX = \".processed\";\n+  private static final Random RANDOM = new Random();\n+\n+  private final File directory;\n+  private final KsqlEngine ksqlEngine;\n+  private final LocalCommandsFile currentLocalCommands;\n+\n+  LocalCommands(\n+      final File directory,\n+      final KsqlEngine ksqlEngine,\n+      final LocalCommandsFile currentLocalCommands\n+  ) {\n+    this.directory = directory;\n+    this.ksqlEngine = ksqlEngine;\n+    this.currentLocalCommands = currentLocalCommands;\n+  }\n+\n+  public File getCurrentLocalCommandsFile() {\n+    return currentLocalCommands.getFile();\n+  }\n+\n+  public void processLocalCommandFiles(\n+      final ServiceContext serviceContext\n+  ) {\n+    final FilenameFilter filter = (dir, fileName) -> fileName.endsWith(LOCAL_COMMANDS_FILE_SUFFIX);\n+    final File[] files = directory.listFiles(filter);\n+    if (files == null) {\n+      throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MDk3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.error(\"Failed to write local command\", e);\n          \n          \n            \n                  LOG.error(\"Failed to write local command for transient query:\" + queryMetadata.getQueryApplicationId(), e);", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538840974", "createdAt": "2020-12-08T22:03:00Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommands.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.server.LocalCommand.Type;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlServerException;\n+import io.confluent.ksql.util.TransientQueryMetadata;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents commands that are issued to this node only (therefore not written to the command\n+ * topic), and might require additional cleanup later.  An example is a transient query.\n+ * These commands are stored locally on disk so that we can do any cleanup required, next time\n+ * the server restarts. This is only appropriate for best effort tasks since the data isn't durable\n+ * (since a node might leave and never rejoin the cluster).\n+ */\n+public class LocalCommands implements Closeable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCommands.class);\n+\n+  static final String LOCAL_COMMANDS_FILE_SUFFIX = \".cmds\";\n+  static final String LOCAL_COMMANDS_PROCESSED_SUFFIX = \".processed\";\n+  private static final Random RANDOM = new Random();\n+\n+  private final File directory;\n+  private final KsqlEngine ksqlEngine;\n+  private final LocalCommandsFile currentLocalCommands;\n+\n+  LocalCommands(\n+      final File directory,\n+      final KsqlEngine ksqlEngine,\n+      final LocalCommandsFile currentLocalCommands\n+  ) {\n+    this.directory = directory;\n+    this.ksqlEngine = ksqlEngine;\n+    this.currentLocalCommands = currentLocalCommands;\n+  }\n+\n+  public File getCurrentLocalCommandsFile() {\n+    return currentLocalCommands.getFile();\n+  }\n+\n+  public void processLocalCommandFiles(\n+      final ServiceContext serviceContext\n+  ) {\n+    final FilenameFilter filter = (dir, fileName) -> fileName.endsWith(LOCAL_COMMANDS_FILE_SUFFIX);\n+    final File[] files = directory.listFiles(filter);\n+    if (files == null) {\n+      throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());\n+    }\n+    for (final File file : files) {\n+      if (file.equals(currentLocalCommands.getFile())) {\n+        continue;\n+      }\n+      try (LocalCommandsFile localCommandsFile = LocalCommandsFile.createReadonly(file)) {\n+        final List<LocalCommand> localCommands = localCommandsFile.readRecords();\n+        cleanUpTransientQueryState(localCommands, serviceContext);\n+\n+        markFileAsProcessed(file);\n+      } catch (Exception e) {\n+        LOG.error(\"Error processing local commands \" + file.getAbsolutePath(), e);\n+        throw new KsqlServerException(\"Error processing local commands\", e);\n+      }\n+    }\n+  }\n+\n+  public void write(final TransientQueryMetadata queryMetadata) {\n+    try {\n+      currentLocalCommands.write(\n+          new LocalCommand(Type.TRANSIENT_QUERY, queryMetadata.getQueryApplicationId()));\n+    } catch (IOException e) {\n+      // Just log an error since not catching it would likely cause more cleanup work than this\n+      // aims to fix.\n+      LOG.error(\"Failed to write local command\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MTU2OA==", "bodyText": "why not just delete the file? Do we every use these?", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538841568", "createdAt": "2020-12-08T22:04:11Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommands.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.server.LocalCommand.Type;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlServerException;\n+import io.confluent.ksql.util.TransientQueryMetadata;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents commands that are issued to this node only (therefore not written to the command\n+ * topic), and might require additional cleanup later.  An example is a transient query.\n+ * These commands are stored locally on disk so that we can do any cleanup required, next time\n+ * the server restarts. This is only appropriate for best effort tasks since the data isn't durable\n+ * (since a node might leave and never rejoin the cluster).\n+ */\n+public class LocalCommands implements Closeable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCommands.class);\n+\n+  static final String LOCAL_COMMANDS_FILE_SUFFIX = \".cmds\";\n+  static final String LOCAL_COMMANDS_PROCESSED_SUFFIX = \".processed\";\n+  private static final Random RANDOM = new Random();\n+\n+  private final File directory;\n+  private final KsqlEngine ksqlEngine;\n+  private final LocalCommandsFile currentLocalCommands;\n+\n+  LocalCommands(\n+      final File directory,\n+      final KsqlEngine ksqlEngine,\n+      final LocalCommandsFile currentLocalCommands\n+  ) {\n+    this.directory = directory;\n+    this.ksqlEngine = ksqlEngine;\n+    this.currentLocalCommands = currentLocalCommands;\n+  }\n+\n+  public File getCurrentLocalCommandsFile() {\n+    return currentLocalCommands.getFile();\n+  }\n+\n+  public void processLocalCommandFiles(\n+      final ServiceContext serviceContext\n+  ) {\n+    final FilenameFilter filter = (dir, fileName) -> fileName.endsWith(LOCAL_COMMANDS_FILE_SUFFIX);\n+    final File[] files = directory.listFiles(filter);\n+    if (files == null) {\n+      throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());\n+    }\n+    for (final File file : files) {\n+      if (file.equals(currentLocalCommands.getFile())) {\n+        continue;\n+      }\n+      try (LocalCommandsFile localCommandsFile = LocalCommandsFile.createReadonly(file)) {\n+        final List<LocalCommand> localCommands = localCommandsFile.readRecords();\n+        cleanUpTransientQueryState(localCommands, serviceContext);\n+\n+        markFileAsProcessed(file);\n+      } catch (Exception e) {\n+        LOG.error(\"Error processing local commands \" + file.getAbsolutePath(), e);\n+        throw new KsqlServerException(\"Error processing local commands\", e);\n+      }\n+    }\n+  }\n+\n+  public void write(final TransientQueryMetadata queryMetadata) {\n+    try {\n+      currentLocalCommands.write(\n+          new LocalCommand(Type.TRANSIENT_QUERY, queryMetadata.getQueryApplicationId()));\n+    } catch (IOException e) {\n+      // Just log an error since not catching it would likely cause more cleanup work than this\n+      // aims to fix.\n+      LOG.error(\"Failed to write local command\", e);\n+    }\n+  }\n+\n+  public static LocalCommands open(\n+      final KsqlEngine ksqlEngine,\n+      final File directory\n+  ) {\n+    if (!directory.exists()) {\n+      if (!directory.mkdirs()) {\n+        throw new KsqlServerException(\"Couldn't create the local commands directory: \"\n+            + directory.getPath()\n+            + \"\\n Make sure the directory exists and is readable/writable for KSQL server \"\n+            + \"\\n or its parent directory is readable/writable by KSQL server\"\n+            + \"\\n or change it to a readable/writable directory by setting '\"\n+            + KsqlRestConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG\n+            + \"' config in the properties file.\"\n+        );\n+      }\n+\n+      try {\n+        Files.setPosixFilePermissions(directory.toPath(),\n+            PosixFilePermissions.fromString(\"rwx------\"));\n+      } catch (final IOException e) {\n+        throw new KsqlServerException(String.format(\n+            \"Couldn't set POSIX permissions on the backups directory: %s. Error = %s\",\n+            directory.getPath(), e.getMessage()));\n+      }\n+    }\n+\n+    if (!directory.isDirectory()) {\n+      throw new KsqlServerException(directory.getPath()\n+          + \" is not a directory.\"\n+          + \"\\n Make sure the directory exists and is readable/writable for KSQL server \"\n+          + \"\\n or its parent directory is readable/writable by KSQL server\"\n+          + \"\\n or change it to a readable/writable directory by setting '\"\n+          + KsqlRestConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG\n+          + \"' config in the properties file.\"\n+      );\n+    }\n+\n+    if (!directory.canWrite() || !directory.canRead() || !directory.canExecute()) {\n+      throw new KsqlServerException(\"The local commands directory is not readable/writable \"\n+          + \"for KSQL server: \"\n+          + directory.getPath()\n+          + \"\\n Make sure the directory exists and is readable/writable for KSQL server \"\n+          + \"\\n or change it to a readable/writable directory by setting '\"\n+          + KsqlRestConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG\n+          + \"' config in the properties file.\"\n+      );\n+    }\n+    final File file = new File(directory, String.format(\"local_commands_%d_%s%s\",\n+        System.currentTimeMillis(), Integer.toHexString(RANDOM.nextInt()),\n+        LOCAL_COMMANDS_FILE_SUFFIX));\n+    return new LocalCommands(directory, ksqlEngine, LocalCommandsFile.createWriteable(file));\n+  }\n+\n+  private void markFileAsProcessed(final File file) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MzQyNQ==", "bodyText": "just making sure, this writes it in UTF8 so it's human readable json, right? I think it would be nice to make these files human readble", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538843425", "createdAt": "2020-12-08T22:07:06Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommandsFile.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.confluent.ksql.util.KsqlException;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Represents a single file of commands issued to this node.\n+ */\n+public final class LocalCommandsFile  implements Closeable {\n+\n+  private static final ObjectMapper MAPPER = new ObjectMapper();\n+  private static final byte[] NEW_LINE_SEPARATOR_BYTES =\n+      \"\\n\".getBytes(StandardCharsets.UTF_8);\n+\n+\n+  private final File file;\n+  private final FileOutputStream writer;\n+\n+  private LocalCommandsFile(final File file, final boolean write) {\n+    this.file = Objects.requireNonNull(file, \"file\");\n+\n+    if (write) {\n+      this.writer = createWriter(file);\n+    } else {\n+      this.writer = null;\n+    }\n+  }\n+\n+  public static LocalCommandsFile createReadonly(final File file) {\n+    return new LocalCommandsFile(file, false);\n+  }\n+\n+  public static LocalCommandsFile createWriteable(final File file) {\n+    return new LocalCommandsFile(file, true);\n+  }\n+\n+  public void write(final LocalCommand localCommand) throws IOException {\n+    if (writer == null) {\n+      throw new IOException(\"Write permission denied.\");\n+    }\n+\n+    final byte[] bytes = MAPPER.writeValueAsBytes(localCommand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0NjU4MA==", "bodyText": "since the file is only relevant on a new startup, does it need to be added to the cleanup service or can we just have it do this cleanup on startup?", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538846580", "createdAt": "2020-12-08T22:12:45Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();\n+    } catch (KafkaResponseGetFailedException e) {\n+      LOG.error(\"Couldn't fetch topic names\", e);\n+      return;\n+    }\n+    // Find any transient query topics\n+    final Set<String> orphanedQueryApplicationIds = topicNames.stream()\n+        .map(topicName -> queryApplicationIds.stream().filter(topicName::startsWith).findFirst())\n+        .filter(Optional::isPresent)\n+        .map(Optional::get)\n+        .collect(Collectors.toSet());\n+    for (final String queryApplicationId : orphanedQueryApplicationIds) {\n+      cleanupService.addCleanupTask(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92cb46260af8aa1c717991f2eb9bdef3a2263250", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/92cb46260af8aa1c717991f2eb9bdef3a2263250", "committedDate": "2020-12-09T00:41:29Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Almog Gavra <almog@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzUyODA3", "url": "https://github.com/confluentinc/ksql/pull/6714#pullrequestreview-547752807", "createdAt": "2020-12-09T00:50:38Z", "commit": {"oid": "92cb46260af8aa1c717991f2eb9bdef3a2263250"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c89d54c78e11a59a640dd7dbb29de933102bba9", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/4c89d54c78e11a59a640dd7dbb29de933102bba9", "committedDate": "2020-12-09T00:56:42Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Almog Gavra <almog@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f73ce512c63df7f61c8d7941014a9c40b23a158", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/1f73ce512c63df7f61c8d7941014a9c40b23a158", "committedDate": "2020-12-09T01:09:56Z", "message": "Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "484484a4a0246e9570697b74b0b6319649f848c7", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/484484a4a0246e9570697b74b0b6319649f848c7", "committedDate": "2020-12-10T22:24:05Z", "message": "Removes redundant type field"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4567, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}