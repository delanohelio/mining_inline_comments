{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MjYxNTYx", "number": 5542, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoxNjo1MVrOECP6Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzozMzowMVrOECQQ5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzkzMzE5OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/timestamp-extractor.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoxNjo1MVrOGelv0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo1MzozNFrOGenDdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyODkxNQ==", "bodyText": "can we add a test for a string column with a timestamp formatter as well?", "url": "https://github.com/confluentinc/ksql/pull/5542#discussion_r434728915", "createdAt": "2020-06-03T17:16:51Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/timestamp-extractor.json", "diffHunk": "@@ -37,7 +37,37 @@\n       ]\n     },\n     {\n-      \"name\": \"KSQL throw on invalid timestamp extractor with format\",\n+      \"name\": \"source key timestamp column\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (K BIGINT KEY, ID bigint) WITH (kafka_topic='test_topic', value_format='JSON', timestamp='K');\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3525b3697e697ee75f7cfeb578eb121fc4d3768e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc1MDMyNQ==", "bodyText": "sure.", "url": "https://github.com/confluentinc/ksql/pull/5542#discussion_r434750325", "createdAt": "2020-06-03T17:53:34Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/timestamp-extractor.json", "diffHunk": "@@ -37,7 +37,37 @@\n       ]\n     },\n     {\n-      \"name\": \"KSQL throw on invalid timestamp extractor with format\",\n+      \"name\": \"source key timestamp column\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (K BIGINT KEY, ID bigint) WITH (kafka_topic='test_topic', value_format='JSON', timestamp='K');\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyODkxNQ=="}, "originalCommit": {"oid": "3525b3697e697ee75f7cfeb578eb121fc4d3768e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzk1NDAyOnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/timestamp/LoggingTimestampExtractor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMjoyOVrOGel8xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo1MzoxOVrOGenC8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMjIzMA==", "bodyText": "nit: I don't think we need these safeX do we? string concatenation should handle it", "url": "https://github.com/confluentinc/ksql/pull/5542#discussion_r434732230", "createdAt": "2020-06-03T17:22:29Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/timestamp/LoggingTimestampExtractor.java", "diffHunk": "@@ -71,11 +70,15 @@ TimestampExtractor getDelegate() {\n     return delegate;\n   }\n \n-  private long handleFailure(final Object value, final RuntimeException e) {\n+  private long handleFailure(final Object key, final Object value, final RuntimeException e) {\n+    final Object safeKey = ObjectUtils.defaultIfNull(key, \"null\");\n     final Object safeValue = ObjectUtils.defaultIfNull(value, \"null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3525b3697e697ee75f7cfeb578eb121fc4d3768e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc1MDE5NA==", "bodyText": "Good point - was blindingly cutting and pasting.", "url": "https://github.com/confluentinc/ksql/pull/5542#discussion_r434750194", "createdAt": "2020-06-03T17:53:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/timestamp/LoggingTimestampExtractor.java", "diffHunk": "@@ -71,11 +70,15 @@ TimestampExtractor getDelegate() {\n     return delegate;\n   }\n \n-  private long handleFailure(final Object value, final RuntimeException e) {\n+  private long handleFailure(final Object key, final Object value, final RuntimeException e) {\n+    final Object safeKey = ObjectUtils.defaultIfNull(key, \"null\");\n     final Object safeValue = ObjectUtils.defaultIfNull(value, \"null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMjIzMA=="}, "originalCommit": {"oid": "3525b3697e697ee75f7cfeb578eb121fc4d3768e"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzk5MDc5OnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/timestamp/TimestampColumnExtractors.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzozMzowMVrOGemVHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo1MjoyOVrOGenBEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczODQ2MQ==", "bodyText": "what happens if the value of the key is null? do we properly handle that? (Lots of cloud errors come from having timestamp extractors that have null values)", "url": "https://github.com/confluentinc/ksql/pull/5542#discussion_r434738461", "createdAt": "2020-06-03T17:33:01Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/timestamp/TimestampColumnExtractors.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.timestamp;\n+\n+import com.google.common.base.Preconditions;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * Extracts a column from the ConsumerRecord\n+ */\n+final class TimestampColumnExtractors {\n+\n+  private TimestampColumnExtractors() {\n+  }\n+\n+  static ColumnExtractor create(final Column column) {\n+    final int index = column.index();\n+    Preconditions.checkArgument(index >= 0, \"negative index: \" + index);\n+\n+    return column.namespace() == Namespace.KEY\n+        ? new KeyColumnExtractor(index)\n+        : new ValueColumnExtractor(index);\n+  }\n+\n+  private static class KeyColumnExtractor implements ColumnExtractor {\n+\n+    private final int index;\n+\n+    KeyColumnExtractor(final int index) {\n+      this.index = index;\n+    }\n+\n+    @Override\n+    public Object extract(final Object key, final GenericRow value) {\n+      final Struct struct = getStruct(key);\n+      final Field field = struct.schema().fields().get(index);\n+      return struct.get(field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3525b3697e697ee75f7cfeb578eb121fc4d3768e"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0OTcxNA==", "bodyText": "It should throw in the same way a null value would fail.  The higher level extractor then decides if this is fatal or not.", "url": "https://github.com/confluentinc/ksql/pull/5542#discussion_r434749714", "createdAt": "2020-06-03T17:52:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/timestamp/TimestampColumnExtractors.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.timestamp;\n+\n+import com.google.common.base.Preconditions;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * Extracts a column from the ConsumerRecord\n+ */\n+final class TimestampColumnExtractors {\n+\n+  private TimestampColumnExtractors() {\n+  }\n+\n+  static ColumnExtractor create(final Column column) {\n+    final int index = column.index();\n+    Preconditions.checkArgument(index >= 0, \"negative index: \" + index);\n+\n+    return column.namespace() == Namespace.KEY\n+        ? new KeyColumnExtractor(index)\n+        : new ValueColumnExtractor(index);\n+  }\n+\n+  private static class KeyColumnExtractor implements ColumnExtractor {\n+\n+    private final int index;\n+\n+    KeyColumnExtractor(final int index) {\n+      this.index = index;\n+    }\n+\n+    @Override\n+    public Object extract(final Object key, final GenericRow value) {\n+      final Struct struct = getStruct(key);\n+      final Field field = struct.schema().fields().get(index);\n+      return struct.get(field);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczODQ2MQ=="}, "originalCommit": {"oid": "3525b3697e697ee75f7cfeb578eb121fc4d3768e"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3350, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}