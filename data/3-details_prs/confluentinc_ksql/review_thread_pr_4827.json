{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMDg1NDc2", "number": 4827, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozOTozOVrODqkJoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNjowNzo0NVrODqp1rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTU5MDcyOnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozOTozOVrOF6ZGkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwOToyODozNlrOF6nnSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MzAwOQ==", "bodyText": "Is this a Stream here to handle joins where we will have multiple source schemas?", "url": "https://github.com/confluentinc/ksql/pull/4827#discussion_r396773009", "createdAt": "2020-03-23T21:39:39Z", "author": {"login": "vpapavas"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -71,41 +93,52 @@ public static boolean isAggregate(final ColumnName name) {\n     return name.text().startsWith(AGGREGATE_COLUMN_PREFIX);\n   }\n \n-  /**\n-   * Determines the next unique column alias.\n-   *\n-   * <p>Finds any existing {@code KSQL_COL_x} column names in the supplied {@code sourceSchema} to\n-   * ensure the returned generated column name is unique.\n-   *\n-   * @param sourceSchema the source schema.\n-   * @return a column name in the form {@code KSQL_COL_x} which does not clash with source schema.\n-   */\n-  public static ColumnName nextGeneratedColumnAlias(final LogicalSchema sourceSchema) {\n-    final int maxExistingIdx = maxGeneratedAliasIndex(sourceSchema);\n-    return generatedColumnAlias(maxExistingIdx + 1);\n+  private static OptionalInt extractGeneratedAliasIndex(final ColumnName columnName) {\n+    final Matcher matcher = GENERATED_ALIAS_PATTERN.matcher(columnName.text());\n+    return matcher.matches()\n+        ? OptionalInt.of(Integer.parseInt(matcher.group(1)))\n+        : OptionalInt.empty();\n   }\n \n-  /**\n-   * Determines the highest index of generated column names like {@code KSQL_COL_x} in the supplied\n-   * {@code sourceSchema}.\n-   *\n-   * @param sourceSchema the schema.\n-   * @return the highest index or {@code -1}\n-   */\n-  private static int maxGeneratedAliasIndex(final LogicalSchema sourceSchema) {\n-    return sourceSchema.columns().stream()\n+  private static IntStream generatedAliasIndexes(final Stream<LogicalSchema> sourceSchema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b72da696c7408a077af3648873402f6d5b832131"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAxMDc2MQ==", "bodyText": "Correct. Joins can have multiple sources...", "url": "https://github.com/confluentinc/ksql/pull/4827#discussion_r397010761", "createdAt": "2020-03-24T09:28:36Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -71,41 +93,52 @@ public static boolean isAggregate(final ColumnName name) {\n     return name.text().startsWith(AGGREGATE_COLUMN_PREFIX);\n   }\n \n-  /**\n-   * Determines the next unique column alias.\n-   *\n-   * <p>Finds any existing {@code KSQL_COL_x} column names in the supplied {@code sourceSchema} to\n-   * ensure the returned generated column name is unique.\n-   *\n-   * @param sourceSchema the source schema.\n-   * @return a column name in the form {@code KSQL_COL_x} which does not clash with source schema.\n-   */\n-  public static ColumnName nextGeneratedColumnAlias(final LogicalSchema sourceSchema) {\n-    final int maxExistingIdx = maxGeneratedAliasIndex(sourceSchema);\n-    return generatedColumnAlias(maxExistingIdx + 1);\n+  private static OptionalInt extractGeneratedAliasIndex(final ColumnName columnName) {\n+    final Matcher matcher = GENERATED_ALIAS_PATTERN.matcher(columnName.text());\n+    return matcher.matches()\n+        ? OptionalInt.of(Integer.parseInt(matcher.group(1)))\n+        : OptionalInt.empty();\n   }\n \n-  /**\n-   * Determines the highest index of generated column names like {@code KSQL_COL_x} in the supplied\n-   * {@code sourceSchema}.\n-   *\n-   * @param sourceSchema the schema.\n-   * @return the highest index or {@code -1}\n-   */\n-  private static int maxGeneratedAliasIndex(final LogicalSchema sourceSchema) {\n-    return sourceSchema.columns().stream()\n+  private static IntStream generatedAliasIndexes(final Stream<LogicalSchema> sourceSchema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MzAwOQ=="}, "originalCommit": {"oid": "b72da696c7408a077af3648873402f6d5b832131"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDUyMjcwOnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNjowNzo0NVrOF6iELg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwOTozNToyOVrOF6n4mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxOTg1NA==", "bodyText": "nit: if we pass 1 here we should get names more consistent with what we had before (start at offset 1), and a smaller test diff.", "url": "https://github.com/confluentinc/ksql/pull/4827#discussion_r396919854", "createdAt": "2020-03-24T06:07:45Z", "author": {"login": "rodesai"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -41,11 +50,24 @@ public static ColumnName aggregateColumn(final int idx) {\n   }\n \n   /**\n-   * Where the user hasn't specified an alias for an expression in a SELECT we generate them using\n-   * this method. This value is exposed to the user in the output schema\n+   * Create a generator that will build column aliases in the form {@code KSQL_COL_x}.\n+   *\n+   * <p>Names are guaranteed not to clash with any existing columns in the {@code sourceSchemas}.\n+   *\n+   * <p>Used where the user hasn't specified an alias for an expression in a SELECT. This generated\n+   * column names are exposed to the user in the output schema.\n+   *\n+   * @param sourceSchemas the stream of source schemas.\n+   * @return a generator of unique column names.\n    */\n-  public static ColumnName generatedColumnAlias(final int idx) {\n-    return ColumnName.of(GENERATED_ALIAS_PREFIX + idx);\n+  public static Supplier<ColumnName> columnAliasGenerator(\n+      final Stream<LogicalSchema> sourceSchemas\n+  ) {\n+    final Set<Integer> used = generatedAliasIndexes(sourceSchemas)\n+        .boxed()\n+        .collect(Collectors.toSet());\n+\n+    return new AliasGenerator(0, used)::next;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b72da696c7408a077af3648873402f6d5b832131"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAxNTE5NQ==", "bodyText": "I thought that too and tried it. However, the old code started at zero too.  If we switch this to 1 we just get a different set of tests to change.\n private int selectItemIndex = 0;\nThe changes are because the name is no longer controlled by the index of the select expresssion.", "url": "https://github.com/confluentinc/ksql/pull/4827#discussion_r397015195", "createdAt": "2020-03-24T09:35:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -41,11 +50,24 @@ public static ColumnName aggregateColumn(final int idx) {\n   }\n \n   /**\n-   * Where the user hasn't specified an alias for an expression in a SELECT we generate them using\n-   * this method. This value is exposed to the user in the output schema\n+   * Create a generator that will build column aliases in the form {@code KSQL_COL_x}.\n+   *\n+   * <p>Names are guaranteed not to clash with any existing columns in the {@code sourceSchemas}.\n+   *\n+   * <p>Used where the user hasn't specified an alias for an expression in a SELECT. This generated\n+   * column names are exposed to the user in the output schema.\n+   *\n+   * @param sourceSchemas the stream of source schemas.\n+   * @return a generator of unique column names.\n    */\n-  public static ColumnName generatedColumnAlias(final int idx) {\n-    return ColumnName.of(GENERATED_ALIAS_PREFIX + idx);\n+  public static Supplier<ColumnName> columnAliasGenerator(\n+      final Stream<LogicalSchema> sourceSchemas\n+  ) {\n+    final Set<Integer> used = generatedAliasIndexes(sourceSchemas)\n+        .boxed()\n+        .collect(Collectors.toSet());\n+\n+    return new AliasGenerator(0, used)::next;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxOTg1NA=="}, "originalCommit": {"oid": "b72da696c7408a077af3648873402f6d5b832131"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3797, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}