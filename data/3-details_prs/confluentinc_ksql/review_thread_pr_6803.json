{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMzU1NDkz", "number": 6803, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxNToxMlrOFHSyCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo1NDozNVrOFHTplg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTkyMDczOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxNToxMlrOIItfSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOToyMzozMlrOIIv8bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDgwOA==", "bodyText": "i think this is OK", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546004808", "createdAt": "2020-12-18T18:15:12Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -663,7 +665,7 @@ private LogicalSchema buildAggregateSchema(\n \n   private LogicalSchema buildRepartitionedSchema(\n       final PlanNode sourceNode,\n-      final Expression partitionBy\n+      final List<Expression> partitionBy // TODO: rename?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NTAzOA==", "bodyText": "Already renamed. Sorry for not squashing my pre-cleanup commits as I usually do. Not worth your time looking at my intermediate thought process while drafting, haha.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546045038", "createdAt": "2020-12-18T19:23:32Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -663,7 +665,7 @@ private LogicalSchema buildAggregateSchema(\n \n   private LogicalSchema buildRepartitionedSchema(\n       final PlanNode sourceNode,\n-      final Expression partitionBy\n+      final List<Expression> partitionBy // TODO: rename?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDgwOA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTkzNTE5OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxODoxNlrOIItohA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDoyMTo1OVrOIIxmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg==", "bodyText": "nit: since we already import ImmutableList let's just use ImmutableList.of here", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546007172", "createdAt": "2020-12-18T18:18:16Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -405,7 +407,7 @@ private PreJoinRepartitionNode buildInternalRepartitionNode(\n         ExpressionTreeRewriter.rewriteWith(plugin, joinExpression);\n \n     final LogicalSchema schema =\n-        buildRepartitionedSchema(source, rewrittenPartitionBy);\n+        buildRepartitionedSchema(source, Collections.singletonList(rewrittenPartitionBy));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MTk4Mg==", "bodyText": "You mean we import ImmutableList in this file or in the module? I don't see it in the file but I can add it.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546041982", "createdAt": "2020-12-18T19:17:47Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -405,7 +407,7 @@ private PreJoinRepartitionNode buildInternalRepartitionNode(\n         ExpressionTreeRewriter.rewriteWith(plugin, joinExpression);\n \n     final LogicalSchema schema =\n-        buildRepartitionedSchema(source, rewrittenPartitionBy);\n+        buildRepartitionedSchema(source, Collections.singletonList(rewrittenPartitionBy));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MjI1MQ==", "bodyText": "oh huh, I must've been looking at a separate file. - in PreJoinRepartitionNode for example it was already there before this PR. It's nice to just standardize on one (and most of hte code uses ImmutableList#of, though there isn't really any good reason to use that over Collections.singletonList except for mabye that ImmutableList has more general usages)", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546072251", "createdAt": "2020-12-18T20:21:59Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -405,7 +407,7 @@ private PreJoinRepartitionNode buildInternalRepartitionNode(\n         ExpressionTreeRewriter.rewriteWith(plugin, joinExpression);\n \n     final LogicalSchema schema =\n-        buildRepartitionedSchema(source, rewrittenPartitionBy);\n+        buildRepartitionedSchema(source, Collections.singletonList(rewrittenPartitionBy));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTkzNzAxOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxODozOFrOIItpvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOToxODozMlrOIIvx5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzQ4NQ==", "bodyText": "nit: same thing about ImmutableList", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546007485", "createdAt": "2020-12-18T18:18:38Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -111,7 +112,7 @@ public void setKeyFormat(final KeyFormat format) {\n     return getSource().buildStream(builder)\n         .selectKey(\n             valueFormat.getFormatInfo(),\n-            partitionBy,\n+            Collections.singletonList(partitionBy),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MjM0MA==", "bodyText": "Sure. For my edification, why is ImmutableList preferred?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546042340", "createdAt": "2020-12-18T19:18:32Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -111,7 +112,7 @@ public void setKeyFormat(final KeyFormat format) {\n     return getSource().buildStream(builder)\n         .selectKey(\n             valueFormat.getFormatInfo(),\n-            partitionBy,\n+            Collections.singletonList(partitionBy),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzQ4NQ=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk0NTAwOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyMDo1N1rOIItupA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOToyMjoxNVrOIIv43A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODc0MA==", "bodyText": "do we still need to make a copy of the original partition by now that it's a list?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546008740", "createdAt": "2020-12-18T18:20:57Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java", "diffHunk": "@@ -103,9 +107,19 @@ public Expression resolveSelect(final int idx, final Expression expression) {\n \n   @Override\n   void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n-    if (!(partitionBy instanceof NullLiteral) && !projection.containsExpression(partitionBy)) {\n-      final ImmutableList<Expression> keys = ImmutableList.of(originalPartitionBy);\n+    if (!PartitionByParamsFactory.isPartitionByNull(partitionBy)\n+        && !containsExpressions(projection, partitionBy)) {\n+      final ImmutableList<Expression> keys = ImmutableList.copyOf(originalPartitionBy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NDEyNA==", "bodyText": "Nope, removed.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546044124", "createdAt": "2020-12-18T19:22:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java", "diffHunk": "@@ -103,9 +107,19 @@ public Expression resolveSelect(final int idx, final Expression expression) {\n \n   @Override\n   void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n-    if (!(partitionBy instanceof NullLiteral) && !projection.containsExpression(partitionBy)) {\n-      final ImmutableList<Expression> keys = ImmutableList.of(originalPartitionBy);\n+    if (!PartitionByParamsFactory.isPartitionByNull(partitionBy)\n+        && !containsExpressions(projection, partitionBy)) {\n+      final ImmutableList<Expression> keys = ImmutableList.copyOf(originalPartitionBy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODc0MA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk0NjM3OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyMToyN1rOIItviw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyMToyN1rOIItviw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODk3MQ==", "bodyText": "ditto: no need for the copy", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546008971", "createdAt": "2020-12-18T18:21:27Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -314,15 +314,15 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n    */\n   public SchemaKStream<K> selectKey(\n       final FormatInfo valueFormat,\n-      final Expression keyExpression,\n+      final List<Expression> keyExpression,\n       final Optional<KeyFormat> forceInternalKeyFormat,\n       final Stacker contextStacker,\n       final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat);\n \n-    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.of(keyExpression));\n+    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.copyOf(keyExpression));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk2NDQ5OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNjozNVrOIIt6Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo0NDozNVrOIIwlgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTcxOA==", "bodyText": "might be interesting to do this with DELIMITED so that we can assert that the key order actually changes", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546011718", "createdAt": "2020-12-18T18:26:35Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1025,6 +1025,140 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Map keys, including types that contain maps, are not supported as they may lead to unexpected behavior due to inconsistent serialization. Key column name: `VAL`. Column type: STRUCT<`F1` MAP<STRING, INTEGER>>. See https://github.com/confluentinc/ksql/issues/6621 for more.\"\n       }\n+    },\n+    {\n+      \"name\": \"multiple columns - select star\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select * from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - select explicit\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - some key some value\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": \"bob\", \"value\": {\"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple key columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT KEY, AGE INT) with (kafka_topic='input', format='JSON');\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NTU1NA==", "bodyText": "Done -- added a new test since delimited doesn't allow testing of null handling.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546055554", "createdAt": "2020-12-18T19:44:35Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1025,6 +1025,140 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Map keys, including types that contain maps, are not supported as they may lead to unexpected behavior due to inconsistent serialization. Key column name: `VAL`. Column type: STRUCT<`F1` MAP<STRING, INTEGER>>. See https://github.com/confluentinc/ksql/issues/6621 for more.\"\n       }\n+    },\n+    {\n+      \"name\": \"multiple columns - select star\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select * from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - select explicit\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - some key some value\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": \"bob\", \"value\": {\"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple key columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT KEY, AGE INT) with (kafka_topic='input', format='JSON');\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTcxOA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk2NzEyOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNzoxOFrOIIt7zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNzoxOFrOIIt7zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjEwOQ==", "bodyText": "can we name one of the expressions in the projection to make sure that the key name is properly propagated to the schema?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546012109", "createdAt": "2020-12-18T18:27:18Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1025,6 +1025,140 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Map keys, including types that contain maps, are not supported as they may lead to unexpected behavior due to inconsistent serialization. Key column name: `VAL`. Column type: STRUCT<`F1` MAP<STRING, INTEGER>>. See https://github.com/confluentinc/ksql/issues/6621 for more.\"\n       }\n+    },\n+    {\n+      \"name\": \"multiple columns - select star\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select * from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - select explicit\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - some key some value\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": \"bob\", \"value\": {\"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple key columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT KEY, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": {\"NAME\": \"bob\", \"ID\": 10}, \"value\": {\"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns with expressions\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk4Mzc1OnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODozMjoyMlrOIIuF1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDoyMjozMVrOIIxnzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw==", "bodyText": "what's wrong with a duplicate partition by expression? I don't see any reason why a user might want it, but I don't see why not either (e.g. maybe their output data expects userId, userSpecialId in the key and this stream always has the same value for both)\nI get that the key name conflicts might be a little weird, so we can do this in a follow-up PR, but I don't think we should prohibit it", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546014677", "createdAt": "2020-12-18T18:32:22Z", "author": {"login": "agavra"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -17,27 +17,43 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.parser.NodeLocation;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class PartitionBy extends AstNode {\n \n-  private final Expression expression;\n+  private final List<Expression> partitionByExpressions;\n \n   public PartitionBy(\n       final Optional<NodeLocation> location,\n-      final Expression partitionBy\n+      final List<Expression> partitionByExpressions\n   ) {\n     super(location);\n-    this.expression = requireNonNull(partitionBy, \"partitionBy\");\n+    this.partitionByExpressions = ImmutableList\n+        .copyOf(requireNonNull(partitionByExpressions, \"partitionByExpressions\"));\n+\n+    if (partitionByExpressions.isEmpty()) {\n+      throw new KsqlException(\"PARTITION BY requires at least one expression\");\n+    }\n+\n+    final HashSet<Object> partitionBys = new HashSet<>(partitionByExpressions.size());\n+    partitionByExpressions.forEach(exp -> {\n+      if (!partitionBys.add(exp)) {\n+        throw new KsqlException(\"Duplicate PARTITION BY expression: \" + exp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0Mzg2Mw==", "bodyText": "This is consistent with what we do for multi-column GROUP BY (which has been around for a long time): \n  \n    \n      ksql/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/GroupBy.java\n    \n    \n        Lines 49 to 53\n      in\n      e7f1f47\n    \n    \n    \n    \n\n        \n          \n           groupingExpressions.forEach(exp -> { \n        \n\n        \n          \n             if (!groupBys.add(exp)) { \n        \n\n        \n          \n               throw new KsqlException(\"Duplicate GROUP BY expression: \" + exp); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }); \n        \n    \n  \n\n\nI believe the reason indeed has to do with naming.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546043863", "createdAt": "2020-12-18T19:21:40Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -17,27 +17,43 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.parser.NodeLocation;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class PartitionBy extends AstNode {\n \n-  private final Expression expression;\n+  private final List<Expression> partitionByExpressions;\n \n   public PartitionBy(\n       final Optional<NodeLocation> location,\n-      final Expression partitionBy\n+      final List<Expression> partitionByExpressions\n   ) {\n     super(location);\n-    this.expression = requireNonNull(partitionBy, \"partitionBy\");\n+    this.partitionByExpressions = ImmutableList\n+        .copyOf(requireNonNull(partitionByExpressions, \"partitionByExpressions\"));\n+\n+    if (partitionByExpressions.isEmpty()) {\n+      throw new KsqlException(\"PARTITION BY requires at least one expression\");\n+    }\n+\n+    final HashSet<Object> partitionBys = new HashSet<>(partitionByExpressions.size());\n+    partitionByExpressions.forEach(exp -> {\n+      if (!partitionBys.add(exp)) {\n+        throw new KsqlException(\"Duplicate PARTITION BY expression: \" + exp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MjUyNg==", "bodyText": "sounds good, we can keep it like that for now", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546072526", "createdAt": "2020-12-18T20:22:31Z", "author": {"login": "agavra"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -17,27 +17,43 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.parser.NodeLocation;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class PartitionBy extends AstNode {\n \n-  private final Expression expression;\n+  private final List<Expression> partitionByExpressions;\n \n   public PartitionBy(\n       final Optional<NodeLocation> location,\n-      final Expression partitionBy\n+      final List<Expression> partitionByExpressions\n   ) {\n     super(location);\n-    this.expression = requireNonNull(partitionBy, \"partitionBy\");\n+    this.partitionByExpressions = ImmutableList\n+        .copyOf(requireNonNull(partitionByExpressions, \"partitionByExpressions\"));\n+\n+    if (partitionByExpressions.isEmpty()) {\n+      throw new KsqlException(\"PARTITION BY requires at least one expression\");\n+    }\n+\n+    final HashSet<Object> partitionBys = new HashSet<>(partitionByExpressions.size());\n+    partitionByExpressions.forEach(exp -> {\n+      if (!partitionBys.add(exp)) {\n+        throw new KsqlException(\"Duplicate PARTITION BY expression: \" + exp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk4NzY1OnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODozMzozNVrOIIuILQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODozMzozNVrOIIuILQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNTI3Nw==", "bodyText": "not your code, but can we rename this partitionBy?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546015277", "createdAt": "2020-12-18T18:33:35Z", "author": {"login": "agavra"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -54,18 +70,18 @@ public boolean equals(final Object o) {\n       return false;\n     }\n     final PartitionBy groupBy = (PartitionBy) o;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjA0OTYxOnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo1MTo0NVrOIIutJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjowNDoyN1rOII0D2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA==", "bodyText": "instead of relying on the implicit ordering of the partition by, it might make sense to lookup the partitionByCol.name in the resultSchema at the cost of a bit of performance. thoughts?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546024740", "createdAt": "2020-12-18T18:51:45Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0OTQyMg==", "bodyText": "Do you mean replacing shouldAppend with a check to see whether the partitionByCol.name is present in the resultSchema as a value column, or do you mean iterating through resultSchema rather than partitionByCols? The former doesn't seem like an improvement to me, if we're still relying on the ordering of partitionByCols in the iteration. To remove reliance on ordering, we can do the latter and replace the lists (of columns and evaluators) with maps keyed on column name instead, but it's not clear to me that's better. It feels slightly harder to reason about code-wise but I wouldn't mind making the change.\nWhat's your concern regarding relying the ordering? Are you worried it's brittle, or something else?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546049422", "createdAt": "2020-12-18T19:31:23Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3NTY4Ng==", "bodyText": "When I was reviewing the code I thought we could just set it at the index (e.g. row.set(resultSchema.get(partitionCol.name).index())). So we still keep the iteration on partitionByCol but we set it in the row based on it's index in the schema.\n\nWhat's your concern regarding relying the ordering? Are you worried it's brittle, or something else?\n\nyeah - I'm worried that it's brittle.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546075686", "createdAt": "2020-12-18T20:29:36Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMDE2MA==", "bodyText": "Ah, interesting. (We'd have to first re-size the row before calling .set() but that's an implementation detail.) The advantage of your proposal is that we can change the details of the result schema without needing to update the logic here. If we extended that further, really we should also be setting the existing value fields in the new row based on the result schema, rather than leaving those intact and appending key columns.\nI guess I'm not convinced this change is necessary since our test coverage in this area is quite good -- lots of tests would break if someone modified the result schema without corresponding updates here. OTOH, it's very possible I'm biased towards thinking this code is understandable as is since I've been working on it for a while. If your assessment differs as someone who hasn't worked with this code as much, I'm inclined to go with your judgment.\nAs for performance, LogicalSchema stores a list of columns so finding a particular column might be slow. If we implemented this we'd want to build the index mapping outside the creation of the actual mapper, and have the mapper use the index mapping directly. I'm not opposed to this. If you think it's preferable I can open a follow-up PR.", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546110160", "createdAt": "2020-12-18T21:58:00Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMjQ3NA==", "bodyText": "I'm happy to leave it as is, though I suspect we'll run into this discussion again if/when we stop copying things from the key into the value", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546112474", "createdAt": "2020-12-18T22:04:27Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjA2Mjk0OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo1NDozNVrOIIu11w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo1NDozNVrOIIu11w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNjk2Nw==", "bodyText": "or... we can finally swap over to using PAPI :)", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546026967", "createdAt": "2020-12-18T18:54:35Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1098,12 +1150,27 @@\n     },\n     {\n       \"name\": \"multiple columns including ROWTIME\",\n+      \"comments\": [\n+        \"Ideally the third row of output would contain ROWTIME populated as 12 in the output key.\",\n+        \"This doesn't happen today because ROWTIME is evaluated from the value, which is null in this\",\n+        \"example. To fix this, we'd have to add special handling to detect when a key expression\",\n+        \"depends only on ROWTIME, similar to how today we have special handling to detect when a key\",\n+        \"expression depends only on key columns.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27844a82ef43ea083000058e16c62ac7be3cd846"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2388, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}