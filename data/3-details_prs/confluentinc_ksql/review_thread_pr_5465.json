{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMTA4NTcw", "number": 5465, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyMzozOVrOD_F26g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyNzozOFrOD_F4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDgyODU4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyMzozOVrOGZl1zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyMzozOVrOGZl1zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // AstSanitizer should catches ambiguous columns\n          \n          \n            \n                        // AstSanitizer should catch ambiguous columns", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487565", "createdAt": "2020-05-22T23:23:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDgyOTY1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyNDo0OVrOGZl2YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMDowNzoyMFrOGZmO6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw==", "bodyText": "seems like if we're checking equality it should be made either an enum or a constant", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487713", "createdAt": "2020-05-22T23:24:49Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns\n+            return Iterables.getOnlyElement(sourcesWithField);\n+          });\n+\n+      referencedSources.add(source);\n+    }\n \n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + name.text() + \"' is ambiguous. \"\n-            + \"Could be any of: \" + possibilities);\n+    private boolean couldBeSyntheticJoinColumn(final ColumnReferenceExp colRef) {\n+      if (!possibleSyntheticColumns) {\n+        // Some queries never have synthetic columns, e.g. pull or aggregations.\n+        return false;\n       }\n \n-      return Optional.of(Iterables.getOnlyElement(sourcesWithField));\n-    }\n+      if (!sourceSchemas.isJoin()) {\n+        // Synthetic join columns only occur in joins... duh!\n+        return false;\n+      }\n \n-    private String errorPrefix(final Optional<NodeLocation> location) {\n-      final String loc = location\n-          .map(Objects::toString)\n-          .map(text -> text + \": \")\n-          .orElse(\"\");\n+      if (colRef instanceof QualifiedColumnReferenceExp) {\n+        // Synthetic join columns can't be qualified, as they don't belong to any source\n+        return false;\n+      }\n+\n+      if (!clauseType.equals(\"SELECT\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5Mzk5NQ==", "bodyText": "Normally I'd agree, but it's only short term code and there are tests to ensure it does what we need.", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429493995", "createdAt": "2020-05-23T00:07:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns\n+            return Iterables.getOnlyElement(sourcesWithField);\n+          });\n+\n+      referencedSources.add(source);\n+    }\n \n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + name.text() + \"' is ambiguous. \"\n-            + \"Could be any of: \" + possibilities);\n+    private boolean couldBeSyntheticJoinColumn(final ColumnReferenceExp colRef) {\n+      if (!possibleSyntheticColumns) {\n+        // Some queries never have synthetic columns, e.g. pull or aggregations.\n+        return false;\n       }\n \n-      return Optional.of(Iterables.getOnlyElement(sourcesWithField));\n-    }\n+      if (!sourceSchemas.isJoin()) {\n+        // Synthetic join columns only occur in joins... duh!\n+        return false;\n+      }\n \n-    private String errorPrefix(final Optional<NodeLocation> location) {\n-      final String loc = location\n-          .map(Objects::toString)\n-          .map(text -> text + \": \")\n-          .orElse(\"\");\n+      if (colRef instanceof QualifiedColumnReferenceExp) {\n+        // Synthetic join columns can't be qualified, as they don't belong to any source\n+        return false;\n+      }\n+\n+      if (!clauseType.equals(\"SELECT\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw=="}, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDgzMjY3OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyNzozOFrOGZl4Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoyNzozOFrOGZl4Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4ODE1OA==", "bodyText": "would be nice to javadoc", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429488158", "createdAt": "2020-05-22T23:27:38Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+\n+public class PreJoinRepartitionNode extends RepartitionNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3276, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}