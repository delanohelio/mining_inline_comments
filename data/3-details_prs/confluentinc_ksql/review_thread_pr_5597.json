{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzI2MTg1", "number": 5597, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoxNjoyNVrOEEelgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNDowNDoyMlrOEEiKTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTMwODgxOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/StandaloneExecutorFunctionalTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoxNjoyNVrOGiIIXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzo1ODo1NFrOGiKGeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzNzk4MQ==", "bodyText": "Whoa, this is so useful! I've been using all sorts of crazy workarounds since I didn't know about this. Thanks for the tip \ud83d\ude05", "url": "https://github.com/confluentinc/ksql/pull/5597#discussion_r438437981", "createdAt": "2020-06-10T22:16:25Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/StandaloneExecutorFunctionalTest.java", "diffHunk": "@@ -51,15 +51,20 @@\n import org.junit.Before;\n import org.junit.BeforeClass;\n import org.junit.ClassRule;\n+import org.junit.FixMethodOrder;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n+import org.junit.runners.MethodSorters;\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnitRunner;\n \n @Category({IntegrationTest.class})\n @RunWith(MockitoJUnitRunner.class)\n+// shouldFailOnAvroWithoutSchemasIfSchemaNotEvolvable fails if run after shouldHandleJsonWithSchemas\n+@FixMethodOrder(MethodSorters.NAME_ASCENDING)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36763838d9b578958b89728c8eb259b40f2940c7"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MDI2NA==", "bodyText": "tbh, this isn't great practice \ud83d\ude05 but I didn't want to distract from the fix. In general tests shouldn't depend on ordering because then you can't parallelize them. Hopefully I'll have time to debug why this is happening, but I spent like 20min and couldn't immediately figure it out", "url": "https://github.com/confluentinc/ksql/pull/5597#discussion_r438470264", "createdAt": "2020-06-10T23:58:54Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/StandaloneExecutorFunctionalTest.java", "diffHunk": "@@ -51,15 +51,20 @@\n import org.junit.Before;\n import org.junit.BeforeClass;\n import org.junit.ClassRule;\n+import org.junit.FixMethodOrder;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n+import org.junit.runners.MethodSorters;\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnitRunner;\n \n @Category({IntegrationTest.class})\n @RunWith(MockitoJUnitRunner.class)\n+// shouldFailOnAvroWithoutSchemasIfSchemaNotEvolvable fails if run after shouldHandleJsonWithSchemas\n+@FixMethodOrder(MethodSorters.NAME_ASCENDING)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzNzk4MQ=="}, "originalCommit": {"oid": "36763838d9b578958b89728c8eb259b40f2940c7"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTg5NDU1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNDowNDoyMlrOGiNxrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNDowNDoyMlrOGiNxrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzMDQ3Nw==", "bodyText": "@agavra would it actually be possible for you to throw a nested KsqlSchemaRegistryNotConfiguredException here? In cloud, we want to throw a very specific error message related to this and we're passing in a cloud specific error message module in the cloud image.\nhttps://github.com/confluentinc/ksql/blob/master/ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/Errors.java#L236\nhttps://github.com/confluentinc/ksql/blob/master/ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/Errors.java#L218", "url": "https://github.com/confluentinc/ksql/pull/5597#discussion_r438530477", "createdAt": "2020-06-11T04:04:22Z", "author": {"login": "stevenpyzhang"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java", "diffHunk": "@@ -118,6 +121,12 @@ private void registerSchema(\n       } catch (IOException | RestClientException e) {\n         throw new KsqlStatementException(\"Could not register schema for topic.\", statementText, e);\n       }\n+    } else {\n+      throw new KsqlStatementException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36763838d9b578958b89728c8eb259b40f2940c7"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3374, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}