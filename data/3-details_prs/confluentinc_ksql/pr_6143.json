{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4MTYxNjcz", "number": 6143, "title": "feat: terminate persistent query on DROP command", "bodyText": "Description\nFixes #2177\nThis PR automatically terminates the persistent query of a stream/table when executing the DROP command. If the stream/table to drop has another query writing/reading on it, then the DROP will fail. This prevents leaking zombie queries on dropped streams.\nThe query termination is done by the MetaStoreImpl.deleteSource in an atomic operation. This code is the one checking for referential integrity so it is the best place to do the job.\nTo check if the query is good to terminate, the metastore stores the stream/table source with a reference to the queryId running. This way, when attempting to delete the source, it checks if the referenced query matches the query in the ReferentialIntegrityTableEntity. The query is terminated only if the query is a Sink query and no other queries exist, either source or sink.\nI added a few tests in the KsqlEngine to verify the drop command works (negative & positively).\nTesting done\nAdded unit tests\nVerified manually\n# terminate query allowed\ncreate stream s1 as select * from t1;\ndrop stream s1;\n\n# terminate query not allowed\ncreate stream s1 as select * from t1;\ncreate stream s2 as select * from s1;\ndrop stream s1; // fail\ndrop stream s2; // success\ndrop stream s1; // success\n\n# terminate query not allowed\ncreate stream s1 as select * from t1;\ninsert into s1 select * from t1;\ndrop stream s1; // fail\nterminate insertquery_1;\ndrop stream s1; // success\n\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-09-02T20:52:43Z", "url": "https://github.com/confluentinc/ksql/pull/6143", "merged": true, "mergeCommit": {"oid": "b5ac1bd6f156447f9109545bacf3d74644000e75"}, "closed": true, "closedAt": "2020-11-06T14:41:13Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFDIGQgBqjM3MjE5MTEyMTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZoyGYABqjM5NjQzNjI1NzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d2101713bdc2d5268cfec244bbe26a973ea4ec5", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/0d2101713bdc2d5268cfec244bbe26a973ea4ec5", "committedDate": "2020-09-02T20:19:26Z", "message": "feat: terminate persistent query on DROP command"}, "afterCommit": {"oid": "f09028581e73fea45a25272b448642bcb30e1ea9", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f09028581e73fea45a25272b448642bcb30e1ea9", "committedDate": "2020-09-02T21:45:10Z", "message": "feat: terminate persistent query on DROP command"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDEyOTI3", "url": "https://github.com/confluentinc/ksql/pull/6143#pullrequestreview-481412927", "createdAt": "2020-09-03T00:58:16Z", "commit": {"oid": "f09028581e73fea45a25272b448642bcb30e1ea9"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMDo1ODoxNlrOHMRc4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMDo1ODoxNlrOHMRc4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMDg4Mg==", "bodyText": "what happens if you drop a stream that a transient query is reading from?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r482630882", "createdAt": "2020-09-03T00:58:16Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/KsqlEngine.java", "diffHunk": "@@ -218,7 +218,7 @@ public TransientQueryMetadata executeQuery(\n               statement.getConfigOverrides())\n           .executeQuery(statement);\n       registerQuery(query);\n-      primaryContext.registerQuery(query);\n+      primaryContext.registerQuery(Optional.empty(), query);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f09028581e73fea45a25272b448642bcb30e1ea9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MTQ2NzY3", "url": "https://github.com/confluentinc/ksql/pull/6143#pullrequestreview-485146767", "createdAt": "2020-09-09T15:46:05Z", "commit": {"oid": "f09028581e73fea45a25272b448642bcb30e1ea9"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f09028581e73fea45a25272b448642bcb30e1ea9", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f09028581e73fea45a25272b448642bcb30e1ea9", "committedDate": "2020-09-02T21:45:10Z", "message": "feat: terminate persistent query on DROP command"}, "afterCommit": {"oid": "466af0fc8b258fdf28f2a00d117692f20f9327c9", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/466af0fc8b258fdf28f2a00d117692f20f9327c9", "committedDate": "2020-09-14T15:32:01Z", "message": "feat: terminate CREATE_AS query on DROP command"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "466af0fc8b258fdf28f2a00d117692f20f9327c9", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/466af0fc8b258fdf28f2a00d117692f20f9327c9", "committedDate": "2020-09-14T15:32:01Z", "message": "feat: terminate CREATE_AS query on DROP command"}, "afterCommit": {"oid": "9242079cf0fd6913088f59570055426a53541d93", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/9242079cf0fd6913088f59570055426a53541d93", "committedDate": "2020-10-23T19:55:10Z", "message": "refactor: remove unused code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTcwOTc3", "url": "https://github.com/confluentinc/ksql/pull/6143#pullrequestreview-517170977", "createdAt": "2020-10-26T20:59:27Z", "commit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1OToyN1rOHoiI9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTo0MDoyNlrOHojc3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NDQzNw==", "bodyText": "what do you think about making this part of the DdlCommand that's passed in instead of passing it in separately? I feel like this makes sense to me because (1) it's only used for some of the DdlCommand types and (2) it would be persisted into the command topic so we can make sure that things get properly tracked in recovery. It might be a bigger change, so it can wait if we want to get this in before the 0.14 cut", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512264437", "createdAt": "2020-10-26T20:59:27Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -57,17 +58,25 @@ public DdlCommandExec(final MutableMetaStore metaStore) {\n   public DdlCommandResult execute(\n       final String sql,\n       final DdlCommand ddlCommand,\n-      final boolean withQuery) {\n-    return new Executor(sql, withQuery).execute(ddlCommand);\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NjE4Mw==", "bodyText": "any reason not to make this a Set<QueryId>? I feel that keeping this strongly typed is a benefit, especially if we want to leverage QueryId more heavily in the future", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512266183", "createdAt": "2020-10-26T21:02:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -134,6 +146,17 @@ EngineContext createSandbox(final ServiceContext serviceContext) {\n     return Collections.unmodifiableMap(persistentQueries);\n   }\n \n+  Set<String> getQueriesWithSink(final SourceName sourceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2OTI5Mg==", "bodyText": "is there any way to avoid special casing DropSourceCommand and just passing what we need into the executor? (applies below as well)", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512269292", "createdAt": "2020-10-26T21:08:30Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MTA5Mw==", "bodyText": "nit: can we add a comment explaining why we terminate the CAS query after we drop the source? It's not clear for me reading the code (without looking at other files) why we don't do it before.", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512271093", "createdAt": "2020-10-26T21:11:38Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MjAwMA==", "bodyText": "when could this ever be null? maybe we should throw some error if it is null?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512272000", "createdAt": "2020-10-26T21:13:24Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      terminateCreateAsQuery(((DropSourceCommand) command).getSourceName());\n+    }\n+\n     return result.getMessage();\n   }\n \n-  void registerQuery(final QueryMetadata query) {\n+  private void terminateCreateAsQuery(final SourceName sourceName) {\n+    createAsQueries.computeIfPresent(sourceName, (ignore , queryId) -> {\n+      final PersistentQueryMetadata query = persistentQueries.get(queryId);\n+      if (query != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MzE5Mw==", "bodyText": "if this condition is ever not met, don't we have some referential integrity issue? if we added a query to the otherQueries under the sourceName key, shouldn't it always be the case that there exists a query and the sink is sourceName? same question goes for getOtherQueriesWithSource", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512273193", "createdAt": "2020-10-26T21:15:41Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      terminateCreateAsQuery(((DropSourceCommand) command).getSourceName());\n+    }\n+\n     return result.getMessage();\n   }\n \n-  void registerQuery(final QueryMetadata query) {\n+  private void terminateCreateAsQuery(final SourceName sourceName) {\n+    createAsQueries.computeIfPresent(sourceName, (ignore , queryId) -> {\n+      final PersistentQueryMetadata query = persistentQueries.get(queryId);\n+      if (query != null) {\n+        query.close();\n+      }\n+\n+      return null;\n+    });\n+  }\n+\n+  private Set<String> getOtherQueriesWithSink(final SourceName sourceName) {\n+    final ImmutableSet.Builder<String> queries = ImmutableSet.builder();\n+\n+    if (otherQueries.containsKey(sourceName)) {\n+      otherQueries.get(sourceName).forEach(queryId -> {\n+        final PersistentQueryMetadata query = persistentQueries.get(queryId);\n+        if (query != null && query.getSinkName().equals(sourceName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzgzNw==", "bodyText": "I noticed that otherQueries is thread safe, but now we're putting non-threadsafe entries inside it (HashSet). If it needs to be thread safe, we should put in a concurrent data structure (I'm guessing just Collections.synchronized(new HashSet<>()) is good enough)", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512277837", "createdAt": "2020-10-26T21:24:44Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -238,10 +335,17 @@ void registerQuery(final QueryMetadata query) {\n       }\n \n       persistentQueries.put(queryId, persistentQuery);\n-      metaStore.updateForPersistentQuery(\n-          queryId.toString(),\n-          persistentQuery.getSourceNames(),\n-          ImmutableSet.of(persistentQuery.getSinkName()));\n+      if (createAsQuery) {\n+        createAsQueries.put(persistentQuery.getSinkName(), queryId);\n+      } else {\n+        final Iterable<SourceName> allSourceNames = Iterables.concat(\n+            Collections.singleton(persistentQuery.getSinkName()),\n+            persistentQuery.getSourceNames()\n+        );\n+\n+        allSourceNames.forEach(sourceName ->\n+            otherQueries.computeIfAbsent(sourceName, x -> new HashSet<>()).add(queryId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTUwOA==", "bodyText": "can we document what the difference between these two are?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512281508", "createdAt": "2020-10-26T21:32:06Z", "author": {"login": "agavra"}, "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -295,25 +277,45 @@ public boolean deleteType(final String name) {\n   private static final class SourceInfo {\n \n     private final DataSource source;\n-    private final ReferentialIntegrityTableEntry referentialIntegrity;\n+    private final Set<SourceName> linkedSources = new ConcurrentHashSet<>();\n+    private final Set<SourceName> referentialSources = new ConcurrentHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTg2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new SourceInfo(source, linkedSources, referentialSources);\n          \n          \n            \n                  return copyWith(source);", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512281861", "createdAt": "2020-10-26T21:32:50Z", "author": {"login": "agavra"}, "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -295,25 +277,45 @@ public boolean deleteType(final String name) {\n   private static final class SourceInfo {\n \n     private final DataSource source;\n-    private final ReferentialIntegrityTableEntry referentialIntegrity;\n+    private final Set<SourceName> linkedSources = new ConcurrentHashSet<>();\n+    private final Set<SourceName> referentialSources = new ConcurrentHashSet<>();\n \n     private SourceInfo(\n         final DataSource source\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = new ReferentialIntegrityTableEntry();\n     }\n \n     private SourceInfo(\n         final DataSource source,\n-        final ReferentialIntegrityTableEntry referentialIntegrity\n+        final Set<SourceName> linkedSources,\n+        final Set<SourceName> referentialSources\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = referentialIntegrity.copy();\n+      this.linkedSources.addAll(\n+          Objects.requireNonNull(linkedSources, \"linkedSources\"));\n+      this.referentialSources.addAll(\n+          Objects.requireNonNull(referentialSources, \"referentialSources\"));\n     }\n \n     public SourceInfo copy() {\n-      return new SourceInfo(source, referentialIntegrity);\n+      return new SourceInfo(source, linkedSources, referentialSources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTk0OQ==", "bodyText": "we should probably make deep copies of the linked/referential sources", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512281949", "createdAt": "2020-10-26T21:33:02Z", "author": {"login": "agavra"}, "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -295,25 +277,45 @@ public boolean deleteType(final String name) {\n   private static final class SourceInfo {\n \n     private final DataSource source;\n-    private final ReferentialIntegrityTableEntry referentialIntegrity;\n+    private final Set<SourceName> linkedSources = new ConcurrentHashSet<>();\n+    private final Set<SourceName> referentialSources = new ConcurrentHashSet<>();\n \n     private SourceInfo(\n         final DataSource source\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = new ReferentialIntegrityTableEntry();\n     }\n \n     private SourceInfo(\n         final DataSource source,\n-        final ReferentialIntegrityTableEntry referentialIntegrity\n+        final Set<SourceName> linkedSources,\n+        final Set<SourceName> referentialSources\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = referentialIntegrity.copy();\n+      this.linkedSources.addAll(\n+          Objects.requireNonNull(linkedSources, \"linkedSources\"));\n+      this.referentialSources.addAll(\n+          Objects.requireNonNull(referentialSources, \"referentialSources\"));\n     }\n \n     public SourceInfo copy() {\n-      return new SourceInfo(source, referentialIntegrity);\n+      return new SourceInfo(source, linkedSources, referentialSources);\n+    }\n+\n+    public SourceInfo copyWith(final DataSource source) {\n+      return new SourceInfo(source, linkedSources, referentialSources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mjc1OA==", "bodyText": "I'm a little confused here, shouldn't existing already have the SourceName as dataSource? why are we calling copyWith(dataSource)?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512282758", "createdAt": "2020-10-26T21:34:35Z", "author": {"login": "agavra"}, "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -93,116 +94,97 @@ public void putSource(final DataSource dataSource, final boolean allowReplace) {\n       });\n     }\n \n-    dataSources.put(dataSource.getName(), new SourceInfo(dataSource));\n+    dataSources.put(dataSource.getName(),\n+        (existing != null) ? existing.copyWith(dataSource) : new SourceInfo(dataSource));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mzk5NA==", "bodyText": "I'm worried that it's not actually a deep copy. if we call metaStore.linkSource(), for example, on the copy - it will also add it to the source (see my comment above about deep copying). Can you add a test that covers this?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512283994", "createdAt": "2020-10-26T21:36:54Z", "author": {"login": "agavra"}, "path": "ksqldb-metastore/src/test/java/io/confluent/ksql/metastore/MetaStoreImplTest.java", "diffHunk": "@@ -116,30 +113,22 @@ public void shouldDeepCopyTypesOnCopy() {\n   }\n \n   @Test\n-  public void shouldDeepCopySourceReferentialIntegrityDataOnCopy() {\n+  public void shouldDeepCopyLinkedAndReferentialSourcesOnCopy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NDcwNA==", "bodyText": "why are we deleting this test? we haven't made the class not thread safe?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512284704", "createdAt": "2020-10-26T21:38:15Z", "author": {"login": "agavra"}, "path": "ksqldb-metastore/src/test/java/io/confluent/ksql/metastore/MetaStoreImplTest.java", "diffHunk": "@@ -359,82 +309,11 @@ public void shouldBeThreadSafe() {\n           when(source.getName()).thenReturn(SourceName.of(\"source\" + idx));\n           metaStore.putSource(source, false);\n           metaStore.getSource(source.getName());\n-\n           metaStore.getAllDataSources();\n-\n-          final String queryId = \"query\" + idx;\n-          metaStore.updateForPersistentQuery(\n-              queryId,\n-              ImmutableSet.of(source.getName()),\n-              ImmutableSet.of(source.getName()));\n-\n-          metaStore.getQueriesWithSource(source.getName());\n-          metaStore.getQueriesWithSink(source.getName());\n-\n           metaStore.copy();\n-\n-          metaStore.removePersistentQuery(queryId);\n           metaStore.deleteSource(source.getName());\n         });\n \n     assertThat(metaStore.getAllDataSources().keySet(), is(empty()));\n   }\n-\n-  @Test(timeout = 10_000)\n-  public void shouldBeThreadSafeAroundRefIntegrity() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTkxOQ==", "bodyText": "can this fail for any reason? we might be left in a state where we drop the source but still have a query running into it. That would be very bad \ud83d\ude22 is there any way to make the drop & terminate an atomic operation?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512285919", "createdAt": "2020-10-26T21:40:26Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      terminateCreateAsQuery(((DropSourceCommand) command).getSourceName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/2f5a62f5f06fc16a62dec86307c552b3635e0605", "committedDate": "2020-10-26T19:54:50Z", "message": "fix: fix tests by changing the order for dropping the streams"}, "afterCommit": {"oid": "a891fc6ea0eaddc31cbe9a2f0f188a0bc68f1278", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/a891fc6ea0eaddc31cbe9a2f0f188a0bc68f1278", "committedDate": "2020-10-27T19:27:30Z", "message": "chore: apply suggestions from Almog's feedback\n\n- return QueryId on getQueriesWithSink() instead of String\n- Add a syncrhonized HashSet to otherQueries\n- Add more tests to validate deep copy on Metastore\n- Remove unnecessary copyWith()\n- Add comments to linkedSources and referentialSources\n- Remove unecessary null check\n- Add comment why terminate is done after delete source\n- Other minor fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MzE5NDkz", "url": "https://github.com/confluentinc/ksql/pull/6143#pullrequestreview-518319493", "createdAt": "2020-10-28T04:41:37Z", "commit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDo0MTozN1rOHpZ1IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDo0MTozN1rOHpZ1IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3Njg2NA==", "bodyText": "can we test also something that depends on B before drop? e.g.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"CREATE STREAM B AS SELECT * FROM A;\",\n          \n          \n            \n                    \"DROP STREAM B;\",\n          \n          \n            \n                    \"CREATE STREAM B AS SELECT * FROM A;\",\n          \n          \n            \n                    \"CREATE STREAM C AS SELECT * FROM B;\",\n          \n          \n            \n                    \"DROP STREAM C;\",\n          \n          \n            \n                    \"DROP STREAM B;\",", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513176864", "createdAt": "2020-10-28T04:41:37Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java", "diffHunk": "@@ -676,6 +676,28 @@ public void shouldRecoverDrop() {\n     shouldRecover(commands);\n   }\n \n+  @Test\n+  public void shouldRecoverDrop() {\n+    server1.submitCommands(\n+        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n+        \"CREATE STREAM B AS SELECT * FROM A;\",\n+        \"DROP STREAM B;\"\n+    );\n+    shouldRecover(commands);\n+  }\n+\n+  @Test\n+  public void shouldRecoverDropWithRecreates() {\n+    server1.submitCommands(\n+        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n+        \"CREATE STREAM B AS SELECT * FROM A;\",\n+        \"DROP STREAM B;\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTYxMzM5", "url": "https://github.com/confluentinc/ksql/pull/6143#pullrequestreview-519161339", "createdAt": "2020-10-28T23:39:05Z", "commit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMzozOTowNVrOHqBX-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMDoxMjowM1rOHqB_0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDc2Mw==", "bodyText": "nit: reading this code, I'm always confused about what otherQueries actually is and it makes me revisit the code often. Can we come up with a better name here?\nAlternatively, maybe it makes sense to have a data structure:\nclass SourceQueryTracker {\n  SourceName target;\n  QueryId createTargetAsQuery;\n  Set<QueryId> nonCreateThatWriteIntoQuery;\n  Set<QueryId> queriesThatReadFromTarget;\n}\n\nprivate final Map<SourceName, SinkQueryTracker> queryTrackers;\nThat would also make it much easier to reason about thread safety. Just make everything in here totally synchronized.", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513824763", "createdAt": "2020-10-28T23:39:05Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -72,6 +86,8 @@\n   private final Map<QueryId, PersistentQueryMetadata> persistentQueries;\n   private final Set<QueryMetadata> allLiveQueries = ConcurrentHashMap.newKeySet();\n   private final QueryCleanupService cleanupService;\n+  private final Map<SourceName, QueryId> createAsQueries = new ConcurrentHashMap<>();\n+  private final Map<SourceName, Set<QueryId>> otherQueries = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzMzczMw==", "bodyText": "why don't we add this query to the otherQueries? It can still read from another (or more) source, right? If we don't do that, our error message that says \"queries that read from this source: [foo, bar]\" will be wrong (can we add a test for that too?)", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513833733", "createdAt": "2020-10-29T00:07:46Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -238,10 +323,18 @@ void registerQuery(final QueryMetadata query) {\n       }\n \n       persistentQueries.put(queryId, persistentQuery);\n-      metaStore.updateForPersistentQuery(\n-          queryId.toString(),\n-          persistentQuery.getSourceNames(),\n-          ImmutableSet.of(persistentQuery.getSinkName()));\n+      if (createAsQuery) {\n+        createAsQueries.put(persistentQuery.getSinkName(), queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzNDExMw==", "bodyText": "I know that this part is enforced by the metastore, which is why we don't use FILTER_QUERIES_WITH_SOURCE anywhere in this class other than here. That seems a little fragile to rely on this lose coupling. I think it's OK for now, but at a minimum add a comment so the next person debugging knows where to look", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513834113", "createdAt": "2020-10-29T00:09:09Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +238,71 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      // terminate the query (linked by create_as commands) after deleting the source to avoid\n+      // other commands to create queries from this source while the query is being terminated\n+      maybeTerminateCreateAsQuery(((DropSourceCommand) command).getSourceName());\n+    }\n+\n     return result.getMessage();\n   }\n \n-  void registerQuery(final QueryMetadata query) {\n+  private void maybeTerminateCreateAsQuery(final SourceName sourceName) {\n+    createAsQueries.computeIfPresent(sourceName, (ignore , queryId) -> {\n+      persistentQueries.get(queryId).close();\n+      return null;\n+    });\n+  }\n+\n+  private Set<QueryId> getOtherQueries(\n+      final SourceName sourceName,\n+      final BiPredicate<SourceName, PersistentQueryMetadata> filterQueries\n+  ) {\n+    return otherQueries.getOrDefault(sourceName, Collections.emptySet()).stream()\n+        .map(persistentQueries::get)\n+        .filter(query -> filterQueries.test(sourceName, query))\n+        .map(QueryMetadata::getQueryId)\n+        .collect(Collectors.toSet());\n+  }\n+\n+  private void throwIfOtherQueriesExist(final SourceName sourceName) {\n+    final Set<QueryId> sinkQueries = getOtherQueries(sourceName, FILTER_QUERIES_WITH_SINK);\n+    final Set<QueryId> sourceQueries = getOtherQueries(sourceName, FILTER_QUERIES_WITH_SOURCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzNDk2Mw==", "bodyText": "nit: we use this below, can we make a helper method out of it?", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513834963", "createdAt": "2020-10-29T00:12:03Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -238,10 +323,18 @@ void registerQuery(final QueryMetadata query) {\n       }\n \n       persistentQueries.put(queryId, persistentQuery);\n-      metaStore.updateForPersistentQuery(\n-          queryId.toString(),\n-          persistentQuery.getSourceNames(),\n-          ImmutableSet.of(persistentQuery.getSinkName()));\n+      if (createAsQuery) {\n+        createAsQueries.put(persistentQuery.getSinkName(), queryId);\n+      } else {\n+        final Iterable<SourceName> allSourceNames = Iterables.concat(\n+            Collections.singleton(persistentQuery.getSinkName()),\n+            persistentQuery.getSourceNames()\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790"}, "originalPosition": 181}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de62bb3e8e0be6cd63b11498be646ae47e4c08f5", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/de62bb3e8e0be6cd63b11498be646ae47e4c08f5", "committedDate": "2020-11-05T19:10:38Z", "message": "refactor: call getQueriesWithSink() from KsqlEngine instead of Metastore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "360fd0a1df79b8542845d3442a52d6074bbaacb7", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/360fd0a1df79b8542845d3442a52d6074bbaacb7", "committedDate": "2020-11-05T19:12:41Z", "message": "feat: terminate persistent query on DROP command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "486b53bc6e4178d3fd28d85aaa7f4112db2d8f29", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/486b53bc6e4178d3fd28d85aaa7f4112db2d8f29", "committedDate": "2020-11-05T19:29:04Z", "message": "refactor: remove unused referential code from Metastore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e5700b32e5d96da35af10de93a2f9542b1e0f3e", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/2e5700b32e5d96da35af10de93a2f9542b1e0f3e", "committedDate": "2020-11-05T19:52:06Z", "message": "fix: support restore & compact"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9238981d60861fc064ef919bc12201bd5f37c5ab", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/9238981d60861fc064ef919bc12201bd5f37c5ab", "committedDate": "2020-11-05T19:54:16Z", "message": "chore: apply suggestions from Almog's feedback\n\n- return QueryId on getQueriesWithSink() instead of String\n- Add a syncrhonized HashSet to otherQueries\n- Add more tests to validate deep copy on Metastore\n- Remove unecessary null check\n- Add comment why terminate is done after delete source\n- Other minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b097de80837b9da97f6f461b1a9be7b4813b5f37", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/b097de80837b9da97f6f461b1a9be7b4813b5f37", "committedDate": "2020-11-05T19:55:02Z", "message": "chore: apply Almog's suggestions\n\n- rename otherQueries to insertQueries\n- helper method to concat query sink and sources"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "committedDate": "2020-10-27T20:02:19Z", "message": "fix: revert back the copyWith() in the SourceInfo"}, "afterCommit": {"oid": "b097de80837b9da97f6f461b1a9be7b4813b5f37", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/b097de80837b9da97f6f461b1a9be7b4813b5f37", "committedDate": "2020-11-05T19:55:02Z", "message": "chore: apply Almog's suggestions\n\n- rename otherQueries to insertQueries\n- helper method to concat query sink and sources"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4636, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}