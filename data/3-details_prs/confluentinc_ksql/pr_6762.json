{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3MTI1ODgw", "number": 6762, "title": "chore: set internal key serde features when necessary", "bodyText": "Description\nPipe the key format that is determined from the repartition step into the select key, instead of creating it with empty serde features. This means that we will ensure that the serde features (wrapping/unwrapping) behave the way we want them to.\nThis is also a minor BREAKING CHANGE. Joins across different window types will no longer work. I think this is a good thing because the previous logic was somewhat insane and allowed you to join windows if they were semantically different but byte-equivalent.\nTesting done\nQTT testing/Unit Testing. I also hacked a QTT test to support wrapping single keys at the source level to see if it is properly resolved:\n    {\n      \"name\": \"stream-table key-to-key - key format properties mismatch\",\n      \"statements\": [\n        \"CREATE TABLE T (ID INT PRIMARY KEY, VAL STRING) WITH (kafka_topic='t', key_format='JSON', value_format='JSON', wrap_single_keys=true);\",\n        \"CREATE STREAM S (ID INT KEY, FOO INT) WITH (kafka_topic='s', key_format='JSON', value_format='JSON');\",\n        \"CREATE STREAM OUTPUT AS SELECT S.ID, VAL FROM S JOIN T ON S.ID = T.ID;\"\n      ],\n      \"inputs\": [\n        {\"topic\": \"t\", \"key\": {\"ID\": 10}, \"value\": {\"VAL\": \"hello\"}},\n        {\"topic\": \"s\", \"key\": 10, \"value\": {\"foo\": 22}}\n      ],\n      \"outputs\": [\n        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": \"hello\"}}\n      ],\n      \"post\": {\n        \"sources\": [\n          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"keyFormat\": {\"format\": \"JSON\"}}\n        ],\n        \"topics\" : {\n          \"topics\": [\n            {\n              \"name\": \"t\",\n              \"keyFormat\": { \"format\": \"JSON\", \"features\": [ \"WRAP_SINGLES\" ] },\n              \"valueFormat\": { \"format\": \"JSON\" },\n              \"partitions\": 4\n            },\n            {\n              \"name\": \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-SelectKey-repartition\",\n              \"keyFormat\": { \"format\": \"JSON\", \"features\": [ \"UNWRAP_SINGLES\" ] },\n              \"valueFormat\": { \"format\": \"JSON\" }\n            },\n            {\n              \"name\": \"OUTPUT\",\n              \"keyFormat\": { \"format\": \"JSON\", \"features\": [ \"UNWRAP_SINGLES\" ] },\n              \"valueFormat\": { \"format\": \"JSON\" },\n              \"partitions\": 4\n            },\n            {\n              \"name\": \"s\",\n              \"keyFormat\": { \"format\": \"JSON\", \"features\": [ \"UNWRAP_SINGLES\" ] },\n              \"valueFormat\": { \"format\": \"JSON\" },\n              \"partitions\": 4\n            },\n            {\n              \"name\": \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-RightSourceKeyed-Materialize-changelog\",\n              \"keyFormat\": { \"format\": \"JSON\", \"features\": [ \"UNWRAP_SINGLES\" ] },\n              \"valueFormat\": { \"format\": \"JSON\" }\n            }\n          ]\n        }\n      }\n    }\nHere was the corresponding topology:\nTopologies:\n   Sub-topology: 0\n    Source: KSTREAM-SOURCE-0000000001 (topics: [t])\n      --> KTABLE-SOURCE-0000000002\n    Processor: KTABLE-SOURCE-0000000002 (stores: [])\n      --> KTABLE-MAPVALUES-0000000003\n      <-- KSTREAM-SOURCE-0000000001\n    Processor: KTABLE-MAPVALUES-0000000003 (stores: [])\n      --> KTABLE-TRANSFORMVALUES-0000000004\n      <-- KTABLE-SOURCE-0000000002\n    Processor: KTABLE-TRANSFORMVALUES-0000000004 (stores: [])\n      --> KTABLE-TOSTREAM-0000000005\n      <-- KTABLE-MAPVALUES-0000000003\n    Processor: KTABLE-TOSTREAM-0000000005 (stores: [])\n      --> RightSourceKeyed-SelectKey-Mapper\n      <-- KTABLE-TRANSFORMVALUES-0000000004\n    Processor: RightSourceKeyed-SelectKey-Mapper (stores: [])\n      --> RightSourceKeyed-SelectKey-repartition-filter\n      <-- KTABLE-TOSTREAM-0000000005\n    Processor: RightSourceKeyed-SelectKey-repartition-filter (stores: [])\n      --> RightSourceKeyed-SelectKey-repartition-sink\n      <-- RightSourceKeyed-SelectKey-Mapper\n    Sink: RightSourceKeyed-SelectKey-repartition-sink (topic: RightSourceKeyed-SelectKey-repartition)\n      <-- RightSourceKeyed-SelectKey-repartition-filter\n\n  Sub-topology: 1\n    Source: KSTREAM-SOURCE-0000000012 (topics: [s])\n      --> KSTREAM-TRANSFORMVALUES-0000000013\n    Processor: KSTREAM-TRANSFORMVALUES-0000000013 (stores: [])\n      --> PrependAliasLeft\n      <-- KSTREAM-SOURCE-0000000012\n    Processor: PrependAliasLeft (stores: [])\n      --> Join\n      <-- KSTREAM-TRANSFORMVALUES-0000000013\n    Processor: Join (stores: [RightSourceKeyed-Materialize])\n      --> Project\n      <-- PrependAliasLeft\n    Source: RightSourceKeyed-SelectKey-repartition-source (topics: [RightSourceKeyed-SelectKey-repartition])\n      --> RightSourceKeyed-SelectKey\n    Processor: Project (stores: [])\n      --> KSTREAM-SINK-0000000017\n      <-- Join\n    Processor: RightSourceKeyed-SelectKey (stores: [RightSourceKeyed-Materialize])\n      --> PrependAliasRight\n      <-- RightSourceKeyed-SelectKey-repartition-source\n    Sink: KSTREAM-SINK-0000000017 (topic: OUTPUT)\n      <-- Project\n    Processor: PrependAliasRight (stores: [])\n      --> none\n      <-- RightSourceKeyed-SelectKey\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-12-11T16:37:31Z", "url": "https://github.com/confluentinc/ksql/pull/6762", "merged": true, "mergeCommit": {"oid": "5e7cc0c46491ba682a06a83b26a492955dd9871a"}, "closed": true, "closedAt": "2020-12-15T06:13:32Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdlKTTVAH2gAyNTM3MTI1ODgwOjQ1ZWY3NmRlNjg5NDA0YjY3ODE5YmRkNjUzN2NmNjg2MjJjY2U5YmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmTCj2gFqTU1MjEwNjA5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "45ef76de689404b67819bdd6537cf68622cce9be", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/45ef76de689404b67819bdd6537cf68622cce9be", "committedDate": "2020-12-11T16:12:34Z", "message": "chore: set internal key serde features when necessary"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjc5MjMw", "url": "https://github.com/confluentinc/ksql/pull/6762#pullrequestreview-550279230", "createdAt": "2020-12-11T16:51:15Z", "commit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjo1MToxNVrOIEBN8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjo1MzozNVrOIEBT3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTE2OA==", "bodyText": "It's odd to me that we're wiping value features on internal topics while passing along key features. I need to think more about the implications here. We might need to write key serde features into all the execution steps if we want this to be evolvable in the future.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541085168", "createdAt": "2020-12-11T16:51:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/InternalFormats.java", "diffHunk": "@@ -50,16 +50,16 @@ private InternalFormats() {\n    * @see <a href=https://github.com/confluentinc/ksql/issues/6296>Issue 6296</a>\n    * @see SerdeFeaturesFactory#buildInternal\n    */\n-  public static Formats of(final FormatInfo keyFormat, final FormatInfo valueFormat) {\n+  public static Formats of(final KeyFormat keyFormat, final FormatInfo valueFormat) {\n     // Do not use NONE format for internal topics:\n-    if (keyFormat.getFormat().equals(NoneFormat.NAME)) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n       throw new IllegalArgumentException(NoneFormat.NAME + \" can not be used for internal topics\");\n     }\n \n     return Formats.of(\n-        keyFormat,\n+        keyFormat.getFormatInfo(),\n         valueFormat,\n-        SerdeFeaturesFactory.buildInternal(FormatFactory.fromName(keyFormat.getFormat())),\n+        keyFormat.getFeatures(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjU5OA==", "bodyText": "This change is strange to me -- what was your motivation? This will have to be updated to support multi-column group by's, since the new schema (post group by) needs to be taken into account when deciding what key serde features to set. (I can do that as part of my group by PR, just curious why this change is being made here when it'll have to change again soon anyway.)\nI also notice that the analogous change wasn't made in SchemaKStream.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541086598", "createdAt": "2020-12-11T16:53:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -224,12 +216,12 @@ public SchemaKGroupedTable groupBy(\n       final Stacker contextStacker\n   ) {\n     final KeyFormat groupedKeyFormat = KeyFormat\n-        .nonWindowed(keyFormat.getFormatInfo(), SerdeFeatures.of());\n+        .nonWindowed(keyFormat.getFormatInfo(), keyFormat.getFeatures());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjY4Ng==", "bodyText": "Why does this test fail with this change? I don't see the connection to key serde features.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541086686", "createdAt": "2020-12-11T16:53:35Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -1907,37 +1907,19 @@\n       }\n     },\n     {\n-      \"name\": \"matching time-windowed\",\n+      \"name\": \"matching time-windowed join with different windows fails\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTA4NjQ2", "url": "https://github.com/confluentinc/ksql/pull/6762#pullrequestreview-550508646", "createdAt": "2020-12-11T19:14:41Z", "commit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOToxNDo0MVrOIEHLLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOToxOToxMVrOIEHcUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE4Mjc2NA==", "bodyText": "Took a deeper look -- looks like we already write serde features into the execution steps that need them, so that shouldn't be a concern.\nThe only potential evolvability concern is that until now, our execution plans have always specified key wrapping in ambiguous situations (single key column with format that supports both wrapping and unwrapping). That changes with this PR, which means we'd be locking ourselves into the current default choices for each format -- namely, always wrap by default. Are we happy with this default, or should we consider defaulting key wrapping to unwrap even though value wrapping default wrapping? If most users unwrap single keys, we may prefer the former despite the inconsistency.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541182764", "createdAt": "2020-12-11T19:14:41Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/InternalFormats.java", "diffHunk": "@@ -50,16 +50,16 @@ private InternalFormats() {\n    * @see <a href=https://github.com/confluentinc/ksql/issues/6296>Issue 6296</a>\n    * @see SerdeFeaturesFactory#buildInternal\n    */\n-  public static Formats of(final FormatInfo keyFormat, final FormatInfo valueFormat) {\n+  public static Formats of(final KeyFormat keyFormat, final FormatInfo valueFormat) {\n     // Do not use NONE format for internal topics:\n-    if (keyFormat.getFormat().equals(NoneFormat.NAME)) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n       throw new IllegalArgumentException(NoneFormat.NAME + \" can not be used for internal topics\");\n     }\n \n     return Formats.of(\n-        keyFormat,\n+        keyFormat.getFormatInfo(),\n         valueFormat,\n-        SerdeFeaturesFactory.buildInternal(FormatFactory.fromName(keyFormat.getFormat())),\n+        keyFormat.getFeatures(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTE2OA=="}, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE4NTE3OQ==", "bodyText": "I think I answered my own question: there is no analogous change in SchemaKStream since stream group bys don't need key format. Defaulting to propagating key serde features in table group bys means fewer historic execution plans change, since internal topics today always unwrap single keys (which is what gets propagated with this change, else we'd get new plans with empty serde features after table group bys).\nI don't think this inconsistency between stream and table group bys makes sense in the long run, but the logic here will change with the next PR anyway so I think it's fine.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541185179", "createdAt": "2020-12-11T19:17:00Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -224,12 +216,12 @@ public SchemaKGroupedTable groupBy(\n       final Stacker contextStacker\n   ) {\n     final KeyFormat groupedKeyFormat = KeyFormat\n-        .nonWindowed(keyFormat.getFormatInfo(), SerdeFeatures.of());\n+        .nonWindowed(keyFormat.getFormatInfo(), keyFormat.getFeatures());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjU5OA=="}, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE4NTU3NA==", "bodyText": "Makes sense. We should call it out as a breaking change, though.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541185574", "createdAt": "2020-12-11T19:17:23Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -1907,37 +1907,19 @@\n       }\n     },\n     {\n-      \"name\": \"matching time-windowed\",\n+      \"name\": \"matching time-windowed join with different windows fails\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjY4Ng=="}, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE4NzE1NQ==", "bodyText": "Adding a note for posterity: all the historic plan changes here appear to be the removal of UNWRAP_SINGLES from stream select key steps, which happens when grouping by a different key or when streams are repartitioned for joins. This makes sense in light of the changes in this PR.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541187155", "createdAt": "2020-12-11T19:19:11Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/group-by_-_AVRO_group_by_struct/6.2.0_1607703224334/plan.json", "diffHunk": "@@ -0,0 +1,204 @@\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f515954f2deff725a45fc31d74d8d312de303bb5", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/f515954f2deff725a45fc31d74d8d312de303bb5", "committedDate": "2020-12-12T00:14:13Z", "message": "chore: fix missing key format propogation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da865f4e2be798d9bd7b52f3ef35915a63d037b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/5da865f4e2be798d9bd7b52f3ef35915a63d037b", "committedDate": "2020-12-14T20:44:44Z", "message": "chore: set the key format eagerly on rekeys"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/187d88c095e041c72bea0f415058fac72c203d4b", "committedDate": "2020-12-14T20:48:46Z", "message": "chore: historical plans"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/099fb853b8b410a3623ddf39a70bedfdff29db4e", "committedDate": "2020-12-11T16:35:08Z", "message": "chore: historical plans"}, "afterCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/187d88c095e041c72bea0f415058fac72c203d4b", "committedDate": "2020-12-14T20:48:46Z", "message": "chore: historical plans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTQzMjg4", "url": "https://github.com/confluentinc/ksql/pull/6762#pullrequestreview-551943288", "createdAt": "2020-12-14T22:22:07Z", "commit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjoyMjowOFrOIFt-wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjozNTowNlrOIFuzBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2NzEzOA==", "bodyText": "I thought this class was marked Immutable?", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542867138", "createdAt": "2020-12-14T22:22:08Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/KeyFormat.java", "diffHunk": "@@ -36,7 +37,7 @@\n public final class KeyFormat {\n \n   private final FormatInfo format;\n-  private final SerdeFeatures features;\n+  private SerdeFeatures features;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3MjcxMA==", "bodyText": "If this is removed and we instead hard-code isSingleKey=true for now (as we have been, and as is still the case in this PR for table group bys) for purposes of setting internal key features, do the changes in QTT historic plans go away? If so, I'd prefer that instead. I'll re-introduce this change in my multi-column group by PR where plans will change anyway.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542872710", "createdAt": "2020-12-14T22:27:30Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -364,37 +358,33 @@ public SchemaKGroupedStream groupBy(\n       final Stacker contextStacker\n   ) {\n     if (!repartitionNeeded(groupByExpressions)) {\n-      return groupByKey(keyFormat.getFormatInfo(), valueFormat, contextStacker);\n+      return groupByKey(keyFormat, valueFormat, contextStacker);\n     }\n \n-    final FormatInfo keyFmtInfo = keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)\n-        ? FormatInfo.of(ksqlConfig.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG))\n-        : keyFormat.getFormatInfo();\n-\n-    final KeyFormat rekeyedKeyFormat = KeyFormat\n-        .nonWindowed(keyFmtInfo, SerdeFeatures.of());\n-\n+    final boolean isSingleKey = groupByExpressions.size() == 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3Mzk1OA==", "bodyText": "We're testing two things, right?\n\nIf key wrapping is present, then the key serde feature is inherited\nIf key wrapping is not present, then it is populated\n\nSeems like it should be two separate unit tests? Same for the other test file below.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542873958", "createdAt": "2020-12-14T22:28:42Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKGroupedStreamTest.java", "diffHunk": "@@ -162,9 +163,10 @@ public void shouldBuildStepForAggregate() {\n   }\n \n   @Test\n-  public void shouldBuildStepForAggregateWhereKeyFormatSupportsBothWrappingAndUnwrapping() {\n+  public void shouldBuildStepForAggregateWithKeyFormatSerdeFeatures() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3Njc5OA==", "bodyText": "Upon first reading I was confused why this wasn't being sanitized with SerdeFeaturesFactory#sanitizeKeyFeatures(). Looks like the reason is all the sanitization happens in SchemaKStream and SchemaKTable instead. Might be worth adding that into the javadocs for the method?", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542876798", "createdAt": "2020-12-14T22:31:26Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -254,16 +255,17 @@ private void ensureMatchingPartitionCounts(final KafkaTopicClient kafkaTopicClie\n             + \"number of partitions match.\");\n   }\n \n-  private FormatInfo getDefaultSourceKeyFormat() {\n+  private KeyFormat getDefaultSourceKeyFormat() {\n     return Stream.of(left, right)\n         .flatMap(PlanNode::getSourceNodes)\n         .map(DataSourceNode::getDataSource)\n         .map(DataSource::getKsqlTopic)\n         .map(KsqlTopic::getKeyFormat)\n-        .map(KeyFormat::getFormatInfo)\n-        .filter(format -> !format.getFormat().equals(NoneFormat.NAME))\n+        .filter(format -> !format.getFormatInfo().getFormat().equals(NoneFormat.NAME))\n         .findFirst()\n-        .orElse(FormatInfo.of(defaultKeyFormat));\n+        // if none exist, assume non-Windowed since that would mean that both sources\n+        // were of NONE format, which doesn't support windowed operations\n+        .orElse(KeyFormat.nonWindowed(FormatInfo.of(defaultKeyFormat), SerdeFeatures.of()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3NzE4NQ==", "bodyText": "This isn't just for aggregations, right? I'm confused by this javadoc.", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542877185", "createdAt": "2020-12-14T22:31:48Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTc3Ng==", "bodyText": "I'm confused. Why are we populating a key format in the case where the key format is NONE? This seems like it changes behavior of things like PARTITION BY NULL where we in fact want the resulting key format to be NONE...?", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542879776", "createdAt": "2020-12-14T22:34:22Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation\n+   */\n+  public static KeyFormat sanitizeKeyFormat(\n+      final KsqlConfig ksqlConfig,\n+      final KeyFormat keyFormat,\n+      final boolean isSingleKey\n+  ) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n+      // explicitly resolve the current default wrapping and write it into the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MDMyNw==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // or no-key, in which case there would not have been specified\n          \n          \n            \n                // a wrapping configuration - we should specify one here\n          \n          \n            \n                // or no-key, in which case there would not have been\n          \n          \n            \n                // a wrapping configuration specified - we should specify one here", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542880327", "createdAt": "2020-12-14T22:34:54Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation\n+   */\n+  public static KeyFormat sanitizeKeyFormat(\n+      final KsqlConfig ksqlConfig,\n+      final KeyFormat keyFormat,\n+      final boolean isSingleKey\n+  ) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n+      // explicitly resolve the current default wrapping and write it into the\n+      // format so that the execution step has it serialized for future backwards\n+      // incompatible changes to what the default may be\n+      final FormatInfo defaultFormat = FormatInfo.of(\n+          ksqlConfig.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG));\n+      final SerdeFeatures defaultWrapping = getKeyWrapping(isSingleKey, defaultFormat.getFormat())\n+          .map(SerdeFeatures::of)\n+          .orElse(SerdeFeatures.of());\n+\n+      return KeyFormat.nonWindowed(defaultFormat, defaultWrapping);\n+    }\n+\n+    // it is possible that the source format was either multi-key\n+    // or no-key, in which case there would not have been specified\n+    // a wrapping configuration - we should specify one here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MDQ4NA==", "bodyText": "nit: any particular reason we extract the format name from FormatInfo and then call FormatFacory.fromName(), rather than directly calling FormatFactory.of()?", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542880484", "createdAt": "2020-12-14T22:35:03Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation\n+   */\n+  public static KeyFormat sanitizeKeyFormat(\n+      final KsqlConfig ksqlConfig,\n+      final KeyFormat keyFormat,\n+      final boolean isSingleKey\n+  ) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n+      // explicitly resolve the current default wrapping and write it into the\n+      // format so that the execution step has it serialized for future backwards\n+      // incompatible changes to what the default may be\n+      final FormatInfo defaultFormat = FormatInfo.of(\n+          ksqlConfig.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG));\n+      final SerdeFeatures defaultWrapping = getKeyWrapping(isSingleKey, defaultFormat.getFormat())\n+          .map(SerdeFeatures::of)\n+          .orElse(SerdeFeatures.of());\n+\n+      return KeyFormat.nonWindowed(defaultFormat, defaultWrapping);\n+    }\n+\n+    // it is possible that the source format was either multi-key\n+    // or no-key, in which case there would not have been specified\n+    // a wrapping configuration - we should specify one here\n+    final boolean hasWrappingFeature = keyFormat\n+        .getFeatures()\n+        .findAny(SerdeFeatures.WRAPPING_FEATURES)\n+        .isPresent();\n+\n+    if (isSingleKey && !hasWrappingFeature) {\n+      final SerdeFeatures defaultWrapping = getKeyWrapping(true, keyFormat.getFormat())\n+          .map(SerdeFeatures::of)\n+          .orElse(SerdeFeatures.of());\n+      return keyFormat.withSerdeFeature(defaultWrapping);\n+    } else {\n+      return keyFormat;\n+    }\n+  }\n+\n+  private static Optional<SerdeFeature> getKeyWrapping(\n+      final boolean singleKey,\n+      final String format\n+  ) {\n+    return getKeyWrapping(singleKey, FormatFactory.fromName(format));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187d88c095e041c72bea0f415058fac72c203d4b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MDUxNw==", "bodyText": "Thanks for adding the breaking change description to the PR! Friendly reminder to copy it into the commit message when this gets merged, in the format BREAKING CHANGE: <text here> so the auto-changelog-generator picks it up :)", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542880517", "createdAt": "2020-12-14T22:35:06Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/joins.json", "diffHunk": "@@ -1907,37 +1907,19 @@\n       }\n     },\n     {\n-      \"name\": \"matching time-windowed\",\n+      \"name\": \"matching time-windowed join with different windows fails\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjY4Ng=="}, "originalCommit": {"oid": "099fb853b8b410a3623ddf39a70bedfdff29db4e"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c063a1118215b12f59135d2bad29d93b53f42d2", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/5c063a1118215b12f59135d2bad29d93b53f42d2", "committedDate": "2020-12-15T04:21:10Z", "message": "chore: review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTA2MDkz", "url": "https://github.com/confluentinc/ksql/pull/6762#pullrequestreview-552106093", "createdAt": "2020-12-15T04:57:21Z", "commit": {"oid": "5c063a1118215b12f59135d2bad29d93b53f42d2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4521, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}