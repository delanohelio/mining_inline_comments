{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1NDEwNTE0", "number": 6188, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzoxMzozN1rOEjPL3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODowNzozOFrOEjQZ0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1Mzg0NDEyOnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/schema/ksql/SchemaConverters.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzoxMzozN1rOHRe6yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjozNDoxMFrOHRpsbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NDQxMQ==", "bodyText": "nit: did you mean Java type?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Convert the supplied Connect {@code schema} to its corresponding SQL type.\n          \n          \n            \n                 * Convert the supplied Connect {@code schema} to its corresponding Java type.\n          \n      \n    \n    \n  \n\n(same below in @return)", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488094411", "createdAt": "2020-09-14T17:13:37Z", "author": {"login": "agavra"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/schema/ksql/SchemaConverters.java", "diffHunk": "@@ -123,6 +123,16 @@ private SchemaConverters() {\n     Schema toConnectSchema(SqlType sqlType, String name, String doc);\n   }\n \n+  public interface ConnectToJavaTypeConverter {\n+    /**\n+     * Convert the supplied Connect {@code schema} to its corresponding SQL type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7f23ff55fd3eba9543bd437ffd594c7d04b8ab5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDk1OA==", "bodyText": "done.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488270958", "createdAt": "2020-09-14T22:34:10Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/schema/ksql/SchemaConverters.java", "diffHunk": "@@ -123,6 +123,16 @@ private SchemaConverters() {\n     Schema toConnectSchema(SqlType sqlType, String name, String doc);\n   }\n \n+  public interface ConnectToJavaTypeConverter {\n+    /**\n+     * Convert the supplied Connect {@code schema} to its corresponding SQL type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NDQxMQ=="}, "originalCommit": {"oid": "a7f23ff55fd3eba9543bd437ffd594c7d04b8ab5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1Mzg5MjUyOnYy", "diffSide": "RIGHT", "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/EnabledSerdeFeatures.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzoyNDo0NFrOHRfWgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo1NjoyOFrOHRqb9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTUwNw==", "bodyText": "not really part of your change, but I'm wondering why we have both SerdeFeature and SerdeOption? what's the difference between them? can we javadoc it for the future?", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488101507", "createdAt": "2020-09-14T17:24:44Z", "author": {"login": "agavra"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/EnabledSerdeFeatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+import static io.confluent.ksql.serde.SerdeFeature.UNWRAP_SINGLES;\n+import static io.confluent.ksql.serde.SerdeFeature.WRAP_SINGLES;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+/**\n+ * Validated set of enabled features\n+ *\n+ * <p>Known to not have conflicting features enabled\n+ */\n+@Immutable\n+public final class EnabledSerdeFeatures {\n+\n+  private final ImmutableSet<SerdeFeature> features;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTg3Ng==", "bodyText": "All will become clear once SerdeOption.WRAP_SINGLE_KEYS is added, which will map to SerdeFeature.WRAP_SINGLE the same as SerdeOption.WRAP_SINGLE_VALUES does.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488271876", "createdAt": "2020-09-14T22:35:21Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/EnabledSerdeFeatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+import static io.confluent.ksql.serde.SerdeFeature.UNWRAP_SINGLES;\n+import static io.confluent.ksql.serde.SerdeFeature.WRAP_SINGLES;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+/**\n+ * Validated set of enabled features\n+ *\n+ * <p>Known to not have conflicting features enabled\n+ */\n+@Immutable\n+public final class EnabledSerdeFeatures {\n+\n+  private final ImmutableSet<SerdeFeature> features;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTUwNw=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MzEyNQ==", "bodyText": "\ud83d\udca1", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488283125", "createdAt": "2020-09-14T22:56:28Z", "author": {"login": "agavra"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/EnabledSerdeFeatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+import static io.confluent.ksql.serde.SerdeFeature.UNWRAP_SINGLES;\n+import static io.confluent.ksql.serde.SerdeFeature.WRAP_SINGLES;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+/**\n+ * Validated set of enabled features\n+ *\n+ * <p>Known to not have conflicting features enabled\n+ */\n+@Immutable\n+public final class EnabledSerdeFeatures {\n+\n+  private final ImmutableSet<SerdeFeature> features;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTUwNw=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzkwMDA3OnYy", "diffSide": "RIGHT", "path": "ksqldb-examples/src/main/java/io/confluent/ksql/datagen/DataGenProducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzoyNjo0M1rOHRfbDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjozNzozMlrOHRp3XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMjY3MA==", "bodyText": "why not just EnabledSerdeFeatures.of(supported)?", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488102670", "createdAt": "2020-09-14T17:26:43Z", "author": {"login": "agavra"}, "path": "ksqldb-examples/src/main/java/io/confluent/ksql/datagen/DataGenProducer.java", "diffHunk": "@@ -160,18 +162,16 @@ private static void produceOne(\n   private Serializer<Struct> getKeySerializer(\n       final ConnectSchema keySchema\n   ) {\n-    final PersistenceSchema schema = PersistenceSchema.from(\n-        keySchema,\n-        keySerializerFactory.format().supportedFeatures().contains(SerdeFeature.UNWRAP_SINGLES)\n-    );\n-\n+    final Set<SerdeFeature> supported = keySerializerFactory.format().supportedFeatures();\n+    final EnabledSerdeFeatures features = supported.contains(SerdeFeature.UNWRAP_SINGLES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3Mzc1Nw==", "bodyText": "The code wants to turn on unwrapping, where its supported, which is what it does. The code doesn't want to turn on any other feature the format may support, e.g. wrapping, or any feature added in the future.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488273757", "createdAt": "2020-09-14T22:37:32Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-examples/src/main/java/io/confluent/ksql/datagen/DataGenProducer.java", "diffHunk": "@@ -160,18 +162,16 @@ private static void produceOne(\n   private Serializer<Struct> getKeySerializer(\n       final ConnectSchema keySchema\n   ) {\n-    final PersistenceSchema schema = PersistenceSchema.from(\n-        keySchema,\n-        keySerializerFactory.format().supportedFeatures().contains(SerdeFeature.UNWRAP_SINGLES)\n-    );\n-\n+    final Set<SerdeFeature> supported = keySerializerFactory.format().supportedFeatures();\n+    final EnabledSerdeFeatures features = supported.contains(SerdeFeature.UNWRAP_SINGLES)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMjY3MA=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzkxNzA3OnYy", "diffSide": "RIGHT", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/avro/AvroSchemas.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzozMTozNVrOHRfltw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo0NTo0OFrOHRqN-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNTM5OQ==", "bodyText": "Any reason not to just always add these? it's unlikely that they exist for STRUCT, ARRAY and MAP but technically not impossible (I think)", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488105399", "createdAt": "2020-09-14T17:31:35Z", "author": {"login": "agavra"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/avro/AvroSchemas.java", "diffHunk": "@@ -86,7 +86,12 @@ private static Schema buildAvroCompatibleSchema(\n           return schema;\n         }\n \n-        schemaBuilder = new SchemaBuilder(schema.type());\n+        schemaBuilder = new SchemaBuilder(schema.type())\n+            .name(schema.name());\n+\n+        if (schema.parameters() != null) {\n+          schemaBuilder.parameters(schema.parameters());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDQ5Nw==", "bodyText": "I'll take a look.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488274497", "createdAt": "2020-09-14T22:38:31Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/avro/AvroSchemas.java", "diffHunk": "@@ -86,7 +86,12 @@ private static Schema buildAvroCompatibleSchema(\n           return schema;\n         }\n \n-        schemaBuilder = new SchemaBuilder(schema.type());\n+        schemaBuilder = new SchemaBuilder(schema.type())\n+            .name(schema.name());\n+\n+        if (schema.parameters() != null) {\n+          schemaBuilder.parameters(schema.parameters());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNTM5OQ=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3OTU0Nw==", "bodyText": "done.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488279547", "createdAt": "2020-09-14T22:45:48Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/avro/AvroSchemas.java", "diffHunk": "@@ -86,7 +86,12 @@ private static Schema buildAvroCompatibleSchema(\n           return schema;\n         }\n \n-        schemaBuilder = new SchemaBuilder(schema.type());\n+        schemaBuilder = new SchemaBuilder(schema.type())\n+            .name(schema.name());\n+\n+        if (schema.parameters() != null) {\n+          schemaBuilder.parameters(schema.parameters());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNTM5OQ=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NDAxODgxOnYy", "diffSide": "RIGHT", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODowMDoxOFrOHRgklw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo1NTo1NVrOHRqbVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMTQ5NQ==", "bodyText": "it seems a little weird to encapsulate this above (applySinglesUnwrapping) but then check for it explicitly here", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488121495", "createdAt": "2020-09-14T18:00:18Z", "author": {"login": "agavra"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -65,52 +74,100 @@ public boolean supportsSchemaInference() {\n \n   @Override\n   public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n-    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+    Schema connectSchema = toConnectSchema(schema);\n \n-    return connectSchema.fields().stream()\n+    if (connectSchema.type() != Type.STRUCT) {\n+      if (!supportsFeature(SerdeFeature.UNWRAP_SINGLES)) {\n+        throw new KsqlException(\"Schema returned from schema registry is anonymous type, \"\n+            + \"but format \" + name() + \" does not support anonymous types. \"\n+            + \"schema: \" + schema);\n+      }\n+\n+      connectSchema = SerdeUtils.wrapSingle(connectSchema);\n+    }\n+\n+    final Schema rowSchema = toKsqlTransformer.apply(connectSchema);\n+\n+    return rowSchema.fields().stream()\n         .map(ConnectFormat::toColumn)\n         .collect(Collectors.toList());\n   }\n \n   public ParsedSchema toParsedSchema(\n       final List<? extends SimpleColumn> columns,\n-      final SerdeOptions serdeOptions,\n+      final EnabledSerdeFeatures serdeFeatures,\n       final FormatInfo formatInfo\n   ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(serdeFeatures, supportedFeatures());\n+\n     final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n     columns.forEach(col -> schemaBuilder.field(\n         col.name().text(),\n         SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n     );\n \n-    final PersistenceSchema persistenceSchema =\n-        buildValuePhysical(schemaBuilder.build(), serdeOptions);\n+    final Schema schema = SerdeUtils.applySinglesUnwrapping(schemaBuilder.build(), serdeFeatures);\n \n-    return fromConnectSchema(persistenceSchema.serializedSchema(), formatInfo);\n+    return fromConnectSchema(schema, formatInfo);\n   }\n \n-  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+  @Override\n+  public Serde<Struct> getSerde(\n+      final PersistenceSchema schema,\n+      final Map<String, String> formatProps,\n+      final KsqlConfig config,\n+      final Supplier<SchemaRegistryClient> srFactory\n+  ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(schema.features(), supportedFeatures());\n \n-  protected abstract ParsedSchema fromConnectSchema(Schema schema, FormatInfo formatInfo);\n+    final ConnectSchema outerSchema = schema.connectSchema();\n+    final ConnectSchema innerSchema = SerdeUtils\n+        .applySinglesUnwrapping(outerSchema, schema.features());\n \n-  private static PersistenceSchema buildValuePhysical(\n-      final Schema valueConnectSchema,\n-      final SerdeOptions serdeOptions\n-  ) {\n-    final boolean singleField = valueConnectSchema.fields().size() == 1;\n+    final Class<?> targetType = SchemaConverters.connectToJavaTypeConverter()\n+        .toJavaType(innerSchema);\n \n-    final boolean unwrapSingle = serdeOptions.valueWrapping()\n-        .map(option -> option == SerdeOption.UNWRAP_SINGLE_VALUES)\n-        .orElse(false);\n+    if (schema.features().enabled(SerdeFeature.UNWRAP_SINGLES)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3ODI2MA==", "bodyText": "Why?  applySinglesUnwrapping(outerSchema) only extracts the inner schema. That's only half the storey. The code still needs to build a serde that can handle the unwrapping, i.e. extracting the value of the single column from the Struct passed to serialize and the reverse for deserialize.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488278260", "createdAt": "2020-09-14T22:43:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -65,52 +74,100 @@ public boolean supportsSchemaInference() {\n \n   @Override\n   public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n-    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+    Schema connectSchema = toConnectSchema(schema);\n \n-    return connectSchema.fields().stream()\n+    if (connectSchema.type() != Type.STRUCT) {\n+      if (!supportsFeature(SerdeFeature.UNWRAP_SINGLES)) {\n+        throw new KsqlException(\"Schema returned from schema registry is anonymous type, \"\n+            + \"but format \" + name() + \" does not support anonymous types. \"\n+            + \"schema: \" + schema);\n+      }\n+\n+      connectSchema = SerdeUtils.wrapSingle(connectSchema);\n+    }\n+\n+    final Schema rowSchema = toKsqlTransformer.apply(connectSchema);\n+\n+    return rowSchema.fields().stream()\n         .map(ConnectFormat::toColumn)\n         .collect(Collectors.toList());\n   }\n \n   public ParsedSchema toParsedSchema(\n       final List<? extends SimpleColumn> columns,\n-      final SerdeOptions serdeOptions,\n+      final EnabledSerdeFeatures serdeFeatures,\n       final FormatInfo formatInfo\n   ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(serdeFeatures, supportedFeatures());\n+\n     final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n     columns.forEach(col -> schemaBuilder.field(\n         col.name().text(),\n         SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n     );\n \n-    final PersistenceSchema persistenceSchema =\n-        buildValuePhysical(schemaBuilder.build(), serdeOptions);\n+    final Schema schema = SerdeUtils.applySinglesUnwrapping(schemaBuilder.build(), serdeFeatures);\n \n-    return fromConnectSchema(persistenceSchema.serializedSchema(), formatInfo);\n+    return fromConnectSchema(schema, formatInfo);\n   }\n \n-  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+  @Override\n+  public Serde<Struct> getSerde(\n+      final PersistenceSchema schema,\n+      final Map<String, String> formatProps,\n+      final KsqlConfig config,\n+      final Supplier<SchemaRegistryClient> srFactory\n+  ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(schema.features(), supportedFeatures());\n \n-  protected abstract ParsedSchema fromConnectSchema(Schema schema, FormatInfo formatInfo);\n+    final ConnectSchema outerSchema = schema.connectSchema();\n+    final ConnectSchema innerSchema = SerdeUtils\n+        .applySinglesUnwrapping(outerSchema, schema.features());\n \n-  private static PersistenceSchema buildValuePhysical(\n-      final Schema valueConnectSchema,\n-      final SerdeOptions serdeOptions\n-  ) {\n-    final boolean singleField = valueConnectSchema.fields().size() == 1;\n+    final Class<?> targetType = SchemaConverters.connectToJavaTypeConverter()\n+        .toJavaType(innerSchema);\n \n-    final boolean unwrapSingle = serdeOptions.valueWrapping()\n-        .map(option -> option == SerdeOption.UNWRAP_SINGLE_VALUES)\n-        .orElse(false);\n+    if (schema.features().enabled(SerdeFeature.UNWRAP_SINGLES)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMTQ5NQ=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4Mjk2Nw==", "bodyText": "I feel like if I'm already checking the UNWRAP_SINGLES variable here, i might as well just extract the inner schema there as well. Not a biggie, but now we're checking it in two places and doing a no-op in one of them if it's disabled.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488282967", "createdAt": "2020-09-14T22:55:55Z", "author": {"login": "agavra"}, "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -65,52 +74,100 @@ public boolean supportsSchemaInference() {\n \n   @Override\n   public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n-    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+    Schema connectSchema = toConnectSchema(schema);\n \n-    return connectSchema.fields().stream()\n+    if (connectSchema.type() != Type.STRUCT) {\n+      if (!supportsFeature(SerdeFeature.UNWRAP_SINGLES)) {\n+        throw new KsqlException(\"Schema returned from schema registry is anonymous type, \"\n+            + \"but format \" + name() + \" does not support anonymous types. \"\n+            + \"schema: \" + schema);\n+      }\n+\n+      connectSchema = SerdeUtils.wrapSingle(connectSchema);\n+    }\n+\n+    final Schema rowSchema = toKsqlTransformer.apply(connectSchema);\n+\n+    return rowSchema.fields().stream()\n         .map(ConnectFormat::toColumn)\n         .collect(Collectors.toList());\n   }\n \n   public ParsedSchema toParsedSchema(\n       final List<? extends SimpleColumn> columns,\n-      final SerdeOptions serdeOptions,\n+      final EnabledSerdeFeatures serdeFeatures,\n       final FormatInfo formatInfo\n   ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(serdeFeatures, supportedFeatures());\n+\n     final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n     columns.forEach(col -> schemaBuilder.field(\n         col.name().text(),\n         SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n     );\n \n-    final PersistenceSchema persistenceSchema =\n-        buildValuePhysical(schemaBuilder.build(), serdeOptions);\n+    final Schema schema = SerdeUtils.applySinglesUnwrapping(schemaBuilder.build(), serdeFeatures);\n \n-    return fromConnectSchema(persistenceSchema.serializedSchema(), formatInfo);\n+    return fromConnectSchema(schema, formatInfo);\n   }\n \n-  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+  @Override\n+  public Serde<Struct> getSerde(\n+      final PersistenceSchema schema,\n+      final Map<String, String> formatProps,\n+      final KsqlConfig config,\n+      final Supplier<SchemaRegistryClient> srFactory\n+  ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(schema.features(), supportedFeatures());\n \n-  protected abstract ParsedSchema fromConnectSchema(Schema schema, FormatInfo formatInfo);\n+    final ConnectSchema outerSchema = schema.connectSchema();\n+    final ConnectSchema innerSchema = SerdeUtils\n+        .applySinglesUnwrapping(outerSchema, schema.features());\n \n-  private static PersistenceSchema buildValuePhysical(\n-      final Schema valueConnectSchema,\n-      final SerdeOptions serdeOptions\n-  ) {\n-    final boolean singleField = valueConnectSchema.fields().size() == 1;\n+    final Class<?> targetType = SchemaConverters.connectToJavaTypeConverter()\n+        .toJavaType(innerSchema);\n \n-    final boolean unwrapSingle = serdeOptions.valueWrapping()\n-        .map(option -> option == SerdeOption.UNWRAP_SINGLE_VALUES)\n-        .orElse(false);\n+    if (schema.features().enabled(SerdeFeature.UNWRAP_SINGLES)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMTQ5NQ=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NDA0MzY4OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/elements.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODowNzozOFrOHRg0JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo0NDo0MlrOHRqMIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyNTQ3Ng==", "bodyText": "does the output intentionally not keep the serde options from the input? I would expect it to be not wrapped here as well", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488125476", "createdAt": "2020-09-14T18:07:38Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/elements.json", "diffHunk": "@@ -39,6 +39,19 @@\n       \"inputs\": [{\"topic\": \"input\", \"value\": {\"c1\": 4}}],\n       \"outputs\": [{\"topic\": \"OUTPUT\", \"value\": {\"C1\": 4}}]\n     },\n+    {\n+      \"name\": \"validate unwrapped value without elements OK - AVRO\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT WITH (kafka_topic='input', value_format='AvRo', wrap_single_value=false);\",\n+        \"CREATE STREAM OUTPUT as SELECT * FROM input;\"\n+      ],\n+      \"topics\": [\n+        {\"name\": \"input\", \"format\": \"AVRO\", \"schema\": \"int\"},\n+        {\"name\": \"OUTPUT\", \"format\": \"AVRO\", \"schema\": {\"name\": \"blah\", \"type\": \"record\", \"fields\": [{\"name\": \"ROWVAL\", \"type\": \"int\"}]}}\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": 4}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"value\": {\"ROWVAL\": 4}}]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3OTA3Mw==", "bodyText": "wrap_single_value is not currently inherited.  Not sure why it was implemented that way, but it was.  This PR doesn't change that.", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488279073", "createdAt": "2020-09-14T22:44:42Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/elements.json", "diffHunk": "@@ -39,6 +39,19 @@\n       \"inputs\": [{\"topic\": \"input\", \"value\": {\"c1\": 4}}],\n       \"outputs\": [{\"topic\": \"OUTPUT\", \"value\": {\"C1\": 4}}]\n     },\n+    {\n+      \"name\": \"validate unwrapped value without elements OK - AVRO\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT WITH (kafka_topic='input', value_format='AvRo', wrap_single_value=false);\",\n+        \"CREATE STREAM OUTPUT as SELECT * FROM input;\"\n+      ],\n+      \"topics\": [\n+        {\"name\": \"input\", \"format\": \"AVRO\", \"schema\": \"int\"},\n+        {\"name\": \"OUTPUT\", \"format\": \"AVRO\", \"schema\": {\"name\": \"blah\", \"type\": \"record\", \"fields\": [{\"name\": \"ROWVAL\", \"type\": \"int\"}]}}\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": 4}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"value\": {\"ROWVAL\": 4}}]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyNTQ3Ng=="}, "originalCommit": {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2761, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}