{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NTgzNDU2", "number": 4609, "title": "refactor: Refactor KsqlClient to use Vert.x", "bodyText": "Description\nImplements #4283\nThis PR refactors the KsqlClient to use Vert.x instead of jax-rs.\nKsqlClient is used by the CLI and also internally to direct requests at different nodes of the cluster.\nThis is part of the API migration work. Eventually this client should go away altogether and will be replaced by the new Java client, however that will require the Java client (we don't have it yet) and it will also require the users of the client to work in a reactive/async way which would be a large refactoring of the calling code.\nThis PR keeps the KsqlClient with more or less the same API so it doesn't require a lot of changes on the caller side, although it does have some changes around streaming  of query results and print topic to expose a non blocking way of doing this\nThis PR also moves some classes to common along with associated tests.\nTesting done\nThe testing has been revamped for KsqlClient. A bunch of new test cases are created, and the overall test coverage is now much better than the previous brittle fine grained unit tests.\nKSqlRestClientFunctionalTest has also been removed as the new KsqlClientTest makes it redundant.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-02-22T12:04:54Z", "url": "https://github.com/confluentinc/ksql/pull/4609", "merged": true, "mergeCommit": {"oid": "849255a243af4276ad8d8b20bb52a0232e0be497"}, "closed": true, "closedAt": "2020-02-27T11:34:42Z", "author": {"login": "purplefox"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHkpxxABqjMwNjcxMjM2NzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIY7xUgH2gAyMzc4NTgzNDU2OmI2MTRkOWM3ZGVkMGYwMDY3M2E1NDNkZmFjMDhmNzhkNDdmZWYyM2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "056c3f0ef3651b8879619b8254de56adfc23188d", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/056c3f0ef3651b8879619b8254de56adfc23188d", "committedDate": "2020-02-24T21:20:43Z", "message": "foo"}, "afterCommit": {"oid": "a6e6babbb0dc8c3d04c2dab772d4e8257340b47b", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/a6e6babbb0dc8c3d04c2dab772d4e8257340b47b", "committedDate": "2020-02-24T21:41:35Z", "message": "refactor KsqlClient to use Vert.x instead of jax-ws"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ec09a3642829102b66cac108b1488db4d4f5695", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/7ec09a3642829102b66cac108b1488db4d4f5695", "committedDate": "2020-02-25T08:20:10Z", "message": "refactor KsqlClient to use Vert.x instead of jax-ws"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/be5c6a22f6ae395271f04b725daaf46570f3f83d", "committedDate": "2020-02-25T08:20:10Z", "message": "fix ssl tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4bd85fc4634cfff0a761428870c3dd44d3962172", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/4bd85fc4634cfff0a761428870c3dd44d3962172", "committedDate": "2020-02-24T23:24:06Z", "message": "fix ssl tests"}, "afterCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/be5c6a22f6ae395271f04b725daaf46570f3f83d", "committedDate": "2020-02-25T08:20:10Z", "message": "fix ssl tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NDY0Mjc0", "url": "https://github.com/confluentinc/ksql/pull/4609#pullrequestreview-365464274", "createdAt": "2020-02-27T07:37:38Z", "commit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNzozNzozOFrOFvHx3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNzo1Mjo1OVrOFvIISQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NDg0NA==", "bodyText": "Closing on newlines does not seem valid, since the TopicStreamWriter may insert them: \n  \n    \n      ksql/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStreamWriter.java\n    \n    \n         Line 107\n      in\n      6bcbd51\n    \n    \n    \n    \n\n        \n          \n           print.println(); \n        \n    \n  \n\n\nI see you've got handling for similar new lines from the QueryStreamWriter, and a test for it in KsqlClientTest. Can we add the analogous for print topic handling as well?", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384954844", "createdAt": "2020-02-27T07:37:38Z", "author": {"login": "vcrfxia"}, "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -510,4 +466,105 @@ private void setRequestPipelining(final boolean newSetting) {\n       requestPipelining = newSetting;\n     }\n   }\n+\n+  private class QueryStreamSubscriber extends BaseSubscriber<StreamedRow> {\n+\n+    private final CompletableFuture<Void> future;\n+    private boolean closed;\n+    private long rowsRead;\n+\n+    QueryStreamSubscriber(final Context context, final CompletableFuture<Void> future) {\n+      super(context);\n+      this.future = Objects.requireNonNull(future);\n+    }\n+\n+    @Override\n+    protected void afterSubscribe(final Subscription subscription) {\n+      makeRequest(1);\n+    }\n+\n+    @Override\n+    protected synchronized void handleValue(final StreamedRow row) {\n+      if (closed) {\n+        return;\n+      }\n+      terminal.printStreamedRow(row);\n+      terminal.flush();\n+      if (row.isTerminal()) {\n+        future.complete(null);\n+        close();\n+        return;\n+      }\n+      if (row.getRow().isPresent()) {\n+        rowsRead++;\n+        if (streamedQueryRowLimit != null && streamedQueryRowLimit == rowsRead) {\n+          future.complete(null);\n+          close();\n+          return;\n+        }\n+      }\n+      makeRequest(1);\n+    }\n+\n+    @Override\n+    protected void handleComplete() {\n+      future.complete(null);\n+    }\n+\n+    @Override\n+    protected void handleError(final Throwable t) {\n+      future.completeExceptionally(t);\n+    }\n+\n+    synchronized void close() {\n+      closed = true;\n+      context.runOnContext(v -> cancel());\n+    }\n+  }\n+\n+  private class PrintTopicSubscriber extends BaseSubscriber<String> {\n+\n+    private final CompletableFuture<Void> future;\n+    private boolean closed;\n+\n+    PrintTopicSubscriber(final Context context, final CompletableFuture<Void> future) {\n+      super(context);\n+      this.future = Objects.requireNonNull(future);\n+    }\n+\n+    @Override\n+    protected void afterSubscribe(final Subscription subscription) {\n+      makeRequest(1);\n+    }\n+\n+    @Override\n+    protected synchronized void handleValue(final String line) {\n+      if (closed) {\n+        return;\n+      }\n+      if (line.isEmpty()) {\n+        close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTYwNw==", "bodyText": "Do we need null checks here and on SSL_KEYSTORE_PASSWORD_CONFIG below? The old SslUtilTest file has a test to verify that the keystore password defaults to the empty string if not provided, which does not appear to have been copied over to the new KsqlClientTests.", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384955607", "createdAt": "2020-02-27T07:39:39Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -38,37 +44,86 @@\n     JsonMapper.INSTANCE.mapper.registerModule(new KsqlTypesDeserializationModule(false));\n   }\n \n-  private final Client httpClient;\n+  public static final String DISABLE_HOSTNAME_VERIFICATION_PROP_NAME\n+      = \"ksql.client.disable.hostname.verification\";\n+  public static final String TLS_ENABLED_PROP_NAME = \"ksql.client.enable.tls\";\n+\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n   private final LocalProperties localProperties;\n+  private final Optional<String> basicAuthHeader;\n+  private final boolean isTls;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions\n   ) {\n-    this(HttpClientBuilder.buildClient(clientProps), credentials, localProperties);\n+    this.localProperties = requireNonNull(localProperties, \"localProperties\");\n+    this.basicAuthHeader = createBasicAuthHeader(\n+        Objects.requireNonNull(credentials, \"credentials\"));\n+    this.vertx = Vertx.vertx();\n+    if (\"true\".equals(clientProps.get(DISABLE_HOSTNAME_VERIFICATION_PROP_NAME))) {\n+      httpClientOptions.setVerifyHost(false);\n+    }\n+    if (\"true\".equals(clientProps.get(TLS_ENABLED_PROP_NAME))) {\n+      httpClientOptions.setSsl(true);\n+      isTls = true;\n+    } else {\n+      isTls = false;\n+    }\n+    final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+    if (trustStoreLocation != null) {\n+      httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+          .setPassword(clientProps.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTkxNQ==", "bodyText": "Why was this retry logic removed?", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384955915", "createdAt": "2020-02-27T07:40:30Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -171,89 +178,123 @@ private KsqlRequest ksqlRequest(\n   }\n \n   private <T> RestResponse<T> get(final String path, final Class<T> type) {\n-    try (Response response = target\n-        .path(path)\n-        .request(MediaType.APPLICATION_JSON_TYPE)\n-        .headers(headers())\n-        .get()\n-    ) {\n-      return KsqlClientUtil.toRestResponse(response, path, r -> r.readEntity(type));\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing GET to KSQL server. path:\" + path, e);\n-    }\n+    return executeRequestSync(HttpMethod.GET, path, null, r -> deserialize(r.getBody(), type));\n   }\n \n   private <T> RestResponse<T> post(\n       final String path,\n       final Object jsonEntity,\n-      final Optional<Integer> readTimeoutMs,\n-      final boolean closeResponse,\n-      final Function<Response, T> mapper\n+      final Function<ResponseWithBody, T> mapper\n   ) {\n-    Response response = null;\n+    return executeRequestSync(HttpMethod.POST, path, jsonEntity, mapper);\n+  }\n \n-    try {\n-      response = target\n-          .path(path)\n-          .request(MediaType.APPLICATION_JSON_TYPE)\n-          .property(ClientProperties.READ_TIMEOUT, readTimeoutMs.orElse(0))\n-          .headers(headers())\n-          .post(Entity.json(jsonEntity));\n-\n-      return KsqlClientUtil.toRestResponse(response, path, mapper);\n-    } catch (final ProcessingException e) {\n-      if (shouldRetry(readTimeoutMs, e)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NzAyMg==", "bodyText": "Does the new client throw a sensible error message if the provided TLS keystore or truststore location does not exist, or if the password is incorrect? (This old logic for TLS keystore/truststore handling threw an explicit error in these cases, but I don't see analogous logic in the new implementation.)", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384957022", "createdAt": "2020-02-27T07:43:28Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/ssl/SslUtil.java", "diffHunk": "@@ -1,90 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.rest.client.ssl;\n-\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.rest.RestConfig;\n-import java.io.FileInputStream;\n-import java.security.KeyStore;\n-import java.util.Map;\n-import java.util.Optional;\n-import javax.net.ssl.HostnameVerifier;\n-import org.apache.http.conn.ssl.NoopHostnameVerifier;\n-import org.apache.kafka.common.config.ConfigException;\n-\n-public final class SslUtil {\n-\n-  private SslUtil() {\n-  }\n-\n-  static Optional<KeyStore> loadKeyStore(final Map<String, String> props) {\n-    return load(props,\n-        RestConfig.SSL_KEYSTORE_LOCATION_CONFIG,\n-        RestConfig.SSL_KEYSTORE_PASSWORD_CONFIG,\n-        RestConfig.SSL_KEYSTORE_TYPE_CONFIG);\n-  }\n-\n-  static Optional<KeyStore> loadTrustStore(final Map<String, String> props) {\n-    return load(props,\n-        RestConfig.SSL_TRUSTSTORE_LOCATION_CONFIG,\n-        RestConfig.SSL_TRUSTSTORE_PASSWORD_CONFIG,\n-        RestConfig.SSL_TRUSTSTORE_TYPE_CONFIG);\n-  }\n-\n-  static String getKeyPassword(final Map<String, String> props) {\n-    return props.getOrDefault(RestConfig.SSL_KEY_PASSWORD_CONFIG, \"\");\n-  }\n-\n-  static Optional<HostnameVerifier> getHostNameVerifier(final Map<String, String> props) {\n-    final String algo = props.getOrDefault(\n-        RestConfig.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, \"\");\n-\n-    if (algo.isEmpty()) {\n-      return Optional.of(NoopHostnameVerifier.INSTANCE);\n-    }\n-\n-    if (algo.equalsIgnoreCase(\"https\")) {\n-      return Optional.empty();\n-    }\n-\n-    throw new ConfigException(\n-        RestConfig.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, algo, \"Not supported\");\n-  }\n-\n-  private static Optional<KeyStore> load(\n-      final Map<String, String> props,\n-      final String locationConfig,\n-      final String passwordConfig,\n-      final String typeConfig\n-  ) {\n-    final String location = props.getOrDefault(locationConfig, \"\");\n-    if (location.isEmpty()) {\n-      return Optional.empty();\n-    }\n-\n-    try (FileInputStream stream = new FileInputStream(location)) {\n-\n-      final String password = props.getOrDefault(passwordConfig, \"\");\n-      final String type = props.getOrDefault(typeConfig, \"JKS\");\n-\n-      final KeyStore keyStore = KeyStore.getInstance(type);\n-      keyStore.load(stream, password.toCharArray());\n-      return Optional.of(keyStore);\n-    } catch (final Exception e) {\n-      throw new KsqlException(\"Failed to load keyStore: \" + location, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NzM1Nw==", "bodyText": "The new handlePrintedTopic() logic does not appear to set this status message. Can we add it back?", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384957357", "createdAt": "2020-02-27T07:44:29Z", "author": {"login": "vcrfxia"}, "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -380,42 +344,34 @@ private void handlePrintedTopic(\n       final String printTopic,\n       final SqlBaseParser.PrintTopicContext ignored\n   ) {\n-    final RestResponse<InputStream> topicResponse =\n+    final RestResponse<StreamPublisher<String>> topicResponse =\n         makeKsqlRequest(printTopic, restClient::makePrintTopicRequest);\n \n     if (topicResponse.isSuccessful()) {\n-      try (Scanner topicStreamScanner = new Scanner(topicResponse.getResponse(), UTF_8.name());\n-          StatusClosable toClose = terminal.setStatusMessage(\"Press CTRL-C to interrupt\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1ODU0Nw==", "bodyText": "Not your code, but I don't see terminal.flush() called after this -- is that necessary?", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384958547", "createdAt": "2020-02-27T07:47:50Z", "author": {"login": "vcrfxia"}, "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -309,68 +298,43 @@ private void printKsqlResponse(final RestResponse<KsqlEntityList> response) {\n     }\n   }\n \n-  private void streamResults(final QueryStream queryStream) {\n-    final Future<?> queryStreamFuture = queryStreamExecutorService.submit(() -> {\n-      for (long rowsRead = 0; limitNotReached(rowsRead) && queryStream.hasNext(); ) {\n-        final StreamedRow row = queryStream.next();\n-\n-        terminal.printStreamedRow(row);\n-        if (row.isTerminal()) {\n-          break;\n-        }\n-\n-        if (row.getRow().isPresent()) {\n-          rowsRead++;\n-        }\n-      }\n-    });\n-\n-    terminal.handle(Terminal.Signal.INT, signal -> {\n-      terminal.handle(Terminal.Signal.INT, Terminal.SignalHandler.SIG_IGN);\n-      queryStream.close();\n-    });\n-\n-    try {\n-      if (streamedQueryTimeoutMs != null) {\n-        try {\n-          queryStreamFuture.get(streamedQueryTimeoutMs, TimeUnit.MILLISECONDS);\n-        } catch (final TimeoutException exception) {\n-          queryStream.close();\n-        }\n-      }\n-\n-      queryStreamFuture.get();\n-    } catch (final InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-    } catch (final ExecutionException e) {\n-      if (e.getCause() instanceof RuntimeException) {\n-        throw (RuntimeException)e.getCause();\n-      }\n-      throw new RuntimeException(e.getCause());\n-    } finally {\n-      terminal.writer().println(\"Query terminated\");\n-      terminal.flush();\n-    }\n-  }\n-\n-  private boolean limitNotReached(final long rowsRead) {\n-    return streamedQueryRowLimit == null || rowsRead < streamedQueryRowLimit;\n-  }\n-\n   @SuppressWarnings({\"try\", \"unused\"}) // ignored param is required to compile.\n   private void handleQuery(\n       final String statement,\n       final SqlBaseParser.QueryStatementContext query\n   ) {\n-    final RestResponse<QueryStream> queryResponse =\n-        makeKsqlRequest(statement, restClient::makeQueryRequest);\n+    final RestResponse<StreamPublisher<StreamedRow>> queryResponse =\n+        makeKsqlRequest(statement, restClient::makeQueryRequestStreamed);\n \n     if (!queryResponse.isSuccessful()) {\n       terminal.printErrorMessage(queryResponse.getErrorMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1ODgxOA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  topicResponse.getResponse().subscribe(subscriber);\n          \n          \n            \n                  publisher.subscribe(subscriber);", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384958818", "createdAt": "2020-02-27T07:48:29Z", "author": {"login": "vcrfxia"}, "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -380,42 +344,34 @@ private void handlePrintedTopic(\n       final String printTopic,\n       final SqlBaseParser.PrintTopicContext ignored\n   ) {\n-    final RestResponse<InputStream> topicResponse =\n+    final RestResponse<StreamPublisher<String>> topicResponse =\n         makeKsqlRequest(printTopic, restClient::makePrintTopicRequest);\n \n     if (topicResponse.isSuccessful()) {\n-      try (Scanner topicStreamScanner = new Scanner(topicResponse.getResponse(), UTF_8.name());\n-          StatusClosable toClose = terminal.setStatusMessage(\"Press CTRL-C to interrupt\")\n-      ) {\n-        final Future<?> topicPrintFuture = queryStreamExecutorService.submit(() -> {\n-          while (!Thread.currentThread().isInterrupted() && topicStreamScanner.hasNextLine()) {\n-            final String line = topicStreamScanner.nextLine();\n-            if (!line.isEmpty()) {\n-              terminal.writer().println(line);\n-              terminal.flush();\n-            }\n-          }\n-        });\n-\n-        terminal.handle(Terminal.Signal.INT, signal -> {\n-          terminal.handle(Terminal.Signal.INT, Terminal.SignalHandler.SIG_IGN);\n-          topicPrintFuture.cancel(true);\n-        });\n+      final CompletableFuture<Void> future = new CompletableFuture<>();\n+      final StreamPublisher<String> publisher = topicResponse.getResponse();\n+      final PrintTopicSubscriber subscriber = new PrintTopicSubscriber(publisher.getContext(),\n+          future);\n+      topicResponse.getResponse().subscribe(subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTI1NQ==", "bodyText": "nit: unnecessary in light of the additions to givenTrustStoreConfigured() and givenClientConfguredWithoutTruststore().", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384959255", "createdAt": "2020-02-27T07:49:36Z", "author": {"login": "vcrfxia"}, "path": "ksql-cli/src/test/java/io/confluent/ksql/cli/SslFunctionalTest.java", "diffHunk": "@@ -109,15 +110,20 @@ public static void classSetUp() {\n \n   @Before\n   public void setUp() {\n-    clientProps = Collections.emptyMap();\n+    clientProps = new HashMap<>();\n+    clientProps.put(KsqlClient.DISABLE_HOSTNAME_VERIFICATION_PROP_NAME, \"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTU1Mg==", "bodyText": "nit: this can just be awaitLatch(latch).", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384959552", "createdAt": "2020-02-27T07:50:13Z", "author": {"login": "vcrfxia"}, "path": "ksql-common/src/test/java/io/confluent/ksql/reactive/ReactiveSubscriberTest.java", "diffHunk": "@@ -87,7 +86,7 @@ public void cancel() {\n     assertThatEventually(afterSubScribeCalled::get, is(true));\n     subscriber.onNext(\"record0\");\n     subscriber.onComplete();\n-    awaitLatch(latch);\n+    assertThat(latch.await(2000, TimeUnit.MILLISECONDS), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTgyMg==", "bodyText": "I'm not familiar with HTTP connection pooling -- is 100 a typical pool size? Feels large.", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384959822", "createdAt": "2020-02-27T07:50:54Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -137,4 +129,9 @@ private KsqlTarget getTarget(final KsqlTarget target, final Optional<String> aut\n         .map(target::authorizationHeader)\n         .orElse(target);\n   }\n+\n+  private static HttpClientOptions createClientOptions() {\n+    return new HttpClientOptions().setMaxPoolSize(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDE0MA==", "bodyText": "Can we have the other constructor call this one, in order to minimize divergence between tests and production code?", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384960140", "createdAt": "2020-02-27T07:51:43Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -38,37 +44,86 @@\n     JsonMapper.INSTANCE.mapper.registerModule(new KsqlTypesDeserializationModule(false));\n   }\n \n-  private final Client httpClient;\n+  public static final String DISABLE_HOSTNAME_VERIFICATION_PROP_NAME\n+      = \"ksql.client.disable.hostname.verification\";\n+  public static final String TLS_ENABLED_PROP_NAME = \"ksql.client.enable.tls\";\n+\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n   private final LocalProperties localProperties;\n+  private final Optional<String> basicAuthHeader;\n+  private final boolean isTls;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions\n   ) {\n-    this(HttpClientBuilder.buildClient(clientProps), credentials, localProperties);\n+    this.localProperties = requireNonNull(localProperties, \"localProperties\");\n+    this.basicAuthHeader = createBasicAuthHeader(\n+        Objects.requireNonNull(credentials, \"credentials\"));\n+    this.vertx = Vertx.vertx();\n+    if (\"true\".equals(clientProps.get(DISABLE_HOSTNAME_VERIFICATION_PROP_NAME))) {\n+      httpClientOptions.setVerifyHost(false);\n+    }\n+    if (\"true\".equals(clientProps.get(TLS_ENABLED_PROP_NAME))) {\n+      httpClientOptions.setSsl(true);\n+      isTls = true;\n+    } else {\n+      isTls = false;\n+    }\n+    final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+    if (trustStoreLocation != null) {\n+      httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+          .setPassword(clientProps.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)));\n+      final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+      if (keyStoreLocation != null) {\n+        httpClientOptions.setKeyStoreOptions(new JksOptions().setPath(keyStoreLocation)\n+            .setPassword(clientProps.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)));\n+      }\n+    }\n+    this.httpClient = vertx.createHttpClient(httpClientOptions);\n   }\n \n   @VisibleForTesting\n   KsqlClient(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDM3MQ==", "bodyText": "GET hardcoded for httpMethod in error message.", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384960371", "createdAt": "2020-02-27T07:52:23Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -171,89 +178,123 @@ private KsqlRequest ksqlRequest(\n   }\n \n   private <T> RestResponse<T> get(final String path, final Class<T> type) {\n-    try (Response response = target\n-        .path(path)\n-        .request(MediaType.APPLICATION_JSON_TYPE)\n-        .headers(headers())\n-        .get()\n-    ) {\n-      return KsqlClientUtil.toRestResponse(response, path, r -> r.readEntity(type));\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing GET to KSQL server. path:\" + path, e);\n-    }\n+    return executeRequestSync(HttpMethod.GET, path, null, r -> deserialize(r.getBody(), type));\n   }\n \n   private <T> RestResponse<T> post(\n       final String path,\n       final Object jsonEntity,\n-      final Optional<Integer> readTimeoutMs,\n-      final boolean closeResponse,\n-      final Function<Response, T> mapper\n+      final Function<ResponseWithBody, T> mapper\n   ) {\n-    Response response = null;\n+    return executeRequestSync(HttpMethod.POST, path, jsonEntity, mapper);\n+  }\n \n-    try {\n-      response = target\n-          .path(path)\n-          .request(MediaType.APPLICATION_JSON_TYPE)\n-          .property(ClientProperties.READ_TIMEOUT, readTimeoutMs.orElse(0))\n-          .headers(headers())\n-          .post(Entity.json(jsonEntity));\n-\n-      return KsqlClientUtil.toRestResponse(response, path, mapper);\n-    } catch (final ProcessingException e) {\n-      if (shouldRetry(readTimeoutMs, e)) {\n-        return post(path, jsonEntity, calcReadTimeout(readTimeoutMs), closeResponse, mapper);\n-      }\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    } finally {\n-      if (response != null && closeResponse) {\n-        response.close();\n-      }\n-    }\n+  private void executeRequestAsync(\n+      final String path,\n+      final Object jsonEntity\n+  ) {\n+    execute(HttpMethod.POST, path, jsonEntity, (resp, vcf) -> {\n+    }).exceptionally(t -> {\n+      log.error(\"Unexpected exception in async request\", t);\n+      return null;\n+    });\n   }\n \n-  private Future<Response> postAsync(\n+  private <T> RestResponse<T> executeRequestSync(\n+      final HttpMethod httpMethod,\n       final String path,\n-      final Object jsonEntity,\n-      final Optional<Integer> readTimeoutMs\n+      final Object requestBody,\n+      final Function<ResponseWithBody, T> mapper\n   ) {\n-    try {\n-      // Performs an asynchronous request\n-      return target\n-          .path(path)\n-          .request(MediaType.APPLICATION_JSON_TYPE)\n-          .property(ClientProperties.READ_TIMEOUT, readTimeoutMs.orElse(0))\n-          .headers(headers())\n-          .async()\n-          .post(Entity.json(jsonEntity));\n-    } catch (final ProcessingException e) {\n-      if (shouldRetry(readTimeoutMs, e)) {\n-        return postAsync(path, jsonEntity, calcReadTimeout(readTimeoutMs));\n-      }\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    }\n+    return executeSync(httpMethod, path, requestBody, mapper, (resp, vcf) -> {\n+      resp.bodyHandler(buff -> vcf.complete(new ResponseWithBody(resp, buff)));\n+    });\n   }\n \n-  private MultivaluedMap<String, Object> headers() {\n-    final MultivaluedMap<String, Object> headers = new MultivaluedHashMap<>();\n-    authHeader.ifPresent(v -> headers.add(HttpHeaders.AUTHORIZATION, v));\n-    return headers;\n+  private <T> RestResponse<StreamPublisher<T>> executeQueryRequestWithStreamResponse(\n+      final String ksql,\n+      final Optional<Long> previousCommandSeqNum,\n+      final Function<Buffer, T> mapper\n+  ) {\n+    final KsqlRequest ksqlRequest = createKsqlRequest(ksql, previousCommandSeqNum);\n+    final AtomicReference<StreamPublisher<T>> pubRef = new AtomicReference<>();\n+    return executeSync(HttpMethod.POST, QUERY_PATH, ksqlRequest, resp -> pubRef.get(),\n+        (resp, vcf) -> {\n+          if (resp.statusCode() == 200) {\n+            pubRef.set(new StreamPublisher<>(Vertx.currentContext(),\n+                resp, mapper, vcf));\n+            vcf.complete(new ResponseWithBody(resp));\n+          } else {\n+            resp.bodyHandler(body -> vcf.complete(new ResponseWithBody(resp, body)));\n+          }\n+        });\n   }\n \n-  private static boolean shouldRetry(\n-      final Optional<Integer> readTimeoutMs,\n-      final ProcessingException e\n+  private <T> RestResponse<T> executeSync(\n+      final HttpMethod httpMethod,\n+      final String path,\n+      final Object requestBody,\n+      final Function<ResponseWithBody, T> mapper,\n+      final BiConsumer<HttpClientResponse, CompletableFuture<ResponseWithBody>> responseHandler\n   ) {\n-    return readTimeoutMs.map(timeout -> timeout < MAX_TIMEOUT).orElse(false)\n-        && e.getCause() instanceof SocketTimeoutException;\n+    final CompletableFuture<ResponseWithBody> vcf =\n+        execute(httpMethod, path, requestBody, responseHandler);\n+\n+    final ResponseWithBody response;\n+    try {\n+      response = vcf.get();\n+    } catch (Exception e) {\n+      throw new KsqlRestClientException(\"Error issuing GET to KSQL server. path:\" + path, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDU4NQ==", "bodyText": "nit: rename to closeConnection() or something similar?", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384960585", "createdAt": "2020-02-27T07:52:59Z", "author": {"login": "vcrfxia"}, "path": "ksql-rest-client/src/test/java/io/confluent/ksql/rest/client/FakeApiServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.client;\n+\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.concurrent.CompletableFuture;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FakeApiServer extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FakeApiServer.class);\n+\n+  private final HttpServerOptions httpServerOptions;\n+\n+  private HttpServer httpServer;\n+  private volatile int port;\n+\n+  private HttpMethod httpMethod;\n+  private String path;\n+  private Buffer body;\n+  private MultiMap headers;\n+\n+  private Object responseObject;\n+  private Buffer responseBuffer;\n+  private volatile CompletableFuture<Buffer> bodyFuture;\n+  private boolean connectionClosed;\n+  private int errorCode = -1;\n+\n+  public FakeApiServer(final HttpServerOptions httpServerOptions) {\n+    this.httpServerOptions = httpServerOptions;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(FakeApiServer::unhandledExceptionHandler);\n+    httpServer.listen(ar -> {\n+      if (ar.succeeded()) {\n+        port = ar.result().actualPort();\n+        startPromise.complete();\n+      } else {\n+        startPromise.fail(ar.cause());\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    final Router router = Router.router(vertx);\n+    router.route()\n+        .handler(BodyHandler.create())\n+        .handler(this::handleRequest);\n+    return router;\n+  }\n+\n+  private static void unhandledExceptionHandler(Throwable t) {\n+    t.printStackTrace();\n+  }\n+\n+  private synchronized void handleRequest(final RoutingContext routingContext) {\n+    HttpServerRequest request = routingContext.request();\n+    request.connection().closeHandler(v -> connectionClosed());\n+\n+    httpMethod = request.method();\n+    path = request.path();\n+    headers = request.headers();\n+    body = routingContext.getBody();\n+    if (bodyFuture != null) {\n+      bodyFuture.complete(body);\n+    }\n+    if (errorCode != -1) {\n+      request.response().setStatusCode(errorCode);\n+    }\n+    if (responseBuffer != null) {\n+      request.response().end(responseBuffer);\n+    } else if (responseObject != null) {\n+      request.response().end(KsqlClientUtil.serialize(responseObject));\n+    } else {\n+      request.response().end();\n+    }\n+  }\n+\n+  public synchronized HttpMethod getHttpMethod() {\n+    return httpMethod;\n+  }\n+\n+  public synchronized String getPath() {\n+    return path;\n+  }\n+\n+  public Buffer waitForRequestBody() throws Exception {\n+    this.bodyFuture = new CompletableFuture<>();\n+    return bodyFuture.get();\n+  }\n+\n+  public synchronized Buffer getBody() {\n+    return body;\n+  }\n+\n+  public synchronized MultiMap getHeaders() {\n+    return headers;\n+  }\n+\n+  public synchronized void setResponseObject(final Object responseBody) {\n+    this.responseObject = responseBody;\n+  }\n+\n+  public synchronized void setResponseBuffer(final Buffer responseBuffer) {\n+    this.responseBuffer = responseBuffer;\n+  }\n+\n+  public int getPort() {\n+    return port;\n+  }\n+\n+  private synchronized void connectionClosed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b614d9c7ded0f00673a543dfac08f78d47fef23b", "author": {"user": {"login": "purplefox", "name": "Tim Fox"}}, "url": "https://github.com/confluentinc/ksql/commit/b614d9c7ded0f00673a543dfac08f78d47fef23b", "committedDate": "2020-02-27T10:40:29Z", "message": "updates after review"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4859, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}