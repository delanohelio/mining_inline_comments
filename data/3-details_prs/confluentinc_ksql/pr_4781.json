{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NDA4Mjk3", "number": 4781, "title": "Partition by prep", "bodyText": "Description\nrefactor: projection expression handling\nPrep for #4749.\nThis commit changes the way the engine resolves '*' in a projection, e.g. SELECT * FROM X;.\nPreviously, the Analyzer was responsible for expanding the * into the set of columns of each source. However, this code was getting complicated and would be much more complicated once the key column can have any name, (#3536). The complexity comes about because the Analyzer would need to determine the presence of joins, group bys, partition bys, etc, which can effect how * is resolved.  This logic duplicates the logic in the LogicalPlanner and PlanNode sub-classes.\nWith this commit sees the logical plan and planner being responsible for resolving any * in the projection. This is achieved by asking the parent of the projection node to resolve the * into the set of columns. Parent node types that do not know how to resolve the *, e.g. FilterNode, forward requests to their parents. In this way, the resolution request ripples up the logical plan until it reaches a DataSourceNode, which can resolve the * into a list of columns. JoinNode knows how forward *, left.* and right.* appropriately.\nPreviously, the list of SelectExpressions was passed down from parent PlanNode to child, allowing some nodes to rewrite the expressions. For example, FlatMapNode would rewrite any expression involving a TableFunction to use the internal names like KSQL_SYNTH_0.\nWith this commit this is no longer necessary. Instead, when building a projection node the planner asks it's parent node to resolve any selects, allowing the parent to perform any rewrite.\nAt the moment, the planner is still responsible for much of this work. In the future, this logic may move into the plan itself. However, such a change would increase the complexity of this commit.\nHow to review.\n\nFirst commit has the bulk of the code changes.\nSecond commit has historical plans.\nThird commit drops the now unused AggregateAnalysis interface.\nFourth commit simplifies ProjectNode.resolveSelectStar and adds unit tests for the changes to the PlanNode subclasses.\n\nThe main code changes are in the first commit.  There's a fair amount of lines changes as this is not a small change. However, at lot of the time its just logic being moved from one place to another.  Specifically, the resolution of * and aggregate analysis is delayed until needed, i.e. we creating the projection or aggregate node.  So worth checking this out.\nAlso, checkout resolveSelect and resolveSelectStar in PlanNode and its sub-classes.\nTesting done\nI've moved tests out of AnalyzerFunctionalTest, QueryAnalyzerFunctionalTest and CodeGenRunnerTest  into JSON based QTT tests, which is the preferred way to test such functionality.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-03-16T17:56:07Z", "url": "https://github.com/confluentinc/ksql/pull/4781", "merged": true, "mergeCommit": {"oid": "5a332a0a87f77a73aa29f3cd9efdd84a64857ced"}, "closed": true, "closedAt": "2020-03-18T13:30:23Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOR47FgH2gAyMzg5NDA4Mjk3OjhkMTdkZGUyNTE0N2IwODQ3NGZjNjYyMjUyYjk1N2Y4MmQwMDdjYjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcO0sdlgH2gAyMzg5NDA4Mjk3OmI4ODc4ZDVhY2Y5ODI1Y2FkNGNhZDQwMmU3NjMwZmYyMjZkMmFhNjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/8d17dde25147b08474fc662252b957f82d007cb5", "committedDate": "2020-03-16T17:51:35Z", "message": "refactor: projection expression handling\n\nPrep for https://github.com/confluentinc/ksql/issues/4749.\n\nThis commit changes the way the engine resolves '*' in a projection, e.g. `SELECT * FROM X;`.\n\nPreviously, the `Analyzer` was responsible for expanding the `*` into the set of columns of each source. However, this code was getting complicated and would be much more complicated once the key column can have any name, (https://github.com/confluentinc/ksql/issues/3536). The complexity comes about because the `Analyzer` would need to determine the presence of joins, group bys, partition bys, etc, which can effect how `*` is resolved.  This logic duplicates the logic in the `LogicalPlanner` and `PlanNode` sub-classes.\n\nWith this commit sees the logical plan and planner being responsible for resolving any `*` in the projection. This is achieved by asking the parent of the projection node to resolve the `*` into the set of columns. Parent node types that do not know how to resolve the `*`, e.g. `FilterNode`, forward requests to their parents. In this way, the resolution request ripples up the logical plan until it reaches a `DataSourceNode`, which can resolve the `*` into a list of columns. `JoinNode` knows how forward `*`, `left.*` and `right.*` appropriately.\n\nPreviously, the list of `SelectExpressions` was passed down from parent `PlanNode` to child, allowing some nodes to rewrite the expressions. For example, `FlatMapNode` would rewrite any expression involving a TableFunction to use the internal names like `KSQL_SYNTH_0`.\n\nWith this commit this is no longer necessary. Instead, when building a projection node the planner asks it's parent node to resolve any selects, allowing the parent to perform any rewrite.\n\nAt the moment, the planner is still responsible for much of this work. In the future, this logic may move into the plan itself. However, such a change would increase the complexity of this commit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/b53fba882cbbb226a66081cbf258c1813fad81bb", "committedDate": "2020-03-16T17:52:03Z", "message": "chore: historic plans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDU2NjEx", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375456611", "createdAt": "2020-03-16T17:57:30Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1NzozMFrOF2_rVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1NzozMFrOF2_rVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMDcxMA==", "bodyText": "Basically moved from QueryAnalyzer.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393210710", "createdAt": "2020-03-16T17:57:30Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -15,47 +15,74 @@\n \n package io.confluent.ksql.analyzer;\n \n+import static java.util.Objects.requireNonNull;\n+\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Sets.SetView;\n import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.execution.expression.tree.FunctionCall;\n import io.confluent.ksql.execution.expression.tree.QualifiedColumnReferenceExp;\n import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n import io.confluent.ksql.function.FunctionRegistry;\n import io.confluent.ksql.name.FunctionName;\n import io.confluent.ksql.util.KsqlException;\n import io.confluent.ksql.util.SchemaUtil;\n import java.util.HashSet;\n-import java.util.Objects;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n \n-class AggregateAnalyzer {\n+public class AggregateAnalyzer {\n \n-  private final MutableAggregateAnalysis aggregateAnalysis;\n-  private final QualifiedColumnReferenceExp defaultArgument;\n   private final FunctionRegistry functionRegistry;\n-  private final boolean hasWindowExpression;\n \n-  AggregateAnalyzer(\n-      final MutableAggregateAnalysis aggregateAnalysis,\n-      final QualifiedColumnReferenceExp defaultArgument,\n-      final boolean hasWindowExpression,\n+  public AggregateAnalyzer(\n       final FunctionRegistry functionRegistry\n   ) {\n-    this.aggregateAnalysis = Objects.requireNonNull(aggregateAnalysis, \"aggregateAnalysis\");\n-    this.defaultArgument = Objects.requireNonNull(defaultArgument, \"defaultArgument\");\n-    this.functionRegistry = Objects.requireNonNull(functionRegistry, \"functionRegistry\");\n-    this.hasWindowExpression = hasWindowExpression;\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n   }\n \n-  void processSelect(final Expression expression) {\n+  public AggregateAnalysisResult analyze(\n+      final ImmutableAnalysis analysis,\n+      final List<SelectExpression> finalProjection\n+  ) {\n+    if (analysis.getGroupByExpressions().isEmpty()) {\n+      throw new IllegalArgumentException(\"Not an aggregate query\");\n+    }\n+\n+    final Context context = new Context(analysis);\n+\n+    finalProjection.stream()\n+        .map(SelectExpression::getExpression)\n+        .forEach(exp -> processSelect(exp, context));\n+\n+    analysis.getWhereExpression()\n+        .ifPresent(exp -> processWhere(exp, context));\n+\n+    analysis.getGroupByExpressions()\n+        .forEach(exp -> processGroupBy(exp, context));\n+\n+    analysis.getHavingExpression()\n+        .ifPresent(exp -> processHaving(exp, context));\n+\n+    enforceAggregateRules(context);\n+\n+    return context.aggregateAnalysis;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDU3NDIz", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375457423", "createdAt": "2020-03-16T17:58:00Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowMVrOF2_sdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowMVrOF2_sdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMDk5OA==", "bodyText": "Moved from QueryAnalyzer", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393210998", "createdAt": "2020-03-16T17:58:01Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -117,18 +150,91 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(final ColumnReferenceEx\n     }\n   }\n \n+  private static void enforceAggregateRules(\n+      final Context context\n+  ) {\n+    if (context.aggregateAnalysis.getAggregateFunctions().isEmpty()) {\n+      throw new KsqlException(\n+          \"GROUP BY requires columns using aggregate functions in SELECT clause.\");\n+    }\n+\n+    final Set<Expression> groupByExprs = getGroupByExpressions(context.analysis);\n+\n+    final List<String> unmatchedSelects = context.aggregateAnalysis\n+        .getNonAggregateSelectExpressions()\n+        .entrySet()\n+        .stream()\n+        // Remove any that exactly match a group by expression:\n+        .filter(e -> !groupByExprs.contains(e.getKey()))\n+        // Remove any that are constants,\n+        // or expressions where all params exactly match a group by expression:\n+        .filter(e -> !Sets.difference(e.getValue(), groupByExprs).isEmpty())\n+        .map(Map.Entry::getKey)\n+        .map(Expression::toString)\n+        .sorted()\n+        .collect(Collectors.toList());\n+\n+    if (!unmatchedSelects.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate SELECT expression(s) not part of GROUP BY: \" + unmatchedSelects);\n+    }\n+\n+    final SetView<ColumnReferenceExp> unmatchedSelectsAgg = Sets\n+        .difference(context.aggregateAnalysis.getAggregateSelectFields(), groupByExprs);\n+    if (!unmatchedSelectsAgg.isEmpty()) {\n+      throw new KsqlException(\n+          \"Column used in aggregate SELECT expression(s) \"\n+              + \"outside of aggregate functions not part of GROUP BY: \" + unmatchedSelectsAgg);\n+    }\n+\n+    final Set<ColumnReferenceExp> havingColumns = context.aggregateAnalysis\n+        .getNonAggregateHavingFields().stream()\n+        .map(ref -> new UnqualifiedColumnReferenceExp(ref.getColumnName()))\n+        .collect(Collectors.toSet());\n+\n+    final Set<ColumnReferenceExp> havingOnly = Sets.difference(havingColumns, groupByExprs);\n+    if (!havingOnly.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate HAVING expression not part of GROUP BY: \" + havingOnly);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDU3NTgx", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375457581", "createdAt": "2020-03-16T17:58:07Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowN1rOF2_ssg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowN1rOF2_ssg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMTA1OA==", "bodyText": "Moved from QueryAnalyzer", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393211058", "createdAt": "2020-03-16T17:58:07Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -117,18 +150,91 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(final ColumnReferenceEx\n     }\n   }\n \n+  private static void enforceAggregateRules(\n+      final Context context\n+  ) {\n+    if (context.aggregateAnalysis.getAggregateFunctions().isEmpty()) {\n+      throw new KsqlException(\n+          \"GROUP BY requires columns using aggregate functions in SELECT clause.\");\n+    }\n+\n+    final Set<Expression> groupByExprs = getGroupByExpressions(context.analysis);\n+\n+    final List<String> unmatchedSelects = context.aggregateAnalysis\n+        .getNonAggregateSelectExpressions()\n+        .entrySet()\n+        .stream()\n+        // Remove any that exactly match a group by expression:\n+        .filter(e -> !groupByExprs.contains(e.getKey()))\n+        // Remove any that are constants,\n+        // or expressions where all params exactly match a group by expression:\n+        .filter(e -> !Sets.difference(e.getValue(), groupByExprs).isEmpty())\n+        .map(Map.Entry::getKey)\n+        .map(Expression::toString)\n+        .sorted()\n+        .collect(Collectors.toList());\n+\n+    if (!unmatchedSelects.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate SELECT expression(s) not part of GROUP BY: \" + unmatchedSelects);\n+    }\n+\n+    final SetView<ColumnReferenceExp> unmatchedSelectsAgg = Sets\n+        .difference(context.aggregateAnalysis.getAggregateSelectFields(), groupByExprs);\n+    if (!unmatchedSelectsAgg.isEmpty()) {\n+      throw new KsqlException(\n+          \"Column used in aggregate SELECT expression(s) \"\n+              + \"outside of aggregate functions not part of GROUP BY: \" + unmatchedSelectsAgg);\n+    }\n+\n+    final Set<ColumnReferenceExp> havingColumns = context.aggregateAnalysis\n+        .getNonAggregateHavingFields().stream()\n+        .map(ref -> new UnqualifiedColumnReferenceExp(ref.getColumnName()))\n+        .collect(Collectors.toSet());\n+\n+    final Set<ColumnReferenceExp> havingOnly = Sets.difference(havingColumns, groupByExprs);\n+    if (!havingOnly.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate HAVING expression not part of GROUP BY: \" + havingOnly);\n+    }\n+  }\n+\n+  private static Set<Expression> getGroupByExpressions(\n+      final ImmutableAnalysis analysis\n+  ) {\n+    if (!analysis.getWindowExpression().isPresent()) {\n+      return ImmutableSet.copyOf(analysis.getGroupByExpressions());\n+    }\n+\n+    // Add in window bounds columns as implicit group by columns:\n+    final Set<UnqualifiedColumnReferenceExp> windowBoundColumnRefs =\n+        SchemaUtil.windowBoundsColumnNames().stream()\n+            .map(UnqualifiedColumnReferenceExp::new)\n+            .collect(Collectors.toSet());\n+\n+    return ImmutableSet.<Expression>builder()\n+        .addAll(analysis.getGroupByExpressions())\n+        .addAll(windowBoundColumnRefs)\n+        .build();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDU5Mzg3", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375459387", "createdAt": "2020-03-16T17:59:10Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1OToxMVrOF2_vHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1OToxMVrOF2_vHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMTY3OA==", "bodyText": "Previously, we captured the resolved select items - now we just capture the unresolved SelectItem", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393211678", "createdAt": "2020-03-16T17:59:11Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analysis.java", "diffHunk": "@@ -89,8 +88,8 @@ ResultMaterialization getResultMaterialization() {\n     return resultMaterialization;\n   }\n \n-  void addSelectItem(final Expression expression, final ColumnName alias) {\n-    selectExpressions.add(SelectExpression.of(alias, expression));\n+  void addSelectItem(final SelectItem selectItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDYxOTY3", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375461967", "createdAt": "2020-03-16T18:00:47Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowMDo0N1rOF2_yuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowMDo0N1rOF2_yuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMjYwMQ==", "bodyText": "To set the serde options we need to know the number of columns, which requires any * to be resolved. Hence this code has now moved to later LogicalPlanner once any * has been resolved.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393212601", "createdAt": "2020-03-16T18:00:47Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -243,27 +218,6 @@ private KeyFormat buildKeyFormat() {\n               .getKeyFormat());\n     }\n \n-    private void setSerdeOptions(final Sink sink) {\n-      final List<ColumnName> columnNames = getColumnNames();\n-\n-      final Format valueFormat = getValueFormat(sink);\n-\n-      final Set<SerdeOption> serdeOptions = serdeOptionsSupplier.build(\n-          columnNames,\n-          valueFormat,\n-          sink.getProperties().getWrapSingleValues(),\n-          defaultSerdeOptions\n-      );\n-\n-      analysis.setSerdeOptions(serdeOptions);\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d5efaafebab990b6a6578d0367150543d090c88", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/0d5efaafebab990b6a6578d0367150543d090c88", "committedDate": "2020-03-16T18:02:58Z", "message": "chore: drop AggregateAnalysis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDY0Mzc4", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375464378", "createdAt": "2020-03-16T18:04:09Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNDoxMFrOF2_9HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNDoxMFrOF2_9HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA==", "bodyText": "Analysis of aggregates is now delayed until the creation of an AggregateNode in the LogicalPlanner.  This is necessary as this code needs any *s to have been resolved.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393215260", "createdAt": "2020-03-16T18:04:10Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "diffHunk": "@@ -97,177 +78,4 @@ public Analysis analyze(\n \n     return analysis;\n   }\n-\n-  public AggregateAnalysis analyzeAggregate(final Query query, final Analysis analysis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDY1MTgz", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375465183", "createdAt": "2020-03-16T18:05:20Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNToyMFrOF3AAtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNToyMFrOF3AAtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNjE4MQ==", "bodyText": "Moved from Analyzer", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393216181", "createdAt": "2020-03-16T18:05:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/DataSourceNode.java", "diffHunk": "@@ -124,6 +140,21 @@ private static LogicalSchema buildSchema(final DataSource dataSource) {\n         .withMetaAndKeyColsInValue(dataSource.getKsqlTopic().getKeyFormat().isWindowed());\n   }\n \n+  private static Stream<ColumnName> orderColumns(\n+      final List<Column> columns,\n+      final LogicalSchema schema\n+  ) {\n+    // When doing a `select *` system and key columns should be at the front of the column list\n+    // but are added at the back during processing for performance reasons.\n+    // Switch them around here:\n+    final Map<Boolean, List<Column>> partitioned = columns.stream().collect(Collectors\n+        .groupingBy(c -> SchemaUtil.isSystemColumn(c.name()) || schema.isKeyColumn(c.name())));\n+\n+    final List<Column> all = partitioned.get(true);\n+    all.addAll(partitioned.get(false));\n+    return all.stream().map(Column::name);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDY5Mzk4", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375469398", "createdAt": "2020-03-16T18:11:29Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxMToyOVrOF3ATww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxMToyOVrOF3ATww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMTA1OQ==", "bodyText": "Found a bug in here when moving tests to QTT:  Comparisons to the NULL type result in SqlType of null, which caused an NPE in this method!\nUnfortunately, fixing it caused the complexity of this method to go over the checkstyle rule, so had to refactor.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393221059", "createdAt": "2020-03-16T18:11:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -15,38 +15,104 @@\n \n package io.confluent.ksql.execution.util;\n \n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableList;\n import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n import io.confluent.ksql.schema.ksql.types.SqlType;\n import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n \n final class ComparisonUtil {\n \n-  private ComparisonUtil() {\n+  private static final List<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(handler(SqlBaseType::isNumber, ComparisonUtil::handleNumber))\n+      .add(handler(SqlBaseType.STRING, ComparisonUtil::handleString))\n+      .add(handler(SqlBaseType.BOOLEAN, ComparisonUtil::handleBoolean))\n+      .build();\n \n+  private ComparisonUtil() {\n   }\n \n-  static boolean isValidComparison(\n+  static void isValidComparison(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDcxNzgy", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-375471782", "createdAt": "2020-03-16T18:14:49Z", "commit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxNDo0OVrOF3AbGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxNDo0OVrOF3AbGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMjkzOQ==", "bodyText": "This actually means KSQL rejects any pull query that uses a mix of * and explicit column names in a pull query. Previously, depending on the order, the explicit columns were ignored or a weird error was returned.  At least now a meaningful error is returned.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393222939", "createdAt": "2020-03-16T18:14:49Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -757,8 +763,15 @@ private static ComparisonTarget extractWhereClauseTarget(\n   }\n \n   private static boolean isSelectStar(final Select select) {\n-    final List<SelectItem> selects = select.getSelectItems();\n-    return selects.size() == 1 && selects.get(0) instanceof AllColumns;\n+    final boolean someStars = select.getSelectItems().stream()\n+        .anyMatch(s -> s instanceof AllColumns);\n+\n+    if (someStars && select.getSelectItems().size() != 1) {\n+      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n+          + \"if they are the only expression\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9566e591bd1d4e982c124e2780ac1ea50a9ed507", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/9566e591bd1d4e982c124e2780ac1ea50a9ed507", "committedDate": "2020-03-17T11:08:22Z", "message": "chore: simplify ProjectNode.resolveSelectStar + unit tests plan nodes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDQyNzM2", "url": "https://github.com/confluentinc/ksql/pull/4781#pullrequestreview-376442736", "createdAt": "2020-03-17T22:15:12Z", "commit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMjoxNToxMlrOF3v8Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMjo0NjoxMFrOF3wt5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMTQ3MQ==", "bodyText": "Moving the analysis out of the analyzer seems less than ideal... I'm trying to wrap my head around what * means in the context of an aggregation. other than COUNT(*) and other aggregate functions that have the * as the argument - how can you even use * in an aggregate? If it doesn't make sense outside of function calls, can we leverage that to keep the analysis in the analyzer?", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394001471", "createdAt": "2020-03-17T22:15:12Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "diffHunk": "@@ -97,177 +78,4 @@ public Analysis analyze(\n \n     return analysis;\n   }\n-\n-  public AggregateAnalysis analyzeAggregate(final Query query, final Analysis analysis) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA=="}, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjA0Nw==", "bodyText": "at what point do we change the names of the columns to prepend <SOURCE>_ and does it make sense to do it here instead? e.g.\nksql> CREATE STREAM s (id VARCHAR, val VARCHAR) WITH (kafka_topic='s', value_format='json', partitions=1);\nksql> CREATE TABLE t (id VARCHAR, val VARCHAR) with (kafka_topic='t', value_format='json', partitions=1, key='id');\nksql> CREATE STREAM j AS SELECT * FROM s LEFT JOIN t ON s.id = t.id;\nksql> SELECT * FROM J EMIT CHANGES;\n+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+\n|ROWTIME|ROWKEY |S_ROWTI|S_ROWKE|S_ID   |S_VAL  |T_ROWTI|T_ROWKE|T_ID   |T_VAL  |\n|       |       |ME     |Y      |       |       |ME     |Y      |       |       |\n+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394012047", "createdAt": "2020-03-17T22:40:07Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -111,6 +112,15 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @Override\n+  public Stream<ColumnName> resolveSelectStar(\n+      final Optional<SourceName> sourceName, final boolean valueOnly\n+  ) {\n+    return getSources().stream()\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjQ5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Expression resolveSelect(final int idx, final Expression expression) {\n          \n          \n            \n              @Override\n          \n          \n            \n              public Expression resolveSelect(final int idx, final Expression expression) {", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394012497", "createdAt": "2020-03-17T22:41:22Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FlatMapNode.java", "diffHunk": "@@ -90,6 +94,10 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return source.getPartitions(kafkaTopicClient);\n   }\n \n+  public Expression resolveSelect(final int idx, final Expression expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNDE4Mg==", "bodyText": "this comment is a little confusing to me - where are we taking only the value columns?", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394014182", "createdAt": "2020-03-17T22:46:10Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -223,6 +262,46 @@ private ProjectNode buildProjectNode(\n     );\n   }\n \n+  private List<SelectExpression> buildSelectExpressions(final PlanNode parentNode) {\n+    return IntStream.range(0, analysis.getSelectItems().size())\n+        .boxed()\n+        .flatMap(idx -> resolveSelectItem(idx, parentNode))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private Stream<SelectExpression> resolveSelectItem(\n+      final int idx,\n+      final PlanNode parentNode\n+  ) {\n+    final SelectItem selectItem = analysis.getSelectItems().get(idx);\n+\n+    if (selectItem instanceof SingleColumn) {\n+      final SingleColumn column = (SingleColumn) selectItem;\n+      final Expression expression = parentNode.resolveSelect(idx, column.getExpression());\n+      final ColumnName alias = column.getAlias()\n+          .orElseThrow(() -> new IllegalStateException(\"Alias should be present by this point\"));\n+\n+      return Stream.of(SelectExpression.of(alias, expression));\n+    }\n+\n+    if (selectItem instanceof AllColumns) {\n+      final AllColumns allColumns = (AllColumns) selectItem;\n+\n+      final Stream<ColumnName> columns = parentNode\n+          .resolveSelectStar(allColumns.getSource(), analysis.getInto().isPresent());\n+\n+      // Only need to take value columns as value schema includes key schema by this point", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc3ab547f45de923d387e87cfae80bfc7f8760f4", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/cc3ab547f45de923d387e87cfae80bfc7f8760f4", "committedDate": "2020-03-18T10:19:54Z", "message": "chore: changes requested by Almog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "053e1de133f4880dcd9dd65714f9becd8a564bad", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/053e1de133f4880dcd9dd65714f9becd8a564bad", "committedDate": "2020-03-18T10:21:30Z", "message": "chore: merge from master\n\nConflicting files\nksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8878d5acf9825cad4cad402e7630ff226d2aa63", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/b8878d5acf9825cad4cad402e7630ff226d2aa63", "committedDate": "2020-03-18T10:24:39Z", "message": "chore: remove historic plans for unreleased feature"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 19, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}