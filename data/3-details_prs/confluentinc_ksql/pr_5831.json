{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NTQxMzQx", "number": 5831, "title": "feat: Replay command topic to local file to backup KSQL Metastore", "bodyText": "Description\nImplements KLIP-31: Metastore Backups - #5741\nAdd a metastore backup service that replays the command_topic to a local file. This local file will be useful to users who desire to restore their command_topic in case of accidental topic disasters.\nTwo new configs are added to enable backups (see KsqlConfig):\n\nksql.enable.metastore.backup to enable the metastore backup\nksql.metastore.backup.location to specify the location of the backup\n\nTwo new classes are created:\n\nCommandTopicBackup\nBackupReplayFile\n\nThe CommandTopicBackup is the service used to backup command topic records through the writeRecord method. It is called by the CommandTopic class on each record read by the Kafka consumer (see getRestoreCommands and getNewCommands from the CommandTopic). The CommandTopicBackup class creates a new backup file (if none exists) or opens a current backup file used in a previous ksqlDB restart to update it with only new commands. It may also create a new backup file in case the record to write does not match the previous ksqlDB replayed records. This is how it handles command_topic deletion accidents.\nThe BackupReplayFile is used to read/write records to a local file, and used by the CommandTopicBackup. Each record is serialized/deserialized using the JSON serde, which is the same used by the command_topic. The record written to the file contains only the CommandId (key) and Command (value) separated by a colon. This formatted data in the file allows users to easily restore their command_topic by executing the following Kafka command:\n$ kafka-console-producer --broker-list localhost:9092 --topic $COMMAND_TOPIC --property \"parse.key=true\" --property \"key.separator=:\" < $BACKUP_FILE\n\nOther classes modified are:\n\nCommandTopic. Calls the CommandTopicBackup on each record read by the command topic consumer.\nCommandStore. Creates the CommandTopicBackup if enabled, and passes it to the CommandTopic class.\n\nTesting done\n\nAdded unit tests on the new and modified classes\nVerified manually by execution the following scenarios:\n\nCreate 1 stream, stop ksqlDB, delete/restore the command topic, start ksqlDB, run show streams [OK]\nCreate 1 stream, stop ksqlDB, delete the backup file, start ksqlDB, check the backup file is created again [OK]\nCreate 2 streams, stop ksqlDB, delete 2nd stream from backup, start ksqlDB, check only 2nd stream is added back [OK]\nCreate 2 streams, stop ksqlDB, delete 1st stream from backup, start ksqlDB, check a new backup is created [OK]\n\n\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-07-15T15:02:18Z", "url": "https://github.com/confluentinc/ksql/pull/5831", "merged": true, "mergeCommit": {"oid": "852305129e596cd04fdaf0d2e503b43953646b50"}, "closed": true, "closedAt": "2020-07-16T21:01:38Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1NJafgBqjM1NDkyNjE4Mzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1ldx6gFqTQ1MDE5NjUyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f50971fcbb656ffceaa7a3891922cd3bbab9ebf", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/0f50971fcbb656ffceaa7a3891922cd3bbab9ebf", "committedDate": "2020-07-15T14:27:02Z", "message": "feat: metastore backups"}, "afterCommit": {"oid": "8e1da4df3b5e3b1df802ded577d7d9774da98412", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/8e1da4df3b5e3b1df802ded577d7d9774da98412", "committedDate": "2020-07-15T15:15:10Z", "message": "feat: metastore backups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e1da4df3b5e3b1df802ded577d7d9774da98412", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/8e1da4df3b5e3b1df802ded577d7d9774da98412", "committedDate": "2020-07-15T15:15:10Z", "message": "feat: metastore backups"}, "afterCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/8c8b54c857d38e8c304b5e7c6415063ecfe60c12", "committedDate": "2020-07-15T17:45:32Z", "message": "feat: metastore backups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDE4ODkz", "url": "https://github.com/confluentinc/ksql/pull/5831#pullrequestreview-449418893", "createdAt": "2020-07-15T23:54:35Z", "commit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMzo1NDozNVrOGyVRPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDo0MzozN1rOGyWILA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMDQ2MA==", "bodyText": "can we test what happens if the command itself has a newline in it (or is it possible for the commandId to have the KEY_VALUE_SEPARATOR in it - I don't think so)? I know it will make it harder to replay the file, but it might make it safer if we have an encoding: commandIdSize (4 bytes) | commandSize (4 byte) | commandId | Command\nanother (perhaps better) option is that because we know that the CommandID and the Command are valid JSON, we can just read one valid JSON then the next (see https://stackoverflow.com/a/37395419/2258040) and we don't even have to worry about newlines (which we can add anyway to make it easier for humans to read)\nI might be too paranoid, let me know if you don't think this is a problem.", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455430460", "createdAt": "2020-07-15T23:54:35Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.confluent.ksql.execution.json.PlanJsonMapper;\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.Pair;\n+\n+import java.io.BufferedWriter;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A file that is used by the backup service to replay command_topic commands.\n+ */\n+public class BackupReplayFile implements Closeable {\n+  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get();\n+  private static final String KEY_VALUE_SEPARATOR = \":\";\n+\n+  private final File file;\n+  private final BufferedWriter writer;\n+\n+  public BackupReplayFile(final File file) {\n+    this.file = Objects.requireNonNull(file, \"file\");\n+    this.writer = createWriter(file);\n+  }\n+\n+  private static BufferedWriter createWriter(final File file) {\n+    try {\n+      return new BufferedWriter(new OutputStreamWriter(\n+          new FileOutputStream(file, true),\n+          StandardCharsets.UTF_8)\n+      );\n+    } catch (final FileNotFoundException e) {\n+      throw new KsqlException(\n+          String.format(\"Failed to create replay file: %s\", file.getAbsolutePath()), e);\n+    }\n+  }\n+\n+  public String getPath() {\n+    return file.getAbsolutePath();\n+  }\n+\n+  public void write(final CommandId commandId, final Command command) throws IOException {\n+    writer.write(MAPPER.writeValueAsString(commandId));\n+    writer.write(KEY_VALUE_SEPARATOR);\n+    writer.write(MAPPER.writeValueAsString(command));\n+    writer.write(\"\\n\");\n+    writer.flush();\n+  }\n+\n+  public void write(final List<Pair<CommandId, Command>> records) throws IOException {\n+    for (final Pair<CommandId, Command> record : records) {\n+      write(record.left, record.right);\n+    }\n+  }\n+\n+  public List<Pair<CommandId, Command>> readRecords() throws IOException {\n+    final List<Pair<CommandId, Command>> commands = new ArrayList<>();\n+    for (final String line : Files.readAllLines(file.toPath(), StandardCharsets.UTF_8)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMTcwNA==", "bodyText": "nit (my preference, feel free to reject): might make the code a little cleaner if instead of an Optional we made CommandTopicBackup an interface and passed in a no-op implementation - that we way don't have ifPresent everywhere", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455431704", "createdAt": "2020-07-15T23:58:37Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopic.java", "diffHunk": "@@ -41,40 +41,52 @@\n \n   private Consumer<CommandId, Command> commandConsumer = null;\n   private final String commandTopicName;\n+  private Optional<CommandTopicBackup> commandTopicBackup;\n \n   public CommandTopic(\n       final String commandTopicName,\n-      final Map<String, Object> kafkaConsumerProperties\n+      final Map<String, Object> kafkaConsumerProperties,\n+      final Optional<CommandTopicBackup> commandTopicBackup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzNzU1MQ==", "bodyText": "another code style thing which might make this a little easier to read:\nFile latestFile = Arrays.stream(files).max(Comparator.comparing(CommandTopicBackup::extractTimestamp));", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455437551", "createdAt": "2020-07-16T00:17:56Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackup.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Ticker;\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.Pair;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Backup service that replays the KSQL command_topic to a local file. A new backup file is\n+ * created whenever a new command does not match the actual backup file. Previously replayed\n+ * messages read up to this new command will be written to the new file. This ensures a new\n+ * complete backup of the command_topic is created.\n+ */\n+public class CommandTopicBackup {\n+  private static final Logger LOG = LoggerFactory.getLogger(CommandTopicBackup.class);\n+  private static final Ticker CURRENT_MILLIS_TICKER = new Ticker() {\n+    @Override\n+    public long read() {\n+      return System.currentTimeMillis();\n+    }\n+  };\n+  private static final String PREFIX = \"backup_\";\n+\n+  private final File backupLocation;\n+  private final String topicName;\n+  private final Ticker ticker;\n+\n+  private BackupReplayFile replayFile;\n+  private List<Pair<CommandId, Command>> latestReplay;\n+  private int latestReplayIdx;\n+\n+  public CommandTopicBackup(final String location, final String topicName) {\n+    this(location, topicName, CURRENT_MILLIS_TICKER);\n+  }\n+\n+  public CommandTopicBackup(final String location, final String topicName, final Ticker ticker) {\n+    final File dir = new File(Objects.requireNonNull(location, \"location\"));\n+    if (!dir.exists() || !dir.isDirectory()) {\n+      throw new KsqlException(String.format(\n+          \"Backup location '%s' does not exist or it is not a directory.\", location));\n+    }\n+\n+    this.backupLocation = dir;\n+    this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    this.ticker = Objects.requireNonNull(ticker, \"ticker\");\n+  }\n+\n+  public void initialize() {\n+    replayFile = openOrCreateReplayFile();\n+\n+    try {\n+      latestReplay = replayFile.readRecords();\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed to read the latest backup from {}. Continue with a new file. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+\n+      replayFile = newReplayFile();\n+      latestReplay = Collections.emptyList();\n+    }\n+\n+    latestReplayIdx = 0;\n+    LOG.info(\"Command topic will be backup on file: {}\", replayFile.getPath());\n+  }\n+\n+  public void close() {\n+    try {\n+      replayFile.close();\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed closing the backup file {}. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  BackupReplayFile getReplayFile() {\n+    return replayFile;\n+  }\n+\n+  public void writeRecord(final ConsumerRecord<CommandId, Command> record) {\n+    if (latestReplayIdx < latestReplay.size()) {\n+      final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);\n+      if (record.key().equals(latestReplayRecord.left)\n+          && record.value().equals(latestReplayRecord.right)) {\n+        // Ignore backup because record was already replayed\n+        latestReplayIdx++;\n+        return;\n+      } else {\n+        LOG.info(\"Previous command topic backup does not match the new command topic data. \"\n+            + \"A new backup file will be created.\");\n+        createNewBackupFile();\n+        LOG.info(\"New backup file created: {}\", replayFile.getPath());\n+      }\n+    } else if (latestReplayIdx > 0) {\n+      // clear latest replay from memory\n+      latestReplay.clear();\n+      latestReplayIdx = 0;\n+    }\n+\n+    try {\n+      replayFile.write(record.key(), record.value());\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed to write to file {}. The command topic backup is not complete. \"\n+              + \"Make sure the file exists and has permissions to write. KSQL must be restarted \"\n+              + \"afterwards to complete the backup process. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+    }\n+  }\n+\n+  private void createNewBackupFile() {\n+    try {\n+      replayFile.close();\n+    } catch (IOException e) {\n+      LOG.warn(\"Couldn't close the current backup file {}. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+    }\n+\n+    replayFile = newReplayFile();\n+\n+    if (latestReplay.size() > 0 && latestReplayIdx > 0) {\n+      try {\n+        replayFile.write(latestReplay.subList(0, latestReplayIdx));\n+      } catch (final IOException e) {\n+        LOG.warn(\"Couldn't write the latest replayed commands to the new backup file {}. \"\n+                + \"Make sure the file exists and has permissions to write. \"\n+                + \"KSQL must be restarted afterwards to complete the backup process. Error = {}\",\n+            replayFile.getPath(), e.getMessage());\n+      }\n+    }\n+\n+    // clear latest replay from memory\n+    latestReplay.clear();\n+    latestReplayIdx = 0;\n+  }\n+\n+  @VisibleForTesting\n+  BackupReplayFile openOrCreateReplayFile() {\n+    final Optional<BackupReplayFile> latestFile = latestReplayFile();\n+    if (latestFile.isPresent()) {\n+      return latestFile.get();\n+    }\n+\n+    return newReplayFile();\n+  }\n+\n+  private BackupReplayFile newReplayFile() {\n+    return new BackupReplayFile(Paths.get(\n+        backupLocation.getAbsolutePath(),\n+        String.format(\"%s%s_%s\", PREFIX, topicName, ticker.read())\n+    ).toFile());\n+  }\n+\n+  private Optional<BackupReplayFile> latestReplayFile() {\n+    final String prefixFilename = String.format(\"%s%s_\", PREFIX, topicName);\n+    final File[] files = backupLocation.listFiles(\n+        (f, name) -> name.toLowerCase().startsWith(prefixFilename));\n+\n+    File latestBakFile = null;\n+    if (files != null) {\n+      long latestTs = 0;\n+      for (int i = 0; i < files.length; i++) {\n+        final File bakFile = files[i];\n+        final String bakTimestamp = bakFile.getName().substring(prefixFilename.length());\n+\n+        try {\n+          final Long ts = Long.valueOf(bakTimestamp);\n+          if (ts > latestTs) {\n+            latestTs = ts;\n+            latestBakFile = bakFile;\n+          }\n+        } catch (final NumberFormatException e) {\n+          LOG.warn(\n+              \"Invalid timestamp '{}' found in backup replay file (file ignored): {}\",\n+              bakTimestamp, bakFile.getName());\n+          continue;\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0MTA1Mw==", "bodyText": "while the logic here is correct, it took me a while to understand what it was doing - it might make this code easier to read if you had a method isRestoring() and then separated the restore logic into a checkIfRecordInLatestReplay method", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455441053", "createdAt": "2020-07-16T00:30:18Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackup.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Ticker;\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.Pair;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Backup service that replays the KSQL command_topic to a local file. A new backup file is\n+ * created whenever a new command does not match the actual backup file. Previously replayed\n+ * messages read up to this new command will be written to the new file. This ensures a new\n+ * complete backup of the command_topic is created.\n+ */\n+public class CommandTopicBackup {\n+  private static final Logger LOG = LoggerFactory.getLogger(CommandTopicBackup.class);\n+  private static final Ticker CURRENT_MILLIS_TICKER = new Ticker() {\n+    @Override\n+    public long read() {\n+      return System.currentTimeMillis();\n+    }\n+  };\n+  private static final String PREFIX = \"backup_\";\n+\n+  private final File backupLocation;\n+  private final String topicName;\n+  private final Ticker ticker;\n+\n+  private BackupReplayFile replayFile;\n+  private List<Pair<CommandId, Command>> latestReplay;\n+  private int latestReplayIdx;\n+\n+  public CommandTopicBackup(final String location, final String topicName) {\n+    this(location, topicName, CURRENT_MILLIS_TICKER);\n+  }\n+\n+  public CommandTopicBackup(final String location, final String topicName, final Ticker ticker) {\n+    final File dir = new File(Objects.requireNonNull(location, \"location\"));\n+    if (!dir.exists() || !dir.isDirectory()) {\n+      throw new KsqlException(String.format(\n+          \"Backup location '%s' does not exist or it is not a directory.\", location));\n+    }\n+\n+    this.backupLocation = dir;\n+    this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    this.ticker = Objects.requireNonNull(ticker, \"ticker\");\n+  }\n+\n+  public void initialize() {\n+    replayFile = openOrCreateReplayFile();\n+\n+    try {\n+      latestReplay = replayFile.readRecords();\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed to read the latest backup from {}. Continue with a new file. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+\n+      replayFile = newReplayFile();\n+      latestReplay = Collections.emptyList();\n+    }\n+\n+    latestReplayIdx = 0;\n+    LOG.info(\"Command topic will be backup on file: {}\", replayFile.getPath());\n+  }\n+\n+  public void close() {\n+    try {\n+      replayFile.close();\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed closing the backup file {}. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  BackupReplayFile getReplayFile() {\n+    return replayFile;\n+  }\n+\n+  public void writeRecord(final ConsumerRecord<CommandId, Command> record) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0MTcwNQ==", "bodyText": "Collections.emptyList will throw an exception if clear gets called on it. While I don't think it's possible for this situation to be hit because latestReplayIdx should never be greater than latestReplay.size() we might want to change this to latestReaply.size() > 0 instead", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455441705", "createdAt": "2020-07-16T00:32:33Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackup.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Ticker;\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.Pair;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Backup service that replays the KSQL command_topic to a local file. A new backup file is\n+ * created whenever a new command does not match the actual backup file. Previously replayed\n+ * messages read up to this new command will be written to the new file. This ensures a new\n+ * complete backup of the command_topic is created.\n+ */\n+public class CommandTopicBackup {\n+  private static final Logger LOG = LoggerFactory.getLogger(CommandTopicBackup.class);\n+  private static final Ticker CURRENT_MILLIS_TICKER = new Ticker() {\n+    @Override\n+    public long read() {\n+      return System.currentTimeMillis();\n+    }\n+  };\n+  private static final String PREFIX = \"backup_\";\n+\n+  private final File backupLocation;\n+  private final String topicName;\n+  private final Ticker ticker;\n+\n+  private BackupReplayFile replayFile;\n+  private List<Pair<CommandId, Command>> latestReplay;\n+  private int latestReplayIdx;\n+\n+  public CommandTopicBackup(final String location, final String topicName) {\n+    this(location, topicName, CURRENT_MILLIS_TICKER);\n+  }\n+\n+  public CommandTopicBackup(final String location, final String topicName, final Ticker ticker) {\n+    final File dir = new File(Objects.requireNonNull(location, \"location\"));\n+    if (!dir.exists() || !dir.isDirectory()) {\n+      throw new KsqlException(String.format(\n+          \"Backup location '%s' does not exist or it is not a directory.\", location));\n+    }\n+\n+    this.backupLocation = dir;\n+    this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    this.ticker = Objects.requireNonNull(ticker, \"ticker\");\n+  }\n+\n+  public void initialize() {\n+    replayFile = openOrCreateReplayFile();\n+\n+    try {\n+      latestReplay = replayFile.readRecords();\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed to read the latest backup from {}. Continue with a new file. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+\n+      replayFile = newReplayFile();\n+      latestReplay = Collections.emptyList();\n+    }\n+\n+    latestReplayIdx = 0;\n+    LOG.info(\"Command topic will be backup on file: {}\", replayFile.getPath());\n+  }\n+\n+  public void close() {\n+    try {\n+      replayFile.close();\n+    } catch (final IOException e) {\n+      LOG.warn(\"Failed closing the backup file {}. Error = {}\",\n+          replayFile.getPath(), e.getMessage());\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  BackupReplayFile getReplayFile() {\n+    return replayFile;\n+  }\n+\n+  public void writeRecord(final ConsumerRecord<CommandId, Command> record) {\n+    if (latestReplayIdx < latestReplay.size()) {\n+      final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);\n+      if (record.key().equals(latestReplayRecord.left)\n+          && record.value().equals(latestReplayRecord.right)) {\n+        // Ignore backup because record was already replayed\n+        latestReplayIdx++;\n+        return;\n+      } else {\n+        LOG.info(\"Previous command topic backup does not match the new command topic data. \"\n+            + \"A new backup file will be created.\");\n+        createNewBackupFile();\n+        LOG.info(\"New backup file created: {}\", replayFile.getPath());\n+      }\n+    } else if (latestReplayIdx > 0) {\n+      // clear latest replay from memory\n+      latestReplay.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0MzAzMQ==", "bodyText": "let's add a test where the command has the newline character (e.g. CREATE STREAM foo (id INT, \"evil \\n field\" INT)...)", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455443031", "createdAt": "2020-07-16T00:37:46Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/BackupReplayFileTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.Pair;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class BackupReplayFileTest {\n+  private static final String KEY_VALUE_SEPARATOR = \":\";\n+  private static final String REPLAY_FILE_NAME = \"backup_command_topic_1\";\n+\n+  @Rule\n+  public TemporaryFolder backupLocation = new TemporaryFolder();\n+\n+  private BackupReplayFile replayFile;\n+  private File internalReplayFile;\n+\n+  @Before\n+  public void setup() throws IOException {\n+    internalReplayFile = backupLocation.newFile(REPLAY_FILE_NAME);\n+    replayFile = new BackupReplayFile(internalReplayFile);\n+  }\n+\n+  @Test\n+  public void shouldGetFilePath() {\n+    // When\n+    final String path = replayFile.getPath();\n+\n+    // Then\n+    assertThat(path, is(String.format(\n+        \"%s/%s\", backupLocation.getRoot().getAbsolutePath(), REPLAY_FILE_NAME)));\n+  }\n+\n+  @Test\n+  public void shouldWriteRecordToFile() throws IOException {\n+    // Given\n+    final Pair<CommandId, Command> record = newStreamRecord(\"stream1\");\n+\n+    // When\n+    replayFile.write(record.left, record.right);\n+\n+    // Then\n+    final List<String> commands = Files.readAllLines(internalReplayFile.toPath());\n+    assertThat(commands.size(), is(1));\n+    assertThat(commands.get(0), is(\n+        \"\\\"stream/stream1/create\\\"\" + KEY_VALUE_SEPARATOR\n+            + \"{\\\"statement\\\":\\\"CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1\\\"}\"\n+    ));\n+  }\n+\n+  @Test\n+  public void shouldWriteListOfRecordsTofile() throws IOException {\n+    // Given\n+    final Pair<CommandId, Command> record1 = newStreamRecord(\"stream1\");\n+    final Pair<CommandId, Command> record2 = newStreamRecord(\"stream2\");\n+\n+    // When\n+    replayFile.write(Arrays.asList(record1, record2));\n+\n+    // Then\n+    final List<String> commands = Files.readAllLines(internalReplayFile.toPath());\n+    assertThat(commands.size(), is(2));\n+    assertThat(commands.get(0), is(\n+        \"\\\"stream/stream1/create\\\"\" + KEY_VALUE_SEPARATOR\n+            + \"{\\\"statement\\\":\\\"CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1\\\"}\"\n+    ));\n+    assertThat(commands.get(1), is(\n+        \"\\\"stream/stream2/create\\\"\" + KEY_VALUE_SEPARATOR\n+            + \"{\\\"statement\\\":\\\"CREATE STREAM stream2 (id INT) WITH (kafka_topic='stream2\\\"}\"\n+    ));\n+  }\n+\n+  @Test\n+  public void shouldBeEmptyWhenReadAllCommandsFromEmptyFile() throws IOException {\n+    // When\n+    final List<?> commands = replayFile.readRecords();\n+\n+    // Then\n+    assertThat(commands.size(), is(0));\n+  }\n+\n+  @Test\n+  public void shouldReadCommandsFromFile() throws IOException {\n+    // Given\n+    final Pair<CommandId, Command> record1 = newStreamRecord(\"stream1\");\n+    final Pair<CommandId, Command> record2 = newStreamRecord(\"stream2\");\n+    Files.write(internalReplayFile.toPath(),\n+        String.format(\"%s%s%s%n%s%s%s\",\n+            \"\\\"stream/stream1/create\\\"\",\n+            KEY_VALUE_SEPARATOR,\n+            \"{\\\"statement\\\":\\\"CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1\\\"}\",\n+            \"\\\"stream/stream2/create\\\"\",\n+            KEY_VALUE_SEPARATOR,\n+            \"{\\\"statement\\\":\\\"CREATE STREAM stream2 (id INT) WITH (kafka_topic='stream2\\\"}\"\n+            ).getBytes(StandardCharsets.UTF_8));\n+\n+    // When\n+    final List<Pair<CommandId, Command>> commands = replayFile.readRecords();\n+\n+    // Then\n+    assertThat(commands.size(), is(2));\n+    assertThat(commands.get(0).left, is(record1.left));\n+    assertThat(commands.get(0).right, is(record1.right));\n+    assertThat(commands.get(1).left, is(record2.left));\n+    assertThat(commands.get(1).right, is(record2.right));\n+  }\n+\n+  private Pair<CommandId, Command> newStreamRecord(final String streamName) {\n+    final CommandId commandId = new CommandId(\n+        CommandId.Type.STREAM, streamName, CommandId.Action.CREATE);\n+    final Command command = new Command(\n+        String.format(\"CREATE STREAM %s (id INT) WITH (kafka_topic='%s\", streamName, streamName),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NDUyNA==", "bodyText": "can we add a test where the backup file is corrupted and we can't properly read it?", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455444524", "createdAt": "2020-07-16T00:43:37Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/CommandTopicBackupTest.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.google.common.base.Ticker;\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.Pair;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class CommandTopicBackupTest {\n+  private static final String COMMAND_TOPIC_NAME = \"command_topic\";\n+\n+  private Pair<CommandId, Command> command1 = newStreamRecord(\"stream1\");\n+  private Pair<CommandId, Command> command2 = newStreamRecord(\"stream2\");\n+  private Pair<CommandId, Command> command3 = newStreamRecord(\"stream3\");\n+\n+  @Mock\n+  private Ticker ticker;\n+\n+  @Rule\n+  public TemporaryFolder backupLocation = new TemporaryFolder();\n+\n+  private CommandTopicBackup commandTopicBackup;\n+\n+  @Before\n+  public void setup() {\n+    commandTopicBackup = new CommandTopicBackup(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDM0NjE0", "url": "https://github.com/confluentinc/ksql/pull/5831#pullrequestreview-449434614", "createdAt": "2020-07-16T00:46:01Z", "commit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDo0NjowMVrOGyWKxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDo0NjowMVrOGyWKxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTE4OA==", "bodyText": "what's meant by private KSQL directories here?", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455445188", "createdAt": "2020-07-16T00:46:01Z", "author": {"login": "rodesai"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -290,6 +290,18 @@\n   public static final String KSQL_CREATE_OR_REPLACE_ENABLED_DOC =\n       \"Feature flag for CREATE OR REPLACE\";\n \n+  public static final String KSQL_ENABLE_METASTORE_BACKUP = \"ksql.enable.metastore.backup\";\n+  public static final Boolean KSQL_ENABLE_METASTORE_BACKUP_DEFAULT = false;\n+  public static final String KSQL_ENABLE_METASTORE_BACKUP_DOC = \"Enable the KSQL metastore \"\n+      + \"backup service. The backup replays the KSQL command_topic to a file located in the \"\n+      + \"same KSQL node. By default, the backup files are located in the private KSQL \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f91953fb4491c36bee764c7676ed8db8f031a938", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f91953fb4491c36bee764c7676ed8db8f031a938", "committedDate": "2020-07-16T15:34:37Z", "message": "feat: metastore backups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd37c7e732d7b764094d41c4717972beadbd904f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/fd37c7e732d7b764094d41c4717972beadbd904f", "committedDate": "2020-07-16T15:30:12Z", "message": "fix: address 1st PR feedback\n\n- New CommandTopicBackupNoOp to replace Optional parameter\n- Refactor writeRecord() logic that checks if record was replayed before\n- Minor fixes"}, "afterCommit": {"oid": "c4357c713ce795e7739e239c41842735e24a601d", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/c4357c713ce795e7739e239c41842735e24a601d", "committedDate": "2020-07-16T15:43:32Z", "message": "fix: address 1st PR feedback\n\n- New CommandTopicBackupNoOp to replace Optional parameter\n- Refactor writeRecord() logic that checks if record was replayed before\n- Minor fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTkzNTQ5", "url": "https://github.com/confluentinc/ksql/pull/5831#pullrequestreview-449993549", "createdAt": "2020-07-16T16:02:00Z", "commit": {"oid": "c4357c713ce795e7739e239c41842735e24a601d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowMjowMFrOGyxz4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowMjowMFrOGyxz4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5ODA4MQ==", "bodyText": "I think my concern was more about reading record with new line characters to make sure that File.readLines works properly", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r455898081", "createdAt": "2020-07-16T16:02:00Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/BackupReplayFileTest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.Pair;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class BackupReplayFileTest {\n+  private static final String KEY_VALUE_SEPARATOR = \":\";\n+  private static final String REPLAY_FILE_NAME = \"backup_command_topic_1\";\n+\n+  @Rule\n+  public TemporaryFolder backupLocation = new TemporaryFolder();\n+\n+  private BackupReplayFile replayFile;\n+  private File internalReplayFile;\n+\n+  @Before\n+  public void setup() throws IOException {\n+    internalReplayFile = backupLocation.newFile(REPLAY_FILE_NAME);\n+    replayFile = new BackupReplayFile(internalReplayFile);\n+  }\n+\n+  @Test\n+  public void shouldGetFilePath() {\n+    // When\n+    final String path = replayFile.getPath();\n+\n+    // Then\n+    assertThat(path, is(String.format(\n+        \"%s/%s\", backupLocation.getRoot().getAbsolutePath(), REPLAY_FILE_NAME)));\n+  }\n+\n+  @Test\n+  public void shouldWriteRecord() throws IOException {\n+    // Given\n+    final Pair<CommandId, Command> record = newStreamRecord(\"stream1\");\n+\n+    // When\n+    replayFile.write(record.left, record.right);\n+\n+    // Then\n+    final List<String> commands = Files.readAllLines(internalReplayFile.toPath());\n+    assertThat(commands.size(), is(1));\n+    assertThat(commands.get(0), is(\n+        \"\\\"stream/stream1/create\\\"\" + KEY_VALUE_SEPARATOR\n+            + \"{\\\"statement\\\":\\\"CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1')\\\"}\"\n+    ));\n+  }\n+\n+  @Test\n+  public void shouldWriteListOfRecords() throws IOException {\n+    // Given\n+    final Pair<CommandId, Command> record1 = newStreamRecord(\"stream1\");\n+    final Pair<CommandId, Command> record2 = newStreamRecord(\"stream2\");\n+\n+    // When\n+    replayFile.write(Arrays.asList(record1, record2));\n+\n+    // Then\n+    final List<String> commands = Files.readAllLines(internalReplayFile.toPath());\n+    assertThat(commands.size(), is(2));\n+    assertThat(commands.get(0), is(\n+        \"\\\"stream/stream1/create\\\"\" + KEY_VALUE_SEPARATOR\n+            + \"{\\\"statement\\\":\\\"CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1')\\\"}\"\n+    ));\n+    assertThat(commands.get(1), is(\n+        \"\\\"stream/stream2/create\\\"\" + KEY_VALUE_SEPARATOR\n+            + \"{\\\"statement\\\":\\\"CREATE STREAM stream2 (id INT) WITH (kafka_topic='stream2')\\\"}\"\n+    ));\n+  }\n+\n+  @Test\n+  public void shouldWriteRecordWithNewLineCharacterInCommand() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4357c713ce795e7739e239c41842735e24a601d"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4b7dabb562a21a6e02db7db0cb78052e5b55c7f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/b4b7dabb562a21a6e02db7db0cb78052e5b55c7f", "committedDate": "2020-07-16T16:13:52Z", "message": "fix: address 1st PR feedback\n\n- New CommandTopicBackupNoOp to replace Optional parameter\n- Refactor writeRecord() logic that checks if record was replayed before\n- Minor fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4357c713ce795e7739e239c41842735e24a601d", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/c4357c713ce795e7739e239c41842735e24a601d", "committedDate": "2020-07-16T15:43:32Z", "message": "fix: address 1st PR feedback\n\n- New CommandTopicBackupNoOp to replace Optional parameter\n- Refactor writeRecord() logic that checks if record was replayed before\n- Minor fixes"}, "afterCommit": {"oid": "b4b7dabb562a21a6e02db7db0cb78052e5b55c7f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/b4b7dabb562a21a6e02db7db0cb78052e5b55c7f", "committedDate": "2020-07-16T16:13:52Z", "message": "fix: address 1st PR feedback\n\n- New CommandTopicBackupNoOp to replace Optional parameter\n- Refactor writeRecord() logic that checks if record was replayed before\n- Minor fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTk2NTIx", "url": "https://github.com/confluentinc/ksql/pull/5831#pullrequestreview-450196521", "createdAt": "2020-07-16T20:35:32Z", "commit": {"oid": "b4b7dabb562a21a6e02db7db0cb78052e5b55c7f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDozNTozMlrOGy70QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDozNTozMlrOGy70QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA2MjAxNg==", "bodyText": "As discussed offline, according to the standard it's not possible for a json string field to have an embedded newline, so we should be good here. I still think a more explicit format (like what @agavra suggested) is safer (even if it means the backup file isn't immediately usable). Up to you.", "url": "https://github.com/confluentinc/ksql/pull/5831#discussion_r456062016", "createdAt": "2020-07-16T20:35:32Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.confluent.ksql.execution.json.PlanJsonMapper;\n+import io.confluent.ksql.rest.entity.CommandId;\n+import io.confluent.ksql.rest.server.computation.Command;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.Pair;\n+\n+import java.io.BufferedWriter;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A file that is used by the backup service to replay command_topic commands.\n+ */\n+public class BackupReplayFile implements Closeable {\n+  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get();\n+  private static final String KEY_VALUE_SEPARATOR = \":\";\n+\n+  private final File file;\n+  private final BufferedWriter writer;\n+\n+  public BackupReplayFile(final File file) {\n+    this.file = Objects.requireNonNull(file, \"file\");\n+    this.writer = createWriter(file);\n+  }\n+\n+  private static BufferedWriter createWriter(final File file) {\n+    try {\n+      return new BufferedWriter(new OutputStreamWriter(\n+          new FileOutputStream(file, true),\n+          StandardCharsets.UTF_8)\n+      );\n+    } catch (final FileNotFoundException e) {\n+      throw new KsqlException(\n+          String.format(\"Failed to create replay file: %s\", file.getAbsolutePath()), e);\n+    }\n+  }\n+\n+  public String getPath() {\n+    return file.getAbsolutePath();\n+  }\n+\n+  public void write(final CommandId commandId, final Command command) throws IOException {\n+    writer.write(MAPPER.writeValueAsString(commandId));\n+    writer.write(KEY_VALUE_SEPARATOR);\n+    writer.write(MAPPER.writeValueAsString(command));\n+    writer.write(\"\\n\");\n+    writer.flush();\n+  }\n+\n+  public void write(final List<Pair<CommandId, Command>> records) throws IOException {\n+    for (final Pair<CommandId, Command> record : records) {\n+      write(record.left, record.right);\n+    }\n+  }\n+\n+  public List<Pair<CommandId, Command>> readRecords() throws IOException {\n+    final List<Pair<CommandId, Command>> commands = new ArrayList<>();\n+    for (final String line : Files.readAllLines(file.toPath(), StandardCharsets.UTF_8)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMDQ2MA=="}, "originalCommit": {"oid": "8c8b54c857d38e8c304b5e7c6415063ecfe60c12"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4839, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}