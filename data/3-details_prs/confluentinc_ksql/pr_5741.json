{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMzAyNzQ1", "number": 5741, "title": "docs: klip-31: Metastore Backups", "bodyText": "Description\nRequest for comment of KLIP-31.\nTesting done\nDescribe the testing strategy. Unit and integration tests are expected for any behavior changes.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-06-30T21:22:48Z", "url": "https://github.com/confluentinc/ksql/pull/5741", "merged": true, "mergeCommit": {"oid": "116427524b717bdbbd341feb65d2612aac9aaea7"}, "closed": true, "closedAt": "2020-07-16T22:07:26Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwwyo0AFqTQ0MTE5NjE2MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1l1TxgBqjM1NTUxNzI5Nzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTk2MTYx", "url": "https://github.com/confluentinc/ksql/pull/5741#pullrequestreview-441196161", "createdAt": "2020-07-01T21:05:11Z", "commit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowNToxMlrOGr1VAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowNToxMlrOGr1VAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNTY4Mg==", "bodyText": "@apurvam @derekjn There are some security implications of having a Metastore backup (see below). I was thinking we should not have these backups enabled by default to avoid users leaking data accidentally. But, if the default will be disabled, then users can still at risk of deleting the command_topic and not able to recover it. And if they need a backup option, won't they configure a better backup service in Kafka instead?", "url": "https://github.com/confluentinc/ksql/pull/5741#discussion_r448615682", "createdAt": "2020-07-01T21:05:12Z", "author": {"login": "spena"}, "path": "design-proposals/klip-31-metastore-backups.md", "diffHunk": "@@ -0,0 +1,122 @@\n+# KLIP 31 - Metastore Backups\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** _KSQL should keep a local backup of the metastore (or command_topic) to allow users recover from an accidental\n+metastore disaster._\n+\n+## Motivation and background\n+\n+There are users that may cause KSQL metastore data loss accidentally. A recent use case where a user set the retention.ms to 0 on the KSQL command_topic caused a severe problem because all the metadata\n+of streams, tables, etc. were lost without any way to recover them. Users should have a plan for Disaster and Recovery in such situations, like configuring backups in Kafka. However, not all KSQL users\n+have this plan in place. To mitigate the risk of these unrecoverable scenarios, we need KSQL to keep a backup of the metastore (or command_topic) somewhere so it can be recovered in case of an accident.\n+\n+This KLIP proposes a simple solution to automatically backup the metastore by replaying the command_topic onto a file located in the same KSQL node. Users can use this file to restore their command_topic\n+if necessary.\n+\n+Note: The proposal does not take into account any future changes related to [KLIP-18: Metastore Database](https://github.com/confluentinc/ksql/pull/4659). If KLIP-18 is implemented, then this backup\n+proposal will not work.\n+\n+## What is in scope\n+\n+* Automatically create KSQL metastore backups\n+* Document steps to manually restore the KSQL command_topic\n+\n+## What is not in scope\n+\n+* `Managing automatic restores`. This is complicated due to unknown reasons of the metastore clean-up and distributed systems challenges. KSQL does not know if the command_topic was cleaned\n+  intentionally or by accident. Also, restoring automatically while KSQL is running may cause conflicts with other nodes in the KSQL cluster.\n+* `Remote backup locations`. Users may want to store their backups in a remote location, but this comes with issues when a cluster is running with multiple nodes. All nodes might be writing\n+to the same remote location causing corruption in the backup files. To keep things simple, we better remove this support.\n+\n+## Value/Return\n+\n+If the KSQL metastore (or command_topic) is accidentally deleted, then the users will be able to recover the metastore from a backup.\n+\n+## Public APIS\n+\n+Two new configurations are required:\n+\n+* `ksql.enable.backup` as Boolean to enable backups (default: False).\n+* `ksql.backup.location` as String to specify a directory location for backups (default: an internal KSQL directory)\n+\n+## Design\n+\n+When backups are enabled, KSQL will start replaying the command_topic messages to a local file in the specified backup location. Every new command added to the\n+command_topic while KSQL is running will be appended to the local file to keep a live metastore backup.\n+\n+The `ksql.enable.backup` config will be used to enable backups. It is better to let users enable/disable backups with this config than disabling by setting an empty backup location.\n+Otherwise, a user setting the location empty just to disable a backup might forgot what the location was when enabling it back.\n+\n+The `ksql.backup.location` will specify the directory where the backup files exist. Only a directory in the local file system is accepted (no remote locations). This is to avoid multiple\n+nodes in the KSQL cluster writing to the same remote location. The location is a directory where KSQL will write one or more files.\n+\n+The backup file name will be formed using the command_topic name and the date of the initial backup (i.e. _confluent-ksql-default__command_topic_1593540976.bak).\n+\n+The messages will be serialized using the command_topic JSON serializer. The backup file content will look pretty similar to what is seen in the command_topic messages. It will have one\n+command per line. Each line will start with the same command_topic row timestamp to allow users identify the backup file with the most recent entries (in case of multiple nodes).\n+\n+i.e. (backup: _confluent-ksql-default__command_topic_1593545289.bak)\n+```\n+1593545289 {\"statement\":\"CREATE STREAM TEST1(ID INT) WITH(KAFKA_TOPIC='test1', VALUE_FORMAT='JSON');\",\"streamsProperties\":{}, ... }\n+1593545382 {\"statement\":\"CREATE STREAM TEST2(ID INT) WITH(KAFKA_TOPIC='test2', VALUE_FORMAT='JSON');\",\"streamsProperties\":{}, ... }\n+1593545529 {\"statement\":\"DROP STREAM TEST1;\",\"streamsProperties\":{}, ... }\n+```\n+\n+This format will allow users to easily restore the command_topic using the Kafka producer scripts.\n+\n+i.e.\n+```\n+$ cut -d' ' -f2- _confluent-ksql-default__command_topic_1593545289.bak | \n+      kafka-console-producer --broker-list localhost:9092 --topic _confluent-ksql-default__command_topic\n+```\n+\n+### Workflow\n+\n+When KSQL starts, it always reads the command topic from the beginning. If the backup file does not exist yet, then it will create a new file and start appending each command_topic message to it.\n+A backup file is not found if it is the first time backups are enabled, or if the KSQL service.id is different from the ones found in the backup filenames.\n+\n+If a backup file with the same KSQL service.id exists, then KSQL will append only the new command_topic messages to that file.\n+\n+KSQL will compare each consumed command_topic message against the next line from the backup file. If both messages are different, then it considers the command_topic as a new restored\n+topic, so KSQL will create a new backup file, copy all read messages to the file, and continue appending the new messages to it. If there are no more messages read from the backup file (EOF),\n+then KSQL considers this file is the current one and will continue appending messages to it.\n+\n+KSQL will not use offsets to compare against the backup file. It will assume each offset starts from 1, beginning consuming messages from the topic and reading messages from the file.\n+\n+### Performance\n+\n+The KSQL metastore is not expect to grow into a big file. Appending each new command to a file is faster. KSQL command messages are not large to cause slowness during backup file writing.\n+It will certainly add extra time during KSQL restarts, but considering the average I/O latency of 10ms per write, then 500 commands would take around 5s to create the initial backup. Also, using\n+the same example of 500 commands and an average size of 4k per command (using the ksql_processing_log stream command size as example), then this backup file would grow to 2Mb.\n+\n+## Test plan\n+\n+- Unit tests\n+- Integration tests to verify backups and restore steps work\n+\n+## LOEs and Delivery Milestones\n+\n+It is a small feature that may take a week or less.\n+\n+## Documentation Updates\n+\n+Documentation about how to enable backups and restore a command topic manually will be written.\n+\n+## Compatibility Implications\n+\n+This is a new feature and does not affect any other feature of KSQL or CP components.\n+\n+## Security Implications", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTc2MTM3", "url": "https://github.com/confluentinc/ksql/pull/5741#pullrequestreview-445976137", "createdAt": "2020-07-09T21:18:38Z", "commit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMToxODozOFrOGviKgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMjoyMTowMVrOGvjv9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5NjAwMQ==", "bodyText": "any reason to not enable it by default?", "url": "https://github.com/confluentinc/ksql/pull/5741#discussion_r452496001", "createdAt": "2020-07-09T21:18:38Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-31-metastore-backups.md", "diffHunk": "@@ -0,0 +1,122 @@\n+# KLIP 31 - Metastore Backups\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** _KSQL should keep a local backup of the metastore (or command_topic) to allow users recover from an accidental\n+metastore disaster._\n+\n+## Motivation and background\n+\n+There are users that may cause KSQL metastore data loss accidentally. A recent use case where a user set the retention.ms to 0 on the KSQL command_topic caused a severe problem because all the metadata\n+of streams, tables, etc. were lost without any way to recover them. Users should have a plan for Disaster and Recovery in such situations, like configuring backups in Kafka. However, not all KSQL users\n+have this plan in place. To mitigate the risk of these unrecoverable scenarios, we need KSQL to keep a backup of the metastore (or command_topic) somewhere so it can be recovered in case of an accident.\n+\n+This KLIP proposes a simple solution to automatically backup the metastore by replaying the command_topic onto a file located in the same KSQL node. Users can use this file to restore their command_topic\n+if necessary.\n+\n+Note: The proposal does not take into account any future changes related to [KLIP-18: Metastore Database](https://github.com/confluentinc/ksql/pull/4659). If KLIP-18 is implemented, then this backup\n+proposal will not work.\n+\n+## What is in scope\n+\n+* Automatically create KSQL metastore backups\n+* Document steps to manually restore the KSQL command_topic\n+\n+## What is not in scope\n+\n+* `Managing automatic restores`. This is complicated due to unknown reasons of the metastore clean-up and distributed systems challenges. KSQL does not know if the command_topic was cleaned\n+  intentionally or by accident. Also, restoring automatically while KSQL is running may cause conflicts with other nodes in the KSQL cluster.\n+* `Remote backup locations`. Users may want to store their backups in a remote location, but this comes with issues when a cluster is running with multiple nodes. All nodes might be writing\n+to the same remote location causing corruption in the backup files. To keep things simple, we better remove this support.\n+\n+## Value/Return\n+\n+If the KSQL metastore (or command_topic) is accidentally deleted, then the users will be able to recover the metastore from a backup.\n+\n+## Public APIS\n+\n+Two new configurations are required:\n+\n+* `ksql.enable.backup` as Boolean to enable backups (default: False).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyMTk3Mg==", "bodyText": "should be even faster given the whole file is probably just one bulk I/O load", "url": "https://github.com/confluentinc/ksql/pull/5741#discussion_r452521972", "createdAt": "2020-07-09T22:21:01Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-31-metastore-backups.md", "diffHunk": "@@ -0,0 +1,122 @@\n+# KLIP 31 - Metastore Backups\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** _KSQL should keep a local backup of the metastore (or command_topic) to allow users recover from an accidental\n+metastore disaster._\n+\n+## Motivation and background\n+\n+There are users that may cause KSQL metastore data loss accidentally. A recent use case where a user set the retention.ms to 0 on the KSQL command_topic caused a severe problem because all the metadata\n+of streams, tables, etc. were lost without any way to recover them. Users should have a plan for Disaster and Recovery in such situations, like configuring backups in Kafka. However, not all KSQL users\n+have this plan in place. To mitigate the risk of these unrecoverable scenarios, we need KSQL to keep a backup of the metastore (or command_topic) somewhere so it can be recovered in case of an accident.\n+\n+This KLIP proposes a simple solution to automatically backup the metastore by replaying the command_topic onto a file located in the same KSQL node. Users can use this file to restore their command_topic\n+if necessary.\n+\n+Note: The proposal does not take into account any future changes related to [KLIP-18: Metastore Database](https://github.com/confluentinc/ksql/pull/4659). If KLIP-18 is implemented, then this backup\n+proposal will not work.\n+\n+## What is in scope\n+\n+* Automatically create KSQL metastore backups\n+* Document steps to manually restore the KSQL command_topic\n+\n+## What is not in scope\n+\n+* `Managing automatic restores`. This is complicated due to unknown reasons of the metastore clean-up and distributed systems challenges. KSQL does not know if the command_topic was cleaned\n+  intentionally or by accident. Also, restoring automatically while KSQL is running may cause conflicts with other nodes in the KSQL cluster.\n+* `Remote backup locations`. Users may want to store their backups in a remote location, but this comes with issues when a cluster is running with multiple nodes. All nodes might be writing\n+to the same remote location causing corruption in the backup files. To keep things simple, we better remove this support.\n+\n+## Value/Return\n+\n+If the KSQL metastore (or command_topic) is accidentally deleted, then the users will be able to recover the metastore from a backup.\n+\n+## Public APIS\n+\n+Two new configurations are required:\n+\n+* `ksql.enable.backup` as Boolean to enable backups (default: False).\n+* `ksql.backup.location` as String to specify a directory location for backups (default: an internal KSQL directory)\n+\n+## Design\n+\n+When backups are enabled, KSQL will start replaying the command_topic messages to a local file in the specified backup location. Every new command added to the\n+command_topic while KSQL is running will be appended to the local file to keep a live metastore backup.\n+\n+The `ksql.enable.backup` config will be used to enable backups. It is better to let users enable/disable backups with this config than disabling by setting an empty backup location.\n+Otherwise, a user setting the location empty just to disable a backup might forgot what the location was when enabling it back.\n+\n+The `ksql.backup.location` will specify the directory where the backup files exist. Only a directory in the local file system is accepted (no remote locations). This is to avoid multiple\n+nodes in the KSQL cluster writing to the same remote location. The location is a directory where KSQL will write one or more files.\n+\n+The backup file name will be formed using the command_topic name and the date of the initial backup (i.e. _confluent-ksql-default__command_topic_1593540976.bak).\n+\n+The messages will be serialized using the command_topic JSON serializer. The backup file content will look pretty similar to what is seen in the command_topic messages. It will have one\n+command per line. Each line will start with the same command_topic row timestamp to allow users identify the backup file with the most recent entries (in case of multiple nodes).\n+\n+i.e. (backup: _confluent-ksql-default__command_topic_1593545289.bak)\n+```\n+1593545289 {\"statement\":\"CREATE STREAM TEST1(ID INT) WITH(KAFKA_TOPIC='test1', VALUE_FORMAT='JSON');\",\"streamsProperties\":{}, ... }\n+1593545382 {\"statement\":\"CREATE STREAM TEST2(ID INT) WITH(KAFKA_TOPIC='test2', VALUE_FORMAT='JSON');\",\"streamsProperties\":{}, ... }\n+1593545529 {\"statement\":\"DROP STREAM TEST1;\",\"streamsProperties\":{}, ... }\n+```\n+\n+This format will allow users to easily restore the command_topic using the Kafka producer scripts.\n+\n+i.e.\n+```\n+$ cut -d' ' -f2- _confluent-ksql-default__command_topic_1593545289.bak | \n+      kafka-console-producer --broker-list localhost:9092 --topic _confluent-ksql-default__command_topic\n+```\n+\n+### Workflow\n+\n+When KSQL starts, it always reads the command topic from the beginning. If the backup file does not exist yet, then it will create a new file and start appending each command_topic message to it.\n+A backup file is not found if it is the first time backups are enabled, or if the KSQL service.id is different from the ones found in the backup filenames.\n+\n+If a backup file with the same KSQL service.id exists, then KSQL will append only the new command_topic messages to that file.\n+\n+KSQL will compare each consumed command_topic message against the next line from the backup file. If both messages are different, then it considers the command_topic as a new restored\n+topic, so KSQL will create a new backup file, copy all read messages to the file, and continue appending the new messages to it. If there are no more messages read from the backup file (EOF),\n+then KSQL considers this file is the current one and will continue appending messages to it.\n+\n+KSQL will not use offsets to compare against the backup file. It will assume each offset starts from 1, beginning consuming messages from the topic and reading messages from the file.\n+\n+### Performance\n+\n+The KSQL metastore is not expect to grow into a big file. Appending each new command to a file is faster. KSQL command messages are not large to cause slowness during backup file writing.\n+It will certainly add extra time during KSQL restarts, but considering the average I/O latency of 10ms per write, then 500 commands would take around 5s to create the initial backup. Also, using", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDQ4NTA5", "url": "https://github.com/confluentinc/ksql/pull/5741#pullrequestreview-447448509", "createdAt": "2020-07-13T17:20:00Z", "commit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzoyMDowMFrOGwyLCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzoyMDowMFrOGwyLCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNjg1OQ==", "bodyText": "What's the comparison function? String equality? Compare the deserialized json objects on both sides? Something else?", "url": "https://github.com/confluentinc/ksql/pull/5741#discussion_r453806859", "createdAt": "2020-07-13T17:20:00Z", "author": {"login": "apurvam"}, "path": "design-proposals/klip-31-metastore-backups.md", "diffHunk": "@@ -0,0 +1,122 @@\n+# KLIP 31 - Metastore Backups\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** _KSQL should keep a local backup of the metastore (or command_topic) to allow users recover from an accidental\n+metastore disaster._\n+\n+## Motivation and background\n+\n+There are users that may cause KSQL metastore data loss accidentally. A recent use case where a user set the retention.ms to 0 on the KSQL command_topic caused a severe problem because all the metadata\n+of streams, tables, etc. were lost without any way to recover them. Users should have a plan for Disaster and Recovery in such situations, like configuring backups in Kafka. However, not all KSQL users\n+have this plan in place. To mitigate the risk of these unrecoverable scenarios, we need KSQL to keep a backup of the metastore (or command_topic) somewhere so it can be recovered in case of an accident.\n+\n+This KLIP proposes a simple solution to automatically backup the metastore by replaying the command_topic onto a file located in the same KSQL node. Users can use this file to restore their command_topic\n+if necessary.\n+\n+Note: The proposal does not take into account any future changes related to [KLIP-18: Metastore Database](https://github.com/confluentinc/ksql/pull/4659). If KLIP-18 is implemented, then this backup\n+proposal will not work.\n+\n+## What is in scope\n+\n+* Automatically create KSQL metastore backups\n+* Document steps to manually restore the KSQL command_topic\n+\n+## What is not in scope\n+\n+* `Managing automatic restores`. This is complicated due to unknown reasons of the metastore clean-up and distributed systems challenges. KSQL does not know if the command_topic was cleaned\n+  intentionally or by accident. Also, restoring automatically while KSQL is running may cause conflicts with other nodes in the KSQL cluster.\n+* `Remote backup locations`. Users may want to store their backups in a remote location, but this comes with issues when a cluster is running with multiple nodes. All nodes might be writing\n+to the same remote location causing corruption in the backup files. To keep things simple, we better remove this support.\n+\n+## Value/Return\n+\n+If the KSQL metastore (or command_topic) is accidentally deleted, then the users will be able to recover the metastore from a backup.\n+\n+## Public APIS\n+\n+Two new configurations are required:\n+\n+* `ksql.enable.backup` as Boolean to enable backups (default: False).\n+* `ksql.backup.location` as String to specify a directory location for backups (default: an internal KSQL directory)\n+\n+## Design\n+\n+When backups are enabled, KSQL will start replaying the command_topic messages to a local file in the specified backup location. Every new command added to the\n+command_topic while KSQL is running will be appended to the local file to keep a live metastore backup.\n+\n+The `ksql.enable.backup` config will be used to enable backups. It is better to let users enable/disable backups with this config than disabling by setting an empty backup location.\n+Otherwise, a user setting the location empty just to disable a backup might forgot what the location was when enabling it back.\n+\n+The `ksql.backup.location` will specify the directory where the backup files exist. Only a directory in the local file system is accepted (no remote locations). This is to avoid multiple\n+nodes in the KSQL cluster writing to the same remote location. The location is a directory where KSQL will write one or more files.\n+\n+The backup file name will be formed using the command_topic name and the date of the initial backup (i.e. _confluent-ksql-default__command_topic_1593540976.bak).\n+\n+The messages will be serialized using the command_topic JSON serializer. The backup file content will look pretty similar to what is seen in the command_topic messages. It will have one\n+command per line. Each line will start with the same command_topic row timestamp to allow users identify the backup file with the most recent entries (in case of multiple nodes).\n+\n+i.e. (backup: _confluent-ksql-default__command_topic_1593545289.bak)\n+```\n+1593545289 {\"statement\":\"CREATE STREAM TEST1(ID INT) WITH(KAFKA_TOPIC='test1', VALUE_FORMAT='JSON');\",\"streamsProperties\":{}, ... }\n+1593545382 {\"statement\":\"CREATE STREAM TEST2(ID INT) WITH(KAFKA_TOPIC='test2', VALUE_FORMAT='JSON');\",\"streamsProperties\":{}, ... }\n+1593545529 {\"statement\":\"DROP STREAM TEST1;\",\"streamsProperties\":{}, ... }\n+```\n+\n+This format will allow users to easily restore the command_topic using the Kafka producer scripts.\n+\n+i.e.\n+```\n+$ cut -d' ' -f2- _confluent-ksql-default__command_topic_1593545289.bak | \n+      kafka-console-producer --broker-list localhost:9092 --topic _confluent-ksql-default__command_topic\n+```\n+\n+### Workflow\n+\n+When KSQL starts, it always reads the command topic from the beginning. If the backup file does not exist yet, then it will create a new file and start appending each command_topic message to it.\n+A backup file is not found if it is the first time backups are enabled, or if the KSQL service.id is different from the ones found in the backup filenames.\n+\n+If a backup file with the same KSQL service.id exists, then KSQL will append only the new command_topic messages to that file.\n+\n+KSQL will compare each consumed command_topic message against the next line from the backup file. If both messages are different, then it considers the command_topic as a new restored", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4341fe10478d6021b424fe8b113f4e1441be070", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/d4341fe10478d6021b424fe8b113f4e1441be070", "committedDate": "2020-07-16T21:08:35Z", "message": "docs: klip-31: Metastore Backups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8439d6f7f91d86354b99b42981306bef06c62012", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/8439d6f7f91d86354b99b42981306bef06c62012", "committedDate": "2020-06-30T21:16:46Z", "message": "docs: klip-31: Metastore Backups"}, "afterCommit": {"oid": "d4341fe10478d6021b424fe8b113f4e1441be070", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/d4341fe10478d6021b424fe8b113f4e1441be070", "committedDate": "2020-07-16T21:08:35Z", "message": "docs: klip-31: Metastore Backups"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 300, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}