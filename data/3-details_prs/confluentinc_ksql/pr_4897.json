{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODg2MDE1", "number": 4897, "title": "chore: add syntax for multi-way joins", "bodyText": "fixes #1612\nDescription\nSimply adds the syntax for multi-way joins, but still fails if users try to use it. The message, however, is now clearer:\nInvalid join criteria specified; KSQL does not support multi-way joins.\n\nTesting done\nAll existing tests pass, and I added a unit and QTT test to make sure that the new message is returned in the case of a multi-way join.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-03-26T00:00:58Z", "url": "https://github.com/confluentinc/ksql/pull/4897", "merged": true, "mergeCommit": {"oid": "eae24a528b0dd174606120460a34cf0b2b812ac5"}, "closed": true, "closedAt": "2020-03-26T19:59:55Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRQhl3AH2gAyMzkzODg2MDE1OjVjMTY3YzRhMTgzZjc3OWE2NzNmZGVmZDliODQ1NWU1YjA3NjFkODM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRgHhDAH2gAyMzkzODg2MDE1OmMwNzA0OWFkZWRhOTM1YTY5NGQ3ODhhZDFjMGVkNDEzNDIxMDg5NjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/5c167c4a183f779a673fdefd9b8455e5b0761d83", "committedDate": "2020-03-25T23:57:58Z", "message": "chore: add syntax for multi-way joins"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxODkxNjQy", "url": "https://github.com/confluentinc/ksql/pull/4897#pullrequestreview-381891642", "createdAt": "2020-03-26T10:49:28Z", "commit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMDo0OToyOFrOF8BKDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMDo1OTozMlrOF8BhXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ3NzgzNw==", "bodyText": "Should we be updating the if statement too?\nAt the moment we don't support JOINs to self. (Streams limitation I believe). Hence, I think we can update the if statement to throw if this would mean that the joinInfo list would be bigger than fromDataSources.", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398477837", "createdAt": "2020-03-26T10:49:28Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analysis.java", "diffHunk": "@@ -169,20 +169,20 @@ void setLimitClause(final int limitClause) {\n     this.limitClause = OptionalInt.of(limitClause);\n   }\n \n-  void setJoin(final JoinInfo joinInfo) {\n+  void addJoin(final JoinInfo joinInfo) {\n     if (fromDataSources.size() <= 1) {\n       throw new IllegalStateException(\"Join info can only be supplied for joins\");\n     }\n \n-    this.joinInfo = Optional.of(joinInfo);\n+    this.joinInfo.add(joinInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ4MDI3Nw==", "bodyText": "why not just:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!analysis.isJoin()) {\n          \n          \n            \n                if (sources.size() == 1) {", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398480277", "createdAt": "2020-03-26T10:53:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -421,36 +421,37 @@ private PlanNode buildSourceNode() {\n \n     final List<AliasedDataSource> sources = analysis.getFromDataSources();\n \n-    final Optional<JoinInfo> joinInfo = analysis.getOriginal().getJoin();\n-    if (!joinInfo.isPresent()) {\n+    if (!analysis.isJoin()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ4MjYzMw==", "bodyText": "nit: IMHO this name is confusing as it doesn't include the left source, so it's not all the sources...   would you mind renaming to something else? maybe getRights or getOthers or something that infers it's not the complete set?", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398482633", "createdAt": "2020-03-26T10:57:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/Join.java", "diffHunk": "@@ -18,78 +18,42 @@\n import static com.google.common.base.MoreObjects.toStringHelper;\n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.parser.NodeLocation;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class Join extends Relation {\n \n-  private final Type type;\n   private final Relation left;\n-  private final Relation right;\n-  private final JoinCriteria criteria;\n-  private final Optional<WithinExpression> withinExpression;\n-\n-  public enum Type {\n-    INNER(\"INNER\"), LEFT(\"LEFT OUTER\"), OUTER(\"FULL OUTER\");\n-\n-    private final String formattedText;\n-\n-    Type(final String formattedText) {\n-      this.formattedText = Objects.requireNonNull(formattedText, \"formattedText\");\n-    }\n-\n-    public String getFormatted() {\n-      return formattedText;\n-    }\n-  }\n+  private final ImmutableList<JoinedSource> sources;\n \n   public Join(\n-      final Type type,\n       final Relation left,\n-      final Relation right,\n-      final JoinCriteria criteria,\n-      final Optional<WithinExpression> withinExpression\n+      final List<JoinedSource> sources\n   ) {\n-    this(Optional.empty(), type, left, right, criteria, withinExpression);\n+    this(Optional.empty(), left, sources);\n   }\n \n   public Join(\n       final Optional<NodeLocation> location,\n-      final Type type,\n       final Relation left,\n-      final Relation right,\n-      final JoinCriteria criteria,\n-      final Optional<WithinExpression> withinExpression\n+      final List<JoinedSource> sources\n   ) {\n     super(location);\n-    this.type = requireNonNull(type, \"type\");\n     this.left = requireNonNull(left, \"left\");\n-    this.right = requireNonNull(right, \"right\");\n-    this.criteria = requireNonNull(criteria, \"criteria\");\n-    this.withinExpression = requireNonNull(withinExpression, \"withinExpression\");\n-  }\n-\n-  public Type getType() {\n-    return type;\n+    this.sources = ImmutableList.copyOf(Objects.requireNonNull(sources, \"sources\"));\n   }\n \n   public Relation getLeft() {\n     return left;\n   }\n \n-  public Relation getRight() {\n-    return right;\n-  }\n-\n-  public JoinCriteria getCriteria() {\n-    return criteria;\n-  }\n-\n-  public Optional<WithinExpression> getWithinExpression() {\n-    return withinExpression;\n+  public ImmutableList<JoinedSource> getSources() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ4Mjg5Nw==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.\nIn this case, throw if sources is empty...", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398482897", "createdAt": "2020-03-26T10:58:06Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/Join.java", "diffHunk": "@@ -18,78 +18,42 @@\n import static com.google.common.base.MoreObjects.toStringHelper;\n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.parser.NodeLocation;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class Join extends Relation {\n \n-  private final Type type;\n   private final Relation left;\n-  private final Relation right;\n-  private final JoinCriteria criteria;\n-  private final Optional<WithinExpression> withinExpression;\n-\n-  public enum Type {\n-    INNER(\"INNER\"), LEFT(\"LEFT OUTER\"), OUTER(\"FULL OUTER\");\n-\n-    private final String formattedText;\n-\n-    Type(final String formattedText) {\n-      this.formattedText = Objects.requireNonNull(formattedText, \"formattedText\");\n-    }\n-\n-    public String getFormatted() {\n-      return formattedText;\n-    }\n-  }\n+  private final ImmutableList<JoinedSource> sources;\n \n   public Join(\n-      final Type type,\n       final Relation left,\n-      final Relation right,\n-      final JoinCriteria criteria,\n-      final Optional<WithinExpression> withinExpression\n+      final List<JoinedSource> sources\n   ) {\n-    this(Optional.empty(), type, left, right, criteria, withinExpression);\n+    this(Optional.empty(), left, sources);\n   }\n \n   public Join(\n       final Optional<NodeLocation> location,\n-      final Type type,\n       final Relation left,\n-      final Relation right,\n-      final JoinCriteria criteria,\n-      final Optional<WithinExpression> withinExpression\n+      final List<JoinedSource> sources\n   ) {\n     super(location);\n-    this.type = requireNonNull(type, \"type\");\n     this.left = requireNonNull(left, \"left\");\n-    this.right = requireNonNull(right, \"right\");\n-    this.criteria = requireNonNull(criteria, \"criteria\");\n-    this.withinExpression = requireNonNull(withinExpression, \"withinExpression\");\n-  }\n-\n-  public Type getType() {\n-    return type;\n+    this.sources = ImmutableList.copyOf(Objects.requireNonNull(sources, \"sources\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ4MzE3Nw==", "bodyText": "consider re-gennning this with in Java 7+ style?", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398483177", "createdAt": "2020-03-26T10:58:31Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/Join.java", "diffHunk": "@@ -100,10 +64,8 @@ public JoinCriteria getCriteria() {\n   @Override\n   public String toString() {\n     return toStringHelper(this)\n-        .add(\"type\", type)\n         .add(\"left\", left)\n-        .add(\"right\", right)\n-        .add(\"criteria\", criteria)\n+        .add(\"sources\", sources)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ4MzMxNA==", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398483314", "createdAt": "2020-03-26T10:58:45Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/JoinedSource.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.tree;\n+\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.parser.NodeLocation;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+@Immutable\n+public class JoinedSource extends Relation {\n+\n+  private final Relation relation;\n+  private final Type type;\n+  private final JoinCriteria criteria;\n+  private final Optional<WithinExpression> withinExpression;\n+\n+  public JoinedSource(\n+      final Optional<NodeLocation> location,\n+      final Relation relation,\n+      final Type type,\n+      final JoinCriteria criteria,\n+      final Optional<WithinExpression> withinExpression\n+  ) {\n+    super(location);\n+    this.relation = relation;\n+    this.type = type;\n+    this.criteria = criteria;\n+    this.withinExpression = withinExpression;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ4MzgwNg==", "bodyText": "any reason why this can't be toString()?", "url": "https://github.com/confluentinc/ksql/pull/4897#discussion_r398483806", "createdAt": "2020-03-26T10:59:32Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/JoinedSource.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.tree;\n+\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.parser.NodeLocation;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+@Immutable\n+public class JoinedSource extends Relation {\n+\n+  private final Relation relation;\n+  private final Type type;\n+  private final JoinCriteria criteria;\n+  private final Optional<WithinExpression> withinExpression;\n+\n+  public JoinedSource(\n+      final Optional<NodeLocation> location,\n+      final Relation relation,\n+      final Type type,\n+      final JoinCriteria criteria,\n+      final Optional<WithinExpression> withinExpression\n+  ) {\n+    super(location);\n+    this.relation = relation;\n+    this.type = type;\n+    this.criteria = criteria;\n+    this.withinExpression = withinExpression;\n+  }\n+\n+  public Relation getRelation() {\n+    return relation;\n+  }\n+\n+  public Type getType() {\n+    return type;\n+  }\n+\n+  public JoinCriteria getCriteria() {\n+    return criteria;\n+  }\n+\n+  public Optional<WithinExpression> getWithinExpression() {\n+    return withinExpression;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    final JoinedSource that = (JoinedSource) o;\n+    return Objects.equals(relation, that.relation)\n+        && Objects.equals(type, that.type)\n+        && Objects.equals(criteria, that.criteria)\n+        && Objects.equals(withinExpression, that.withinExpression);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(relation, type, criteria, withinExpression);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"JoinedSource{\"\n+        + \"relation=\" + relation\n+        + \", type=\" + type\n+        + \", criteria=\" + criteria\n+        + \", withinExpression=\" + withinExpression\n+        + '}';\n+  }\n+\n+  public enum Type {\n+    INNER(\"INNER\"), LEFT(\"LEFT OUTER\"), OUTER(\"FULL OUTER\");\n+\n+    private final String formattedText;\n+\n+    Type(final String formattedText) {\n+      this.formattedText = Objects.requireNonNull(formattedText, \"formattedText\");\n+    }\n+\n+    public String getFormatted() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c167c4a183f779a673fdefd9b8455e5b0761d83"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d171c25f7e8adda703081d45f9c412e93915967e", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/d171c25f7e8adda703081d45f9c412e93915967e", "committedDate": "2020-03-26T16:44:51Z", "message": "chore: address andys comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c07049adeda935a694d788ad1c0ed41342108960", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/c07049adeda935a694d788ad1c0ed41342108960", "committedDate": "2020-03-26T18:07:58Z", "message": "chore: remove unused import"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4926, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}