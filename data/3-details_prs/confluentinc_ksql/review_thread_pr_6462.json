{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTAyMzc5", "number": 6462, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMDozNFrOEvcYOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNToxMToyNFrOExwJnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTgzNDgwOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMDozNFrOHkblpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMDozNFrOHkblpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2Mjc4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Where the result of the query is a stream, the response will not include the **row.key** or\n          \n          \n            \n            If the query result is a stream, the response doesn't include the **row.key** or", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r507962788", "createdAt": "2020-10-19T18:10:34Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +82,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+Where the result of the query is a stream, the response will not include the **row.key** or\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTgzNzIzOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMTowOVrOHkbnIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMTowOVrOHkbnIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2MzE2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            **row.tombstone** fields, as streams do not have primary keys.\n          \n          \n            \n            **row.tombstone** fields, because streams don't have primary keys.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r507963169", "createdAt": "2020-10-19T18:11:09Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +82,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+Where the result of the query is a stream, the response will not include the **row.key** or\r\n+**row.tombstone** fields, as streams do not have primary keys.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTg0MDM3OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMjowM1rOHkbpGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMjowM1rOHkbpGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2MzY3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Where the result of the query is a table, the response will include the primary key of each row in \n          \n          \n            \n            If the query result is a table, the response includes the primary key of each row in", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r507963675", "createdAt": "2020-10-19T18:12:03Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +82,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+Where the result of the query is a stream, the response will not include the **row.key** or\r\n+**row.tombstone** fields, as streams do not have primary keys.\r\n+\r\n+```http\r\n+HTTP/1.1 200 OK\r\n+Content-Type: application/vnd.ksql.v2+json\r\n+Transfer-Encoding: chunked\r\n+\r\n+...\r\n+{\"header\":{\"queryId\":\"_confluent_id_19\",schema\":\"`ROWTIME` BIGINT, `NAME` STRING, `AGE` INT\"}}\r\n+{\"row\":{\"columns\":[1524760769983,\"1\",1524760769747,\"alice\",\"home\"]}}\r\n+...\r\n+```\r\n+\r\n+### Example table response\r\n+\r\n+Where the result of the query is a table, the response will include the primary key of each row in \r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTg0Mzg3OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMzowMlrOHkbrPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxMzowMlrOHkbrPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2NDIyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the **row.key** field. Deletes from the result table will be identified by the **row.tombstone** \n          \n          \n            \n            the **row.key** field. Rows that are deleted from the result table are identified by the **row.tombstone**", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r507964223", "createdAt": "2020-10-19T18:13:02Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +82,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+Where the result of the query is a stream, the response will not include the **row.key** or\r\n+**row.tombstone** fields, as streams do not have primary keys.\r\n+\r\n+```http\r\n+HTTP/1.1 200 OK\r\n+Content-Type: application/vnd.ksql.v2+json\r\n+Transfer-Encoding: chunked\r\n+\r\n+...\r\n+{\"header\":{\"queryId\":\"_confluent_id_19\",schema\":\"`ROWTIME` BIGINT, `NAME` STRING, `AGE` INT\"}}\r\n+{\"row\":{\"columns\":[1524760769983,\"1\",1524760769747,\"alice\",\"home\"]}}\r\n+...\r\n+```\r\n+\r\n+### Example table response\r\n+\r\n+Where the result of the query is a table, the response will include the primary key of each row in \r\n+the **row.key** field. Deletes from the result table will be identified by the **row.tombstone** \r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTg1MTIyOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxNDo1MVrOHkbvtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoxNDo1MVrOHkbvtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2NTM2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note: media type `application/vnd.ksql.v1+json` does not populate **row.key** or return tombstone\n          \n          \n            \n            !!! note\n          \n          \n            \n                Media type `application/vnd.ksql.v1+json` does not populate **row.key** or return tombstone", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r507965366", "createdAt": "2020-10-19T18:14:51Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +82,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+Where the result of the query is a stream, the response will not include the **row.key** or\r\n+**row.tombstone** fields, as streams do not have primary keys.\r\n+\r\n+```http\r\n+HTTP/1.1 200 OK\r\n+Content-Type: application/vnd.ksql.v2+json\r\n+Transfer-Encoding: chunked\r\n+\r\n+...\r\n+{\"header\":{\"queryId\":\"_confluent_id_19\",schema\":\"`ROWTIME` BIGINT, `NAME` STRING, `AGE` INT\"}}\r\n+{\"row\":{\"columns\":[1524760769983,\"1\",1524760769747,\"alice\",\"home\"]}}\r\n+...\r\n+```\r\n+\r\n+### Example table response\r\n+\r\n+Where the result of the query is a table, the response will include the primary key of each row in \r\n+the **row.key** field. Deletes from the result table will be identified by the **row.tombstone** \r\n+field.\r\n \r\n ```http\r\n HTTP/1.1 200 OK\r\n-Content-Type: application/vnd.ksql.v1+json\r\n+Content-Type: application/vnd.ksql.v2+json\r\n Transfer-Encoding: chunked\r\n \r\n ...\r\n-{\"row\":{\"columns\":[1524760769983,\"1\",1524760769747,\"alice\",\"home\"]},\"errorMessage\":null}\r\n+{\"header\":{\"queryId\":\"_confluent_id_34\",key\":\"`ID BIGINT`\",schema\":\"`ROWTIME` BIGINT, `NAME` STRING, `AGE` INT\"}}\r\n+{\"row\":{\"key\":[10],\"columns\":[1524760769983,\"alice\",10]}},\r\n+{\"row\":{\"key\":[10],\"tombstone\":true}}\r\n ...\r\n ```\r\n \r\n+Note: media type `application/vnd.ksql.v1+json` does not populate **row.key** or return tombstone\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzY5NjA2OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MTo0M1rOHks0eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo0MzoyOVrOHnVicA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTExMw==", "bodyText": "Why not directly return boolean?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245113", "createdAt": "2020-10-20T06:41:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -218,21 +368,80 @@ public boolean equals(final Object o) {\n       }\n       final Header header = (Header) o;\n       return Objects.equals(queryId, header.queryId)\n-          && Objects.equals(schema, header.schema);\n+          && Objects.equals(keySchema, header.keySchema)\n+          && Objects.equals(columnsSchema, header.columnsSchema);\n     }\n \n     @Override\n     public int hashCode() {\n-      return Objects.hash(queryId, schema);\n+      return Objects.hash(queryId, keySchema, columnsSchema);\n+    }\n+  }\n+\n+  @JsonInclude(Include.NON_EMPTY)\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  public static final class DataRow extends BaseRow {\n+\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> key;\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> columns;\n+\n+    public static DataRow row(\n+        final Optional<List<?>> key,\n+        final List<?> columns\n+    ) {\n+      return new DataRow(key, Optional.of(columns));\n+    }\n+\n+    public static DataRow tombstone(\n+        final List<?> key\n+    ) {\n+      return new DataRow(Optional.of(key), Optional.empty());\n+    }\n+\n+\n+    public Optional<List<?>> getKey() {\n+      return key;\n+    }\n+\n+    public Optional<List<?>> getColumns() {\n+      return columns;\n+    }\n+\n+    public Optional<Boolean> getTombstone() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NjcyOA==", "bodyText": "This is about getting the JSON right. In this case we only want the tombstone in the JSON if its a tombstone row.  Returning Optional.empty means its excluded from the JSON.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508756728", "createdAt": "2020-10-20T18:41:50Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -218,21 +368,80 @@ public boolean equals(final Object o) {\n       }\n       final Header header = (Header) o;\n       return Objects.equals(queryId, header.queryId)\n-          && Objects.equals(schema, header.schema);\n+          && Objects.equals(keySchema, header.keySchema)\n+          && Objects.equals(columnsSchema, header.columnsSchema);\n     }\n \n     @Override\n     public int hashCode() {\n-      return Objects.hash(queryId, schema);\n+      return Objects.hash(queryId, keySchema, columnsSchema);\n+    }\n+  }\n+\n+  @JsonInclude(Include.NON_EMPTY)\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  public static final class DataRow extends BaseRow {\n+\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> key;\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> columns;\n+\n+    public static DataRow row(\n+        final Optional<List<?>> key,\n+        final List<?> columns\n+    ) {\n+      return new DataRow(key, Optional.of(columns));\n+    }\n+\n+    public static DataRow tombstone(\n+        final List<?> key\n+    ) {\n+      return new DataRow(Optional.of(key), Optional.empty());\n+    }\n+\n+\n+    public Optional<List<?>> getKey() {\n+      return key;\n+    }\n+\n+    public Optional<List<?>> getColumns() {\n+      return columns;\n+    }\n+\n+    public Optional<Boolean> getTombstone() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTExMw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwOTM5Mg==", "bodyText": "I think there are better ways of achieving this than using optionals, which seems a little error prone and confusing. For example JsonInclude.Include.NON_DEFAULT can be used to omit the serialization of false.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511009392", "createdAt": "2020-10-23T16:43:29Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -218,21 +368,80 @@ public boolean equals(final Object o) {\n       }\n       final Header header = (Header) o;\n       return Objects.equals(queryId, header.queryId)\n-          && Objects.equals(schema, header.schema);\n+          && Objects.equals(keySchema, header.keySchema)\n+          && Objects.equals(columnsSchema, header.columnsSchema);\n     }\n \n     @Override\n     public int hashCode() {\n-      return Objects.hash(queryId, schema);\n+      return Objects.hash(queryId, keySchema, columnsSchema);\n+    }\n+  }\n+\n+  @JsonInclude(Include.NON_EMPTY)\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  public static final class DataRow extends BaseRow {\n+\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> key;\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> columns;\n+\n+    public static DataRow row(\n+        final Optional<List<?>> key,\n+        final List<?> columns\n+    ) {\n+      return new DataRow(key, Optional.of(columns));\n+    }\n+\n+    public static DataRow tombstone(\n+        final List<?> key\n+    ) {\n+      return new DataRow(Optional.of(key), Optional.empty());\n+    }\n+\n+\n+    public Optional<List<?>> getKey() {\n+      return key;\n+    }\n+\n+    public Optional<List<?>> getColumns() {\n+      return columns;\n+    }\n+\n+    public Optional<Boolean> getTombstone() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTExMw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzY5NzAxOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MTo1OVrOHks1Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MTo1OVrOHks1Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTI3MQ==", "bodyText": "This should be marked as new as of v2.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245271", "createdAt": "2020-10-20T06:41:59Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -28,18 +28,38 @@ Each response chunk is a JSON object with the following format:\n \r\n Response JSON Object:\r\n \r\n+- **header** (object): Information about the result.\r\n+    - **header.queryId**: (string): the unique id of the query. This can be useful when debugging. \r\n+    For example, when looking in the logs or processing log for errors or issues.\r\n+    - **header.key**: (string)(since v2): the list of key columns, if the result is a table. \r\n+    This defines the schema for the data returned later in **row.key**. \r\n+    - **header.schema**: (string): the list of columns being returned. This defines the schema for \r\n+    the data returned later in **row.columns**.  \r\n - **row** (object): A single row being returned. This will be null if an error is being returned.\r\n-- **row.columns** (array): The values contained in the row.\r\n-- **row.columns[i]** (?): The value contained in a single column for the row. The value type depends on the type of the column.\r\n-- **finalMessage** (string): If this field is non-null, it contains a final message from the server. No additional rows will be returned and the server will end the response.\r\n-- **errorMessage** (string): If this field is non-null, an error has been encountered while running the statement. No additional rows are returned and the server will end the response.\r\n+    - **row.key** (array): If the data being returned is a table, the primary key of the row.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzY5ODQ1OnYy", "diffSide": "RIGHT", "path": "ksqldb-cli/src/test/java/io/confluent/ksql/cli/console/ConsoleTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MjozMVrOHks17A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MjozMVrOHks17A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTQ4NA==", "bodyText": "Looks like something was meant to be here but was forgotten. Perhaps check that <TOMBSTONE> is present?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245484", "createdAt": "2020-10-20T06:42:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-cli/src/test/java/io/confluent/ksql/cli/console/ConsoleTest.java", "diffHunk": "@@ -187,24 +187,58 @@ public void after() {\n   }\n \n   @Test\n-  public void testPrintGenericStreamedRow() {\n+  public void testPrintStreamRow() {\n     // Given:\n-    final StreamedRow row = StreamedRow.row(genericRow(\"col_1\", \"col_2\"));\n+    final StreamedRow row = StreamedRow.streamRow(genericRow(\"col_1\", \"col_2\"));\n \n     // When:\n     console.printStreamedRow(row);\n \n     // Then:\n+    assertThat(terminal.getOutputString(), containsString(\"col_1\"));\n+    assertThat(terminal.getOutputString(), containsString(\"col_2\"));\n+  }\n+\n+  @Test\n+  public void testPrintTableRow() {\n+    // Given:\n+    final StreamedRow row = StreamedRow.tableRow(ImmutableList.of(\"k_0\"), genericRow(\"col_1\", \"col_2\"));\n+\n+    // When:\n+    console.printStreamedRow(row);\n+\n+    // Then:\n+    if (console.getOutputFormat() != OutputFormat.TABULAR) {\n+      assertThat(terminal.getOutputString(), containsString(\"k_0\"));\n+    }\n+    assertThat(terminal.getOutputString(), containsString(\"col_1\"));\n+    assertThat(terminal.getOutputString(), containsString(\"col_2\"));\n+  }\n+\n+  @Test\n+  public void testPrintTableTombstone() {\n+    // Given:\n+    console.printStreamedRow(StreamedRow.pushHeader(new QueryId(\"id\"), SCHEMA.key(), SCHEMA.value()));\n+\n+    final StreamedRow row = StreamedRow.tombstone(ImmutableList.of(\"k_0\"));\n+\n+    // When:\n+    console.printStreamedRow(row);\n+\n+    // Then:\n+    assertThat(terminal.getOutputString(), containsString(\"k_0\"));\n+\n     if (console.getOutputFormat() == OutputFormat.TABULAR) {\n-      assertThat(terminal.getOutputString(), containsString(\"col_1\"));\n-      assertThat(terminal.getOutputString(), containsString(\"col_2\"));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzcwMDg3OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/KsqlBareOutputNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MzoyM1rOHks3aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0Mjo1M1rOHlMGvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTg2NA==", "bodyText": "To check my understanding: the reason this PR adds window info into the output node is so the window info can be printed as part of the key?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245864", "createdAt": "2020-10-20T06:43:23Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/KsqlBareOutputNode.java", "diffHunk": "@@ -15,25 +15,32 @@\n \n package io.confluent.ksql.planner.plan;\n \n+import static java.util.Objects.requireNonNull;\n+\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.timestamp.TimestampColumn;\n import io.confluent.ksql.name.SourceName;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.WindowInfo;\n import io.confluent.ksql.structured.SchemaKStream;\n import java.util.Optional;\n import java.util.OptionalInt;\n \n @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n public class KsqlBareOutputNode extends OutputNode {\n \n+  private final Optional<WindowInfo> windowInfo;\n+\n   public KsqlBareOutputNode(\n       final PlanNodeId id,\n       final PlanNode source,\n       final LogicalSchema schema,\n       final OptionalInt limit,\n-      final Optional<TimestampColumn> timestampColumn\n+      final Optional<TimestampColumn> timestampColumn,\n+      final Optional<WindowInfo> windowInfo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NzY5NQ==", "bodyText": "It's needed so that the key schema, returned at the start of a push query, can include the window bounds columns for windowed results.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508757695", "createdAt": "2020-10-20T18:42:53Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/KsqlBareOutputNode.java", "diffHunk": "@@ -15,25 +15,32 @@\n \n package io.confluent.ksql.planner.plan;\n \n+import static java.util.Objects.requireNonNull;\n+\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.timestamp.TimestampColumn;\n import io.confluent.ksql.name.SourceName;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.WindowInfo;\n import io.confluent.ksql.structured.SchemaKStream;\n import java.util.Optional;\n import java.util.OptionalInt;\n \n @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n public class KsqlBareOutputNode extends OutputNode {\n \n+  private final Optional<WindowInfo> windowInfo;\n+\n   public KsqlBareOutputNode(\n       final PlanNodeId id,\n       final PlanNode source,\n       final LogicalSchema schema,\n       final OptionalInt limit,\n-      final Optional<TimestampColumn> timestampColumn\n+      final Optional<TimestampColumn> timestampColumn,\n+      final Optional<WindowInfo> windowInfo", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTg2NA=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzcwMTUwOnYy", "diffSide": "RIGHT", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/StructKeyUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MzozN1rOHks30w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MzozN1rOHks30w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTk3MQ==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IllegalArgumentException(\"None struct key: \" + key);\n          \n          \n            \n                  throw new IllegalArgumentException(\"Non struct key: \" + key);", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245971", "createdAt": "2020-10-20T06:43:37Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/StructKeyUtil.java", "diffHunk": "@@ -55,6 +58,40 @@ public static KeyBuilder keyBuilder(final ColumnName name, final SqlType type) {\n     );\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n+  public static List<?> asList(final Object key) {\n+    final Optional<Windowed<Object>> windowed = key instanceof Windowed\n+        ? Optional.of((Windowed<Object>) key)\n+        : Optional.empty();\n+\n+    final Object naturalKey = windowed\n+        .map(Windowed::key)\n+        .orElse(key);\n+\n+    if (naturalKey != null && !(naturalKey instanceof Struct)) {\n+      throw new IllegalArgumentException(\"None struct key: \" + key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzcwNzExOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/spi/QueryPublisher.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0NToxNVrOHks7Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowNjozOFrOHlNA2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjgwMw==", "bodyText": "How come we use List<?> for the key type and GenericRow for the value type throughout this PR? Isn't GenericRow essentially just a wrapper around List<?>? Wondering what motivates the inconsistency here.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508246803", "createdAt": "2020-10-20T06:45:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/spi/QueryPublisher.java", "diffHunk": "@@ -24,7 +25,7 @@\n  * query that is executed. A subscriber from the API implementation then subscribes to it, then a\n  * stream of query results flows from back-end to front-end where they are written to the wire.\n  */\n-public interface QueryPublisher extends Publisher<GenericRow> {\n+public interface QueryPublisher extends Publisher<KeyValue<List<?>, GenericRow>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTMwMw==", "bodyText": "Not sure I follow...\nI you suggesting we should have KeyValue<GenericRow, GenericRow>?  That would obviously be wrong, as the key shouldn't be represented by GenericRow.\nOr maybe KeyValue<List<?>, List<?>>?  We could do this, but that's changing more code.  The PR just adds the key, (which is just a list of values), and leaves the value as it was.   We could switch the GenericRow to List<?>, but... out of scope...", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508761303", "createdAt": "2020-10-20T18:46:59Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/spi/QueryPublisher.java", "diffHunk": "@@ -24,7 +25,7 @@\n  * query that is executed. A subscriber from the API implementation then subscribes to it, then a\n  * stream of query results flows from back-end to front-end where they are written to the wire.\n  */\n-public interface QueryPublisher extends Publisher<GenericRow> {\n+public interface QueryPublisher extends Publisher<KeyValue<List<?>, GenericRow>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjgwMw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MjU2OA==", "bodyText": "I think I see the difference now... while it's true that GenericRow essentially just wraps List<?>, the interpretation of the list elements in GenericRow is that each element represents a column, which is a dubious interpretation for the key since today the key is either a single column or three columns (single, primary column plus window start and end). Is that the reason you say KeyValue<GenericRow, GenericRow> would be incorrect?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508772568", "createdAt": "2020-10-20T19:06:38Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/spi/QueryPublisher.java", "diffHunk": "@@ -24,7 +25,7 @@\n  * query that is executed. A subscriber from the API implementation then subscribes to it, then a\n  * stream of query results flows from back-end to front-end where they are written to the wire.\n  */\n-public interface QueryPublisher extends Publisher<GenericRow> {\n+public interface QueryPublisher extends Publisher<KeyValue<List<?>, GenericRow>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjgwMw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzcwNzk1OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0NTozMlrOHks7mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowODoyNFrOHlNE2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw==", "bodyText": "nit: can we rename this to something more meaningful?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508246937", "createdAt": "2020-10-20T06:45:32Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -54,11 +61,13 @@\n       final TransientQueryMetadata queryMetadata,\n       final long disconnectCheckInterval,\n       final ObjectMapper objectMapper,\n-      final CompletableFuture<Void> connectionClosedFuture\n+      final CompletableFuture<Void> connectionClosedFuture,\n+      final boolean oldFormat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTQ1MA==", "bodyText": "suggestions?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508761450", "createdAt": "2020-10-20T18:47:16Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -54,11 +61,13 @@\n       final TransientQueryMetadata queryMetadata,\n       final long disconnectCheckInterval,\n       final ObjectMapper objectMapper,\n-      final CompletableFuture<Void> connectionClosedFuture\n+      final CompletableFuture<Void> connectionClosedFuture,\n+      final boolean oldFormat", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2NzAyNw==", "bodyText": "Gone with v1Format. Not sure it's any better.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508767027", "createdAt": "2020-10-20T18:57:02Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -54,11 +61,13 @@\n       final TransientQueryMetadata queryMetadata,\n       final long disconnectCheckInterval,\n       final ObjectMapper objectMapper,\n-      final CompletableFuture<Void> connectionClosedFuture\n+      final CompletableFuture<Void> connectionClosedFuture,\n+      final boolean oldFormat", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MzU5NQ==", "bodyText": "Definitely better. Thanks!", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508773595", "createdAt": "2020-10-20T19:08:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -54,11 +61,13 @@\n       final TransientQueryMetadata queryMetadata,\n       final long disconnectCheckInterval,\n       final ObjectMapper objectMapper,\n-      final CompletableFuture<Void> connectionClosedFuture\n+      final CompletableFuture<Void> connectionClosedFuture,\n+      final boolean oldFormat", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzcxMTQ1OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0Njo0NlrOHks9xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0ODo1MVrOHlMY6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzQ5NQ==", "bodyText": "I'm a bit confused about what media types are accepted for the websocket endpoint. Is only v1 accepted, or is v2 also accepted but v2 functions the same as v1? I thought the former but I don't see any check here to fail on v2.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508247495", "createdAt": "2020-10-20T06:46:46Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "diffHunk": "@@ -217,16 +217,16 @@ public void executeStreamQuery(final ServerWebSocket webSocket, final MultiMap r\n     }\n   }\n \n-  private void validateVersion(final MultiMap requestParams) {\n-\n-    final String version = requestParams.get(Versions.KSQL_V1_WS_PARAM);\n-\n+  private static void validateVersion(final MultiMap requestParams) {\n+    final String version = requestParams.get(\"version\");\n     if (version == null) {\n       return;\n     }\n \n-    if (!Versions.KSQL_V1_WS.equals(version)) {\n-      throw new IllegalArgumentException(\"Received invalid api version: \" + version);\n+    try {\n+      KsqlMediaType.valueOf(\"JSON\", Integer.parseInt(version));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjM0Ng==", "bodyText": "I'm a bit confused about what media types are accepted for the websocket endpoint.\n\nThis is defined in ServerVerticle: currently only V1.   #6439 will add V2.\n\nalso accepted but v2 functions the same as v1?\n\nYou've lost me...", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508762346", "createdAt": "2020-10-20T18:48:51Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "diffHunk": "@@ -217,16 +217,16 @@ public void executeStreamQuery(final ServerWebSocket webSocket, final MultiMap r\n     }\n   }\n \n-  private void validateVersion(final MultiMap requestParams) {\n-\n-    final String version = requestParams.get(Versions.KSQL_V1_WS_PARAM);\n-\n+  private static void validateVersion(final MultiMap requestParams) {\n+    final String version = requestParams.get(\"version\");\n     if (version == null) {\n       return;\n     }\n \n-    if (!Versions.KSQL_V1_WS.equals(version)) {\n-      throw new IllegalArgumentException(\"Received invalid api version: \" + version);\n+    try {\n+      KsqlMediaType.valueOf(\"JSON\", Integer.parseInt(version));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzQ5NQ=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzcxNDE3OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0Nzo0M1rOHks_ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0OToxNVrOHlMZrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzkwOA==", "bodyText": "Read this a few times but I'm still not understanding this comment. (The two lines below make sense but I can't parse Type used Logical Schema to serialize key columns. in a meaningful way.)", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508247908", "createdAt": "2020-10-20T06:47:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -181,31 +269,93 @@ private static void checkUnion(final Optional<?>... fs) {\n   }\n \n   @Immutable\n+  public abstract static class BaseRow {\n+\n+    @Override\n+    public String toString() {\n+      try {\n+        return OBJECT_MAPPER.writeValueAsString(this);\n+      } catch (final JsonProcessingException e) {\n+        return super.toString();\n+      }\n+    }\n+  }\n+\n+  // Note: Type used `LogicalSchema` as a cheeky way of (de)serializing lists of columns.\n+  @JsonInclude(Include.NON_EMPTY)\n   @JsonIgnoreProperties(ignoreUnknown = true)\n-  public static final class Header {\n+  public static final class Header extends BaseRow {\n \n     private final QueryId queryId;\n-    private final LogicalSchema schema;\n+    private final Optional<ImmutableList<SimpleColumn>> keySchema;\n+    private final LogicalSchema columnsSchema;\n \n-    @JsonCreator\n     public static Header of(\n-        @JsonProperty(value = \"queryId\", required = true) final QueryId queryId,\n-        @JsonProperty(value = \"schema\", required = true) final LogicalSchema schema\n+        final QueryId queryId,\n+        final Optional<List<? extends SimpleColumn>> key,\n+        final LogicalSchema columnsSchema\n     ) {\n-      return new Header(queryId, schema);\n+      final Optional<List<? extends SimpleColumn>> keySchema = key\n+          .map(k -> LogicalSchema.builder().valueColumns(k).build())\n+          .map(LogicalSchema::columns);\n+\n+      return new Header(queryId, keySchema, columnsSchema);\n     }\n \n     public QueryId getQueryId() {\n       return queryId;\n     }\n \n-    public LogicalSchema getSchema() {\n-      return schema;\n+    /**\n+     * Used for push queries to return the schema of the key columns.\n+     *\n+     * <p>Note: The columns that make up the key may or may not be present in the projection, i.e.\n+     * in the {@link #getColumnsSchema()}.\n+     *\n+     * @return the columns that make up the key.\n+     */\n+    @JsonIgnore\n+    public Optional<List<SimpleColumn>> getKeySchema() {\n+      return keySchema.map(v -> v);\n     }\n \n-    private Header(final QueryId queryId, final LogicalSchema schema) {\n+    /**\n+     * @return The schema of the columns being returned by the query.\n+     */\n+    @JsonProperty(\"schema\")\n+    public LogicalSchema getColumnsSchema() {\n+      return columnsSchema;\n+    }\n+\n+    @JsonProperty(\"key\")\n+    @SuppressWarnings(\"unused\") // Invoked by reflection by Jackson.\n+    private Optional<LogicalSchema> getSerializedKeySchema() {\n+      // Type used Logical Schema to serialize key columns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjU0Mg==", "bodyText": "I'll update.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508762542", "createdAt": "2020-10-20T18:49:15Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -181,31 +269,93 @@ private static void checkUnion(final Optional<?>... fs) {\n   }\n \n   @Immutable\n+  public abstract static class BaseRow {\n+\n+    @Override\n+    public String toString() {\n+      try {\n+        return OBJECT_MAPPER.writeValueAsString(this);\n+      } catch (final JsonProcessingException e) {\n+        return super.toString();\n+      }\n+    }\n+  }\n+\n+  // Note: Type used `LogicalSchema` as a cheeky way of (de)serializing lists of columns.\n+  @JsonInclude(Include.NON_EMPTY)\n   @JsonIgnoreProperties(ignoreUnknown = true)\n-  public static final class Header {\n+  public static final class Header extends BaseRow {\n \n     private final QueryId queryId;\n-    private final LogicalSchema schema;\n+    private final Optional<ImmutableList<SimpleColumn>> keySchema;\n+    private final LogicalSchema columnsSchema;\n \n-    @JsonCreator\n     public static Header of(\n-        @JsonProperty(value = \"queryId\", required = true) final QueryId queryId,\n-        @JsonProperty(value = \"schema\", required = true) final LogicalSchema schema\n+        final QueryId queryId,\n+        final Optional<List<? extends SimpleColumn>> key,\n+        final LogicalSchema columnsSchema\n     ) {\n-      return new Header(queryId, schema);\n+      final Optional<List<? extends SimpleColumn>> keySchema = key\n+          .map(k -> LogicalSchema.builder().valueColumns(k).build())\n+          .map(LogicalSchema::columns);\n+\n+      return new Header(queryId, keySchema, columnsSchema);\n     }\n \n     public QueryId getQueryId() {\n       return queryId;\n     }\n \n-    public LogicalSchema getSchema() {\n-      return schema;\n+    /**\n+     * Used for push queries to return the schema of the key columns.\n+     *\n+     * <p>Note: The columns that make up the key may or may not be present in the projection, i.e.\n+     * in the {@link #getColumnsSchema()}.\n+     *\n+     * @return the columns that make up the key.\n+     */\n+    @JsonIgnore\n+    public Optional<List<SimpleColumn>> getKeySchema() {\n+      return keySchema.map(v -> v);\n     }\n \n-    private Header(final QueryId queryId, final LogicalSchema schema) {\n+    /**\n+     * @return The schema of the columns being returned by the query.\n+     */\n+    @JsonProperty(\"schema\")\n+    public LogicalSchema getColumnsSchema() {\n+      return columnsSchema;\n+    }\n+\n+    @JsonProperty(\"key\")\n+    @SuppressWarnings(\"unused\") // Invoked by reflection by Jackson.\n+    private Optional<LogicalSchema> getSerializedKeySchema() {\n+      // Type used Logical Schema to serialize key columns.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzkwOA=="}, "originalCommit": {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjAyNTU5OnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1NjoyNlrOHoA5ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1NjoyNlrOHoA5ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcxOTc4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                - **row.tombstone** (boolean): the row is a deletion of a previously row.\n          \n          \n            \n                - **row.tombstone** (boolean): Whether the row is a deletion of a previous row.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511719781", "createdAt": "2020-10-26T04:56:26Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -28,18 +28,32 @@ Each response chunk is a JSON object with the following format:\n \r\n Response JSON Object:\r\n \r\n+- **header** (object): Information about the result.\r\n+    - **header.queryId**: (string): the unique id of the query. This can be useful when debugging. \r\n+    For example, when looking in the logs or processing log for errors or issues.\r\n+    - **header.schema**: (string): the list of columns being returned. This defines the schema for \r\n+    the data returned later in **row.columns**.  \r\n - **row** (object): A single row being returned. This will be null if an error is being returned.\r\n-- **row.columns** (array): The values contained in the row.\r\n-- **row.columns[i]** (?): The value contained in a single column for the row. The value type depends on the type of the column.\r\n-- **finalMessage** (string): If this field is non-null, it contains a final message from the server. No additional rows will be returned and the server will end the response.\r\n-- **errorMessage** (string): If this field is non-null, an error has been encountered while running the statement. No additional rows are returned and the server will end the response.\r\n+    - **row.columns** (array): The values of the columns requested. The schema of the columns was\r\n+    already supplied in **header.schema**.\r\n+    - **row.tombstone** (boolean): the row is a deletion of a previously row.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjAyNjIxOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1Njo1NlrOHoA5wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjowOTowOFrOHsLD3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcxOTg3Mg==", "bodyText": "This is out of date in the newest version of this PR and should be removed. Same with the sentence below that mentions v2 of the API.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511719872", "createdAt": "2020-10-26T04:56:56Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -28,18 +28,32 @@ Each response chunk is a JSON object with the following format:\n \r\n Response JSON Object:\r\n \r\n+- **header** (object): Information about the result.\r\n+    - **header.queryId**: (string): the unique id of the query. This can be useful when debugging. \r\n+    For example, when looking in the logs or processing log for errors or issues.\r\n+    - **header.schema**: (string): the list of columns being returned. This defines the schema for \r\n+    the data returned later in **row.columns**.  \r\n - **row** (object): A single row being returned. This will be null if an error is being returned.\r\n-- **row.columns** (array): The values contained in the row.\r\n-- **row.columns[i]** (?): The value contained in a single column for the row. The value type depends on the type of the column.\r\n-- **finalMessage** (string): If this field is non-null, it contains a final message from the server. No additional rows will be returned and the server will end the response.\r\n-- **errorMessage** (string): If this field is non-null, an error has been encountered while running the statement. No additional rows are returned and the server will end the response.\r\n+    - **row.columns** (array): The values of the columns requested. The schema of the columns was\r\n+    already supplied in **header.schema**.\r\n+    - **row.tombstone** (boolean): the row is a deletion of a previously row.\r\n+    The **row.key** field contains the unique key of the row that has been deleted.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MDYwNQ==", "bodyText": "Good catch.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r516080605", "createdAt": "2020-11-02T16:09:08Z", "author": {"login": "big-andy-coates"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -28,18 +28,32 @@ Each response chunk is a JSON object with the following format:\n \r\n Response JSON Object:\r\n \r\n+- **header** (object): Information about the result.\r\n+    - **header.queryId**: (string): the unique id of the query. This can be useful when debugging. \r\n+    For example, when looking in the logs or processing log for errors or issues.\r\n+    - **header.schema**: (string): the list of columns being returned. This defines the schema for \r\n+    the data returned later in **row.columns**.  \r\n - **row** (object): A single row being returned. This will be null if an error is being returned.\r\n-- **row.columns** (array): The values contained in the row.\r\n-- **row.columns[i]** (?): The value contained in a single column for the row. The value type depends on the type of the column.\r\n-- **finalMessage** (string): If this field is non-null, it contains a final message from the server. No additional rows will be returned and the server will end the response.\r\n-- **errorMessage** (string): If this field is non-null, an error has been encountered while running the statement. No additional rows are returned and the server will end the response.\r\n+    - **row.columns** (array): The values of the columns requested. The schema of the columns was\r\n+    already supplied in **header.schema**.\r\n+    - **row.tombstone** (boolean): the row is a deletion of a previously row.\r\n+    The **row.key** field contains the unique key of the row that has been deleted.\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcxOTg3Mg=="}, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjAyNzczOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1ODoxM1rOHoA6nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1ODoxM1rOHoA6nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMDA5Mw==", "bodyText": "There is no row.key field ever now, right?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511720093", "createdAt": "2020-10-26T04:58:13Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +76,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+If the query result is a stream, the response doesn't include the **row.key** or\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjAyODUwOnYy", "diffSide": "RIGHT", "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1ODo0NlrOHoA6_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNDo1ODo0NlrOHoA6_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMDE4OA==", "bodyText": "There is no row.key field now, right?", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511720188", "createdAt": "2020-10-26T04:58:46Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/ksqldb-rest-api/query-endpoint.md", "diffHunk": "@@ -62,15 +76,40 @@ Content-Type: application/vnd.ksql.v1+json\n }\r\n ```\r\n \r\n-### Example response\r\n+### Example stream response\r\n+\r\n+If the query result is a stream, the response doesn't include the **row.key** or\r\n+\r\n+**row.tombstone** fields, because streams don't have primary keys.\r\n+\r\n \r\n ```http\r\n HTTP/1.1 200 OK\r\n Content-Type: application/vnd.ksql.v1+json\r\n Transfer-Encoding: chunked\r\n \r\n ...\r\n-{\"row\":{\"columns\":[1524760769983,\"1\",1524760769747,\"alice\",\"home\"]},\"errorMessage\":null}\r\n+{\"header\":{\"queryId\":\"_confluent_id_19\",schema\":\"`ROWTIME` BIGINT, `NAME` STRING, `AGE` INT\"}}\r\n+{\"row\":{\"columns\":[1524760769983,\"1\",1524760769747,\"alice\",\"home\"]}}\r\n ...\r\n ```\r\n \r\n+### Example table response\r\n+\r\n+If the query result is a table, the response includes the primary key of each row in\r\n+\r\n+the **row.key** field. Rows that are deleted from the result table are identified by the **row.tombstone** \r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjAzNjQ4OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTowNDozNlrOHoA_WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTowNDozNlrOHoA_WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMTMwNQ==", "bodyText": "This comment is out of date.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511721305", "createdAt": "2020-10-26T05:04:36Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -147,62 +148,63 @@ private Router setupRouter() {\n     // ----------------------------------------------\n \n     router.route(HttpMethod.GET, \"/\")\n-        .handler(this::handleInfoRedirect);\n+        .handler(ServerVerticle::handleInfoRedirect);\n     router.route(HttpMethod.POST, \"/ksql\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleKsqlRequest);\n     router.route(HttpMethod.POST, \"/ksql/terminate\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleTerminateRequest);\n     router.route(HttpMethod.POST, \"/query\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleQueryRequest);\n     router.route(HttpMethod.GET, \"/info\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleInfoRequest);\n     router.route(HttpMethod.POST, \"/heartbeat\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleHeartbeatRequest);\n     router.route(HttpMethod.GET, \"/clusterStatus\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleClusterStatusRequest);\n     router.route(HttpMethod.GET, \"/status/:type/:entity/:action\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleStatusRequest);\n     router.route(HttpMethod.GET, \"/status\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleAllStatusesRequest);\n     router.route(HttpMethod.POST, \"/lag\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleLagReportRequest);\n     router.route(HttpMethod.GET, \"/healthcheck\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleHealthcheckRequest);\n     router.route(HttpMethod.GET, \"/v1/metadata\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleServerMetadataRequest);\n     router.route(HttpMethod.GET, \"/v1/metadata/id\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleServerMetadataClusterIdRequest);\n     router.route(HttpMethod.GET, \"/ws/query\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n+        // No support yet for V2. See https://github.com/confluentinc/ksql/issues/6439.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjA0NTczOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNToxMToyNFrOHoBEgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjozNTowNFrOHsMNCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMjYyNg==", "bodyText": "Now that we're no longer returning the key as part of the API, is there any point in continuing to pipe it in? I'm wondering if these changes can be removed, along with KeyValue and StructKeyUtil#asList.", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511722626", "createdAt": "2020-10-26T05:11:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -124,14 +126,22 @@ public synchronized void close() {\n   }\n \n   private StreamedRow buildHeader() {\n+    final QueryId queryId = queryMetadata.getQueryId();\n+\n     // Push queries only return value columns, but query metadata schema includes key and meta:\n     final LogicalSchema storedSchema = queryMetadata.getLogicalSchema();\n \n-    final Builder actualSchemaBuilder = LogicalSchema.builder();\n+    final Builder projectionSchema = LogicalSchema.builder();\n+\n+    storedSchema.value().forEach(projectionSchema::valueColumn);\n \n-    storedSchema.value().forEach(actualSchemaBuilder::valueColumn);\n+    return StreamedRow.header(queryId, projectionSchema.build());\n+  }\n \n-    return StreamedRow.header(NO_QUERY_ID, actualSchemaBuilder.build());\n+  private StreamedRow buildRow(final KeyValue<List<?>, GenericRow> row) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5OTMzNg==", "bodyText": "We still need the key.\nDeletes will come through with row.value as null.   The code then needs to build a new GenericRow to send to the client using row.key.  For example, consider these two key-values, where the second represents a deletion of the first:\n-- Given query, where ID is the primary key:\nSELECT ID, COL0 FROM FOO EMIT CHANGES;\n\n\n\nkey\nvalue\n\n\n\n\n10\n[10, 1]\n\n\n10\nnull\n\n\n\nThe code needs to translate the above two key-values posted to the blocking queue into a GenericRow that can be sent to the client.  When the value is not null we can just send the value. However, when value is null we must build a new GenericRow with any primary key columns set, which in this case would be [10, null].\nOnce all three APIs are handling tombstones we should be able to move this logic to the producing side of the queue and just queue the StreamedRow, e.g. we'd just queue:\n\n\n\nvalue\n\n\n\n\n{\"columns\": [10,1]\"}\n\n\n{\"columns\": [10,null]\", \"tombstone\": true}", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r516099336", "createdAt": "2020-11-02T16:35:04Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -124,14 +126,22 @@ public synchronized void close() {\n   }\n \n   private StreamedRow buildHeader() {\n+    final QueryId queryId = queryMetadata.getQueryId();\n+\n     // Push queries only return value columns, but query metadata schema includes key and meta:\n     final LogicalSchema storedSchema = queryMetadata.getLogicalSchema();\n \n-    final Builder actualSchemaBuilder = LogicalSchema.builder();\n+    final Builder projectionSchema = LogicalSchema.builder();\n+\n+    storedSchema.value().forEach(projectionSchema::valueColumn);\n \n-    storedSchema.value().forEach(actualSchemaBuilder::valueColumn);\n+    return StreamedRow.header(queryId, projectionSchema.build());\n+  }\n \n-    return StreamedRow.header(NO_QUERY_ID, actualSchemaBuilder.build());\n+  private StreamedRow buildRow(final KeyValue<List<?>, GenericRow> row) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMjYyNg=="}, "originalCommit": {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2535, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}