{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMTcyMjY4", "number": 6717, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjowMzowNVrOFA3gig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjowMzowNVrOFA3gig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDUzNzcwOnYy", "diffSide": "RIGHT", "path": "docs/index.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjowMzowNVrOH_XWJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjowNTo0NFrOH_Xc1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIwNDgzNw==", "bodyText": "I feel like something at this hints more at the overview nature of the blog post. Looking at the text alone, I thought the link was going to be something like the syntax guide.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  <li><a href=\"https://www.confluent.io/blog/how-real-time-stream-processing-works-with-ksqldb/\">The SQL language</a></li>\n          \n          \n            \n                  <li><a href=\"https://www.confluent.io/blog/how-real-time-stream-processing-works-with-ksqldb/\">Stream processing with SQL</a></li>", "url": "https://github.com/confluentinc/ksql/pull/6717#discussion_r536204837", "createdAt": "2020-12-04T16:03:05Z", "author": {"login": "colinhicks"}, "path": "docs/index.md", "diffHunk": "@@ -6,172 +6,94 @@ description: Learn about ksqlDB, the event streaming database for creating strea\n keywords: ksqldb\n ---\n \n-## What is ksqlDB?\n-\n-ksqlDB is an event streaming database purpose-built to help developers create\n+[ksqlDB](https://ksqldb.io/) is an event streaming database purpose-built to help developers create\n stream processing applications on top of {{ site.aktm }}.\n \n-\n-## Why use ksqlDB to build stream processing applications?\n-\n-In today\u2019s world, applications that leverage stream processing need a\n-heavyweight architecture that requires integrating several distributed\n-systems together. These architectures often include a fleet of connectors\n-or agents for acquiring events from the outside world, durable storage to house\n-these events, a stream processing framework for processing the events, and a\n-database to serve aggregations of events to applications.\n-\n-![Diagram of a streaming architecture that doesn't use ksqlDB](img/streaming-architecture-without-ksqldb-desat.png)\n-\n-Unfortunately, the parts don't fit together as well as you'd hope; all of these\n-systems are complex, and each integration is a small project to figure out.\n-It's like trying to build a car out of parts, but the parts come from different\n-manufacturers who don't talk to each other.\n-\n-It shouldn't be this difficult to build stream processing applications.\n-\n-ksqlDB greatly reduces the operational complexity required to build stream\n-processing applications, which enables you to build real-time systems without\n-requiring significant time and overhead. It combines the power of real-time\n-stream processing with the approachable feel of a database, through\n-a familiar, lightweight SQL syntax. And because ksqlDB is natively powered by\n-{{ site.aktm }}, it seamlessly leverages the underlying, battle-tested event\n-streaming platform.\n-\n-![Diagram of ksqlDB architecure](img/ksqldb-architecture.png)\n-\n-## What are the components of ksqlDB?\n-\n-These are the core categories that are foundational to building an app:\n-collections, materialized views, and queries.\n-\n-### Collections\n-\n-Collections provide durable storage for sequences of events. ksqlDB offers\n-two kinds of collections: streams and tables. Both operate under a simple\n-key/value model. \n-\n-- **Streams** are immutable, append-only collections. They're useful for\n-  representing a series of historical facts. Adding multiple events with the\n-  same key means that they are simply appended to the end of the stream.\n-- **Tables** are mutable collections. They let you represent the latest version\n-  of each value per key. They're helpful for modeling change over time, and\n-  they're often used to represent aggregations.\n-\n-Because ksqlDB leverages {{ site.ak }} for its storage layer, creating a new\n-collection equates to defining a stream or a table over a {{ site.aktm }}\n-topic. You can declare a collection over an existing topic, or ksqlDB can\n-create a new topic for the collection at declaration time. For more information,\n-see [Collections](concepts/collections/index.md).\n-\n-### Materialized Views\n-\n-Materialized views are derived representations of streams or tables. They\n-enable you to create new collections over existing streams or tables.\n-Materialized views are perpetually kept up to date as new events arrive. This\n-means that you can chain materialized views together to create many\n-representations of the same data. Materialized views are especially useful for\n-maintaining aggregated tables of data. For more information,\n-see [Materialized Views](concepts/materialized-views.md).\n-\n-### Queries\n-\n-While materialized views allow you to maintain state, queries enable you to\n-access these materializations from applications or microservices. Applications\n-can query materialized views with *pull queries* and *push queries*.\n-\n-- **Pull queries** enable you to fetch the current state of a materialized view.\n-  Because materialized views are updated incrementally as new events arrive,\n-  pull queries run with predictably low latency. They're a good fit for\n-  request/response flows.\n-- **Push queries** enable you to subscribe to materialized view updates and\n-  stream changes. When new events arrive, push queries emit refinements, so\n-  your event streaming applications can react to new information in real-time.\n-  They\u2019re a good fit for asynchronous application flows.\n-\n-## What Can I Do With ksqlDB?\n-\n-### Streaming ETL\n-    \n-Apache Kafka is a popular choice for powering data pipelines. ksqlDB\n-makes it simple to transform data within the pipeline, readying\n-messages to cleanly land in another system.\n-\n-### Real-time Monitoring and Analytics\n-\n-Track, understand, and manage infrastructure, applications, and data\n-feeds by quickly building real-time dashboards, generating metrics,\n-and creating custom alerts and messages.\n-\n-### Data exploration and discovery\n-\n-Navigate and browse through your data in {{ site.ak }}.\n-\n-### Anomaly detection\n-\n-Identify patterns and spot anomalies in real-time data with\n-millisecond latency, enabling you to properly surface out-of-the-ordinary\n-events and to handle fraudulent activities separately.\n-\n-### Personalization\n-\n-Create data driven real-time experiences and insight for users.\n-\n-### Sensor data and IoT\n-\n-Understand and deliver sensor data how and where it needs to be.\n-\n-### Customer 360-view\n-\n-Achieve a comprehensive understanding of your customers across every\n-interaction through a variety of channels, where new information is\n-continuously incorporated in real-time.\n-\n-## How does it fit in my architecture?\n-\n-![](img/ksqldb-architecture-and-components.png)\n-\n-ksqlDB servers, clients, queries, and applications run outside of {{ site.ak }}\n-brokers, in separate JVM instances, or in completely separate clusters.\n-\n-### ksqlDB Server\n-\n-The ksqlDB server runs the engine that executes SQL queries. This\n-includes processing, reading, and writing data to and from the\n-target {{ site.ak }} cluster.\n-\n-ksqlDB servers form ksqlDB clusters and can run in containers, virtual\n-machines, and bare-metal machines. You can add and remove servers\n-to/from the same ksqlDB cluster during live operations to scale ksqlDB's\n-processing capacity as desired. You can deploy different ksqlDB clusters\n-to achieve workload isolation.\n-\n-### ksqlDB CLI\n-\n-You can write SQL queries interactively by using the ksqlDB command\n-line interface (CLI). The ksqlDB CLI acts as a client to ksqlDB\n-Server.\n-\n-## Supported Versions and Interoperability\n-\n-You can use {{ site.ak }} with compatible {{ site.cp }} and {{ site.aktm }}\n-versions.\n-\n-|    ksqlDB version     | {{ site.ksqldbversion }} |\n-| --------------------- | ------------------------ |\n-| Apache Kafka version  | 0.11.0 and later         |\n-\n-## ksqlDB in {{ site.cp }}\n-\n-ksqlDB is available with {{ site.cp }} on-premises deployments and as a\n-fully managed service in {{ site.ccloud }}. For more information, see the\n-following topics in the {{ site.cp }} documentation.\n-\n-- [Install ksqlDB as part of the {{ site.cp }} bundle](https://docs.confluent.io/current/ksqldb/installing.html)\n-- [Install](https://docs.confluent.io/current/ksqldb/installing.html), [Operate](https://docs.confluent.io/current/ksqldb/operations.html), and [Upgrade](https://docs.confluent.io/current/ksqldb/upgrading.html) ksqlDB\n-- [Run ksqlDB in {{ site.ccloud }}](https://docs.confluent.io/current/cloud/quickstart/ksql.html)\n-- [Connect ksqlDB to {{ site.ccloud }}](https://docs.confluent.io/current/cloud/cp-component/ksql-cloud-config.html)\n-- [Run ksqlDB in {{ site.c3 }}](https://docs.confluent.io/current/control-center/ksql.html)\n-- [Connect ksqlDB to  {{ site.c3 }}](https://docs.confluent.io/current/ksqldb/integrate-ksql-with-confluent-control-center.html)\n-- [ksqlDB and role-based access control (RBAC)](https://docs.confluent.io/current/security/rbac/ksql-rbac.html)\n-\n+## Try it\n+\n+<div class=\"cards\">\n+  <div class=\"card\">\n+    <strong>Quickstarts</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"https://ksqldb.io/quickstart.html\">Standalone quickstart</a></li>\n+    </ul>\n+  </div>\n+\n+  <div class=\"card\">\n+    <strong>How-to guides</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"/how-to-guides/query-structured-data/\">Structured data</a></li>\n+      <li><a href=\"/how-to-guides/use-connector-management/\">Connector management</a></li>\n+      <li><a href=\"/how-to-guides/create-a-user-defined-function/\">User-defined functions</a></li>\n+      <li><a href=\"/how-to-guides/substitute-variables/\">Variables</a></li>\n+    </ul>\n+    <small><a href=\"/how-to-guides/\" class=\"card-more\">More \u2192</a></small>\n+  </div>\n+\n+  <div class=\"card\">\n+    <strong>Tutorials</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"/tutorials/materialized/\">Materialized cache</a></li>\n+      <li><a href=\"/tutorials/etl/\">Streaming ETL pipeline</a></li>\n+      <li><a href=\"/tutorials/event-driven-microservice/\">Event-driven microservice</a></li>\n+    </ul>\n+    <small><a href=\"/tutorials/\" class=\"card-more\">More \u2192</a></small>\n+  </div>\n+</div>\n+\n+## Learn\n+\n+<div class=\"cards\">\n+  <div class=\"card\">\n+    <strong>How it works</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"https://www.confluent.io/blog/how-real-time-stream-processing-works-with-ksqldb/\">The SQL language</a></li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff050dea43798569d5f09bcaf086348bbbdc135"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIwNjU0OQ==", "bodyText": "fwiw, the suggestion still fits in the horizontal space", "url": "https://github.com/confluentinc/ksql/pull/6717#discussion_r536206549", "createdAt": "2020-12-04T16:05:44Z", "author": {"login": "colinhicks"}, "path": "docs/index.md", "diffHunk": "@@ -6,172 +6,94 @@ description: Learn about ksqlDB, the event streaming database for creating strea\n keywords: ksqldb\n ---\n \n-## What is ksqlDB?\n-\n-ksqlDB is an event streaming database purpose-built to help developers create\n+[ksqlDB](https://ksqldb.io/) is an event streaming database purpose-built to help developers create\n stream processing applications on top of {{ site.aktm }}.\n \n-\n-## Why use ksqlDB to build stream processing applications?\n-\n-In today\u2019s world, applications that leverage stream processing need a\n-heavyweight architecture that requires integrating several distributed\n-systems together. These architectures often include a fleet of connectors\n-or agents for acquiring events from the outside world, durable storage to house\n-these events, a stream processing framework for processing the events, and a\n-database to serve aggregations of events to applications.\n-\n-![Diagram of a streaming architecture that doesn't use ksqlDB](img/streaming-architecture-without-ksqldb-desat.png)\n-\n-Unfortunately, the parts don't fit together as well as you'd hope; all of these\n-systems are complex, and each integration is a small project to figure out.\n-It's like trying to build a car out of parts, but the parts come from different\n-manufacturers who don't talk to each other.\n-\n-It shouldn't be this difficult to build stream processing applications.\n-\n-ksqlDB greatly reduces the operational complexity required to build stream\n-processing applications, which enables you to build real-time systems without\n-requiring significant time and overhead. It combines the power of real-time\n-stream processing with the approachable feel of a database, through\n-a familiar, lightweight SQL syntax. And because ksqlDB is natively powered by\n-{{ site.aktm }}, it seamlessly leverages the underlying, battle-tested event\n-streaming platform.\n-\n-![Diagram of ksqlDB architecure](img/ksqldb-architecture.png)\n-\n-## What are the components of ksqlDB?\n-\n-These are the core categories that are foundational to building an app:\n-collections, materialized views, and queries.\n-\n-### Collections\n-\n-Collections provide durable storage for sequences of events. ksqlDB offers\n-two kinds of collections: streams and tables. Both operate under a simple\n-key/value model. \n-\n-- **Streams** are immutable, append-only collections. They're useful for\n-  representing a series of historical facts. Adding multiple events with the\n-  same key means that they are simply appended to the end of the stream.\n-- **Tables** are mutable collections. They let you represent the latest version\n-  of each value per key. They're helpful for modeling change over time, and\n-  they're often used to represent aggregations.\n-\n-Because ksqlDB leverages {{ site.ak }} for its storage layer, creating a new\n-collection equates to defining a stream or a table over a {{ site.aktm }}\n-topic. You can declare a collection over an existing topic, or ksqlDB can\n-create a new topic for the collection at declaration time. For more information,\n-see [Collections](concepts/collections/index.md).\n-\n-### Materialized Views\n-\n-Materialized views are derived representations of streams or tables. They\n-enable you to create new collections over existing streams or tables.\n-Materialized views are perpetually kept up to date as new events arrive. This\n-means that you can chain materialized views together to create many\n-representations of the same data. Materialized views are especially useful for\n-maintaining aggregated tables of data. For more information,\n-see [Materialized Views](concepts/materialized-views.md).\n-\n-### Queries\n-\n-While materialized views allow you to maintain state, queries enable you to\n-access these materializations from applications or microservices. Applications\n-can query materialized views with *pull queries* and *push queries*.\n-\n-- **Pull queries** enable you to fetch the current state of a materialized view.\n-  Because materialized views are updated incrementally as new events arrive,\n-  pull queries run with predictably low latency. They're a good fit for\n-  request/response flows.\n-- **Push queries** enable you to subscribe to materialized view updates and\n-  stream changes. When new events arrive, push queries emit refinements, so\n-  your event streaming applications can react to new information in real-time.\n-  They\u2019re a good fit for asynchronous application flows.\n-\n-## What Can I Do With ksqlDB?\n-\n-### Streaming ETL\n-    \n-Apache Kafka is a popular choice for powering data pipelines. ksqlDB\n-makes it simple to transform data within the pipeline, readying\n-messages to cleanly land in another system.\n-\n-### Real-time Monitoring and Analytics\n-\n-Track, understand, and manage infrastructure, applications, and data\n-feeds by quickly building real-time dashboards, generating metrics,\n-and creating custom alerts and messages.\n-\n-### Data exploration and discovery\n-\n-Navigate and browse through your data in {{ site.ak }}.\n-\n-### Anomaly detection\n-\n-Identify patterns and spot anomalies in real-time data with\n-millisecond latency, enabling you to properly surface out-of-the-ordinary\n-events and to handle fraudulent activities separately.\n-\n-### Personalization\n-\n-Create data driven real-time experiences and insight for users.\n-\n-### Sensor data and IoT\n-\n-Understand and deliver sensor data how and where it needs to be.\n-\n-### Customer 360-view\n-\n-Achieve a comprehensive understanding of your customers across every\n-interaction through a variety of channels, where new information is\n-continuously incorporated in real-time.\n-\n-## How does it fit in my architecture?\n-\n-![](img/ksqldb-architecture-and-components.png)\n-\n-ksqlDB servers, clients, queries, and applications run outside of {{ site.ak }}\n-brokers, in separate JVM instances, or in completely separate clusters.\n-\n-### ksqlDB Server\n-\n-The ksqlDB server runs the engine that executes SQL queries. This\n-includes processing, reading, and writing data to and from the\n-target {{ site.ak }} cluster.\n-\n-ksqlDB servers form ksqlDB clusters and can run in containers, virtual\n-machines, and bare-metal machines. You can add and remove servers\n-to/from the same ksqlDB cluster during live operations to scale ksqlDB's\n-processing capacity as desired. You can deploy different ksqlDB clusters\n-to achieve workload isolation.\n-\n-### ksqlDB CLI\n-\n-You can write SQL queries interactively by using the ksqlDB command\n-line interface (CLI). The ksqlDB CLI acts as a client to ksqlDB\n-Server.\n-\n-## Supported Versions and Interoperability\n-\n-You can use {{ site.ak }} with compatible {{ site.cp }} and {{ site.aktm }}\n-versions.\n-\n-|    ksqlDB version     | {{ site.ksqldbversion }} |\n-| --------------------- | ------------------------ |\n-| Apache Kafka version  | 0.11.0 and later         |\n-\n-## ksqlDB in {{ site.cp }}\n-\n-ksqlDB is available with {{ site.cp }} on-premises deployments and as a\n-fully managed service in {{ site.ccloud }}. For more information, see the\n-following topics in the {{ site.cp }} documentation.\n-\n-- [Install ksqlDB as part of the {{ site.cp }} bundle](https://docs.confluent.io/current/ksqldb/installing.html)\n-- [Install](https://docs.confluent.io/current/ksqldb/installing.html), [Operate](https://docs.confluent.io/current/ksqldb/operations.html), and [Upgrade](https://docs.confluent.io/current/ksqldb/upgrading.html) ksqlDB\n-- [Run ksqlDB in {{ site.ccloud }}](https://docs.confluent.io/current/cloud/quickstart/ksql.html)\n-- [Connect ksqlDB to {{ site.ccloud }}](https://docs.confluent.io/current/cloud/cp-component/ksql-cloud-config.html)\n-- [Run ksqlDB in {{ site.c3 }}](https://docs.confluent.io/current/control-center/ksql.html)\n-- [Connect ksqlDB to  {{ site.c3 }}](https://docs.confluent.io/current/ksqldb/integrate-ksql-with-confluent-control-center.html)\n-- [ksqlDB and role-based access control (RBAC)](https://docs.confluent.io/current/security/rbac/ksql-rbac.html)\n-\n+## Try it\n+\n+<div class=\"cards\">\n+  <div class=\"card\">\n+    <strong>Quickstarts</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"https://ksqldb.io/quickstart.html\">Standalone quickstart</a></li>\n+    </ul>\n+  </div>\n+\n+  <div class=\"card\">\n+    <strong>How-to guides</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"/how-to-guides/query-structured-data/\">Structured data</a></li>\n+      <li><a href=\"/how-to-guides/use-connector-management/\">Connector management</a></li>\n+      <li><a href=\"/how-to-guides/create-a-user-defined-function/\">User-defined functions</a></li>\n+      <li><a href=\"/how-to-guides/substitute-variables/\">Variables</a></li>\n+    </ul>\n+    <small><a href=\"/how-to-guides/\" class=\"card-more\">More \u2192</a></small>\n+  </div>\n+\n+  <div class=\"card\">\n+    <strong>Tutorials</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"/tutorials/materialized/\">Materialized cache</a></li>\n+      <li><a href=\"/tutorials/etl/\">Streaming ETL pipeline</a></li>\n+      <li><a href=\"/tutorials/event-driven-microservice/\">Event-driven microservice</a></li>\n+    </ul>\n+    <small><a href=\"/tutorials/\" class=\"card-more\">More \u2192</a></small>\n+  </div>\n+</div>\n+\n+## Learn\n+\n+<div class=\"cards\">\n+  <div class=\"card\">\n+    <strong>How it works</strong>\n+    <ul class=\"card-items\">\n+      <li><a href=\"https://www.confluent.io/blog/how-real-time-stream-processing-works-with-ksqldb/\">The SQL language</a></li>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIwNDgzNw=="}, "originalCommit": {"oid": "5ff050dea43798569d5f09bcaf086348bbbdc135"}, "originalPosition": 212}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2504, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}