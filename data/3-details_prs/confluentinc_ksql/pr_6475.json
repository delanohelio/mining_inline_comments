{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2OTk3NzI4", "number": 6475, "title": "feat: support `IN` operator for non-pull queries", "bodyText": "Description\nfixes: #6473\nAdds support for IN operator for push and persistent queries, to match the same functionality being added for pull queries: #6409\nTesting done\nUsual\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-10-20T18:08:28Z", "url": "https://github.com/confluentinc/ksql/pull/6475", "merged": true, "mergeCommit": {"oid": "09414077ee9cb101e25d0a40535c15d7bb350191"}, "closed": true, "closedAt": "2020-11-16T09:46:00Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUcxw0gH2gAyNTA2OTk3NzI4OjIxNTQwMTJiMzk1ZmFmY2Y3YTE3MDdiZmY3NzQxZDBkMWEzZTY2ZWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdcM-UvgH2gAyNTA2OTk3NzI4OmU1YTQ4MjEwYzk0YTdjNGU4NjkyZDQyNjQ4ZjM1NDNlM2VmYmM0NGM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2154012b395fafcf7a1707bff7741d0d1a3e66ea", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/2154012b395fafcf7a1707bff7741d0d1a3e66ea", "committedDate": "2020-10-20T18:07:25Z", "message": "feat: support `IN` operator for non-pull queries\n\nfixes: https://github.com/confluentinc/ksql/issues/6473\n\nAdds support for `IN` operator for push and persistent queries."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4d9fd2fb5863ba47f9902caf69700450b501f17", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/c4d9fd2fb5863ba47f9902caf69700450b501f17", "committedDate": "2020-10-20T18:07:41Z", "message": "test: historical plans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "committedDate": "2020-10-20T18:38:01Z", "message": "docs: docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDc1MTA4", "url": "https://github.com/confluentinc/ksql/pull/6475#pullrequestreview-513075108", "createdAt": "2020-10-20T19:44:47Z", "commit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo0NDo0N1rOHlOSGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo0NDo0N1rOHlOSGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MzM3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The IN operator allows you to specify multiple values in a `WHERE` clause.\n          \n          \n            \n            The IN operator enables specifying multiple values in a `WHERE` clause.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508793370", "createdAt": "2020-10-20T19:44:47Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-reference/operators.md", "diffHunk": "@@ -66,6 +67,17 @@ SELECT USERID,\n   EMIT CHANGES;\r\n ```\r\n \r\n+IN\r\n+--\r\n+\r\n+The IN operator allows you to specify multiple values in a `WHERE` clause.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDc2NTAx", "url": "https://github.com/confluentinc/ksql/pull/6475#pullrequestreview-513076501", "createdAt": "2020-10-20T19:46:48Z", "commit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo0Njo0OFrOHlOWnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo0Njo0OFrOHlOWnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NDUyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The IN operator is a shorthand for multiple `OR` conditions.\n          \n          \n            \n            It provides the equivalent of multiple `OR` conditions.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508794524", "createdAt": "2020-10-20T19:46:48Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-reference/operators.md", "diffHunk": "@@ -66,6 +67,17 @@ SELECT USERID,\n   EMIT CHANGES;\r\n ```\r\n \r\n+IN\r\n+--\r\n+\r\n+The IN operator allows you to specify multiple values in a `WHERE` clause.\r\n+\r\n+The IN operator is a shorthand for multiple `OR` conditions.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDc2ODc1", "url": "https://github.com/confluentinc/ksql/pull/6475#pullrequestreview-513076875", "createdAt": "2020-10-20T19:47:19Z", "commit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo0NzoxOVrOHlOXww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo0NzoxOVrOHlOXww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NDgxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Short hand for multiple `OR` conditions.\n          \n          \n            \n            Specifies multiple `OR` conditions.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508794819", "createdAt": "2020-10-20T19:47:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-reference/quick-reference.md", "diffHunk": "@@ -427,6 +427,23 @@ SELECT user_id\n   EMIT CHANGES;\r\n ```\r\n \r\n+## IN\r\n+Short hand for multiple `OR` conditions.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDc3NjE1", "url": "https://github.com/confluentinc/ksql/pull/6475#pullrequestreview-513077615", "createdAt": "2020-10-20T19:48:22Z", "commit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjEwOTIz", "url": "https://github.com/confluentinc/ksql/pull/6475#pullrequestreview-513210923", "createdAt": "2020-10-20T23:43:04Z", "commit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0MzowNVrOHlU_CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDoyNzo0NVrOHlV79Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMzE3Ng==", "bodyText": "Is it really a condition?  I think of condition as something that evaluates to a boolean.  I assume it works for any expression.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508903176", "createdAt": "2020-10-20T23:43:05Z", "author": {"login": "AlanConfluent"}, "path": "docs/developer-guide/ksqldb-reference/quick-reference.md", "diffHunk": "@@ -427,6 +427,23 @@ SELECT user_id\n   EMIT CHANGES;\r\n ```\r\n \r\n+## IN\r\n+Short hand for multiple `OR` conditions.\r\n+\r\n+```sql hl_lines\"3\"\r\n+  SELECT select_expr [., ...]\r\n+    FROM from_stream | from_table\r\n+    WHERE condition IN (exp0, exp1, exp2);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwOTg2NA==", "bodyText": "I assume this catches the case where the pValue is null and rEntry.getValue() isn't.\nIf they are both null, then they would be considered not to match, per the null handler, right?  Is that the intended behavior for a map?", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508909864", "createdAt": "2020-10-20T23:57:35Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/helpers/InListEvaluator.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.codegen.helpers;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.Struct;\n+\n+/**\n+ * Used in the code generation to evaluate SQL 'IN (a, b, c)' expressions.\n+ *\n+ * <p>For tests, see {@code in.json} QTT test.\n+ *\n+ * @see io.confluent.ksql.execution.expression.tree.InPredicate\n+ */\n+public final class InListEvaluator {\n+\n+  private static final Object NO_MATCH = new Object();\n+\n+  private static final ImmutableList<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(InListEvaluator::nullsNeverMatch)\n+      .add(handler(List.class, InListEvaluator::arraysMatch))\n+      .add(handler(Map.class, InListEvaluator::mapsMatch))\n+      .add(handler(Struct.class, InListEvaluator::structsMatch))\n+      .add(InListEvaluator::exactMatch)\n+      .add(handler(String.class, Object.class, InListEvaluator::requiredParsedMatches))\n+      .add(handler(Object.class, String.class, InListEvaluator::possibleParsedMatches))\n+      .add(handler(Long.class, Integer.class, InListEvaluator::upCastInt))\n+      .add(handler(Double.class, BigDecimal.class, InListEvaluator::downCastDecimal))\n+      .build();\n+\n+  private static final ImmutableMap<Class<?>, Function<String, ?>> STRING_PARSERS = ImmutableMap\n+      .<Class<?>, Function<String, ?>>builder()\n+      .put(Boolean.class, InListEvaluator::stringToBoolean)\n+      .put(Integer.class, Integer::valueOf)\n+      .put(Long.class, Long::valueOf)\n+      .put(Double.class, Double::valueOf)\n+      .put(BigDecimal.class, BigDecimal::new)\n+      .build();\n+\n+  private InListEvaluator() {\n+  }\n+\n+  /**\n+   * Looks for {@code value} in {@code values}.\n+   *\n+   * <p>SQL NULLs never match.\n+   *\n+   * <p>Conversion from INT to BIGINT is handled.\n+   *\n+   * <p>Conversion from DECIMAL to DOUBLE is handled.\n+   *\n+   * <p>Conversion between STRING and other primitive keys is handled.\n+   *\n+   * <p>Invalid conversions are ignored.\n+   *\n+   * @param value the value to look for\n+   * @param values the values to look in\n+   * @return {@code true} if {@code value} is in {@code values}.\n+   */\n+  public static boolean matches(final Object value, final Object... values) {\n+    if (value == null) {\n+      // SQL NULL never matches anything:\n+      return false;\n+    }\n+\n+    for (final Object v : values) {\n+      if (v == null) {\n+        // SQL NULL never matches anything:\n+        continue;\n+      }\n+\n+      if (isMatch(value, v)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean isMatch(final Object requiredValue, final Object possibleMatch) {\n+    for (final Handler handler : HANDLERS) {\n+      final Optional<Boolean> result = handler.accept(requiredValue, possibleMatch);\n+      if (result.isPresent()) {\n+        return result.get();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static Optional<Boolean> nullsNeverMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue == null || possibleMatch == null) {\n+      // SQL NULL never matches anything:\n+      return Optional.of(false);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Boolean> exactMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue.equals(possibleMatch)) {\n+      return Optional.of(true);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Object parseString(\n+      final String value,\n+      final Class<?> requiredType\n+  ) {\n+    final Function<String, ?> parser = STRING_PARSERS.get(requiredType);\n+    if (parser == null) {\n+      return NO_MATCH;\n+    }\n+\n+    try {\n+      return parser.apply(value);\n+    } catch (final NumberFormatException e) {\n+      return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean requiredParsedMatches(\n+      final String requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    return possibleParsedMatches(possibleMatch, requiredValue);\n+  }\n+\n+  private static boolean possibleParsedMatches(\n+      final Object requiredValue,\n+      final String possibleMatch\n+  ) {\n+    final Object parsed = parseString(possibleMatch, requiredValue.getClass());\n+    return requiredValue.equals(parsed);\n+  }\n+\n+  private static boolean upCastInt(\n+      final Long requiredValue,\n+      final Integer possibleMatch\n+  ) {\n+    return requiredValue.equals(possibleMatch.longValue());\n+  }\n+\n+  private static boolean downCastDecimal(\n+      final Double requiredValue,\n+      final BigDecimal possibleMatch\n+  ) {\n+    final double d = possibleMatch.doubleValue();\n+    if (!new BigDecimal(String.valueOf(d)).equals(possibleMatch)) {\n+      // Lossy conversion:\n+      return false;\n+    }\n+\n+    return requiredValue.equals(d);\n+  }\n+\n+\n+  private static Object stringToBoolean(final String value) {\n+    switch (value.toUpperCase()) {\n+      case \"T\":\n+      case \"TRUE\":\n+        return true;\n+\n+      case \"F\":\n+      case \"FALSE\":\n+        return false;\n+\n+      default:\n+        return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean arraysMatch(final List<?> requiredValue, final List<?> possibleMatch) {\n+    final Iterator<?> rIt = requiredValue.iterator();\n+    final Iterator<?> pIt = possibleMatch.iterator();\n+\n+    while (rIt.hasNext() && pIt.hasNext()) {\n+      final Object rNext = rIt.next();\n+      final Object pNext = pIt.next();\n+\n+      if (!isMatch(rNext, pNext)) {\n+        return false;\n+      }\n+    }\n+\n+    return !rIt.hasNext() && !pIt.hasNext();\n+  }\n+\n+  private static boolean mapsMatch(final Map<?, ?> requiredValue, final Map<?, ?> possibleMatch) {\n+    if (requiredValue.size() != possibleMatch.size()) {\n+      return false;\n+    }\n+\n+    for (final Entry<?, ?> rEntry : requiredValue.entrySet()) {\n+      final Object pValue = possibleMatch.get(rEntry.getKey());\n+\n+      if (!isMatch(rEntry.getValue(), pValue)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxNjgxMg==", "bodyText": "Is it not possible to have the reverse as well, BigDecimal is required and Double is matched against?  Is that not the case with the integer/long as well?\nIt would be good to do some test that cover these casting cases.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508916812", "createdAt": "2020-10-21T00:20:48Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/helpers/InListEvaluator.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.codegen.helpers;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.Struct;\n+\n+/**\n+ * Used in the code generation to evaluate SQL 'IN (a, b, c)' expressions.\n+ *\n+ * <p>For tests, see {@code in.json} QTT test.\n+ *\n+ * @see io.confluent.ksql.execution.expression.tree.InPredicate\n+ */\n+public final class InListEvaluator {\n+\n+  private static final Object NO_MATCH = new Object();\n+\n+  private static final ImmutableList<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(InListEvaluator::nullsNeverMatch)\n+      .add(handler(List.class, InListEvaluator::arraysMatch))\n+      .add(handler(Map.class, InListEvaluator::mapsMatch))\n+      .add(handler(Struct.class, InListEvaluator::structsMatch))\n+      .add(InListEvaluator::exactMatch)\n+      .add(handler(String.class, Object.class, InListEvaluator::requiredParsedMatches))\n+      .add(handler(Object.class, String.class, InListEvaluator::possibleParsedMatches))\n+      .add(handler(Long.class, Integer.class, InListEvaluator::upCastInt))\n+      .add(handler(Double.class, BigDecimal.class, InListEvaluator::downCastDecimal))\n+      .build();\n+\n+  private static final ImmutableMap<Class<?>, Function<String, ?>> STRING_PARSERS = ImmutableMap\n+      .<Class<?>, Function<String, ?>>builder()\n+      .put(Boolean.class, InListEvaluator::stringToBoolean)\n+      .put(Integer.class, Integer::valueOf)\n+      .put(Long.class, Long::valueOf)\n+      .put(Double.class, Double::valueOf)\n+      .put(BigDecimal.class, BigDecimal::new)\n+      .build();\n+\n+  private InListEvaluator() {\n+  }\n+\n+  /**\n+   * Looks for {@code value} in {@code values}.\n+   *\n+   * <p>SQL NULLs never match.\n+   *\n+   * <p>Conversion from INT to BIGINT is handled.\n+   *\n+   * <p>Conversion from DECIMAL to DOUBLE is handled.\n+   *\n+   * <p>Conversion between STRING and other primitive keys is handled.\n+   *\n+   * <p>Invalid conversions are ignored.\n+   *\n+   * @param value the value to look for\n+   * @param values the values to look in\n+   * @return {@code true} if {@code value} is in {@code values}.\n+   */\n+  public static boolean matches(final Object value, final Object... values) {\n+    if (value == null) {\n+      // SQL NULL never matches anything:\n+      return false;\n+    }\n+\n+    for (final Object v : values) {\n+      if (v == null) {\n+        // SQL NULL never matches anything:\n+        continue;\n+      }\n+\n+      if (isMatch(value, v)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean isMatch(final Object requiredValue, final Object possibleMatch) {\n+    for (final Handler handler : HANDLERS) {\n+      final Optional<Boolean> result = handler.accept(requiredValue, possibleMatch);\n+      if (result.isPresent()) {\n+        return result.get();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static Optional<Boolean> nullsNeverMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue == null || possibleMatch == null) {\n+      // SQL NULL never matches anything:\n+      return Optional.of(false);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Boolean> exactMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue.equals(possibleMatch)) {\n+      return Optional.of(true);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Object parseString(\n+      final String value,\n+      final Class<?> requiredType\n+  ) {\n+    final Function<String, ?> parser = STRING_PARSERS.get(requiredType);\n+    if (parser == null) {\n+      return NO_MATCH;\n+    }\n+\n+    try {\n+      return parser.apply(value);\n+    } catch (final NumberFormatException e) {\n+      return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean requiredParsedMatches(\n+      final String requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    return possibleParsedMatches(possibleMatch, requiredValue);\n+  }\n+\n+  private static boolean possibleParsedMatches(\n+      final Object requiredValue,\n+      final String possibleMatch\n+  ) {\n+    final Object parsed = parseString(possibleMatch, requiredValue.getClass());\n+    return requiredValue.equals(parsed);\n+  }\n+\n+  private static boolean upCastInt(\n+      final Long requiredValue,\n+      final Integer possibleMatch\n+  ) {\n+    return requiredValue.equals(possibleMatch.longValue());\n+  }\n+\n+  private static boolean downCastDecimal(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxODc3Mw==", "bodyText": "Is it not considered a type error to mix types in the in list?  You would also think that it would be an error if the types weren't comparable.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508918773", "createdAt": "2020-10-21T00:27:45Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/in.json", "diffHunk": "@@ -0,0 +1,223 @@\n+{\n+  \"tests\": [\n+    {\n+      \"name\": \"expressions\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (VAL, VAL * 2);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {\"VAL\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {\"VAL\": 20}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {\"VAL\": 110}},\n+        {\"topic\": \"input_topic\", \"key\": 38, \"value\": {\"VAL\": 19}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": 38, \"value\": {\"VAL\": 19}}\n+      ]\n+    },\n+    {\n+      \"name\": \"nulls\",\n+      \"comment\": \"Null is not equivalent to null, i.e. it never matches\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (11,NULL,VAL);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"VAL\":10}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"VAL\":null}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {\"VAL\":10}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {\"VAL\":10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 11, \"value\": {\"VAL\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"inverted\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID NOT IN (11,20,10);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 12, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 19, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"boolean\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID BOOLEAN KEY, VAL BOOLEAN, VAL2 STRING) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (true, 'Not a boolean', 10) OR VAL IN ('TruE', ARRAY[1]) OR VAL2 IN (true);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": true, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL2\": \"true\"}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL2\": \"t\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"VAL\": false, \"VAL2\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"VAL\": true, \"VAL2\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"VAL\": null, \"VAL2\": \"true\"}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"VAL\": null, \"VAL2\": \"t\"}}\n+      ]\n+    },\n+    {\n+      \"name\": \"int\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (11,20,10,'not a number',false,12.0, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 11, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"bigint\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID BIGINT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (123456789123456789,20,10,'not a number',false,12.0, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 123456789123456789, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 123456789123456789, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"double\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID DOUBLE KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (10, 10.1, '10.2', 10.30, '10.40', 'not a number', false, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10.0, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.1, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.2, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.3, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.4, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10.1, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10.2, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10.4, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"string\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID STRING KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN ('k', 10, '10.1', 10.30, 'not a match', false, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": \"k\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"no\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10.0\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10.1\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10.10\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"false\", \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": \"k\", \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": \"10\", \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": \"10.1\", \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": \"false\", \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"decimal\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID DECIMAL(4,2) KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (10, 10.0, 10.10, 10.201, '10.30', '10.4', '10.400', 'not a match', false, ARRAY[1]);\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39dc8304255420b9a673d16f0d21b6e5e3ba4985", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/39dc8304255420b9a673d16f0d21b6e5e3ba4985", "committedDate": "2020-10-21T09:04:53Z", "message": "Update docs/developer-guide/ksqldb-reference/operators.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3079b3eb16d1b8b82729191ca72a2af902aff26f", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/3079b3eb16d1b8b82729191ca72a2af902aff26f", "committedDate": "2020-10-21T09:05:01Z", "message": "Update docs/developer-guide/ksqldb-reference/operators.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dfc6c6c9776aad5b48ecedc8979cb534943871e", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/4dfc6c6c9776aad5b48ecedc8979cb534943871e", "committedDate": "2020-10-21T09:05:07Z", "message": "Update docs/developer-guide/ksqldb-reference/quick-reference.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4OTY4OTk0", "url": "https://github.com/confluentinc/ksql/pull/6475#pullrequestreview-518968994", "createdAt": "2020-10-28T18:29:28Z", "commit": {"oid": "4dfc6c6c9776aad5b48ecedc8979cb534943871e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyOToyOFrOHp4EDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyOToyOFrOHp4EDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3MjIwNg==", "bodyText": "I just noticed that IN is already mentioned above.", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r513672206", "createdAt": "2020-10-28T18:29:28Z", "author": {"login": "AlanConfluent"}, "path": "docs/reference/sql/appendix.md", "diffHunk": "@@ -58,6 +58,7 @@ The following table shows all keywords in the language.\n | `INTERVAL`     | number of messages to skip in `PRINT` | `PRINT <topic-name> INTERVAL 5;`                                     |\n | `INTO`         | stream/table to insert values         | `INSERT INTO stream_name ...`                                        |\n | `IS`           |                                       |                                                                      |\n+| `IN`           | in operator                           | `SELECT * FROM S WHERE ID IN (1, 2, 9, 24);`                         |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc6c6c9776aad5b48ecedc8979cb534943871e"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af4c611e612b82321a019dffe56171b2036f6aea", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/af4c611e612b82321a019dffe56171b2036f6aea", "committedDate": "2020-11-02T17:12:49Z", "message": "chore: merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4d653ebba0ccb96724b17b03b814d4e5cd0555c", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/b4d653ebba0ccb96724b17b03b814d4e5cd0555c", "committedDate": "2020-11-03T14:01:12Z", "message": "Merge branch 'master' into in_exp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bf6b0c2096eedd37cb8ac58dd1c65a68282def4", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/6bf6b0c2096eedd37cb8ac58dd1c65a68282def4", "committedDate": "2020-11-11T09:34:11Z", "message": "chore: merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "230e5c47ba2605a7ca92ead31c16279aad73ccec", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/230e5c47ba2605a7ca92ead31c16279aad73ccec", "committedDate": "2020-11-11T09:37:59Z", "message": "chore: revert unnecessary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5a48210c94a7c4e8692d42648f3543e3efbc44c", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/e5a48210c94a7c4e8692d42648f3543e3efbc44c", "committedDate": "2020-11-13T20:14:03Z", "message": "chore: refactor"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4584, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}