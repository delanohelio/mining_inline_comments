{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwOTQ2NDUw", "number": 5434, "title": "docs(client): add Java client docs", "bodyText": "Description\nDraft of docs for new Java client. @MichaelDrogalis had some ideas for integrating these with the new use case tutorials, which is a potential direction for these docs to evolve.\nAPI docs generated from javadocs on the interfaces are WIP, and will likely be a separate PR.\nTesting done\nDocs-only change.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-05-20T18:27:31Z", "url": "https://github.com/confluentinc/ksql/pull/5434", "merged": true, "mergeCommit": {"oid": "fa3a638c38c4185006bb7ec75043c1681d8d38d7"}, "closed": true, "closedAt": "2020-06-15T23:23:10Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjNVs1AH2gAyNDIwOTQ2NDUwOmZkNjRiN2M0N2NhODY5ZmYzODQ0NjBjNGIzOTExMzMwOGFmNWM2ZWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcroVjNAH2gAyNDIwOTQ2NDUwOjQ0MWY0MmFmYjcxNjk2MDQ2YzQ5Yjk2ZjUzM2RmZmEzMDY3NTc1NTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fd64b7c47ca869ff384460c4b39113308af5c6eb", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/fd64b7c47ca869ff384460c4b39113308af5c6eb", "committedDate": "2020-05-20T18:25:54Z", "message": "docs(client): add Java client docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61a4cfafba84e2f325be420b0841f1b1866a525e", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/61a4cfafba84e2f325be420b0841f1b1866a525e", "committedDate": "2020-05-21T00:04:11Z", "message": "Merge branch 'master' into java-client-docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "836747b1cdf793958d356a08cbf6a11273afbb99", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/836747b1cdf793958d356a08cbf6a11273afbb99", "committedDate": "2020-05-21T16:30:34Z", "message": "docs: refactor into single page"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad714a6cfbf43a23d1f3fdcea5be8ce831df82b1", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/ad714a6cfbf43a23d1f3fdcea5be8ce831df82b1", "committedDate": "2020-05-21T19:13:16Z", "message": "docs: add docs for (non-streaming) insert into"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a2e33dfd0ae234231057b16915089644e7d8288", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/4a2e33dfd0ae234231057b16915089644e7d8288", "committedDate": "2020-05-21T19:54:17Z", "message": "chore: minor touchups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e64c901a01e6884c74c83cab4d372962d8f6bf5", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/9e64c901a01e6884c74c83cab4d372962d8f6bf5", "committedDate": "2020-05-21T23:35:10Z", "message": "chore: more touchups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f5f70b955817e82d2d3df3b860228795ce1526a9", "committedDate": "2020-05-22T00:46:50Z", "message": "docs: clarify auto.offset.reset behavior"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTczNTM0", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416973534", "createdAt": "2020-05-22T14:52:38Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1MjozOFrOGZaEUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1MjozOFrOGZaEUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NDY3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ---\n          \n          \n            \n            keywords: ksqlDB, java, client\n          \n          \n            \n            ---", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429294674", "createdAt": "2020-05-22T14:52:38Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc0NTg3", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416974587", "createdAt": "2020-05-22T14:54:00Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDowMFrOGZaHTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDowMFrOGZaHTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NTQzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `streamQuery()` method allows client apps to receive query results one row at a time,\n          \n          \n            \n            The `streamQuery()` method enables client apps to receive query results one row at a time,", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429295436", "createdAt": "2020-05-22T14:54:00Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc1MjQ2", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416975246", "createdAt": "2020-05-22T14:54:55Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDo1NVrOGZaJVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NDo1NVrOGZaJVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NTk1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n          \n          \n            \n            You can use this method to issue both push and pull queries, but the usage pattern is better for push queries.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429295956", "createdAt": "2020-05-22T14:54:55Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc1NzE5", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416975719", "createdAt": "2020-05-22T14:55:35Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NTozNVrOGZaK3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NTozNVrOGZaK3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NjM0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n          \n          \n            \n            To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429296348", "createdAt": "2020-05-22T14:55:35Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc2NjA3", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416976607", "createdAt": "2020-05-22T14:56:46Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1Njo0NlrOGZaNeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1Njo0NlrOGZaNeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NzAxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n          \n          \n            \n            To consume records asynchronously, create a [Reactive Streams](http://www.reactive-streams.org/) subscriber to receive query result rows:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429297016", "createdAt": "2020-05-22T14:56:46Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc3MTk4", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416977198", "createdAt": "2020-05-22T14:57:33Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NzozM1rOGZaPEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1NzozM1rOGZaPEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NzQyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, use the client to send the query result to the server and stream results to the subscriber:\n          \n          \n            \n            Use the Java client to send the query result to the server and stream results to the subscriber:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429297427", "createdAt": "2020-05-22T14:57:33Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc3OTA5", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416977909", "createdAt": "2020-05-22T14:58:25Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODoyNlrOGZaRHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODoyNlrOGZaRHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5Nzk0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n          \n          \n            \n            If `poll()` is called with no arguments, `poll()` blocks until a new row becomes available or the query is terminated.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429297949", "createdAt": "2020-05-22T14:58:26Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 193}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc4MTcy", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416978172", "createdAt": "2020-05-22T14:58:47Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODo0N1rOGZaR0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1ODo0N1rOGZaR0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5ODEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n          \n          \n            \n            You can also pass a `Duration` argument to `poll()`, which causes `poll()` to return `null` if no new rows are received by the time the duration has elapsed.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429298130", "createdAt": "2020-05-22T14:58:47Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 194}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc4NjA0", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416978604", "createdAt": "2020-05-22T14:59:18Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OToxOFrOGZaTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OToxOFrOGZaTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5ODQ0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See [the API reference](TODO) for more.\n          \n          \n            \n            For more information, see the [API reference](TODO).", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429298449", "createdAt": "2020-05-22T14:59:18Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 195}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c", "committedDate": "2020-05-22T14:59:36Z", "message": "chore: remove batch insert"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc4OTg3", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416978987", "createdAt": "2020-05-22T14:59:46Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OTo0NlrOGZaUOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo1OTo0NlrOGZaUOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5ODc0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `executeQuery()` method allows client apps to receive query results as a single batch,\n          \n          \n            \n            The `executeQuery()` method enables client apps to receive query results as a single batch", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429298746", "createdAt": "2020-05-22T14:59:46Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTc5NDIz", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416979423", "createdAt": "2020-05-22T15:00:19Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMDoxOVrOGZaVlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMDoxOVrOGZaVlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5OTA5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            returned once the query has completed.\n          \n          \n            \n            that's returned when the query completes.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429299093", "createdAt": "2020-05-22T15:00:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgwMTgw", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416980180", "createdAt": "2020-05-22T15:01:19Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMToxOVrOGZaXww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMToxOVrOGZaXww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5OTY1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n          \n          \n            \n            This method is suitable for both pull queries and for terminating push queries, for example, queries that have a `LIMIT` clause.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429299651", "createdAt": "2020-05-22T15:01:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgwNzY2", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416980766", "createdAt": "2020-05-22T15:02:09Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjowOVrOGZaZfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjowOVrOGZaZfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDA5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n          \n          \n            \n            Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300095", "createdAt": "2020-05-22T15:02:09Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 244}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgxMDY2", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416981066", "createdAt": "2020-05-22T15:02:37Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjozN1rOGZaaeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMjozN1rOGZaaeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDM0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n          \n          \n            \n            To start from the end and receive only newly arriving rows, set the `auto.offset.reset` property to `latest`.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300344", "createdAt": "2020-05-22T15:02:37Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 247}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgxMzk5", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416981399", "createdAt": "2020-05-22T15:03:05Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzowNVrOGZabZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzowNVrOGZabZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDU4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `terminatePushQuery()` method allows client apps to terminate push queries.\n          \n          \n            \n            The `terminatePushQuery()` method enables client apps to terminate push queries.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300583", "createdAt": "2020-05-22T15:03:05Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 272}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgxOTIw", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416981920", "createdAt": "2020-05-22T15:03:49Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzo0OVrOGZacyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowMzo0OVrOGZacyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMDkzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The query ID is obtained from the query result response object when push queries are issued via the client,\n          \n          \n            \n            The query ID is obtained from the query result response object when the client issues push queries,", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429300936", "createdAt": "2020-05-22T15:03:49Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 293}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgyMjUy", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416982252", "createdAt": "2020-05-22T15:04:18Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDoxOVrOGZadtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDoxOVrOGZadtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTE3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n          \n          \n            \n            by using either the [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md) methods.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301173", "createdAt": "2020-05-22T15:04:19Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 294}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgyNzAy", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416982702", "createdAt": "2020-05-22T15:04:53Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDo1M1rOGZae5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNDo1M1rOGZae5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTQ3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here's an example of terminating a push query issued via `streamQuery()`:\n          \n          \n            \n            Here's an example of terminating a push query issued by using the `streamQuery()` method:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301476", "createdAt": "2020-05-22T15:04:53Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 298}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgzMDMw", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416983030", "createdAt": "2020-05-22T15:05:20Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNToyMFrOGZaf3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNToyMFrOGZaf3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTcyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And here's an analogous example for terminating a push query issued via `executeQuery()`:\n          \n          \n            \n            And here's an analogous example for terminating a push query issued by using the `executeQuery()` method:", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301724", "createdAt": "2020-05-22T15:05:20Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 319}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgzMjkz", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416983293", "createdAt": "2020-05-22T15:05:43Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNTo0M1rOGZagnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNTo0M1rOGZagnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMTkxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Client apps can insert rows of data into existing ksqlDB streams via the `insertInto()` method.\n          \n          \n            \n            Client apps can insert rows of data into existing ksqlDB streams by using the `insertInto()` method.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429301916", "createdAt": "2020-05-22T15:05:43Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,416 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a batch of rows into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final String queryId;\n+try {\n+  queryId = batchedQueryResult.queryID().get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+try {\n+  client.terminatePushQuery(queryId).get();\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+Insert a batch of rows into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------------\n+\n+Client apps can insert rows of data into existing ksqlDB streams via the `insertInto()` method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "originalPosition": 343}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTg2MDY4", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416986068", "createdAt": "2020-05-22T15:09:27Z", "commit": {"oid": "f5f70b955817e82d2d3df3b860228795ce1526a9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTg3Njg1", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-416987685", "createdAt": "2020-05-22T15:11:40Z", "commit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToxMTo0MFrOGZas6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToxMTo0MFrOGZas6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTA2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n          \n          \n            \n            Query properties can be passed as an optional second argument. For more information, see the [client API reference](TODO).", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429305067", "createdAt": "2020-05-22T15:11:40Z", "author": {"login": "JimGalasyn"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f7c5da31e90511b48fccf70f0f65ef0f89c613a", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/2f7c5da31e90511b48fccf70f0f65ef0f89c613a", "committedDate": "2020-05-23T08:01:34Z", "message": "chore: update javadocs to latest version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f73349d73f3a1a9c285c3af44d206f6544c56f80", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f73349d73f3a1a9c285c3af44d206f6544c56f80", "committedDate": "2020-05-23T08:19:00Z", "message": "chore: jim's feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Mjg3ODY0", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-417287864", "createdAt": "2020-05-23T15:41:01Z", "commit": {"oid": "f73349d73f3a1a9c285c3af44d206f6544c56f80"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MDAxNjg2", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-417001686", "createdAt": "2020-05-22T15:31:12Z", "commit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozMToxMlrOGZbVpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozNTozNlrOGZbeLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTQ5Mw==", "bodyText": "Would need to call subscription.request(n) here", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429315493", "createdAt": "2020-05-22T15:31:12Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ==", "bodyText": "And again here", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429315575", "createdAt": "2020-05-22T15:31:20Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTk2NQ==", "bodyText": "We can consider providing a simple Subscriber class (like our BaseSubscriber) that does the requests for you to make things a bit simpler.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429315965", "createdAt": "2020-05-22T15:32:08Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTU3NQ=="}, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjQ1NA==", "bodyText": "I would avoid the try.. catch here - it doesn't really add anything to the understanding and clutters the example.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429316454", "createdAt": "2020-05-22T15:33:09Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjk0Ng==", "bodyText": "Again, try...catch doesn't add much.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429316946", "createdAt": "2020-05-22T15:34:06Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNzY3Nw==", "bodyText": "I think some examples showing how futures can be composed here would be great - that's really the point of using futures in the first place.", "url": "https://github.com/confluentinc/ksql/pull/5434#discussion_r429317677", "createdAt": "2020-05-22T15:35:36Z", "author": {"login": "purplefox"}, "path": "docs/developer-guide/ksqldb-clients/java-client.md", "diffHunk": "@@ -0,0 +1,387 @@\n+---\n+layout: page\n+title: Java Client for ksqlDB\n+tagline: Java client for ksqlDB\n+description: Send requests to ksqlDB from your Java app\n+---\n+\n+Use the Java client to:\n+\n+- [Receive query results one row at a time (streamQuery())](#stream-query)\n+- [Receive query results in a single batch (executeQuery())](#execute-query)\n+- [Terminate a push query (terminatePushQuery())](#terminate-push-query)\n+- [Insert a new row into a stream (insertInto())](#insert-into)\n+\n+Getting Started\n+---------------\n+\n+Start by creating a `pom.xml` for your Java application:\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>my.ksqldb.app</groupId>\n+    <artifactId>my-ksqldb-app</artifactId>\n+    <version>0.0.1</version>\n+\n+    <properties>\n+        <!-- Keep versions as properties to allow easy modification -->\n+        <java.version>8</java.version>\n+        <ksqldb.version>{{ site.release }}</ksqldb.version>\n+        <!-- Maven properties for compilation -->\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.confluent.ksql</groupId>\n+            <artifactId>ksqldb-api-client</artifactId>\n+            <version>${ksqldb.version}</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+              <groupId>org.apache.maven.plugins</groupId>\n+              <artifactId>maven-compiler-plugin</artifactId>\n+              <version>3.8.1</version>\n+              <configuration>\n+                <source>${java.version}</source>\n+                <target>${java.version}</target>\n+                <compilerArgs>\n+                  <arg>-Xlint:all</arg>\n+                </compilerArgs>\n+              </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+</project>\n+```\n+\n+Create your example app at `src/main/java/my/ksqldb/app/ExampleApp.java`:\n+\n+```java\n+package my.ksqldb.app;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+\n+public class ExampleApp {\n+\n+  public static final String KSQLDB_SERVER_HOST = \"localhost\";\n+  public static final int KSQLDB_SERVER_HOST_PORT = 8088;\n+  \n+  public static void main(final String[] args) {\n+    final ClientOptions options = ClientOptions.create()\n+        .setHost(KSQLDB_SERVER_HOST)\n+        .setPort(KSQLDB_SERVER_HOST_PORT);\n+    final Client client = Client.create(options);\n+    \n+    // Send requests with the client by following the other examples\n+    \n+    client.close();\n+  }\n+}\n+```\n+\n+For additional client options, see [the API reference](TODO).\n+\n+Receive query results one row at a time (streamQuery())<a name=\"stream-query\"></a>\n+----------------------------------------------------------------------------------\n+\n+The `streamQuery()` method allows client apps to receive query results one row at a time,\n+either asynchronously via a Reactive Streams subscriber or synchronously in a polling fashion.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns the results one row at a time.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return a future that completes once the server response is received, and contains the query\n+   *         result if successful\n+   */\n+  CompletableFuture<StreamedQueryResult> streamQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method may be used to issue both push and pull queries, though the usage pattern is most suited for push queries.\n+For pull queries, consider [the `executeQuery()` method](./execute-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Asynchronous Usage ###\n+\n+To consume records in an asynchronous fashion, first create a Reactive Streams subscriber to receive query result rows:\n+\n+```java\n+import io.confluent.ksql.api.client.Row;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class RowSubscriber implements Subscriber<Row> {\n+\n+  private Subscription subscription;\n+\n+  public RowSubscriber() {\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    System.out.println(\"Subscriber is subscribed.\");\n+    this.subscription = subscription;\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Row row) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    System.out.println(\"Received an error: \" + t);\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    System.out.println(\"Query has ended.\");\n+  }\n+\n+  public Subscription getSubscription() {\n+    return subscription;\n+  }\n+}\n+```\n+\n+Then, use the client to send the query result to the server and stream results to the subscriber:\n+\n+```java\n+client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\")\n+    .thenAccept(streamedQueryResult -> {\n+      System.out.println(\"Query has started. Query ID: \" + streamedQueryResult.queryID());\n+      \n+      final RowSubscriber subscriber = new RowSubscriber();\n+      streamedQueryResult.subscribe(subscriber);\n+      subscriber.getSubscription().request(10);\n+    }).exceptionally(e -> {\n+      System.out.println(\"Request failed: \" + e);\n+      return null;\n+    });\n+```\n+\n+### Synchronous Usage ###\n+\n+To consume records one-at-a-time in a synchronous fashion, use the `poll()` method on the query result object.\n+If `poll()` is called with no arguments, `poll()` will block until a new row becomes available or the query is terminated.\n+You can also pass a `Duration` argument to `poll()` which will cause `poll()` to return null if no new rows are received by the time the duration has elapsed.\n+See [the API reference](TODO) for more.\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+for (int i = 0; i < 10; i++) {\n+  // Block until a new row is available\n+  final Row row = streamedQueryResult.poll();\n+  if (row != null) {\n+    System.out.println(\"Received a row!\");\n+    System.out.println(\"Row: \" + row.values());\n+  } else {\n+    System.out.println(\"Query has ended.\");\n+  }\n+}\n+```\n+\n+Receive query results in a single batch (executeQuery())<a name=\"execute-query\"></a>\n+------------------------------------------------------------------------------------\n+\n+The `executeQuery()` method allows client apps to receive query results as a single batch,\n+returned once the query has completed.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Executes a query (push or pull) and returns all result rows in a single batch, once the query\n+   * has completed.\n+   *\n+   * @param sql statement of query to execute\n+   * @return query result\n+   */\n+  BatchedQueryResult executeQuery(String sql);\n+  \n+  ...\n+  \n+}\n+```\n+\n+This method is suitable for both pull queries as well as terminating push queries (e.g., those with a `LIMIT` clause).\n+For non-temrinating push queries, use [the `streamQuery()` method](./stream-query.md) instead. \n+\n+Query properties can be passed as an optional second argument. See the [client API reference](TODO) for more.\n+\n+By default, push queries return results starting from the beginning of the stream or table.\n+To instead start from the end and only receive newly arriving rows, set the property `auto.offset.reset` to `latest`.\n+\n+### Example Usage ###\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_MATERIALIZED_TABLE WHERE KEY_FIELD='some_key';\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final List<Row> resultRows;\n+try {\n+  resultRows = batchedQueryResult.get();\n+} catch (Exception e) {\n+  System.out.println(\"Request failed: \" + e);\n+  return;\n+}\n+\n+System.out.println(\"Received results. Num rows: \" + resultRows.size());\n+for (final Row row : resultRows) {\n+  System.out.println(\"Row: \" + row.values());\n+}\n+```\n+\n+Terminate a push query (terminatePushQuery())<a name=\"terminate-push-query\"></a>\n+--------------------------------------------------------------------------------\n+\n+The `terminatePushQuery()` method allows client apps to terminate push queries.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Terminates a push query with the specified query ID.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param queryId ID of the query to terminate\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> terminatePushQuery(String queryId);\n+  \n+  ...\n+  \n+}\n+```\n+\n+The query ID is obtained from the query result response object when push queries are issued via the client,\n+via either [`streamQuery()`](./stream-query.md) or [`executeQuery()`](./execute-query.md).\n+\n+### Example Usage ###\n+\n+Here's an example of terminating a push query issued via `streamQuery()`:\n+\n+```java\n+final StreamedQueryResult streamedQueryResult;\n+try {\n+  streamedQueryResult = client.streamQuery(\"SELECT * FROM MY_STREAM EMIT CHANGES;\").get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+final String queryId = streamedQueryResult.queryID();\n+System.out.println(\"Terminating query with ID: \" + queryId);\n+try {\n+  client.terminatePushQuery(queryId).get();\n+  System.out.println(\"Sucessfully terminated query.\");\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+And here's an analogous example for terminating a push query issued via `executeQuery()`:\n+\n+```java\n+final String pullQuery = \"SELECT * FROM MY_STREAM EMIT CHANGES LIMIT 10;\";\n+final BatchedQueryResult batchedQueryResult = client.executeQuery(pullQuery);\n+\n+final String queryId;\n+try {\n+  queryId = batchedQueryResult.queryID().get();\n+} catch (Exception e) {\n+  System.out.println(\"Query request failed: \" + e);\n+  return;\n+}\n+\n+try {\n+  client.terminatePushQuery(queryId).get();\n+} catch (Exception e) {\n+  System.out.println(\"Terminate request failed: \" + e);\n+}\n+```\n+\n+Insert a new row into a stream (insertInto())<a name=\"insert-into\"></a>\n+-----------------------------------------------------------------------\n+\n+Client apps can insert new rows of data into existing ksqlDB streams via the `insertInto()` method.\n+\n+```java\n+public interface Client {\n+\n+  /**\n+   * Inserts a row into a ksqlDB stream.\n+   *\n+   * <p>The {@code CompletableFuture} will be failed if a non-200 response is received from the\n+   * server, or if the server encounters an error while processing the insertion.\n+   *\n+   * @param streamName name of the target stream\n+   * @param row the row to insert. Keys are column names and values are column values.\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, KsqlObject row);\n+  \n+  ...\n+  \n+}\n+```\n+\n+Rows for insertion are represented as `KsqlObject` instances. A `KsqlObject` represents a map of strings\n+(in this case, column names) to values (column values).\n+\n+### Example Usage ###\n+\n+Here's an example of using the client to insert a new row into an existing stream `ORDERS`\n+with schema (ORDER_ID BIGINT, PRODUCT_ID VARCHAR, USER_ID VARCHAR).\n+\n+```java\n+final Row row = new KsqlObject()\n+    .put(\"ROWKEY\", \"k1\")\n+    .put(\"ORDER_ID\", 12345678L)\n+    .put(\"PRODUCT_ID\", \"UAC-222-19234\")\n+    .put(\"USER_ID\", \"User_321\"));\n+\n+try {\n+  client.insertInto(\"ORDERS\", row).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00ac4fbc1c474ef7c63a232c2aa3150b2ba3560c"}, "originalPosition": 381}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MzczNTY0", "url": "https://github.com/confluentinc/ksql/pull/5434#pullrequestreview-418373564", "createdAt": "2020-05-26T14:46:48Z", "commit": {"oid": "f73349d73f3a1a9c285c3af44d206f6544c56f80"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21cb07c13205710520ea086db30829e3795b9195", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/21cb07c13205710520ea086db30829e3795b9195", "committedDate": "2020-05-27T04:08:32Z", "message": "docs: tweaks and a typo fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c3ff7172332e4f84b82b038751c40dae0fc3320", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/5c3ff7172332e4f84b82b038751c40dae0fc3320", "committedDate": "2020-06-02T23:06:59Z", "message": "docs: drop finals"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1743e0e2db1620144aa44906e3d4013f753d6c41", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/1743e0e2db1620144aa44906e3d4013f753d6c41", "committedDate": "2020-06-03T06:32:18Z", "message": "docs: add intro blurb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af902835eae6a05107cacb71370562809c5eb8c5", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/af902835eae6a05107cacb71370562809c5eb8c5", "committedDate": "2020-06-03T07:42:52Z", "message": "docs: more complete usage examples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45aa3a0b95a987c2c59d480c3e4252af31718305", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/45aa3a0b95a987c2c59d480c3e4252af31718305", "committedDate": "2020-06-03T07:43:16Z", "message": "Merge branch 'master' into java-client-docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0297c0bdcc77af66923a6182278aacfe5c35cb3", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/d0297c0bdcc77af66923a6182278aacfe5c35cb3", "committedDate": "2020-06-03T07:52:36Z", "message": "chore: remove try-catch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d38de93fc16262b42d8014ecb8be59a517bbb077", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/d38de93fc16262b42d8014ecb8be59a517bbb077", "committedDate": "2020-06-03T07:52:36Z", "message": "chore: grammar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eca3fd8c53750296f99aed0cd80d614361eeab8b", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/eca3fd8c53750296f99aed0cd80d614361eeab8b", "committedDate": "2020-06-03T07:57:28Z", "message": "chore: fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beb65bf9397dc51129fc902fd5a2cb5b7fdf9f71", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/beb65bf9397dc51129fc902fd5a2cb5b7fdf9f71", "committedDate": "2020-06-08T17:42:26Z", "message": "chore: pin rocksdbjni dependency version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6299b10718e8fa455e7cc707a09df5975b82a791", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/6299b10718e8fa455e7cc707a09df5975b82a791", "committedDate": "2020-06-12T23:27:03Z", "message": "chore: jim's feedback from colin's pr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "441f42afb71696046c49b96f533dffa306757551", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/441f42afb71696046c49b96f533dffa306757551", "committedDate": "2020-06-15T22:24:34Z", "message": "Revert \"chore: pin rocksdbjni dependency version\"\n\nThis reverts commit beb65bf9397dc51129fc902fd5a2cb5b7fdf9f71."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4793, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}