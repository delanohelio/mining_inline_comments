{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNTY5NDI0", "number": 5023, "title": "fix: Improve error message for where/having type errors", "bodyText": "Description\nThis change does additional validation during the analysis phase, before code generation, for where expressions, namely doing type checking and giving useful error messages.\nFixes: #4501\nTesting done\nWrote additional QTT tests and verified messages.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-04-08T00:42:51Z", "url": "https://github.com/confluentinc/ksql/pull/5023", "merged": true, "mergeCommit": {"oid": "23eb80d06ea0275b28edac9b0fb5453ea4a966f8"}, "closed": true, "closedAt": "2020-04-15T21:10:47Z", "author": {"login": "AlanConfluent"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcV6J_hAFqTM5MDY1OTg3NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX6yBIAH2gAyNDAwNTY5NDI0OmI0NmZmZGExODRkZjJhOWE1OGI2YWM0ODM3NjM4YzI4ZTU2ODE5N2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNjU5ODc1", "url": "https://github.com/confluentinc/ksql/pull/5023#pullrequestreview-390659875", "createdAt": "2020-04-09T10:06:16Z", "commit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDowNjoxNlrOGDSPWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoxNToyNFrOGDSjPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5Nzc1NQ==", "bodyText": "This is s pretty ambiguous error message. Can we do better?\nMaybe: Can not perform add BOOLEAN and DECIMAL: 'TRUE + 1.5'.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406097755", "createdAt": "2020-04-09T10:06:16Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/comparison-expression.json", "diffHunk": "@@ -0,0 +1,74 @@\n+{\n+  \"comments\": [\n+    \"Tests covering comparison expressions\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"invalid where predicate - type mismatch\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID >= 'not an int' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type mismatch in WHERE expression: Cannot compare INPUT.ID (INTEGER) to 'not an int' (STRING).\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - type mismatch complex expression\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY STRING KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ROWKEY = 'abc' AND ID >= 'not an int' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type mismatch in WHERE expression: Cannot compare INPUT.ID (INTEGER) to 'not an int' (STRING).\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - type mismatch join\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT_1 (ROWKEY INT KEY, foo INT, bar INT) WITH (kafka_topic='t1', value_format='JSON', KEY='FOO');\",\n+        \"CREATE STREAM INPUT_2 (ROWKEY INT KEY, foo INT, bar STRING) WITH (kafka_topic='t2', value_format='JSON', KEY='FOO');\",\n+        \"CREATE STREAM OUTPUT AS SELECT I1.BAR, I2.BAR FROM INPUT_1 I1 JOIN INPUT_2 I2 WITHIN 1 MINUTE ON I1.FOO = I2.FOO WHERE I1.BAR > I2.BAR;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type mismatch in WHERE expression: Cannot compare I1.BAR (INTEGER) to I2.BAR (STRING).\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - string literal\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE 'not a boolean' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type error in WHERE expression: Should evaluate to boolean but is 'not a boolean' (STRING) instead.\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - double expression\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE RANDOM() + 1.5 EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type error in WHERE expression: Should evaluate to boolean but is (RANDOM() + 1.5) (DOUBLE) instead.\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - illegal expression\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE TRUE + 1.5 EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Unsupported arithmetic types. BOOLEAN DECIMAL\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5OTI4NQ==", "bodyText": "We need  ALL of these negative tests to check for KsqlStatementException, as this then references the exact expression with the issue.\nIt's possible the right exception is being thrown already - just update the test and re-run.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"type\": \"io.confluent.ksql.util.KsqlException\",\n          \n          \n            \n                    \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n          \n      \n    \n    \n  \n\nNote: in the validation code you throw a KsqlException. Higher up the call stack, (where the code had the full statement), this should be getting caught and converted to a KsqlStatementException.  There is no need to pass down the SQL so you can throw KsqlStatementException from lower down.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406099285", "createdAt": "2020-04-09T10:08:56Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/comparison-expression.json", "diffHunk": "@@ -0,0 +1,74 @@\n+{\n+  \"comments\": [\n+    \"Tests covering comparison expressions\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"invalid where predicate - type mismatch\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID >= 'not an int' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMjg0NQ==", "bodyText": "Let's move this validation to LogicalPlanner.buildFilterNode, as that doesn't need to worry about multiple sources etc. So we're making the problem simpler by moving the validation there.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406102845", "createdAt": "2020-04-09T10:15:24Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -486,6 +486,11 @@ protected AstNode visitSelect(final Select node, final Void context) {\n \n     private void analyzeWhere(final Expression node) {\n       analysis.setWhereExpression(node);\n+\n+      final WhereTypeValidator validator = new WhereTypeValidator(\n+          analysis.getFromSourceSchemas(false),\n+          metaStore);\n+      validator.validateWhereExpression(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTE2NDQ1", "url": "https://github.com/confluentinc/ksql/pull/5023#pullrequestreview-391116445", "createdAt": "2020-04-09T20:40:32Z", "commit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDo0MDozMlrOGDonJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDo0NTo0NlrOGDoxaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NDI5NQ==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406464295", "createdAt": "2020-04-09T20:40:32Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -486,6 +486,11 @@ protected AstNode visitSelect(final Select node, final Void context) {\n \n     private void analyzeWhere(final Expression node) {\n       analysis.setWhereExpression(node);\n+\n+      final WhereTypeValidator validator = new WhereTypeValidator(\n+          analysis.getFromSourceSchemas(false),\n+          metaStore);\n+      validator.validateWhereExpression(node);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMjg0NQ=="}, "originalCommit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NDU3MQ==", "bodyText": "Made everything KsqlStatementException, and I pass in the expression to the statement text.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406464571", "createdAt": "2020-04-09T20:41:10Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/comparison-expression.json", "diffHunk": "@@ -0,0 +1,74 @@\n+{\n+  \"comments\": [\n+    \"Tests covering comparison expressions\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"invalid where predicate - type mismatch\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID >= 'not an int' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5OTI4NQ=="}, "originalCommit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NjkyMQ==", "bodyText": "Yeah...  I changed it to Error in WHERE expression: Unsupported arithmetic types. BOOLEAN DECIMAL\nWithout handling things in greater granularity explicitly, such as binary arithmetic expressions, and everything else, it's not really possible to easily have nice detailed messages.  That makes me wonder, should I really just be pushing this improved error message to ExpressionTypeManager and not special-casing comparisons?", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406466921", "createdAt": "2020-04-09T20:45:46Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/comparison-expression.json", "diffHunk": "@@ -0,0 +1,74 @@\n+{\n+  \"comments\": [\n+    \"Tests covering comparison expressions\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"invalid where predicate - type mismatch\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID >= 'not an int' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type mismatch in WHERE expression: Cannot compare INPUT.ID (INTEGER) to 'not an int' (STRING).\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - type mismatch complex expression\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY STRING KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ROWKEY = 'abc' AND ID >= 'not an int' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type mismatch in WHERE expression: Cannot compare INPUT.ID (INTEGER) to 'not an int' (STRING).\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - type mismatch join\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT_1 (ROWKEY INT KEY, foo INT, bar INT) WITH (kafka_topic='t1', value_format='JSON', KEY='FOO');\",\n+        \"CREATE STREAM INPUT_2 (ROWKEY INT KEY, foo INT, bar STRING) WITH (kafka_topic='t2', value_format='JSON', KEY='FOO');\",\n+        \"CREATE STREAM OUTPUT AS SELECT I1.BAR, I2.BAR FROM INPUT_1 I1 JOIN INPUT_2 I2 WITHIN 1 MINUTE ON I1.FOO = I2.FOO WHERE I1.BAR > I2.BAR;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type mismatch in WHERE expression: Cannot compare I1.BAR (INTEGER) to I2.BAR (STRING).\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - string literal\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE 'not a boolean' EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type error in WHERE expression: Should evaluate to boolean but is 'not a boolean' (STRING) instead.\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - double expression\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE RANDOM() + 1.5 EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Type error in WHERE expression: Should evaluate to boolean but is (RANDOM() + 1.5) (DOUBLE) instead.\"\n+      }\n+    },\n+    {\n+      \"name\": \"invalid where predicate - illegal expression\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ROWKEY DOUBLE KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE TRUE + 1.5 EMIT CHANGES;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlException\",\n+        \"message\": \"Unsupported arithmetic types. BOOLEAN DECIMAL\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5Nzc1NQ=="}, "originalCommit": {"oid": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjA4MjE3", "url": "https://github.com/confluentinc/ksql/pull/5023#pullrequestreview-391208217", "createdAt": "2020-04-10T00:21:31Z", "commit": {"oid": "3766f35bddac286b0138058b5b393078ec9609a2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDoyMTozMVrOGDtgyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDo0Nzo0NFrOGDt5TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NDU4NQ==", "bodyText": "nit: error message like \"Error evaluating type for \"  + filterType.name() + \" expression\" would be more accurate", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406544585", "createdAt": "2020-04-10T00:21:31Z", "author": {"login": "rodesai"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.VisitParentExpressionVisitor;\n+import io.confluent.ksql.execution.util.ComparisonUtil;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Traverse the AST and throw errors if necessary\n+    final TypeChecker typeChecker = new TypeChecker(filterType, expressionTypeManager);\n+    typeChecker.process(exp, null);\n+  }\n+\n+  /**\n+   * Does the actual type checking, ensuring that the where expression uses the proper types and\n+   * then giving a decent error message if there's an issue.\n+   */\n+  private static final class TypeChecker extends VisitParentExpressionVisitor<Void, Object> {\n+\n+    private final FilterType filterType;\n+    private final ExpressionTypeManager expressionTypeManager;\n+\n+    TypeChecker(final FilterType filterType, final ExpressionTypeManager expressionTypeManager) {\n+      this.filterType = filterType;\n+      this.expressionTypeManager = expressionTypeManager;\n+    }\n+\n+    public Void visitExpression(final Expression exp, final Object context) {\n+      final SqlType type;\n+      try {\n+        type = expressionTypeManager.getExpressionSqlType(exp);\n+      } catch (KsqlException e) {\n+        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3766f35bddac286b0138058b5b393078ec9609a2"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MDg2MA==", "bodyText": "This feels like something we should check at a higher level. There's lots of expressions where it would make sense to check that the operands have compatible types. For example:\n\nNotExpression should have a binary operand\nArithmeticBinary/Unary should have arithmetic operands\n\nOne option would be to move this in to ExpressionTypeManager. Then this class can be much simpler - it just needs to resolve the expression type and throw if its non-boolean.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406550860", "createdAt": "2020-04-10T00:47:44Z", "author": {"login": "rodesai"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.VisitParentExpressionVisitor;\n+import io.confluent.ksql.execution.util.ComparisonUtil;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Traverse the AST and throw errors if necessary\n+    final TypeChecker typeChecker = new TypeChecker(filterType, expressionTypeManager);\n+    typeChecker.process(exp, null);\n+  }\n+\n+  /**\n+   * Does the actual type checking, ensuring that the where expression uses the proper types and\n+   * then giving a decent error message if there's an issue.\n+   */\n+  private static final class TypeChecker extends VisitParentExpressionVisitor<Void, Object> {\n+\n+    private final FilterType filterType;\n+    private final ExpressionTypeManager expressionTypeManager;\n+\n+    TypeChecker(final FilterType filterType, final ExpressionTypeManager expressionTypeManager) {\n+      this.filterType = filterType;\n+      this.expressionTypeManager = expressionTypeManager;\n+    }\n+\n+    public Void visitExpression(final Expression exp, final Object context) {\n+      final SqlType type;\n+      try {\n+        type = expressionTypeManager.getExpressionSqlType(exp);\n+      } catch (KsqlException e) {\n+        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n+            e.getMessage(), exp.toString());\n+      }\n+      if (!SqlTypes.BOOLEAN.equals(type)) {\n+        throw new KsqlStatementException(\"Type error in \" + filterType.name() + \" expression: \"\n+            + \"Should evaluate to boolean but is \" + exp.toString()\n+            + \" (\" + type.toString(FormatOptions.none()) + \") instead.\",\n+            exp.toString());\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitComparisonExpression(\n+        final ComparisonExpression exp,\n+        final Object context\n+    ) {\n+      final SqlType leftType;\n+      final SqlType rightType;\n+      try {\n+        leftType = expressionTypeManager.getExpressionSqlType(exp.getLeft());\n+        rightType = expressionTypeManager.getExpressionSqlType(exp.getRight());\n+      } catch (KsqlException e) {\n+        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n+            e.getMessage(), exp.toString());\n+      }\n+      if (!ComparisonUtil.isValidComparison(leftType, exp.getType(), rightType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3766f35bddac286b0138058b5b393078ec9609a2"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNjk2MDI3", "url": "https://github.com/confluentinc/ksql/pull/5023#pullrequestreview-391696027", "createdAt": "2020-04-10T22:47:34Z", "commit": {"oid": "ce9619699379a1dce101247057f69b226b68dedd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjo0NzozNFrOGEHq9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjo0NzozNFrOGEHq9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzE3NQ==", "bodyText": "I don't think you need this class anymore. You can just call visitExpression directly from validateFilterExpression (or inline it). So something like :\npublic void validateFilterExpression(final Expression exp) {\n    // Construct an expression type manager to be used when checking types.\n    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n        functionRegistry);\n\n    // Rewrite the expression with magic timestamps, so type checking can pass\n    final Expression magicTimestampRewrite =\n        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n\n    final SqlType type;\n    try {\n        type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n    } catch (KsqlStatementException e) {\n        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n            e.getRawMessage(), e.getSqlStatement());\n    } catch (KsqlException e) {\n        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n            e.getMessage(), exp.toString());\n    }\n    if (!SqlTypes.BOOLEAN.equals(type)) {\n        throw new KsqlStatementException(\"Type error in \" + filterType.name() + \" expression: \"\n            + \"Should evaluate to boolean but is \" + exp.toString()\n            + \" (\" + type.toString(FormatOptions.none()) + \") instead.\",\n            exp.toString());\n    }\n}", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406973175", "createdAt": "2020-04-10T22:47:34Z", "author": {"login": "rodesai"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.VisitParentExpressionVisitor;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    // Traverse the AST and throw errors if necessary\n+    final TypeChecker typeChecker = new TypeChecker(filterType, expressionTypeManager);\n+    typeChecker.process(magicTimestampRewrite, null);\n+  }\n+\n+  /**\n+   * Does the actual type checking, ensuring that the where expression uses the proper types and\n+   * then giving a decent error message if there's an issue.\n+   */\n+  private static final class TypeChecker extends VisitParentExpressionVisitor<Void, Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce9619699379a1dce101247057f69b226b68dedd"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzIwNTQx", "url": "https://github.com/confluentinc/ksql/pull/5023#pullrequestreview-391720541", "createdAt": "2020-04-11T01:00:37Z", "commit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzI5ODMz", "url": "https://github.com/confluentinc/ksql/pull/5023#pullrequestreview-393329833", "createdAt": "2020-04-14T22:07:06Z", "commit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjowNzowNlrOGFislg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyNzowOVrOGFjMZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NDUzNA==", "bodyText": "nit: do comments like this add any benefit?  Isn't this line basically saying \"I'm creating an instance of ExpressionTypeManager\"??", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408464534", "createdAt": "2020-04-14T22:07:06Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NjMzOQ==", "bodyText": "Suggestion:  when you find yourself writing code like this, i.e. where you have a try/catch block that sets a variable created outside the scope of the try/catch, then it's often a sign you could easily refactor the code by pulling the try/catch into a method, e.g.\npublic void validateFilterExpression(final Expression exp) {\n  final SqlType type = getExpressionReturnType(exp);\n  if (!SqlTypes.BOOLEAN.equals(type)) {\n     // throw... \n  }\n}\n\nprivate SqlType getExpressionReturnType(final Expression exp) {\n   final ExpressionTypeManager expressionTypeManager = \n      new ExpressionTypeManager(schema, functionRegistry);\n\n    final Expression magicTimestampRewrite =\n        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n\n    try {\n      return expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n    } catch (KsqlStatementException e) {\n      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n          + e.getRawMessage(), e.getSqlStatement());\n    } catch (KsqlException e) {\n      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n          + e.getMessage(), exp.toString());\n    }\n}", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408466339", "createdAt": "2020-04-14T22:11:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    final SqlType type;\n+    try {\n+      type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n+    } catch (KsqlStatementException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getRawMessage(), e.getSqlStatement());\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getMessage(), exp.toString());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzI3OA==", "bodyText": "I don't think you need to worry about KsqlStatementException here.  Though I could be wrong.  Generally, the code lower down just throws KsqlException, as it doesn't have the whole SQL statement.  Higher up the call stack this is caught and converted to a KsqlStatementException.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408467278", "createdAt": "2020-04-14T22:13:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    final SqlType type;\n+    try {\n+      type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n+    } catch (KsqlStatementException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getRawMessage(), e.getSqlStatement());\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getMessage(), exp.toString());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzkxNA==", "bodyText": "This is a misuse of KsqlStatementException.  It takes the full sql statement as its second parameter, not the snippet of the statement that causes the error.\nAs above, just throw KsqlException. Code higher up will handle the conversion to KsqlStatementException.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408467914", "createdAt": "2020-04-14T22:15:03Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    final SqlType type;\n+    try {\n+      type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n+    } catch (KsqlStatementException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getRawMessage(), e.getSqlStatement());\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getMessage(), exp.toString());\n+    }\n+    if (!SqlTypes.BOOLEAN.equals(type)) {\n+      throw new KsqlStatementException(\"Type error in \" + filterType.name() + \" expression: \"\n+          + \"Should evaluate to boolean but is \" + exp.toString()\n+          + \" (\" + type.toString(FormatOptions.none()) + \") instead.\",\n+          exp.toString());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2ODI3MA==", "bodyText": "I think you misunderstood what I was meaning when I was talking about factory classes.  No worries. But I don't think injecting this filterNodeFactory is actually used by any testing, and its not what I had in mind, so we can probably simplify the code by removing it and just calling the function directly.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408468270", "createdAt": "2020-04-14T22:15:58Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -84,26 +86,38 @@\n   private final RewrittenAnalysis analysis;\n   private final FunctionRegistry functionRegistry;\n   private final AggregateAnalyzer aggregateAnalyzer;\n+  private final BiFunction<PlanNode, Expression, FilterNode> filterNodeFactory;\n   private final ColumnReferenceRewriter refRewriter;\n \n   public LogicalPlanner(\n       final KsqlConfig ksqlConfig,\n       final ImmutableAnalysis analysis,\n-      final FunctionRegistry functionRegistry\n+      final FunctionRegistry functionRegistry,\n+      final BiFunction<PlanNode, Expression, FilterNode> filterNodeFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDI0Nw==", "bodyText": "As above, let's remove this for now.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408470247", "createdAt": "2020-04-14T22:20:58Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FilterNode.java", "diffHunk": "@@ -81,4 +82,11 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n             contextStacker\n         );\n   }\n+\n+  public interface FilterNodeFactory {\n+    FilterNode create(\n+        FunctionRegistry functionRegistry,\n+        PlanNode sourcePlanNode,\n+        Expression filterExpression);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDQzNQ==", "bodyText": "ExpectedException is deprecated - use assertThrows instead. (You can search the code base for exampels)", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408470435", "createdAt": "2020-04-14T22:21:33Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/analyzer/FilterTypeValidatorTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static io.confluent.ksql.schema.ksql.Column.Namespace.VALUE;\n+import static io.confluent.ksql.schema.ksql.types.SqlTypes.INTEGER;\n+import static io.confluent.ksql.schema.ksql.types.SqlTypes.STRING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.analyzer.FilterTypeValidator.FilterType;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class FilterTypeValidatorTest {\n+  private static final ColumnName COLUMN1 = ColumnName.of(\"col1\");\n+  private static final ColumnName COLUMN2 = ColumnName.of(\"col2\");\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTU3Ng==", "bodyText": "Another misuse of KsqlStatementException - just throw KsqlException.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408471576", "createdAt": "2020-04-14T22:24:24Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -164,7 +165,13 @@ public Void visitComparisonExpression(\n       final SqlType leftSchema = expressionTypeContext.getSqlType();\n       process(node.getRight(), expressionTypeContext);\n       final SqlType rightSchema = expressionTypeContext.getSqlType();\n-      ComparisonUtil.isValidComparison(leftSchema, node.getType(), rightSchema);\n+      if (!ComparisonUtil.isValidComparison(leftSchema, node.getType(), rightSchema)) {\n+        throw new KsqlStatementException(\"Cannot compare \"\n+            + node.getLeft().toString() + \" (\" + leftSchema.toString() + \") to \"\n+            + node.getRight().toString() + \" (\" + rightSchema.toString() + \") \"\n+            + \"with \" + node.getType() + \".\",\n+            node.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTcwNg==", "bodyText": "I think this can be package private again now.", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408471706", "createdAt": "2020-04-14T22:24:47Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -27,7 +27,7 @@\n import java.util.function.BiPredicate;\n import java.util.function.Predicate;\n \n-final class ComparisonUtil {\n+public final class ComparisonUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjA3MA==", "bodyText": "This method appears to only be called from tests.... so should probably be deleted, and the tests changed to check the return value of isValidComparison", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408472070", "createdAt": "2020-04-14T22:25:44Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -38,25 +38,31 @@\n   private ComparisonUtil() {\n   }\n \n-  static void isValidComparison(\n+  public static void assertValidComparison(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjY3Ng==", "bodyText": "I take it these have changed before they were invalid otherwise?", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408472676", "createdAt": "2020-04-14T22:27:09Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java", "diffHunk": "@@ -114,7 +114,7 @@ public void testSimpleLeftJoinFilterLogicalPlan() {\n     final String\n         simpleQuery =\n         \"SELECT t1.col1, t2.col1, col5, t2.col4, t2.col2 FROM test1 t1 LEFT JOIN test2 t2 ON \"\n-        + \"t1.col0 = t2.col0 WHERE t1.col1 > 10 AND t2.col4 = 10.8 EMIT CHANGES;\";\n+        + \"t1.col0 = t2.col0 WHERE t1.col3 > 10.8 AND t2.col2 = 'foo' EMIT CHANGES;\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2b65ad80a1bd88a7c6b780a916e60266a7b2367", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/c2b65ad80a1bd88a7c6b780a916e60266a7b2367", "committedDate": "2020-04-15T15:58:49Z", "message": "fix: Improve error message for where type errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe6e881e7592d5ad04448e1b265e7419cd75dc8", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/dbe6e881e7592d5ad04448e1b265e7419cd75dc8", "committedDate": "2020-04-15T15:59:53Z", "message": "Makes type checks work across sources, such as with a join"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f35c0b2cb9eb03e0695fb833214a56d167d97299", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/f35c0b2cb9eb03e0695fb833214a56d167d97299", "committedDate": "2020-04-15T16:00:22Z", "message": "High level feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "939ea7a74fc282606a4bf71686a7e74047ed23e9", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/939ea7a74fc282606a4bf71686a7e74047ed23e9", "committedDate": "2020-04-15T16:00:23Z", "message": "More feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0266e2150e468c6a0bdd49240b774358b7a83ee0", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/0266e2150e468c6a0bdd49240b774358b7a83ee0", "committedDate": "2020-04-15T16:00:23Z", "message": "Comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d59a39009bfca93e7589a3b4a2a52741695691dc", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/d59a39009bfca93e7589a3b4a2a52741695691dc", "committedDate": "2020-04-15T16:00:23Z", "message": "Fixes magic rewrite error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76630d05057a40b9f1d008058ace0fd1e67ba59a", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/76630d05057a40b9f1d008058ace0fd1e67ba59a", "committedDate": "2020-04-15T16:00:23Z", "message": "Feedback to push changes to ExpressionTypeManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "569fe9f8d51b19007f8bc977b40c8846c9ac380e", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/569fe9f8d51b19007f8bc977b40c8846c9ac380e", "committedDate": "2020-04-15T16:00:23Z", "message": "More feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f8de7c178846f73e72c3e4114587dd640b96eb3", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/8f8de7c178846f73e72c3e4114587dd640b96eb3", "committedDate": "2020-04-15T16:00:23Z", "message": "Moooooore feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "40741a213facd253280ba5d5e999f12ea48587c3", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/40741a213facd253280ba5d5e999f12ea48587c3", "committedDate": "2020-04-15T00:04:36Z", "message": "Moooooore feedback"}, "afterCommit": {"oid": "8f8de7c178846f73e72c3e4114587dd640b96eb3", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/8f8de7c178846f73e72c3e4114587dd640b96eb3", "committedDate": "2020-04-15T16:00:23Z", "message": "Moooooore feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b46ffda184df2a9a58b6ac4837638c28e568197f", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/b46ffda184df2a9a58b6ac4837638c28e568197f", "committedDate": "2020-04-15T16:35:28Z", "message": "Fixs a few test cases with updated error messages"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4825, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}