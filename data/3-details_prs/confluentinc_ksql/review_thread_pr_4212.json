{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4ODI1Mzgw", "number": 4212, "reviewThreads": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwMDoxMTo1MlrODVkp5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMToxODoxM1rODWXy4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjIzOTQ3MjM2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwMDoxMTo1MlrOFZ39RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNDowNFrOFaFHyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY3NTUyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n          \n          \n            \n            This tutorial shows how to integrate ksqlDB with an external data source to power a simple ridesharing app. The external source is a PostgreSQL database containing relatively static data that describes each driver\u2019s vehicle. This tutorial combines the human-friendly static data with a continuous stream of computer-friendly driver and rider location events to derive an enriched output stream that the ridesharing app uses to set up a rendezvous in real time.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362675524", "createdAt": "2020-01-03T00:11:52Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4MTQ2MQ==", "bodyText": "Can you please break these paras at column 80?", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362681461", "createdAt": "2020-01-03T00:52:52Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY3NTUyNA=="}, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MTIxMA==", "bodyText": "My bad, I will ensure all lines are broken at 80 chars \ud83d\udc4d", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362891210", "createdAt": "2020-01-03T17:24:04Z", "author": {"login": "derekjn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY3NTUyNA=="}, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDUxMTExOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDozNTo1NlrOFaBXpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDozNTo1NlrOFaBXpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgyOTczNA==", "bodyText": "nit: inconsistent spacing before AS", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362829734", "createdAt": "2020-01-03T14:35:56Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDUyMzkxOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0MDoyN1rOFaBe0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0MDoyN1rOFaBe0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzMTU3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n          \n          \n            \n            Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. Because ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362831570", "createdAt": "2020-01-03T14:40:27Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDUyNjI3OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0MToyMlrOFaBgPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0MToyMlrOFaBgPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzMTkzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional describing the driver's vehicle.\n          \n          \n            \n            As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional information describing the driver's vehicle.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362831932", "createdAt": "2020-01-03T14:41:22Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n+\n+```sql\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (0, 37.3965, -122.0818, 23.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (0, 37.3952, -122.0813);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (1, 37.7850, -122.40270, 12.0);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (2, 37.7925, -122.4148, 11.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876,-122.4235);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (3, 37.4471, -122.1625, 14.7);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (3, 37.4442, -122.1658);\n+```\n+\n+As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional describing the driver's vehicle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDUzMzg2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0NDo0NVrOFaBk0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0NDo0NVrOFaBk0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzMzEwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This tutorial has demonstrated how to run ksqlDB in embedded Connect mode using Docker. We have used the JDBC connector to integrate ksqlDB with PostgreSQL data, but this is just one of many connectors that are available to help you integrate ksqlDB with external systems. Check out [Confluent Hub](https://www.confluent.io/hub/) to learn more about all of the various connectors that enable integration with a wide variety of external systems.\n          \n          \n            \n            This tutorial demonstrated how to run ksqlDB in embedded Connect mode using Docker. We used the JDBC connector to integrate ksqlDB with PostgreSQL data, but this is just one of many connectors that are available to help you integrate ksqlDB with external systems. Check out [Confluent Hub](https://www.confluent.io/hub/) to learn more about all of the various connectors that enable integration with a wide variety of external systems.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362833106", "createdAt": "2020-01-03T14:44:45Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n+\n+```sql\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (0, 37.3965, -122.0818, 23.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (0, 37.3952, -122.0813);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (1, 37.7850, -122.40270, 12.0);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (2, 37.7925, -122.4148, 11.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876,-122.4235);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (3, 37.4471, -122.1625, 14.7);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (3, 37.4442, -122.1658);\n+```\n+\n+As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional describing the driver's vehicle.\n+\n+Next steps\n+-------------\n+\n+This tutorial has demonstrated how to run ksqlDB in embedded Connect mode using Docker. We have used the JDBC connector to integrate ksqlDB with PostgreSQL data, but this is just one of many connectors that are available to help you integrate ksqlDB with external systems. Check out [Confluent Hub](https://www.confluent.io/hub/) to learn more about all of the various connectors that enable integration with a wide variety of external systems.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDU0MDgyOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0Nzo0MVrOFaBo-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0Nzo0MVrOFaBo-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzNDE3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);\n          \n          \n            \n            INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887, -122.4074);", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362834171", "createdAt": "2020-01-03T14:47:41Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n+\n+```sql\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (0, 37.3965, -122.0818, 23.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (0, 37.3952, -122.0813);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (1, 37.7850, -122.40270, 12.0);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDU0MTI5OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0Nzo1NFrOFaBpSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo0Nzo1NFrOFaBpSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzNDI0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876,-122.4235);\n          \n          \n            \n            INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876, -122.4235);", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362834248", "createdAt": "2020-01-03T14:47:54Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n+\n+```sql\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (0, 37.3965, -122.0818, 23.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (0, 37.3952, -122.0813);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (1, 37.7850, -122.40270, 12.0);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (2, 37.7925, -122.4148, 11.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876,-122.4235);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDU1MzcxOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNDo1MzoyN1rOFaBw3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMjowOVrOFaFFQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzNjE4OA==", "bodyText": "The docker-compose files to the right\n\nI suspect \"to the right\" may be vestigial from the quickstart text. On the docs site it will render below, no?", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362836188", "createdAt": "2020-01-03T14:53:27Z", "author": {"login": "colinhicks"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4NDM0NQ==", "bodyText": "Yes, code renders inline.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362884345", "createdAt": "2020-01-03T17:03:06Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzNjE4OA=="}, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MDU2Mg==", "bodyText": "Good catch @colinhicks, missed that one ;)", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362890562", "createdAt": "2020-01-03T17:22:09Z", "author": {"login": "derekjn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgzNjE4OA=="}, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg2NzQwOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzowNjo1NlrOFaEx3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzowNjo1NlrOFaEx3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4NTU5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n          \n          \n            \n            Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }} installation that ksqlDB is configured to use. The following docker-compose files run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of {{ site.kconnect }} without having to manage a separate {{ site.kconnect }} cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL as an external datastore to integrate with ksqlDB.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362885597", "createdAt": "2020-01-03T17:06:56Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg2OTMwOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzowNzo1NFrOFaEzGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzowNzo1NFrOFaEzGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4NTkxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n          \n          \n            \n            In an empty local working directory, copy and paste the following `docker-compose` content into a file named `docker-compose.yml`. You will create and add a number of other files to this directory during this tutorial.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362885913", "createdAt": "2020-01-03T17:07:54Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg3MzQxOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzowOTo0MVrOFaE1rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzowOTo0MVrOFaE1rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4NjU3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```bash\n          \n          \n            \n            ```yaml", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362886573", "createdAt": "2020-01-03T17:09:41Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg3NjI5OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxMTowOFrOFaE3iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxMTowOFrOFaE3iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4NzA0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n          \n          \n            \n            In the directory containing the `docker-compose.yml` file you created in the first step, run the following command to start all services in the correct order.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362887049", "createdAt": "2020-01-03T17:11:08Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg3NzY1OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxMTo0NlrOFaE4Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxMTo0NlrOFaE4Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4NzI2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Establish an interactive session with PostgreSQL by running this command:\n          \n          \n            \n            Run the following command to establish an interactive session with PostgreSQL.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362887266", "createdAt": "2020-01-03T17:11:46Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg4NDk1OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxNTo0MVrOFaE9Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxNTo0MVrOFaE9Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4ODQ3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n          \n          \n            \n            In the PostgreSQL session, run the following SQL statements to set up the driver data. You will join this PostgreSQL data with event streams in ksqlDB.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362888470", "createdAt": "2020-01-03T17:15:41Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg4NjczOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxNjozMFrOFaE-Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxNjozMFrOFaE-Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4ODc1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n          \n          \n            \n            Run the following command to connect to the ksqlDB server and start an interactive command-line interface (CLI) session.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362888754", "createdAt": "2020-01-03T17:16:30Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg4ODM5OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxNzoyNFrOFaE_Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxNzoyNFrOFaE_Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4OTAxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n          \n          \n            \n            Make your PostgreSQL data accessible to ksqlDB by creating a *source* connector. In the ksqlDB CLI, run the following command.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362889010", "createdAt": "2020-01-03T17:17:24Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg5MTY1OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxODo1NVrOFaFBHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoxODo1NVrOFaFBHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4OTUwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n          \n          \n            \n            When the source connector is created, it imports any PostgreSQL tables matching the specified `table.whitelist`. Tables are imported via {{ site.ak }} topics, with one topic per imported table. Once these topics are created, you can interact with them just like any other {{ site.ak }} topic used by ksqlDB.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362889500", "createdAt": "2020-01-03T17:18:55Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg5MzcyOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMDowN1rOFaFCiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMDowN1rOFaFCiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg4OTg2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n          \n          \n            \n            In the ksqlDB CLI session, run the following command to verify that the `drivers` table has been imported. Because you specified `jdbc_` as the topic prefix, you should see a `jdbc_drivers` topic in the output.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362889864", "createdAt": "2020-01-03T17:20:07Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg5Njc3OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMTozMVrOFaFEfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMTozMVrOFaFEfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MDM2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n          \n          \n            \n            The driver data is now integrated as a {{ site.ak }} topic, but you need to create a ksqlDB table over this topic to begin referencing it from ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a {{ site.ak }} topic, breaking each message in the topic into strongly typed columns.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362890365", "createdAt": "2020-01-03T17:21:31Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDg5ODU4OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMjozMVrOFaFFrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMjozMVrOFaFFrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MDY2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            11. Create driverLocations and riderLocations streams\n          \n          \n            \n            11. Create streams for driver locations and rider locations", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362890669", "createdAt": "2020-01-03T17:22:31Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkwMTc5OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMzo1NFrOFaFHlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyMzo1NFrOFaFHlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MTE1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n          \n          \n            \n            In this step, you create streams to encapsulate location pings that are sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, so they're suitable for a continuous stream of location updates.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362891158", "createdAt": "2020-01-03T17:23:54Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkwMjQwOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNDoxNFrOFaFIBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNDoxNFrOFaFIBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MTI3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            12. Enrich driverLocations stream by joining with PostgreSQL data\n          \n          \n            \n            12. Enrich the driver locations stream by joining with PostgreSQL data", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362891271", "createdAt": "2020-01-03T17:24:14Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkwNDY2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNTozMlrOFaFJlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNTozMlrOFaFJlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MTY2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n          \n          \n            \n            The `driverLocations` stream has a relatively compact schema, and it doesn\u2019t contain much data that a human would find particularly useful. You can *enrich* the stream of driver location events by joining them with the human-friendly vehicle information stored in the PostgreSQL database. This enriched data can be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362891669", "createdAt": "2020-01-03T17:25:32Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkwNzA0OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNjo0OFrOFaFLGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyNjo0OFrOFaFLGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MjA1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n          \n          \n            \n            You can achieve this result easily by joining the `driverLocations` stream with the `drivers` table stored in PostgreSQL.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362892056", "createdAt": "2020-01-03T17:26:48Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkwOTY2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyODowNlrOFaFMsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyODowNlrOFaFMsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MjQ2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n          \n          \n            \n            To put all of this together, create a final stream that the ridesharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app can use to show the rider their driver\u2019s position as the rider waits to be picked up.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362892465", "createdAt": "2020-01-03T17:28:06Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkxMDE5OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyODoxOVrOFaFM9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyODoxOVrOFaFM9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5MjUzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            13. Create rendezvous stream\n          \n          \n            \n            13. Create the rendezvous stream", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362892532", "createdAt": "2020-01-03T17:28:19Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkxMjIwOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyOToyM1rOFaFOMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzoyOToyM1rOFaFOMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5Mjg1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n          \n          \n            \n            The rendezvous stream includes human-friendly information describing the driver\u2019s vehicle for the rider. Also, the rendezvous stream computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362892851", "createdAt": "2020-01-03T17:29:23Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkxOTA0OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozMjozMVrOFaFSMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozMjozMVrOFaFSMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5Mzg3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n          \n          \n            \n            Run the following command twice to open two separate ksqlDB CLI sessions. If you still have a CLI session open from a previous step, you can reuse that session.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362893875", "createdAt": "2020-01-03T17:32:31Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkyMDU0OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozMzowN1rOFaFTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozMzowN1rOFaFTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5NDA5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We\u2019re now going to run a continuous query over the rendezvous stream.\n          \n          \n            \n            In this step, you run a continuous query over the rendezvous stream.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362894097", "createdAt": "2020-01-03T17:33:07Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkyMzg2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozNDoyM1rOFaFU7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozNDoyM1rOFaFU7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5NDU3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n          \n          \n            \n            This may feel a bit unfamiliar, because the query never returns until you terminate it. The query perpetually pushes output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as events are written into ksqlDB.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362894574", "createdAt": "2020-01-03T17:34:23Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkyNjY2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozNTozM1rOFaFWgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozNTozM1rOFaFWgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5NDk3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n          \n          \n            \n            Your continuous query reads from the `rendezvous` stream, which takes its input from the `enrichedDriverLocations` and `riderLocations` streams. And `enrichedDriverLocations` takes its input from the `driverLocations` stream, so you need to write data into `driverLocations` and `riderLocations` before `rendezvous` produces the joined output that the continuous query reads.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362894979", "createdAt": "2020-01-03T17:35:33Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkzMDg3OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozNzoyMFrOFaFZBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozNzoyMFrOFaFZBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5NTYyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional describing the driver's vehicle.\n          \n          \n            \n            As soon as you start writing rows to the input streams, your continuous query from the previous step starts producing joined output. The rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, and additional information describing the driver's vehicle.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362895620", "createdAt": "2020-01-03T17:37:20Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n+\n+```sql\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (0, 37.3965, -122.0818, 23.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (0, 37.3952, -122.0813);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (1, 37.7850, -122.40270, 12.0);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (2, 37.7925, -122.4148, 11.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876,-122.4235);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (3, 37.4471, -122.1625, 14.7);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (3, 37.4442, -122.1658);\n+```\n+\n+As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional describing the driver's vehicle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDkzNTgwOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozOTowMlrOFaFbrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzozOTowMlrOFaFbrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5NjMwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This tutorial has demonstrated how to run ksqlDB in embedded Connect mode using Docker. We have used the JDBC connector to integrate ksqlDB with PostgreSQL data, but this is just one of many connectors that are available to help you integrate ksqlDB with external systems. Check out [Confluent Hub](https://www.confluent.io/hub/) to learn more about all of the various connectors that enable integration with a wide variety of external systems.\n          \n          \n            \n            This tutorial shows how to run ksqlDB in embedded {{ site.kconnect }} mode using Docker. It uses the JDBC connector to integrate ksqlDB with PostgreSQL data, but this is just one of many connectors that are available to help you integrate ksqlDB with external systems. Check out [Confluent Hub](https://www.confluent.io/hub/) to learn more about all of the various connectors that enable integration with a wide variety of external systems.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362896302", "createdAt": "2020-01-03T17:39:02Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,334 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data source to power a simple ride sharing app. Our external source will be a PostgreSQL database containing relatively static data describing each driver\u2019s vehicle. By combining this human-friendly static data with a continuous stream of computer-friendly driver and rider location events, we derive an enriched output stream that the ride sharing app may use to facilitate a rendezvous in real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on Apache Kafka\u00ae, you'll need to have a Kafka installation running that ksqlDB is configured to use. The docker-compose files to the right will run everything for you via Docker, including ksqlDB running [Kafka Connect](https://docs.confluent.io/current/connect/index.html) in embedded mode. Embedded Connect enables you to leverage the power of Connect without having to manage a separate Connect cluster--ksqlDB will manage one for you. Additionally, we will be using PostgreSQL as an external datastore to integrate with ksqlDB.\n+\n+Copy and paste the below ``docker-compose`` content into a file named ``docker-compose.yml`` in an empty local working directory. We will create and add a number of other files to this directory during this tutorial.\n+\n+```bash\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc) to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB to a separate Connect configuration file. In our docker-compose file, this is done via the ``KSQL_KSQL_CONNECT_WORKER_CONFIG`` environment variable. From within your local working directory, run this command to generate the Connect configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+From a directory containing the ``docker-compose.yml`` file created in the first step, run this command in order to start all services in the correct order:\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Establish an interactive session with PostgreSQL by running this command:\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+From within the session opened in the previous step, run these SQL statements to set up our driver data. We will ultimately join this PostgreSQL data with our event streams in ksqlDB:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run this command to connect to the ksqlDB server and enter an interactive command-line interface (CLI) session:\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Next, we are going to make our PostgreSQL data accessible to ksqlDB by creating a *source* connector. From within the ksqlDB session opened in the previous step, run this command:\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+Once the source connector is created, it will import any PostgreSQL tables matching the specified ``table.whitelist``. Tables are imported via Kafka topics, one topic per imported table. Once these topics are created, we may interact with them just like any other Kafka topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+From within your ksqlDB CLI session, run this command to verify that the drivers table has been imported. Since we\u2019ve specified ``jdbc_`` as our topic prefix, you should see a ``jdbc_drivers`` topic in the output of this command:\n+\n+```bash\n+SHOW TOPICS;\n+```\n+\n+10. Create drivers table in ksqlDB\n+----------------------------------\n+\n+While our driver data is now integrated as a Kafka topic, we\u2019ll want to create a ksqlDB table over this topic in order to begin referencing it from any ksqlDB queries. Streams and tables in ksqlDB essentially associate a schema with a Kafka topic, breaking each message in the topic into strongly typed columns:\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id INTEGER,\n+  make STRING,\n+  model STRING,\n+  year INTEGER,\n+  license_plate STRING,\n+  rating DOUBLE\n+)\n+WITH (kafka_topic='jdbc_drivers', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+Tables in ksqlDB support update semantics, where each message in the underlying topic represents a row in the table. For messages in the topic with the same key, the latest message associated with a given key represents the latest value for the corresponding row in the table.\n+\n+11. Create driverLocations and riderLocations streams\n+-----------------------------------------------------\n+\n+Next we\u2019ll create streams to encapsulate location pings sent every few seconds by drivers\u2019 and riders\u2019 phones. In contrast to tables, ksqlDB streams are append-only collections of events, and therefore suitable for a continuous stream of location updates.\n+\n+```sql\n+CREATE STREAM driverLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE,\n+  speed DOUBLE\n+)\n+WITH (kafka_topic='driver_locations', value_format='json', partitions=1, key='driver_id');\n+\n+CREATE STREAM riderLocations (\n+  driver_id INTEGER,\n+  latitude DOUBLE,\n+  longitude DOUBLE\n+)\n+WITH (kafka_topic='rider_locations', value_format='json', partitions=1, key='driver_id');\n+```\n+\n+12. Enrich driverLocations stream by joining with PostgreSQL data\n+-----------------------------------------------------------------\n+\n+The ``driverLocations`` stream has a relatively compact schema, and doesn\u2019t contain much data that a human would find particularly useful. We\u2019d therefore like to *enrich* our stream of driver location events by joining them with the human-friendly vehicle information stored in our PostgreSQL database. This enriched data may then be presented by the rider\u2019s mobile application, ultimately helping the rider to safely identify the driver\u2019s vehicle.\n+\n+We can easily achieve this result using ksqlDB by simply joining the ``driverLocations`` stream with the ``drivers`` table stored in PostgreSQL:\n+\n+```sql\n+CREATE STREAM enrichedDriverLocations AS\n+  SELECT\n+    dl.driver_id       AS driver_id,\n+    dl.latitude        AS latitude,\n+    dl.longitude       AS longitude,\n+    dl.speed           AS speed,\n+    jdbc.make          AS make,\n+    jdbc.model         AS model,\n+    jdbc.year          AS year,\n+    jdbc.license_plate AS license_plate,\n+    jdbc.rating AS rating\n+  FROM driverLocations dl JOIN drivers jdbc\n+    ON dl.driver_id = jdbc.driver_id\n+  EMIT CHANGES; \n+```\n+\n+13. Create rendezvous stream\n+----------------------------\n+\n+Putting all of this together, we will now create a final stream that the ride sharing app can use to facilitate a driver-rider rendezvous in real time. This stream is defined by a query that joins together rider and driver location updates, resulting in a contextualized output that the app may use to show the rider their driver\u2019s position as the rider waits to be picked up.\n+\n+Our rendezvous stream also includes human-friendly information describing the driver\u2019s vehicle for the rider, and even computes (albeit naively) the driver\u2019s estimated time of arrival (ETA) at the rider\u2019s location:\n+\n+```sql\n+CREATE STREAM rendezvous AS\n+  SELECT\n+    e.license_plate AS license_plate,\n+    e.make          AS make,\n+    e.model         AS model,\n+    e.year          AS year,\n+    e.latitude      AS vehicle_lat,\n+    e.longitude     AS vehicle_long,\n+    GEO_DISTANCE(e.latitude, e.longitude, r.latitude, r.longitude) / e.speed AS eta\n+  FROM enrichedDriverLocations e JOIN riderLocations r WITHIN 1 MINUTE\n+    ON e.driver_id = r.driver_id\n+  EMIT CHANGES;\n+```\n+\n+14. Start two ksqlDB CLI sessions\n+---------------------------------\n+\n+Run this command to twice to open two separate ksqlDB CLI sessions. Will we use both of these sessions in the steps to follow. Note that if you still have a CLI session open from a previous step, you may reuse that session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+15. Run a continuous query\n+--------------------------\n+\n+We\u2019re now going to run a continuous query over the rendezvous stream.\n+\n+This is the first thing that may feel a bit unfamiliar to you, because the query will never return until it's terminated. It will perpetually push output rows to the client as events are written to the rendezvous stream. Leave the query running in your CLI session for now. It will begin producing output as soon as we write events into ksqlDB:\n+\n+```sql\n+SELECT * FROM rendezvous EMIT CHANGES;\n+```\n+\n+16. Write data to input streams\n+-------------------------------\n+\n+Our continuous query is reading from the ``rendezvous`` stream, which takes its input from the ``enrichedDriverLocations`` and ``riderLocations`` streams. And ``enrichedDriverLocations`` takes its input from the ``driverLocations`` stream, so we'll need to write data into ``driverLocations`` and ``riderLocations`` before ``rendezvous`` will produce the joined output that our continuous query will read:\n+\n+```sql\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (0, 37.3965, -122.0818, 23.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (0, 37.3952, -122.0813);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (1, 37.7850, -122.40270, 12.0);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (1, 37.7887,-122.4074);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (2, 37.7925, -122.4148, 11.2);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (2, 37.7876,-122.4235);\n+\n+INSERT INTO driverLocations (driver_id, latitude, longitude, speed) VALUES (3, 37.4471, -122.1625, 14.7);\n+INSERT INTO riderLocations (driver_id, latitude, longitude) VALUES (3, 37.4442, -122.1658);\n+```\n+\n+As soon as you start writing rows to the input streams, your continuous query from the previous step will begin producing joined output: the rider's location pings are joined with their inbound driver's location pings in real time, providing the rider with driver ETA, rating, as well as additional describing the driver's vehicle.\n+\n+Next steps\n+-------------\n+\n+This tutorial has demonstrated how to run ksqlDB in embedded Connect mode using Docker. We have used the JDBC connector to integrate ksqlDB with PostgreSQL data, but this is just one of many connectors that are available to help you integrate ksqlDB with external systems. Check out [Confluent Hub](https://www.confluent.io/hub/) to learn more about all of the various connectors that enable integration with a wide variety of external systems.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDk0Mzg2OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/index.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzo0MjozM1rOFaFgeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNzo0MjozM1rOFaFgeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg5NzUyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ksqlDB has native integration with Kafka Connect. While ksqlDB can integrate with a separate [Kafka Connect](https://docs.confluent.io/current/connect/index.html) cluster, it can also run Connect embedded within the ksqlDB server, making it unnecessary to run a separate Connect cluster. The [embedded Connect tutorial](embedded-connect.md) provides an overview of how ksqlDB may be configured and used to run Connect in embedded mode.\n          \n          \n            \n            ksqlDB has native integration with {{ site.kconnect }}. While ksqlDB can integrate with a separate [Kafka Connect](https://docs.confluent.io/current/connect/index.html) cluster, it can also run {{ site.kconnect }} embedded within the ksqlDB server, making it unnecessary to run a separate {{ site.kconnect }} cluster. The [embedded Connect tutorial](embedded-connect.md) shows how you can configure ksqlDB to run {{ site.kconnect }} in embedded mode.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362897529", "createdAt": "2020-01-03T17:42:33Z", "author": {"login": "JimGalasyn"}, "path": "docs-md/tutorials/index.md", "diffHunk": "@@ -101,6 +102,11 @@ installs. Running the Clickstream demo locally without Docker requires\n that you have {{ site.cp }} installed locally, along with\n Elasticsearch and Grafana.\n \n+ksqlDB with Embedded Connect\n+-------------------------------\n+\n+ksqlDB has native integration with Kafka Connect. While ksqlDB can integrate with a separate [Kafka Connect](https://docs.confluent.io/current/connect/index.html) cluster, it can also run Connect embedded within the ksqlDB server, making it unnecessary to run a separate Connect cluster. The [embedded Connect tutorial](embedded-connect.md) provides an overview of how ksqlDB may be configured and used to run Connect in embedded mode.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e30cba43817b326914bea67f3a94956e28ae4dc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTQ1NzgwOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/index.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMjoxMTo1NlrOFaKcMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMjoxMTo1NlrOFaKcMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk3ODM1NA==", "bodyText": "should we give some guidance about when it makes sense to use embedded connect vs a separate cluster?", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362978354", "createdAt": "2020-01-03T22:11:56Z", "author": {"login": "rodesai"}, "path": "docs-md/tutorials/index.md", "diffHunk": "@@ -101,6 +102,11 @@ installs. Running the Clickstream demo locally without Docker requires\n that you have {{ site.cp }} installed locally, along with\n Elasticsearch and Grafana.\n \n+ksqlDB with Embedded Connect\n+-------------------------------\n+\n+ksqlDB has native integration with {{ site.kconnect }}. While ksqlDB can integrate with a separate [Kafka Connect](https://docs.confluent.io/current/connect/index.html) cluster, it can also run {{ site.kconnect }} embedded within the ksqlDB server, making it unnecessary to run a separate {{ site.kconnect }} cluster. The [embedded Connect tutorial](embedded-connect.md) shows how you can configure ksqlDB to run {{ site.kconnect }} in embedded mode.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTQ2NzQzOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMjoxODowNVrOFaKiCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMjoxODowNVrOFaKiCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk3OTg0OA==", "bodyText": "maybe specify that the drivers table has been imported as a kafka topic? At first I thought you meant I would see it as a KSQL table.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362979848", "createdAt": "2020-01-03T22:18:05Z", "author": {"login": "rodesai"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc)\n+to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB\n+to a separate Connect configuration file. In our docker-compose file, this is\n+done via the `KSQL_KSQL_CONNECT_WORKER_CONFIG` environment variable. From\n+within your local working directory, run this command to generate the Connect\n+configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+In the directory containing the `docker-compose.yml` file you created in the\n+first step, run the following command to start all services in the correct\n+order.\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Run the following command to establish an interactive session with PostgreSQL.\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+In the PostgreSQL session, run the following SQL statements to set up the\n+driver data. You will join this PostgreSQL data with event streams in ksqlDB.\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run the following command to connect to the ksqlDB server and start an\n+interactive command-line interface (CLI) session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Make your PostgreSQL data accessible to ksqlDB by creating a *source*\n+connector. In the ksqlDB CLI, run the following command.\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+When the source connector is created, it imports any PostgreSQL tables matching\n+the specified `table.whitelist`. Tables are imported via {{ site.ak }} topics,\n+with one topic per imported table. Once these topics are created, you can\n+interact with them just like any other {{ site.ak }} topic used by ksqlDB.\n+\n+9. View imported topic\n+----------------------\n+\n+In the ksqlDB CLI session, run the following command to verify that the\n+`drivers` table has been imported. Because you specified `jdbc_` as the topic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTU0ODc4OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMzoyMTozMVrOFaLTbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1MjoyNFrOFcQsyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5MjQ5Mw==", "bodyText": "Latest JDBC source connector is now confluentinc-kafka-connect-jdbc-5.3.2.zip", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362992493", "createdAt": "2020-01-03T23:21:31Z", "author": {"login": "mikebin"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc)\n+to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3ODA1OA==", "bodyText": "Updated", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r365178058", "createdAt": "2020-01-10T10:52:24Z", "author": {"login": "rmoff"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc)\n+to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5MjQ5Mw=="}, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTU1MDQ1OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMzoyMzoxN1rOFaLUdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1Mjo0NFrOFcQtXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5Mjc1Ng==", "bodyText": "5.3.2 is now the latest for all CP components (with 5.4.0 coming soon)", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362992756", "createdAt": "2020-01-03T23:23:17Z", "author": {"login": "mikebin"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3ODIwNA==", "bodyText": "updated", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r365178204", "createdAt": "2020-01-10T10:52:44Z", "author": {"login": "rmoff"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5Mjc1Ng=="}, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTU1NDkyOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMzoyNzoyOFrOFaLXBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1MjozNFrOFcQtHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5MzQxNA==", "bodyText": "5.3.2 is the current JDBC connector download version on Confluent Hub", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362993414", "createdAt": "2020-01-03T23:27:28Z", "author": {"login": "mikebin"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3ODE0Mw==", "bodyText": "Updated", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r365178143", "createdAt": "2020-01-10T10:52:34Z", "author": {"login": "rmoff"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5MzQxNA=="}, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTU2MDc3OnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMzozMzoyNVrOFaLafw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMzozMzoyNVrOFaLafw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk5NDMwMw==", "bodyText": "Would it be worth mentioning the special key config property on the connector? This is unique to ksqlDB.", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r362994303", "createdAt": "2020-01-03T23:33:25Z", "author": {"login": "mikebin"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,409 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc)\n+to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB\n+to a separate Connect configuration file. In our docker-compose file, this is\n+done via the `KSQL_KSQL_CONNECT_WORKER_CONFIG` environment variable. From\n+within your local working directory, run this command to generate the Connect\n+configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+In the directory containing the `docker-compose.yml` file you created in the\n+first step, run the following command to start all services in the correct\n+order.\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Run the following command to establish an interactive session with PostgreSQL.\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+In the PostgreSQL session, run the following SQL statements to set up the\n+driver data. You will join this PostgreSQL data with event streams in ksqlDB.\n+\n+```sql\n+CREATE TABLE drivers (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO drivers (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run the following command to connect to the ksqlDB server and start an\n+interactive command-line interface (CLI) session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Make your PostgreSQL data accessible to ksqlDB by creating a *source*\n+connector. In the ksqlDB CLI, run the following command.\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'drivers',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);\n+\n+```\n+\n+When the source connector is created, it imports any PostgreSQL tables matching", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbaa50bbeead67cf2c2327c4c67750e1f8ed7d24"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0Nzg0OTEzOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMToxNzoyMVrOFbGDAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMToxNzoyMVrOFbGDAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1NDk0NQ==", "bodyText": "Internal converters are not needed, they were deprecated in Apache Kafka 2.0 / KIP -174", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r363954945", "createdAt": "2020-01-07T21:17:21Z", "author": {"login": "rmoff"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,408 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc)\n+to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB\n+to a separate Connect configuration file. In our docker-compose file, this is\n+done via the `KSQL_KSQL_CONNECT_WORKER_CONFIG` environment variable. From\n+within your local working directory, run this command to generate the Connect\n+configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8efecdc76fc514b0357384503c49e328062ca25"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0Nzg1MTIxOnYy", "diffSide": "RIGHT", "path": "docs-md/tutorials/embedded-connect.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMToxODoxM1rOFbGEbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMToxODoxM1rOFbGEbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1NTMwOQ==", "bodyText": "Not needed as you've already specified it in the worker config", "url": "https://github.com/confluentinc/ksql/pull/4212#discussion_r363955309", "createdAt": "2020-01-07T21:18:13Z", "author": {"login": "rmoff"}, "path": "docs-md/tutorials/embedded-connect.md", "diffHunk": "@@ -0,0 +1,408 @@\n+---\n+layout: page\n+title: ksqlDB with Embedded Connect\n+tagline: Run Kafka Connect embedded within ksqlDB\n+description: Learn how to use ksqlDB with embedded Connect to integrate with external data sources and sinks\n+keywords: ksqlDB, connect, PostgreSQL, jdbc\n+---\n+\n+Overview\n+==============\n+\n+This tutorial will demonstrate how to integrate ksqlDB with an external data\n+source to power a simple ride sharing app. Our external source will be a\n+PostgreSQL database containing relatively static data describing each driver\u2019s\n+vehicle. By combining this human-friendly static data with a continuous stream\n+of computer-friendly driver and rider location events, we derive an enriched\n+output stream that the ride sharing app may use to facilitate a rendezvous in\n+real time.\n+\n+1. Get ksqlDB\n+--------------\n+\n+Since ksqlDB runs natively on {{ site.aktm }}, you need a running {{ site.ak }}\n+installation that ksqlDB is configured to use. The following docker-compose\n+files run everything for you via Docker, including ksqlDB running\n+[Kafka Connect](https://docs.confluent.io/current/connect/index.html) in\n+embedded mode. Embedded Connect enables you to leverage the power of\n+{{ site.kconnect }} without having to manage a separate {{ site.kconnect }}\n+cluster, because ksqlDB manages one for you. Also, this tutorial use PostgreSQL\n+as an external datastore to integrate with ksqlDB.\n+\n+In an empty local working directory, copy and paste the following\n+`docker-compose` content into a file named `docker-compose.yml`. You will\n+create and add a number of other files to this directory during this tutorial.\n+\n+```yaml\n+---\n+version: '2'\n+\n+services:\n+  zookeeper:\n+    image: confluentinc/cp-zookeeper:5.3.1\n+    hostname: zookeeper\n+    container_name: zookeeper\n+    ports:\n+      - \"2181:2181\"\n+    environment:\n+      ZOOKEEPER_CLIENT_PORT: 2181\n+      ZOOKEEPER_TICK_TIME: 2000\n+\n+  broker:\n+    image: confluentinc/cp-enterprise-kafka:5.3.1\n+    hostname: broker\n+    container_name: broker\n+    depends_on:\n+      - zookeeper\n+    ports:\n+      - \"29092:29092\"\n+    environment:\n+      KAFKA_BROKER_ID: 1\n+      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'\n+      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n+      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:9092,PLAINTEXT_HOST://localhost:29092\n+      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n+      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n+\n+  ksqldb-server:\n+    image: confluentinc/ksqldb-server:0.6.0\n+    hostname: ksqldb-server\n+    container_name: ksqldb-server\n+    depends_on:\n+      - broker\n+    ports:\n+      - \"8088:8088\"\n+    environment:\n+      KSQL_LISTENERS: http://0.0.0.0:8088\n+      KSQL_BOOTSTRAP_SERVERS: broker:9092\n+      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n+      KSQL_KSQL_CONNECT_WORKER_CONFIG: \"/connect/connect.properties\"\n+    volumes:\n+      - ./confluentinc-kafka-connect-jdbc-5.3.1:/usr/share/kafka/plugins/jdbc\n+      - ./connect.properties:/connect/connect.properties\n+\n+  ksqldb-cli:\n+    image: confluentinc/ksqldb-cli:0.6.0\n+    container_name: ksqldb-cli\n+    depends_on:\n+      - broker\n+      - ksqldb-server\n+    entrypoint: /bin/sh\n+    tty: true\n+  \n+  postgres:\n+    image: postgres:12\n+    hostname: postgres\n+    container_name: postgres\n+    ports:\n+      - \"5432:5432\"\n+```\n+\n+2. Get the JDBC connector\n+-------------------------\n+\n+[Download the JDBC connector](https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc)\n+to your local working directory. Next, unzip the downloaded archive:\n+\n+```bash\n+unzip confluentinc-kafka-connect-jdbc-5.3.1.zip\n+```\n+\n+3. Configure Connect\n+--------------------\n+\n+In order to tell ksqlDB to run Connect in embedded mode, we must point ksqlDB\n+to a separate Connect configuration file. In our docker-compose file, this is\n+done via the `KSQL_KSQL_CONNECT_WORKER_CONFIG` environment variable. From\n+within your local working directory, run this command to generate the Connect\n+configuration file:\n+\n+```bash\n+cat << EOF > ./connect.properties\n+bootstrap.servers=broker:9092\n+plugin.path=/usr/share/kafka/plugins\n+group.id=ksql-connect-cluster\n+key.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter=org.apache.kafka.connect.json.JsonConverter\n+value.converter.schemas.enable=false\n+internal.key.converter.schemas.enable=false\n+config.storage.topic=ksql-connect-configs\n+offset.storage.topic=ksql-connect-offsets\n+status.storage.topic=ksql-connect-statuses\n+config.storage.replication.factor=1\n+offset.storage.replication.factor=1\n+status.storage.replication.factor=1\n+EOF\n+```\n+\n+4. Start ksqlDB and PostgreSQL\n+------------------------------\n+\n+In the directory containing the `docker-compose.yml` file you created in the\n+first step, run the following command to start all services in the correct\n+order.\n+\n+```bash\n+docker-compose up\n+```\n+\n+5. Connect to PostgreSQL\n+------------------------\n+\n+Run the following command to establish an interactive session with PostgreSQL.\n+\n+```bash\n+docker exec -it postgres psql -U postgres\n+```\n+\n+6. Populate PostgreSQL with vehicle/driver data\n+-----------------------------------------------\n+\n+In the PostgreSQL session, run the following SQL statements to set up the\n+driver data. You will join this PostgreSQL data with event streams in ksqlDB.\n+\n+```sql\n+CREATE TABLE driver_profiles (\n+  driver_id integer PRIMARY KEY,\n+  make text,\n+  model text,\n+  year integer,\n+  license_plate text,\n+  rating float\n+);\n+\n+INSERT INTO driver_profiles (driver_id, make, model, year, license_plate, rating) VALUES\n+  (0, 'Toyota', 'Prius',   2019, 'KAFKA-1', 5.00),\n+  (1, 'Kia',    'Sorento', 2017, 'STREAMS', 4.89),\n+  (2, 'Tesla',  'Model S', 2019, 'CNFLNT',  4.92),\n+  (3, 'Toyota', 'Camry',   2018, 'ILVKSQL', 4.85);\n+```\n+\n+7. Start ksqlDB's interactive CLI\n+---------------------------------\n+\n+ksqlDB runs as a server which clients connect to in order to issue queries.\n+\n+Run the following command to connect to the ksqlDB server and start an\n+interactive command-line interface (CLI) session.\n+\n+```bash\n+docker exec -it ksqldb-cli ksql http://ksqldb-server:8088\n+```\n+\n+8. Create source connector\n+--------------------------\n+\n+Make your PostgreSQL data accessible to ksqlDB by creating a *source*\n+connector. In the ksqlDB CLI, run the following command.\n+\n+```sql\n+CREATE SOURCE CONNECTOR jdbc_source WITH (\n+  'connector.class'          = 'io.confluent.connect.jdbc.JdbcSourceConnector',\n+  'connection.url'           = 'jdbc:postgresql://postgres:5432/postgres',\n+  'connection.user'          = 'postgres',\n+  'topic.prefix'             = 'jdbc_',\n+  'table.whitelist'          = 'driver_profiles',\n+  'mode'                     = 'incrementing',\n+  'numeric.mapping'          = 'best_fit',\n+  'incrementing.column.name' = 'driver_id',\n+  'key'                      = 'driver_id',\n+  'value.converter.schemas.enable' = false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8efecdc76fc514b0357384503c49e328062ca25"}, "originalPosition": 211}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2332, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}