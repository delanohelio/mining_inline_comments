{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyMDc2OTc4", "number": 6628, "title": "chore: support complex key pull queries", "bodyText": "Description\nfixes #6602\nSupports key-lookups for keys that are not just literals. This is necessary for the generic key work being done because we will expose keys that are not just primitives, but can also be arrays and structs.\nNote that maps are not tested because of #6621, we may consider just prohibiting maps from being keys altogether. I will port this over after #6375 is merged.\nTesting done\n\nnew unit tests\nnew RQTT tests\n\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-11-17T01:28:26Z", "url": "https://github.com/confluentinc/ksql/pull/6628", "merged": true, "mergeCommit": {"oid": "bec50c31acaeca6a01b578a9e1c3b96c78a24262"}, "closed": true, "closedAt": "2020-11-19T03:28:41Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddSV6iAFqTUzMjAyMzY0MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdd4aaFAH2gAyNTIyMDc2OTc4OjI4YzQzZDQzZGQyZmY3MmMyN2NjZGUwNzlmZjZkYTM3NWE5YTRjNzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDIzNjQx", "url": "https://github.com/confluentinc/ksql/pull/6628#pullrequestreview-532023641", "createdAt": "2020-11-17T05:03:16Z", "commit": {"oid": "60e2c17146102441da6556b34ebdff228f627c25"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTowMzoxNlrOH0kgJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTowMzoxNlrOH0kgJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4NjA1Mw==", "bodyText": "Do we want to support generic expressions in pull query WHERE clauses at this time? Last I spoke to @AlanConfluent it sounded like we wanted to limit support to literal expressions (i.e., those that create arrays and structs with literal values) for now.", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r524886053", "createdAt": "2020-11-17T05:03:16Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -1927,17 +1914,90 @@\n       }\n     },\n     {\n-      \"name\": \"IN: fail on non-literal key\",\n+      \"name\": \"non-windowed - function in where clause\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e2c17146102441da6556b34ebdff228f627c25"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODUyMDI1", "url": "https://github.com/confluentinc/ksql/pull/6628#pullrequestreview-532852025", "createdAt": "2020-11-17T22:05:48Z", "commit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjowNTo0OFrOH1NZDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjowNTo0OFrOH1NZDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTk4Mw==", "bodyText": "What should be supported is functions on literals, maps and arrays of literals but not functions on columns?", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525555983", "createdAt": "2020-11-17T22:05:48Z", "author": {"login": "vpapavas"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -1927,17 +1914,103 @@\n       }\n     },\n     {\n-      \"name\": \"IN: fail on non-literal key\",\n+      \"name\": \"IN: fail on column reference key\",\n       \"statements\": [\n         \"CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n         \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n-        \"SELECT * FROM AGGREGATE WHERE ID IN (CAST(1 AS INTEGER));\"\n+        \"SELECT * FROM AGGREGATE WHERE ID IN (COUNT + 1);\"\n       ],\n       \"expectedError\": {\n         \"type\": \"io.confluent.ksql.rest.entity.KsqlStatementErrorMessage\",\n-        \"message\": \"Only comparison to literals is currently supported: (ID IN (CAST(1 AS INTEGER)))\",\n+        \"message\": \"Unsupported column reference in pull query: (COUNT + 1)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODU3MzI3", "url": "https://github.com/confluentinc/ksql/pull/6628#pullrequestreview-532857327", "createdAt": "2020-11-17T22:14:11Z", "commit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjoxNDoxMlrOH1Npqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjoxNDoxMlrOH1Npqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MDIzNA==", "bodyText": "Could we maybe make the IN take more than one key since that is its primary use case? Something like:\nSELECT * FROM AGGREGATE WHERE ID IN (CAST(10 AS INTEGER), CAST(\"11\" AS INTEGER));", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525560234", "createdAt": "2020-11-17T22:14:12Z", "author": {"login": "vpapavas"}, "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -1927,17 +1914,103 @@\n       }\n     },\n     {\n-      \"name\": \"IN: fail on non-literal key\",\n+      \"name\": \"IN: fail on column reference key\",\n       \"statements\": [\n         \"CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n         \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n-        \"SELECT * FROM AGGREGATE WHERE ID IN (CAST(1 AS INTEGER));\"\n+        \"SELECT * FROM AGGREGATE WHERE ID IN (COUNT + 1);\"\n       ],\n       \"expectedError\": {\n         \"type\": \"io.confluent.ksql.rest.entity.KsqlStatementErrorMessage\",\n-        \"message\": \"Only comparison to literals is currently supported: (ID IN (CAST(1 AS INTEGER)))\",\n+        \"message\": \"Unsupported column reference in pull query: (COUNT + 1)\",\n         \"status\": 400\n       }\n+    },\n+    {\n+      \"name\": \"non-windowed - function in where clause\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID STRING KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT ID, COUNT, ROWTIME FROM AGGREGATE WHERE ID=CONCAT('1','0');\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"timestamp\": 12345, \"key\": \"11\", \"value\": {}},\n+        {\"topic\": \"test_topic\", \"timestamp\": 12365, \"key\": \"10\", \"value\": {}}\n+      ],\n+      \"responses\": [\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"query\": [\n+          {\"header\":{\"schema\":\"`ID` STRING KEY, `COUNT` BIGINT, `ROWTIME` BIGINT\"}},\n+          {\"row\":{\"columns\":[\"10\", 1, 12365]}}\n+        ]}\n+      ]\n+    },\n+    {\n+      \"name\": \"non-windowed - array keys\",\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID ARRAY<STRING> KEY, IGNORED INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT ID, COUNT, ROWTIME FROM AGGREGATE WHERE ID=ARRAY['1','0'];\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"timestamp\": 12345, \"key\": [\"1\", \"1\"], \"value\": {}},\n+        {\"topic\": \"test_topic\", \"timestamp\": 12365, \"key\": [\"1\", \"0\"], \"value\": {}}\n+      ],\n+      \"responses\": [\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"query\": [\n+          {\"header\":{\"schema\":\"`ID` ARRAY<STRING> KEY, `COUNT` BIGINT, `ROWTIME` BIGINT\"}},\n+          {\"row\":{\"columns\":[[\"1\", \"0\"], 1, 12365]}}\n+        ]}\n+      ]\n+    },\n+    {\n+      \"name\": \"non-windowed - struct keys\",\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID STRUCT<f1 STRING, f2 STRING> KEY, IGNORED INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT ID, COUNT, ROWTIME FROM AGGREGATE WHERE ID=STRUCT(F1:='1',F2:='0');\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"timestamp\": 12345, \"key\": {\"F1\": \"1\", \"F2\": \"1\"}, \"value\": {}},\n+        {\"topic\": \"test_topic\", \"timestamp\": 12365, \"key\": {\"F1\": \"1\", \"F2\": \"0\"}, \"value\": {}}\n+      ],\n+      \"responses\": [\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"query\": [\n+          {\"header\":{\"schema\":\"`ID` STRUCT<`F1` STRING, `F2` STRING> KEY, `COUNT` BIGINT, `ROWTIME` BIGINT\"}},\n+          {\"row\":{\"columns\":[{\"F1\": \"1\", \"F2\": \"0\"}, 1, 12365]}}\n+        ]}\n+      ]\n+    },\n+    {\n+      \"name\": \"IN: support non-literal key\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT * FROM AGGREGATE WHERE ID IN (CAST(10 AS INTEGER));\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODU3ODk3", "url": "https://github.com/confluentinc/ksql/pull/6628#pullrequestreview-532857897", "createdAt": "2020-11-17T22:15:07Z", "commit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODc1MDQw", "url": "https://github.com/confluentinc/ksql/pull/6628#pullrequestreview-532875040", "createdAt": "2020-11-17T22:44:25Z", "commit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjo0NDoyNVrOH1OiwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjo1MjowOFrOH1Oxfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDg0OQ==", "bodyText": "This is just done because GenericExpressionResolver isn't as low overhead right?", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525574849", "createdAt": "2020-11-17T22:44:25Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -778,31 +798,40 @@ private static Object extractKeyWhereClause(\n     }\n \n     final Expression other = getNonColumnRefSide(comparison);\n-    if (!(other instanceof Literal)) {\n-      throw new KsqlException(\"Ony comparison to literals is currently supported: \" + comparison);\n-    }\n-\n-    if (other instanceof NullLiteral) {\n-      throw new KsqlException(\"Primary key columns can not be NULL: \" + comparison);\n-    }\n-\n-    final Object right = ((Literal) other).getValue();\n-    return coerceKey(schema, right, windowed);\n+    final Column keyColumn = schema.key().get(0);\n+    return resolveKey(other, keyColumn, executionContext, config, comparison);\n   }\n \n-  private static Object coerceKey(\n-      final LogicalSchema schema,\n-      final Object right,\n-      final boolean windowed\n+  private static Object resolveKey(\n+      final Expression exp,\n+      final Column keyColumn,\n+      final KsqlExecutionContext executionContext,\n+      final KsqlConfig config,\n+      final Expression errorMessageHint\n   ) {\n-    if (schema.key().size() != 1) {\n-      throw invalidWhereClauseException(\"Only single KEY column supported\", windowed);\n+    final Object obj;\n+    if (exp instanceof NullLiteral) {\n+      obj = null;\n+    } else if (exp instanceof Literal) {\n+      // skip the GenericExpressionResolver because this is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODYyMw==", "bodyText": "Just curious, how much overhead is it to compile the java into bytecode, load the bytecode, and then run it.  It makes a lot of sense when you compile once and then run many times, but in this case, there's a 1:1 relationship.  In general, it seems like interpreting the expression would be lower overhead and possibly faster.  Do we do it this way because this is the main method that currently exists for \"evaluating a sql expression\"?\nI'd be curious to run a benchmark doing just expression lookups (rather than literals).", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525578623", "createdAt": "2020-11-17T22:52:08Z", "author": {"login": "AlanConfluent"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/generic/GenericExpressionResolver.java", "diffHunk": "@@ -76,11 +83,12 @@ public Object resolve(final Expression expression) {\n \n     @Override\n     protected Object visitExpression(final Expression expression, final Void context) {\n+      new EnsureNoColReferences(expression).process(expression, context);\n       final ExpressionMetadata metadata =\n           CodeGenRunner.compileExpression(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48b3b6d96d97676a0d7dfc1284cef242b727746"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dd79121d58e310f4cac749c0dbfa5a1f53fec48", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/5dd79121d58e310f4cac749c0dbfa5a1f53fec48", "committedDate": "2020-11-19T00:29:33Z", "message": "chore: support complex key pull queries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4b4c4cd82f4549cd198a5ce358b1432e9311161", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/a4b4c4cd82f4549cd198a5ce358b1432e9311161", "committedDate": "2020-11-19T00:29:51Z", "message": "chore: update to better error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cb93e548b265cd4e09e1993f47d6be469394405", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/5cb93e548b265cd4e09e1993f47d6be469394405", "committedDate": "2020-11-19T00:29:53Z", "message": "test: update test case for multiple IN statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2756cfb722218ff67e9f48ef70661da751b988f8", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/2756cfb722218ff67e9f48ef70661da751b988f8", "committedDate": "2020-11-19T00:58:12Z", "message": "chore: rebase with master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d9922dc3119d0cfe30330d198a37a91c6a0532a", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/7d9922dc3119d0cfe30330d198a37a91c6a0532a", "committedDate": "2020-11-17T22:23:56Z", "message": "test: update test case for multiple IN statements"}, "afterCommit": {"oid": "2756cfb722218ff67e9f48ef70661da751b988f8", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/2756cfb722218ff67e9f48ef70661da751b988f8", "committedDate": "2020-11-19T00:58:12Z", "message": "chore: rebase with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28c43d43dd2ff72c27ccde079ff6da375a9a4c75", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/28c43d43dd2ff72c27ccde079ff6da375a9a4c75", "committedDate": "2020-11-19T01:24:34Z", "message": "chore: fix checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4543, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}