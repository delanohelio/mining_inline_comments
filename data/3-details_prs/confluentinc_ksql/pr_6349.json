{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2ODI4NjAz", "number": 6349, "title": "feat: `NONE` format for key-less streams", "bodyText": "Description\nfixes: #6221\nIntroduce a NONE format, used to indicate the key data, in key-less streams, should not be deserialized.\nThere's a piece of follow up work to make joins involving key-less streams with NONE key format work.  This will be done under #6213.\nTesting done\nusual\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-10-02T10:43:36Z", "url": "https://github.com/confluentinc/ksql/pull/6349", "merged": true, "mergeCommit": {"oid": "25bb3520955d6f9ec64b0beeffe78069c2496a7f"}, "closed": true, "closedAt": "2020-10-02T14:07:17Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOjn1rAH2gAyNDk2ODI4NjAzOjliNzQxOTgxMjI3NzczMWRjYzJmNWEyMWNmZDcxMjRhMTdlMzg5Zjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOmisqAH2gAyNDk2ODI4NjAzOjY2ODM3NzlmODI4OWZlNTU1OTQxNWRkODY2MDk3ZjI5OGIxZjkyY2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9b7419812277731dcc2f5a21cfd7124a17e389f8", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/9b7419812277731dcc2f5a21cfd7124a17e389f8", "committedDate": "2020-10-02T10:42:22Z", "message": "feat: add NONE format\n\nfixes: https://github.com/confluentinc/ksql/issues/6221\n\nIntroduce a `NONE` format, used to indicate the key data, in key-less streams, should not be deserialized."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/451f166349180f7dc2048ae8afd508dfd310e31c", "committedDate": "2020-10-02T10:42:40Z", "message": "test: historical plans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTIyNTMw", "url": "https://github.com/confluentinc/ksql/pull/6349#pullrequestreview-501122530", "createdAt": "2020-10-02T13:13:24Z", "commit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMzoxMzoyNFrOHbtGOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMzozODo0M1rOHbt_DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjQ3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   [`NONE`](#none) used to indicate the data should not be derialized.\n          \n          \n            \n            -   [`NONE`](#none) used to indicate the data should not be deserialized.", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498812474", "createdAt": "2020-10-02T13:13:24Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjc3Ng==", "bodyText": "Also, can we move this to the end of the list? Seems confusing to have it as the first item (before the actual formats).", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498812776", "createdAt": "2020-10-02T13:13:57Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjQ3NA=="}, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzA5Nw==", "bodyText": "This is no longer true if the NONE format is not supported as a value format.", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498813097", "createdAt": "2020-10-02T13:14:31Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzU5NA==", "bodyText": "Add link to config?", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498813594", "createdAt": "2020-10-02T13:15:22Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzY3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n          \n          \n            \n            If the schema did not exist, the statement would be rejected.  In such situations, the key format can", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498813672", "createdAt": "2020-10-02T13:15:33Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNTU4OA==", "bodyText": "Clarify that it's only columns for the relevant portion of the record that fails the statement? I know it's clear after a moment's thought but on first read this sentence as written is confusing, especially given the immediately preceding example that defines columns.\nThere's also room for misinterpretation in light of the discussion about schema inference above, which is a different scenario under which columns might not be defined.", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498815588", "createdAt": "2020-10-02T13:18:52Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n+be set to `NONE`: \n+\n+```sql\n+CREATE STREAM KEY_LESS_STREAM (\n+    VAL STRING\n+  ) WITH (\n+    KEY_FORMAT='NONE',\n+    VALUE_FORMAT='JSON',\n+    KAFKA_TOPIC='foo'\n+  );\n+```\n+\n+Any statement using format `NONE` that defines columns will result in an error.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNjc5MA==", "bodyText": "What about the reverse scenario: the source stream has a key format defined and the CSAS removes the key (via PARTITION BY NULL). Does the user need to explicitly set the key format in the CSAS to NONE? I assume not, could be good to clarify in the docs.", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498816790", "createdAt": "2020-10-02T13:21:01Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n+be set to `NONE`: \n+\n+```sql\n+CREATE STREAM KEY_LESS_STREAM (\n+    VAL STRING\n+  ) WITH (\n+    KEY_FORMAT='NONE',\n+    VALUE_FORMAT='JSON',\n+    KAFKA_TOPIC='foo'\n+  );\n+```\n+\n+Any statement using format `NONE` that defines columns will result in an error.\n+\n+If a `CREATE TABLE AS` or `CREATE STREAM AS` statement has a source with a key format of `NONE`, but\n+the newly created table or stream has key column, then you may either explicitly define the key \n+format to use in the `WITH` clause, or the default key format, as set in `ksql.persistence.default.format.key`\n+will be used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNzA1Ng==", "bodyText": "nit: \"keyless\" is usually one word?", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498817056", "createdAt": "2020-10-02T13:21:31Z", "author": {"login": "vcrfxia"}, "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n+be set to `NONE`: \n+\n+```sql\n+CREATE STREAM KEY_LESS_STREAM (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyMDQ2NA==", "bodyText": "Is the thinking here that JSON works even if no key columns are specified, so we might as well always use JSON so that if a stream with no key columns is the source for a another stream/table down the line, then the sink stream/table will automatically get JSON as the key format, regardless of what the config default key format is?", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498820464", "createdAt": "2020-10-02T13:27:31Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/InternalFormats.java", "diffHunk": "@@ -50,10 +52,15 @@ private InternalFormats() {\n    * @see SerdeFeaturesFactory#buildInternal\n    */\n   public static Formats of(final KeyFormat keyFormat, final ValueFormat valueFormat) {\n+    // Do not use NONE format for internal topics:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNDU3NA==", "bodyText": "Not directly related to this PR: I notice the printing of the schema doesn't distinguish between KEY and PRIMARY KEY. What was the reasoning for that? Is it just easier to not worry about passing in information about source type to the schema, or is the current behavior preferred outside of the logistical concern too?", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498824574", "createdAt": "2020-10-02T13:34:27Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/none.json", "diffHunk": "@@ -0,0 +1,181 @@\n+{\n+  \"comments\": [\n+    \"NONE format testing.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"as key format of keyless stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"foo\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": \"data that should be ignored\", \"value\": {\"foo\": 11}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 11}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"as key format of keyed stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as key format of table\",\n+      \"statements\": [\n+        \"CREATE TABLE INPUT (K STRING PRIMARY KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as value format with value columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', value_format='NONE');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`FOO` INTEGER]\"\n+      }\n+    },\n+    {\n+      \"name\": \"in CSAS from keyless stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT WITH(key_format='NONE') AS SELECT * FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": \"ignored\", \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"in CSAS partitioning by null\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT WITH(key_format='NONE') AS SELECT * FROM INPUT PARTITION BY null;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 9, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10, \"ID\": 9}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicitly set in CSAS with key\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT, bar INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT WITH (key_format='NONE') AS SELECT * FROM INPUT PARTITION BY BAR;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`BAR` INTEGER KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"explicitly set in CTAS\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT, bar INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='NONE') AS SELECT BAR AS K, COUNT() FROM INPUT GROUP BY BAR;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` INTEGER KEY]\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNzAyMQ==", "bodyText": "Can we add a test for what happens if someone tries to set NONE as value format with no value columns? I assume this is not supported. It'd be good to check that the error message is sensible.", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498827021", "createdAt": "2020-10-02T13:38:43Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/none.json", "diffHunk": "@@ -0,0 +1,181 @@\n+{\n+  \"comments\": [\n+    \"NONE format testing.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"as key format of keyless stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"foo\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": \"data that should be ignored\", \"value\": {\"foo\": 11}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 11}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"as key format of keyed stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as key format of table\",\n+      \"statements\": [\n+        \"CREATE TABLE INPUT (K STRING PRIMARY KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as value format with value columns\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce80465f860bad5d1b3cbff110310674e9384209", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/ce80465f860bad5d1b3cbff110310674e9384209", "committedDate": "2020-10-02T13:40:48Z", "message": "Update docs/developer-guide/serialization.md\n\nCo-authored-by: Victoria Xia <victoria.f.xia281@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6683779f8289fe5559415dd866097f298b1f92cb", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/6683779f8289fe5559415dd866097f298b1f92cb", "committedDate": "2020-10-02T14:06:28Z", "message": "chore: requested changes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4618, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}