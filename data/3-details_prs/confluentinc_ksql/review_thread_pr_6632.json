{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNjEyMjY2", "number": 6632, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo0Mzo0NlrOE6P1PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo0NDoxNVrOE6P17w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTEyMjUzOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo0Mzo0NlrOH1MrdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxOToxODoyNFrOH1-Oqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NDMwOQ==", "bodyText": "What's the purpose of separately handling potential auth errors here rather than unifying in SchemaRegistryUtil where missing schemas are handled?", "url": "https://github.com/confluentinc/ksql/pull/6632#discussion_r525544309", "createdAt": "2020-11-17T21:43:46Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "diffHunk": "@@ -303,21 +303,25 @@ private void ensureKeySchemasMatch(\n         .getSchemaTranslator(keyFormat.getFormatInfo().getProperties())\n         .toParsedSchema(keySchema);\n \n+    final Optional<SchemaMetadata> latest;\n     try {\n-      final SchemaMetadata latest = serviceContext.getSchemaRegistryClient()\n-          .getLatestSchemaMetadata(\n-              KsqlConstants.getSRSubject(dataSource.getKafkaTopicName(), true));\n-      if (!latest.getSchema().equals(schema.canonicalString())) {\n-        throw new KsqlException(\"Cannot INSERT VALUES into data source \" + dataSource.getName()\n-            + \". ksqlDB generated schema would overwrite existing key schema.\"\n-            + \"\\n\\tExisting Schema: \" + latest.getSchema()\n-            + \"\\n\\tksqlDB Generated: \" + schema.canonicalString());\n-      }\n-    } catch (IOException | RestClientException e) {\n+      latest = SchemaRegistryUtil.getLatestSchema(\n+          serviceContext.getSchemaRegistryClient(),\n+          dataSource.getKafkaTopicName(),\n+          true);\n+\n+    } catch (final Exception e) {\n       maybeThrowSchemaRegistryAuthError(format, dataSource.getKafkaTopicName(), true, \"read\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84473b6b7d50a208bca6635a190db98d14f9e8b3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM1NjEzOA==", "bodyText": "It makes it a little easier to handle the error message. If it's an auth error, I want to expose that directly. If it's another error, then I want to throw our generic shim: \"Could not determine that insert values...\"\nIf I handled this in the SchemaRegistryUtil, then I would have to throw a different exception type or parse the exception message to decide whether to propagate it or to wrap it.", "url": "https://github.com/confluentinc/ksql/pull/6632#discussion_r526356138", "createdAt": "2020-11-18T19:18:24Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "diffHunk": "@@ -303,21 +303,25 @@ private void ensureKeySchemasMatch(\n         .getSchemaTranslator(keyFormat.getFormatInfo().getProperties())\n         .toParsedSchema(keySchema);\n \n+    final Optional<SchemaMetadata> latest;\n     try {\n-      final SchemaMetadata latest = serviceContext.getSchemaRegistryClient()\n-          .getLatestSchemaMetadata(\n-              KsqlConstants.getSRSubject(dataSource.getKafkaTopicName(), true));\n-      if (!latest.getSchema().equals(schema.canonicalString())) {\n-        throw new KsqlException(\"Cannot INSERT VALUES into data source \" + dataSource.getName()\n-            + \". ksqlDB generated schema would overwrite existing key schema.\"\n-            + \"\\n\\tExisting Schema: \" + latest.getSchema()\n-            + \"\\n\\tksqlDB Generated: \" + schema.canonicalString());\n-      }\n-    } catch (IOException | RestClientException e) {\n+      latest = SchemaRegistryUtil.getLatestSchema(\n+          serviceContext.getSchemaRegistryClient(),\n+          dataSource.getKafkaTopicName(),\n+          true);\n+\n+    } catch (final Exception e) {\n       maybeThrowSchemaRegistryAuthError(format, dataSource.getKafkaTopicName(), true, \"read\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NDMwOQ=="}, "originalCommit": {"oid": "84473b6b7d50a208bca6635a190db98d14f9e8b3"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTEyNDMxOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTo0NDoxNVrOH1Mshw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxOTowNzoyNVrOH191CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NDU4Mw==", "bodyText": "Do we ever expect exceptions other than KsqlException here?", "url": "https://github.com/confluentinc/ksql/pull/6632#discussion_r525544583", "createdAt": "2020-11-17T21:44:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "diffHunk": "@@ -303,21 +303,25 @@ private void ensureKeySchemasMatch(\n         .getSchemaTranslator(keyFormat.getFormatInfo().getProperties())\n         .toParsedSchema(keySchema);\n \n+    final Optional<SchemaMetadata> latest;\n     try {\n-      final SchemaMetadata latest = serviceContext.getSchemaRegistryClient()\n-          .getLatestSchemaMetadata(\n-              KsqlConstants.getSRSubject(dataSource.getKafkaTopicName(), true));\n-      if (!latest.getSchema().equals(schema.canonicalString())) {\n-        throw new KsqlException(\"Cannot INSERT VALUES into data source \" + dataSource.getName()\n-            + \". ksqlDB generated schema would overwrite existing key schema.\"\n-            + \"\\n\\tExisting Schema: \" + latest.getSchema()\n-            + \"\\n\\tksqlDB Generated: \" + schema.canonicalString());\n-      }\n-    } catch (IOException | RestClientException e) {\n+      latest = SchemaRegistryUtil.getLatestSchema(\n+          serviceContext.getSchemaRegistryClient(),\n+          dataSource.getKafkaTopicName(),\n+          true);\n+\n+    } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84473b6b7d50a208bca6635a190db98d14f9e8b3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0OTU3Nw==", "bodyText": "No, we shouldn't have any other exception type here. I'll consolidate it", "url": "https://github.com/confluentinc/ksql/pull/6632#discussion_r526349577", "createdAt": "2020-11-18T19:07:25Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/InsertValuesExecutor.java", "diffHunk": "@@ -303,21 +303,25 @@ private void ensureKeySchemasMatch(\n         .getSchemaTranslator(keyFormat.getFormatInfo().getProperties())\n         .toParsedSchema(keySchema);\n \n+    final Optional<SchemaMetadata> latest;\n     try {\n-      final SchemaMetadata latest = serviceContext.getSchemaRegistryClient()\n-          .getLatestSchemaMetadata(\n-              KsqlConstants.getSRSubject(dataSource.getKafkaTopicName(), true));\n-      if (!latest.getSchema().equals(schema.canonicalString())) {\n-        throw new KsqlException(\"Cannot INSERT VALUES into data source \" + dataSource.getName()\n-            + \". ksqlDB generated schema would overwrite existing key schema.\"\n-            + \"\\n\\tExisting Schema: \" + latest.getSchema()\n-            + \"\\n\\tksqlDB Generated: \" + schema.canonicalString());\n-      }\n-    } catch (IOException | RestClientException e) {\n+      latest = SchemaRegistryUtil.getLatestSchema(\n+          serviceContext.getSchemaRegistryClient(),\n+          dataSource.getKafkaTopicName(),\n+          true);\n+\n+    } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NDU4Mw=="}, "originalCommit": {"oid": "84473b6b7d50a208bca6635a190db98d14f9e8b3"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2421, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}