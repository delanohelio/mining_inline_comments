{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MDY4MTU0", "number": 5115, "title": "docs: add klip-24: key column semantics in queries.", "bodyText": "This klip looks to address some of the shortcomings found during the recent work to remove the restriction that all key columns must be named ROWKEY.\nPlease have a read and let me know your thoughts.\nImportantly, the 'any key name' work is not yet enabled, (See #5093). So we have a choice... do we fix these semantics before or after we enable this feature?\nBefore means less disruption for users, but may mean the feature slips the milestone.\nAfter means we'll hit the milestone, but users will be asked to change their existing queries one way, only to be asked to change them back on the next release ... annoying!  For example:\n-- existing valid GROUP BY persistent query:\nCREATE TABLE OUTPUT AS \n   SELECT V0, COUNT() AS COUNT \n     FROM INPUT GROUP BY V0;\n\n-- with 'any key name' merged the above fails with a duplicate column error on V0.\n-- the user needs to change the query to:\nCREATE TABLE OUTPUT AS \n   SELECT COUNT() AS COUNT \n     FROM INPUT GROUP BY V0;\n\n-- with this klip the first statement is valid, but the second is not, hence we'd be asking users to change their query back again.", "createdAt": "2020-04-20T13:35:19Z", "url": "https://github.com/confluentinc/ksql/pull/5115", "merged": true, "mergeCommit": {"oid": "bd9302aba90db5d0f7d460ea9b1ba8b224c45093"}, "closed": true, "closedAt": "2020-05-07T16:01:12Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZfGpDAH2gAyNDA2MDY4MTU0OjgwZjY2ZTJkYmU5YjllYzYxYmQ4NjYxMTI4YTUyZjg2YzNmMzUxODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeH0fJ2gFqTYyMjk4NDA0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "committedDate": "2020-04-20T13:28:30Z", "message": "docs: add klip-24"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjEyMzQ3", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-396612347", "createdAt": "2020-04-20T16:22:38Z", "commit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoyMjozOFrOGIc17Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjo0NDoxOFrOGIdy9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxNDM0OQ==", "bodyText": "+1 I think this is a much cleaner way - I was working on aliasing for joins, and it gets very sticky (especially in the case of N-way joins). I might punt that work in favorite of this KLIP (I can implement the join part if you want, it should be pretty easy after #5081)", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411514349", "createdAt": "2020-04-20T16:22:38Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ==", "bodyText": "what do you think about having it so that if the user does not include the key field, they simply cannot access it? That way they don't need to explicitly specify it in the project, they just won't be able to access it otherwise.\nI think this is reasonable, as with plain SQL I wouldn't be able to access the GROUP BY field (for example) if I didn't include it in the projection (even if you CREATE TABLE AS SELECT ... GROUP BY foo)\npostgres=# CREATE TABLE input (id VARCHAR, count INTEGER);\nCREATE TABLE\npostgres=# INSERT INTO input (id, count) VALUES ('a', 1);\nINSERT 0 1\npostgres=# INSERT INTO input (id, count) VALUES ('b', 1);\nINSERT 0 1\npostgres=# CREATE TABLE agg AS SELECT SUM(count) FROM input GROUP BY id;\nSELECT 1\n--- notice that the ID column is nowhere to be found, even though it is the \"key\" for\n--- the table below\npostgres=# \\d agg\n                Table \"public.agg\"\n Column |  Type  | Collation | Nullable | Default\n--------+--------+-----------+----------+---------\n sum    | bigint |           |          |\npostgres=# SELECT * FROM agg;\n sum\n-----\n   1\n   1", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411519191", "createdAt": "2020-04-20T16:29:07Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTQ4NA==", "bodyText": "\ud83d\udc4e relying on order is super confusing. how often are people going to be copying keys into the value? if it's OK for it to be a little clunky, we can introduce a IDENTITY(foo) or COPY(foo) UDF that just returns the same value as the input. that way you could always do:\nCREATE TABLE OUTPUT AS SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT\nI admit that feels like a workaround, but I don't think it's awful and it fits nicely into the existing model", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411525484", "createdAt": "2020-04-20T16:37:50Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+\n+### The thorn in the design's side\n+\n+Hopefully, all of the above seems simple and clear. Now for the tricky and murky bit...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+Outside of introducing some non-standard keyword into the statement, e.g.\n+\n+```sql\n+-- KEY keyword to indicate its a KEY column\n+CREATE TABLE OUTPUT AS SELECT ID AS V2 KEY, V0, V1 FROM INPUT;\n+-- resulting schema: V2 INT KEY, V0 INT, V1 INT\n+\n+-- VALUE keyword to indicate its a VALUE column\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which are pretty yuck as its moving away from standard SQL.\n+\n+Or by adding some `WITH(KEY_COLUMNS=?)` style syntax, e.g.\n+\n+```sql\n+CREATE TABLE OUTPUT WITH(KEY_COLUMNS=[ID]) AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which is better, but still a little verbose. Also, it would be nice to not couple this KLIP to any\n+discussion about 'Should ksqlDB have `KEY` columns in the schema of CSAS statements or list them in\n+the WITH clause?'\n+\n+Aside from these, the only ways we can think of that are standard SQL would to treat the first\n+occurrence of the key column in the projection as naming the key column in the result, and any\n+subsequent copies to be value columns, (see example below). However, this reliance on the _order_\n+of columns is less than ideal. Anyone got any better ideas for a short term fix for this edge case?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyOTk3NQ==", "bodyText": "I don't think we should do this, it seems like other sql systems keeps the duplicate columns:\npostgres=# CREATE TABLE input (id VARCHAR, count INTEGER);\npostgres=# CREATE TABLE in2 (id VARCHAR, cost INTEGER);;\npostgres=# SELECT * FROM input JOIN in2 ON input.id = in2.id;\n id | count | id | cost\n----+-------+----+------\n a  |     1 | a  |  100", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411529975", "createdAt": "2020-04-20T16:44:18Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/8a6151ec204168e71b088265ac97fd4f18094c5d", "committedDate": "2020-04-20T18:43:58Z", "message": "chore: removal of the optional about removing the right key column"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c769789f5b43e250a0ac6c7ac0b80bea799dfdb", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/6c769789f5b43e250a0ac6c7ac0b80bea799dfdb", "committedDate": "2020-04-21T13:41:15Z", "message": "chore: update\n\nupdate with Almog's requested changes and suggestions and doc another edge case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48273b799a6f0183adce82109a9fde3ea420eec1", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/48273b799a6f0183adce82109a9fde3ea420eec1", "committedDate": "2020-04-21T13:55:07Z", "message": "add group by aliasing as possible solution"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mjk3NDE5", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-397297419", "createdAt": "2020-04-21T12:51:44Z", "commit": {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjo1MTo0NVrOGJECmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNDoyMDo0NVrOGJIZhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA==", "bodyText": "would this also be supported?\nCREATE TABLE OUTPUT AS SELECT (V0 + v1) AS K, COUNT() AS COUNT FROM INPUT GROUP BY K;", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412156568", "createdAt": "2020-04-21T12:51:45Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+\n+### The thorn in the design's side\n+\n+Hopefully, all of the above seems simple and clear. Now for the tricky and murky bit...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+Outside of introducing some non-standard keyword into the statement, e.g.\n+\n+```sql\n+-- KEY keyword to indicate its a KEY column\n+CREATE TABLE OUTPUT AS SELECT ID AS V2 KEY, V0, V1 FROM INPUT;\n+-- resulting schema: V2 INT KEY, V0 INT, V1 INT\n+\n+-- VALUE keyword to indicate its a VALUE column\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which are pretty yuck as its moving away from standard SQL.\n+\n+Or by adding some `WITH(KEY_COLUMNS=?)` style syntax, e.g.\n+\n+```sql\n+CREATE TABLE OUTPUT WITH(KEY_COLUMNS=[ID]) AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which is better, but still a little verbose. Also, it would be nice to not couple this KLIP to any\n+discussion about 'Should ksqlDB have `KEY` columns in the schema of CSAS statements or list them in\n+the WITH clause?'\n+\n+Aside from these, the only ways we can think of that are standard SQL would to treat the first\n+occurrence of the key column in the projection as naming the key column in the result, and any\n+subsequent copies to be value columns, (see example below). However, this reliance on the _order_\n+of columns is less than ideal. Anyone got any better ideas for a short term fix for this edge case?\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+\n+\n+CREATE TABLE OUTPUT AS SELECT ID AS NEW_KEY, V0, V1, ID FROM INPUT;\n+-- resulting schema: NEW_KEY INT KEY, V0 INT, V1 INT, ID INT\n+```\n+\n+## What is in scope\n+\n+- Removal of implicit copying of key column,\n+  in favour of requiring key column in projection of persistent queries.\n+- Removal of non-standard GROUP BY, PARTITION BY and JOIN aliasing syntax,\n+  in favour of standard aliasing of the key column in the projection.\n+- removal of duplicate left join column on 'select *' joins.\n+- TBD: syntax for allowing user to add key column to value schema.\n+\n+## What is not in scope\n+\n+- Changes in syntax for changing the key column, e.g. allowing the projection to change the key\n+  column.  This out of scope and is only potential future work. It should be discussion separately.\n+- Replacing the use of the `KEY` keyword in CSAS statements with other syntax:\n+  this is mostly orthogonal to this change.\n+- everything else.\n+\n+## Value/Return\n+\n+Standardizing the key semantics in queries will lower the barrier for entry for users and engineers\n+alike, and reduce the support burden of explaining the subtleties. It will also simplify the code,\n+which should result in less bugs.\n+\n+Removing of the non-standard `GROUP BY`, `PARTITION BY` and `JON ON` aliasing in favour of aliasing\n+in the projection will improve out standards compliance.\n+\n+## Public APIS\n+\n+1. Persistent queries, i.e. those used in `CREATE TABLE AS`, `CREATE STREAM AS` and `INSERT INTO`\n+statements, will be required to _always_ include their key columns in their projection. An error\n+will be generated should the projection of a persistent query not include its key column. For\n+example:\n+\n+```sql\n+-- old syntax that worked:\n+CREATE TABLE OUTPUT AS SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- will now fail with an error explaining the projection must include the key column `V0`.sql\n+\n+-- corrected query:\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: V0 INT KEY, COUNT BIGINT\n+```\n+\n+2. The, as yet unreleased, non-standard `GROUP BY`, `PARTITION BY` and `JOIN ON` alias syntax will\n+be removed in favour of using the existing standard-compliant aliasing in the projection. For\n+example:\n+\n+```sql\n+-- 'any key' aliasing syntax that will be dropped:\n+CREATE TABLE OUTPUT AS SELECT COUNT() AS COUNT FROM INPUT GROUP BY (V0 + V1) AS K;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+\n+-- proposed key column aliasing in projection:\n+CREATE TABLE OUTPUT AS SELECT (V0 + v1) AS K, COUNT() AS COUNT FROM INPUT GROUP BY V0 + V1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MTA2NQ==", "bodyText": "I like the logic here. In the case of a SELECT * I think I1_ID would be better as it's clearer. If I2's join column was not ID then it's not immediately apparent why it's not present in the output. Not a strong preference though.", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412161065", "createdAt": "2020-04-21T12:57:48Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA==", "bodyText": "Can we also support the alias in the PARTITION BY?\nCREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY NEW_KEY;", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412162244", "createdAt": "2020-04-21T12:59:18Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MzE1OQ==", "bodyText": "nit: s/of/have :)", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412163159", "createdAt": "2020-04-21T13:00:41Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2NjMwNA==", "bodyText": "I'm not convinced about this\nCREATE TABLE BAR AS SELECT COUNT(*) FROM FOO GROUP BY ID;\n\nIt feels like the kind of thing a user would do by mistake, and then be puzzled why they couldn't access ID. IIUC current discussion is not to actually implement this proposal yet, just maybe in the future, if that's right then I am fine to push this debate to the future :)", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412166304", "createdAt": "2020-04-21T13:04:57Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, "originalCommit": {"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNjk5Nw==", "bodyText": "I think this is ok to do.", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412226997", "createdAt": "2020-04-21T14:19:38Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,387 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `COPY` function, (name TBD - maybe 'AS_VALUE'?), that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48273b799a6f0183adce82109a9fde3ea420eec1"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzQ0Mg==", "bodyText": "since we're going to deliver multiple keys in the future, I don't see the benefit really of adding something non-standard now", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412227442", "createdAt": "2020-04-21T14:20:09Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,387 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `COPY` function, (name TBD - maybe 'AS_VALUE'?), that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias\n+for the name of the key column resulting from multiple grouping expressions. This will be resolved\n+when support for multiple key columns is added.\n+\n+Alternatively, ksqlDB could support the non-strandard `GROUP BY (a, b) AS c` style aliasing, to allow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48273b799a6f0183adce82109a9fde3ea420eec1"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg==", "bodyText": "+1 for AS_VALUE, IMO COPY is too ambiguous", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412227972", "createdAt": "2020-04-21T14:20:45Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,387 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `COPY` function, (name TBD - maybe 'AS_VALUE'?), that can be used to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48273b799a6f0183adce82109a9fde3ea420eec1"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDY0NTU0", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-397464554", "createdAt": "2020-04-21T16:16:04Z", "commit": {"oid": "48273b799a6f0183adce82109a9fde3ea420eec1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b02b6548b0a5e8a259608d43a0c4a535f3152f40", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/b02b6548b0a5e8a259608d43a0c4a535f3152f40", "committedDate": "2020-04-22T12:00:59Z", "message": "remove incorrect use of aliasing on multi-column grouping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da2ec54ed43189c78abf9e300a14dd8ec943bfcc", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/da2ec54ed43189c78abf9e300a14dd8ec943bfcc", "committedDate": "2020-04-22T12:06:08Z", "message": "chore: it's so unfair."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a", "committedDate": "2020-04-23T10:12:05Z", "message": "chore: add outer join edge case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MjIzMDIy", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-399223022", "createdAt": "2020-04-23T15:35:02Z", "commit": {"oid": "1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTozNTowM1rOGKukGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTozNTowM1rOGKukGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMTg0OQ==", "bodyText": "also, how would we handle expressions?", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413901849", "createdAt": "2020-04-23T15:35:03Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -385,3 +450,56 @@ in downstream queries.\n This was rejected for this KLIP as it would involve considerably more work. This may be picked up in\n a future KLIP.\n \n+### Storing all join columns in the key of the result\n+\n+A more correct solution for handling columns within a join may look to store all join columns in the\n+Kafka record's key, for example:\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: I1_ID INT KEY, I2_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note that both `I1_ID` and `I2_ID` are marked as key columns. Such an approach may be required if\n+ksqlDB is to support join criterion other than the current equality.\n+\n+However, this is rejected as a solution for now for the following reasons:\n+  a. Such a solution requires ksqlDB to support multiple key columns. It currently does not, and this\n+     KLIP is part of the work moving towards such support. Hence its a chicken and egg problem.\n+  b. Such a solution requires Streams to be able to correctly handle the multiple key columns\n+     correctly, which it currently does not.  This is particularly challenging for outer joins,\n+     where some key columns may initially be `null` and later populated. Any solution needs to ensure\n+     correct partitioning and update semantics for such rows.\n+\n+### System generated naming for the synthesised join column\n+\n+Where a join introduces a synthesised key column the column would have a system generated name.\n+Two naming strategies were rejected:\n+\n+#### `KSQL_COL_x`\n+\n+The synthesised column would take on a generated name in the form `KSQL_COL_x`, where `x` is an\n+integer and the name is guaranteed to be unique, i.e. to not clash with any other system generated\n+column names.\n+\n+This was rejected as the name would be hard for the user to know by looking at the query, i.e. the\n+presence of other columns with generated names may affect the name of the synthesised column. This\n+was deemed to make this solution unworkable.\n+\n+#### Data driven naming\n+\n+The synthesised column would take on a name generated from the join criteria. For example, a join\n+such as `A JOIN B ON A.ID = B.ID` would result in a key column named `A_ID__B_ID`.\n+\n+While this is deterministic and offers improved protection against column name clashes than a static\n+naming strategy, it was rejected as:\n+  a. it adds additional complexity to the code\n+  b. it adds additional cognitive load for users, i.e. the need to know the naming strategy and work\n+     out the name from the criteria.\n+  c. a change in the join criteria requires a change in the projection.\n+  d. name clashes are still possible.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a"}, "originalPosition": 201}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1599a97399fb1dc49ae084d0a967c434d2a3b504", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/1599a97399fb1dc49ae084d0a967c434d2a3b504", "committedDate": "2020-04-24T15:37:52Z", "message": "Update klip-24-key-column-semantics-in-queries.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/772ccf884819c2150f473f1ce58e61967a5bf2df", "committedDate": "2020-04-24T15:43:26Z", "message": "Update klip-24-key-column-semantics-in-queries.md"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDkxNzgx", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400091781", "createdAt": "2020-04-24T16:22:12Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyMjoxMlrOGLfYJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyMjoxMlrOGLfYJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMTYwNA==", "bodyText": "nit: the the", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414701604", "createdAt": "2020-04-24T16:22:12Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDk3MzEz", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400097313", "createdAt": "2020-04-24T16:29:38Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyOTozOFrOGLfqXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyOTozOFrOGLfqXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNjI3MA==", "bodyText": "This is allowed? How is this implemented? It's unclear to me how it's compiled down correctly to a Kafka Streams program?", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414706270", "createdAt": "2020-04-24T16:29:38Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDk5MzQ5", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400099349", "createdAt": "2020-04-24T16:32:31Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjozMjozMVrOGLfxdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjozMjozMVrOGLfxdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwODA4NA==", "bodyText": "nit: ROwKEY -> ROWKEY", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414708084", "createdAt": "2020-04-24T16:32:31Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTAwNzg1", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400100785", "createdAt": "2020-04-24T16:34:33Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjozNDozNFrOGLf2hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjozNDozNFrOGLf2hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwOTM4Mw==", "bodyText": "I guess, only the first query should work. After this KIP is merged, the second query should have a column called ROWKEY and thus should fail?", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414709383", "createdAt": "2020-04-24T16:34:34Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would have failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTA0ODI4", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400104828", "createdAt": "2020-04-24T16:40:19Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjo0MDoxOVrOGLgEzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjo0MDoxOVrOGLgEzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ==", "bodyText": "Personally, I don't buy this argument. The result of a query that returns a table changelog stream (even if it's a stream) should contain the PK IMHO and should be mandatory to have the PK in the SELECT clause... (the EMIT CHANGE should really just be an \"addendum\" to the query without altering what is allowed or not allowed). This difference in behavior is rather confusion and also does not allow to use those push queries (ie, that remove the PK) directly as persistent CT query, but require a rewrite. IMHO, it would be better to align the semantics.", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414713039", "createdAt": "2020-04-24T16:40:19Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would have failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTA4MzU2", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400108356", "createdAt": "2020-04-24T16:45:16Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjo0NToxNlrOGLgQwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjo0NToxNlrOGLgQwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxNjA5Nw==", "bodyText": "As the proposal is to use ROWKEY column for outer joins, it seems the same pattern could be applied for this case to allow people to rename the PK?", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414716097", "createdAt": "2020-04-24T16:45:16Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would have failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `AS_VALUE` function that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, AS_VALUE(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 297}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTkxNDgw", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400191480", "createdAt": "2020-04-24T18:49:06Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a337830a29425a76f5469901fe34b6a825b18361", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/a337830a29425a76f5469901fe34b6a825b18361", "committedDate": "2020-04-27T10:38:17Z", "message": "chore: updated with mjsax's requested changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODM0NTc2", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-400834576", "createdAt": "2020-04-27T10:45:27Z", "commit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDo0NToyN1rOGMctxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDo0NToyN1rOGMctxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ==", "bodyText": "I'm still not convinced about the use of ROWKEY for the synthesised column in some joins. I'm currently coding this up and will play around to see what works best.\nOne concern with ROWKEY is that a lot of existing users will have sources with a ROWKEY key column, meaning there'll be a column clash, which is nasty.\nAlternatives are:\n\na new reserved JOINKEY column name.\nsystem generated KSQL_COL_x style name.\na special UDF that resolves to the new synthesised column, e.g.\n\nCREATE TABLE OUTPUT AS\n   SELECT JOINKEY(S1.ID, S2.ID), S1.V0, S2.V1 \n      FROM SI FULL OUTER JOIN S2 ON S1.ID = S2.ID;\n-- resulting schema: KSQL_COL_0 INT KEY, S1_V0 INT, S2_V1\n\n-- or with an alias:\n\nCREATE TABLE OUTPUT AS\n   SELECT JOINKEY(S1.ID, S2.ID) AS ID, S1.V0, S2.V1 \n      FROM SI FULL OUTER JOIN S2 ON S1.ID = S2.ID;\n-- resulting schema: ID INT KEY, S1_V0 INT, S2_V1\nI'm actually leaning to the JOINKEY() UDF as it allows for better validation than a synthesised column.\ncc @derekjn, @agavra @mjsax : any issue with the JOINKEY() UDF?", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415706565", "createdAt": "2020-04-27T10:45:27Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/3bde52b015a9a4979878adaf73982082c8eb57e3", "committedDate": "2020-04-27T14:35:38Z", "message": "chore: update to use JOINKEY udf for synthetic join columns"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzA3NTUw", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-401307550", "createdAt": "2020-04-27T20:38:13Z", "commit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozODoxM1rOGM2pAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozODoxM1rOGM2pAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTMzMA==", "bodyText": "typo: it to fail", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416131330", "createdAt": "2020-04-27T20:38:13Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzA5NTcx", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-401309571", "createdAt": "2020-04-27T20:41:23Z", "commit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo0MToyM1rOGM2wVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo0MToyM1rOGM2wVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzIwNQ==", "bodyText": "Where does the name ID come from? It's not specified in the query via AS ID? Do you mean\nCREATE TABLE OUTPUT AS\n   SELECT ROWKEY AS ID, * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416133205", "createdAt": "2020-04-27T20:41:23Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzEyODI4", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-401312828", "createdAt": "2020-04-27T20:46:18Z", "commit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo0NjoxOFrOGM27pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo0NjoxOFrOGM27pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzNjEwMQ==", "bodyText": "typo: by by use", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416136101", "createdAt": "2020-04-27T20:46:18Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+First, consider a full outer join on columns from the left and right sources:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+The data stored in the Kafka message's key will be equal to either the left join column, the right\n+join column or both, depending on whether only one side matches or both:\n+\n+|                  | I1.ID | I2.ID | Message Key |\n+| ---------------- | ----- | ----- | ----------- |\n+| both sides match | 10    | 10    | 10          |\n+| left side only   | 10    | null  | 10          |\n+| right side only  | null  | 10    | 10          |\n+\n+As you can see, the message key is not equivalent to either of the source columns. This is\n+problematic.\n+\n+The same is also true of other join types where no sides within the join criteria are a simple\n+column reference, a.k.a. non-column joins. For example:\n+\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+```\n+\n+Again, the message key is not equivalent to any column for the sources involved in the join. (Note:\n+if either side of the join criteria is a simple column reference, then the Kafka message's key is\n+equivalent to that column, and hence no additional column is synthesised by the join).\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own.\n+\n+Though not ideal, we propose that in the short term the synthesised column can be included in the\n+projection by by use of a new `JOINKEY` udf. For example, the above examples that used `*` in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzE3NjI3", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-401317627", "createdAt": "2020-04-27T20:53:24Z", "commit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo1MzoyNVrOGM3NTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo1MzoyNVrOGM3NTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MDYyMw==", "bodyText": "typo: to correctly handle [...] correctly,\n\nwhich it currently does not\n\nAnd maybe never will. However, as discussed in person, there seems to be a solution by compiling down some additional logic into the Kafka Streams program.", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416140623", "createdAt": "2020-04-27T20:53:25Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+First, consider a full outer join on columns from the left and right sources:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+The data stored in the Kafka message's key will be equal to either the left join column, the right\n+join column or both, depending on whether only one side matches or both:\n+\n+|                  | I1.ID | I2.ID | Message Key |\n+| ---------------- | ----- | ----- | ----------- |\n+| both sides match | 10    | 10    | 10          |\n+| left side only   | 10    | null  | 10          |\n+| right side only  | null  | 10    | 10          |\n+\n+As you can see, the message key is not equivalent to either of the source columns. This is\n+problematic.\n+\n+The same is also true of other join types where no sides within the join criteria are a simple\n+column reference, a.k.a. non-column joins. For example:\n+\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+```\n+\n+Again, the message key is not equivalent to any column for the sources involved in the join. (Note:\n+if either side of the join criteria is a simple column reference, then the Kafka message's key is\n+equivalent to that column, and hence no additional column is synthesised by the join).\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own.\n+\n+Though not ideal, we propose that in the short term the synthesised column can be included in the\n+projection by by use of a new `JOINKEY` udf. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(ABS(I1.ID), ABS(I2.ID)), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT\n+      FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Key to this solution, is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID) AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS\n+   SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROWKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that the last query above should work, without any modification, and without storing\n+duplicate data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS\n+   SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `AS_VALUE` function that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, AS_VALUE(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias\n+for the name of the key column resulting from multiple grouping expressions. This will be resolved\n+when support for multiple key columns is added.\n+\n+Alternatively, ksqlDB could support the non-strandard `GROUP BY (a, b) AS c` style aliasing, to allow\n+users to provide their own name. This support could be removed once multiple key columns are \n+supported.\n+\n+If anyone has any suggestions on how we can support this in a compatible manner, please speak up!\n+\n+## What is in scope\n+\n+- Removal of implicit copying of key column,\n+  in favour of requiring key column in projection of persistent queries.\n+- Removal of non-standard GROUP BY, PARTITION BY and JOIN aliasing syntax,\n+  in favour of standard aliasing of the key column in the projection.\n+- removal of duplicate left join column on 'select *' joins.\n+- Addition of `COPY` function to allow users to add key column to value schema.\n+- TODO(ac): group by multiple fields...\n+\n+## What is not in scope\n+\n+- Changes in syntax for changing the key column, e.g. allowing the projection to change the key\n+  column.  This out of scope and is only potential future work. It should be discussion separately.\n+- Replacing the use of the `KEY` keyword in CSAS statements with other syntax:\n+  this is mostly orthogonal to this change.\n+- everything else.\n+\n+## Value/Return\n+\n+Standardizing the key semantics in queries will lower the barrier for entry for users and engineers\n+alike, and reduce the support burden of explaining the subtleties. It will also simplify the code,\n+which should result in less bugs.\n+\n+Removing of the non-standard `GROUP BY`, `PARTITION BY` and `JON ON` aliasing in favour of aliasing\n+in the projection will improve out standards compliance.\n+\n+## Public APIS\n+\n+1. Persistent queries, i.e. those used in `CREATE TABLE AS`, `CREATE STREAM AS` and `INSERT INTO`\n+statements, will be required to _always_ include their key columns in their projection. An error\n+will be generated should the projection of a persistent query not include its key column. For\n+example:\n+\n+```sql\n+-- old syntax that worked:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- will now fail with an error explaining the projection must include the key column `V0`.sql\n+\n+-- corrected query:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: V0 INT KEY, COUNT BIGINT\n+```\n+\n+2. The, as yet unreleased, non-standard `GROUP BY`, `PARTITION BY` and `JOIN ON` alias syntax will\n+be removed in favour of using the existing standard-compliant aliasing in the projection. For\n+example:\n+\n+```sql\n+-- 'any key' aliasing syntax that will be dropped:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0 AS K;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+\n+-- proposed key column aliasing in projection:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0 AS K, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+```\n+\n+3. Removal of duplicate left join column on `select *` joins. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- current result schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID, I1_ID and I2_ID columns.\n+\n+-- proposed result schema either (TBD):\n+-- a): ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID and I2_ID columns, only.\n+-- b): I1_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in I1_ID and I2_ID columns, only.\n+```\n+\n+4. Syntax for allowing key column to be added as value column:\n+\n+A new `COPY` method will be added to allow users to copy the key column into the value. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Name of `COPY` TBD. Alternatives:\n+ - `IDENTITY`\n+ - `AS_VALUE`\n+\n+## Design\n+\n+N/A: the change is a simple(ish) syntax change.\n+\n+## Test plan\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Existing functional (QTT) tested will be converted to the new syntax with any missing cases added.\n+\n+As a purely syntactical change, nothing else is required.\n+\n+## LOEs and Delivery Milestones\n+\n+This is a small change, deliverable as a single milestone.\n+\n+## Documentation Updates\n+\n+Docs and examples in the ksqlDB repo, and any ksqlDB usage in the 'examples' repo, will be checked\n+to ensure the match the new syntax.\n+\n+## Compatibility Implications\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Some existing SQL, if reissued, will fail if a persistent query's projection does not include the\n+key column. However, a helpful error message will inform the user of the changes they need to make\n+to resolve this.  Resolution is simple: just add the key column to the projection!\n+\n+## Security Implications\n+\n+None.\n+\n+## Rejected alternatives\n+\n+### Magic key column copying if no key column in persistent query's projection.\n+\n+Design as above, but not _requiring_ the key column in the projection. Instead, allow the key\n+column in the projection and implicitly copy it across if its not there.  This was rejected for two\n+key reasons:\n+  a. Potentially confusing 'magic implicits' - the output contains columns the projection doesn't\n+     specify.\n+  b. It over complicates the implementation.\n+\n+### Full support for no key column in persistent query's projection.\n+\n+Design as above, but allowing persistent query projections to not include the key column in the\n+projection. If not present, the created data source would have no _exposed_ key column.\n+\n+Given that the created source is actually a materialized view, it seems completely reasonable to\n+allow users to control the set of columns the view exposes. Any requirement internally for the key,\n+e.g. to allow updates to be processed correctly, would remain. The key would just not be available\n+in downstream queries.\n+\n+This was rejected for this KLIP as it would involve considerably more work. This may be picked up in\n+a future KLIP.\n+\n+### Storing all join columns in the key of the result\n+\n+A more correct solution for handling columns within a join may look to store all join columns in the\n+Kafka record's key, for example:\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: I1_ID INT KEY, I2_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note that both `I1_ID` and `I2_ID` are marked as key columns. Such an approach may be required if\n+ksqlDB is to support join criterion other than the current equality.\n+\n+However, this is rejected as a solution for now for the following reasons:\n+  a. Such a solution requires ksqlDB to support multiple key columns. It currently does not, and this\n+     KLIP is part of the work moving towards such support. Hence its a chicken and egg problem.\n+  b. Such a solution requires Streams to be able to correctly handle the multiple key columns\n+     correctly, which it currently does not.  This is particularly challenging for outer joins,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "originalPosition": 519}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzE4MTU2", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-401318156", "createdAt": "2020-04-27T20:54:11Z", "commit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo1NDoxMVrOGM3POw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo1NDoxMVrOGM3POw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MTExNQ==", "bodyText": "typo: to the any source", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416141115", "createdAt": "2020-04-27T20:54:11Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+First, consider a full outer join on columns from the left and right sources:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+The data stored in the Kafka message's key will be equal to either the left join column, the right\n+join column or both, depending on whether only one side matches or both:\n+\n+|                  | I1.ID | I2.ID | Message Key |\n+| ---------------- | ----- | ----- | ----------- |\n+| both sides match | 10    | 10    | 10          |\n+| left side only   | 10    | null  | 10          |\n+| right side only  | null  | 10    | 10          |\n+\n+As you can see, the message key is not equivalent to either of the source columns. This is\n+problematic.\n+\n+The same is also true of other join types where no sides within the join criteria are a simple\n+column reference, a.k.a. non-column joins. For example:\n+\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+```\n+\n+Again, the message key is not equivalent to any column for the sources involved in the join. (Note:\n+if either side of the join criteria is a simple column reference, then the Kafka message's key is\n+equivalent to that column, and hence no additional column is synthesised by the join).\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own.\n+\n+Though not ideal, we propose that in the short term the synthesised column can be included in the\n+projection by by use of a new `JOINKEY` udf. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(ABS(I1.ID), ABS(I2.ID)), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT\n+      FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Key to this solution, is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID) AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS\n+   SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROWKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that the last query above should work, without any modification, and without storing\n+duplicate data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS\n+   SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `AS_VALUE` function that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, AS_VALUE(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias\n+for the name of the key column resulting from multiple grouping expressions. This will be resolved\n+when support for multiple key columns is added.\n+\n+Alternatively, ksqlDB could support the non-strandard `GROUP BY (a, b) AS c` style aliasing, to allow\n+users to provide their own name. This support could be removed once multiple key columns are \n+supported.\n+\n+If anyone has any suggestions on how we can support this in a compatible manner, please speak up!\n+\n+## What is in scope\n+\n+- Removal of implicit copying of key column,\n+  in favour of requiring key column in projection of persistent queries.\n+- Removal of non-standard GROUP BY, PARTITION BY and JOIN aliasing syntax,\n+  in favour of standard aliasing of the key column in the projection.\n+- removal of duplicate left join column on 'select *' joins.\n+- Addition of `COPY` function to allow users to add key column to value schema.\n+- TODO(ac): group by multiple fields...\n+\n+## What is not in scope\n+\n+- Changes in syntax for changing the key column, e.g. allowing the projection to change the key\n+  column.  This out of scope and is only potential future work. It should be discussion separately.\n+- Replacing the use of the `KEY` keyword in CSAS statements with other syntax:\n+  this is mostly orthogonal to this change.\n+- everything else.\n+\n+## Value/Return\n+\n+Standardizing the key semantics in queries will lower the barrier for entry for users and engineers\n+alike, and reduce the support burden of explaining the subtleties. It will also simplify the code,\n+which should result in less bugs.\n+\n+Removing of the non-standard `GROUP BY`, `PARTITION BY` and `JON ON` aliasing in favour of aliasing\n+in the projection will improve out standards compliance.\n+\n+## Public APIS\n+\n+1. Persistent queries, i.e. those used in `CREATE TABLE AS`, `CREATE STREAM AS` and `INSERT INTO`\n+statements, will be required to _always_ include their key columns in their projection. An error\n+will be generated should the projection of a persistent query not include its key column. For\n+example:\n+\n+```sql\n+-- old syntax that worked:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- will now fail with an error explaining the projection must include the key column `V0`.sql\n+\n+-- corrected query:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: V0 INT KEY, COUNT BIGINT\n+```\n+\n+2. The, as yet unreleased, non-standard `GROUP BY`, `PARTITION BY` and `JOIN ON` alias syntax will\n+be removed in favour of using the existing standard-compliant aliasing in the projection. For\n+example:\n+\n+```sql\n+-- 'any key' aliasing syntax that will be dropped:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0 AS K;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+\n+-- proposed key column aliasing in projection:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0 AS K, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+```\n+\n+3. Removal of duplicate left join column on `select *` joins. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- current result schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID, I1_ID and I2_ID columns.\n+\n+-- proposed result schema either (TBD):\n+-- a): ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID and I2_ID columns, only.\n+-- b): I1_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in I1_ID and I2_ID columns, only.\n+```\n+\n+4. Syntax for allowing key column to be added as value column:\n+\n+A new `COPY` method will be added to allow users to copy the key column into the value. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Name of `COPY` TBD. Alternatives:\n+ - `IDENTITY`\n+ - `AS_VALUE`\n+\n+## Design\n+\n+N/A: the change is a simple(ish) syntax change.\n+\n+## Test plan\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Existing functional (QTT) tested will be converted to the new syntax with any missing cases added.\n+\n+As a purely syntactical change, nothing else is required.\n+\n+## LOEs and Delivery Milestones\n+\n+This is a small change, deliverable as a single milestone.\n+\n+## Documentation Updates\n+\n+Docs and examples in the ksqlDB repo, and any ksqlDB usage in the 'examples' repo, will be checked\n+to ensure the match the new syntax.\n+\n+## Compatibility Implications\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Some existing SQL, if reissued, will fail if a persistent query's projection does not include the\n+key column. However, a helpful error message will inform the user of the changes they need to make\n+to resolve this.  Resolution is simple: just add the key column to the projection!\n+\n+## Security Implications\n+\n+None.\n+\n+## Rejected alternatives\n+\n+### Magic key column copying if no key column in persistent query's projection.\n+\n+Design as above, but not _requiring_ the key column in the projection. Instead, allow the key\n+column in the projection and implicitly copy it across if its not there.  This was rejected for two\n+key reasons:\n+  a. Potentially confusing 'magic implicits' - the output contains columns the projection doesn't\n+     specify.\n+  b. It over complicates the implementation.\n+\n+### Full support for no key column in persistent query's projection.\n+\n+Design as above, but allowing persistent query projections to not include the key column in the\n+projection. If not present, the created data source would have no _exposed_ key column.\n+\n+Given that the created source is actually a materialized view, it seems completely reasonable to\n+allow users to control the set of columns the view exposes. Any requirement internally for the key,\n+e.g. to allow updates to be processed correctly, would remain. The key would just not be available\n+in downstream queries.\n+\n+This was rejected for this KLIP as it would involve considerably more work. This may be picked up in\n+a future KLIP.\n+\n+### Storing all join columns in the key of the result\n+\n+A more correct solution for handling columns within a join may look to store all join columns in the\n+Kafka record's key, for example:\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: I1_ID INT KEY, I2_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note that both `I1_ID` and `I2_ID` are marked as key columns. Such an approach may be required if\n+ksqlDB is to support join criterion other than the current equality.\n+\n+However, this is rejected as a solution for now for the following reasons:\n+  a. Such a solution requires ksqlDB to support multiple key columns. It currently does not, and this\n+     KLIP is part of the work moving towards such support. Hence its a chicken and egg problem.\n+  b. Such a solution requires Streams to be able to correctly handle the multiple key columns\n+     correctly, which it currently does not.  This is particularly challenging for outer joins,\n+     where some key columns may initially be `null` and later populated. Any solution needs to ensure\n+     correct partitioning and update semantics for such rows.\n+\n+### System generated naming for the synthesised join column\n+\n+Where a join introduces a synthesised key column the column would have a system generated name.\n+\n+Requiring the user to include a column within the projection that does not belong to the any source", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3"}, "originalPosition": 527}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "519a7b75af167f52b991858dd7b1e9e582b0c4f1", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/519a7b75af167f52b991858dd7b1e9e582b0c4f1", "committedDate": "2020-05-06T18:04:07Z", "message": "chore: updated with latest comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2698f8ccde0021fb38ed7ea6322cfd793ef92240", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/2698f8ccde0021fb38ed7ea6322cfd793ef92240", "committedDate": "2020-05-06T18:41:24Z", "message": "Merge branch 'master' into klip-24-key-column-query-semantics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NjE3MTMy", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-407617132", "createdAt": "2020-05-07T16:01:23Z", "commit": {"oid": "2698f8ccde0021fb38ed7ea6322cfd793ef92240"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyOTg0MDQ0", "url": "https://github.com/confluentinc/ksql/pull/5115#pullrequestreview-622984044", "createdAt": "2021-03-29T08:34:57Z", "commit": {"oid": "2698f8ccde0021fb38ed7ea6322cfd793ef92240"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4864, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}