{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODk3MTg2", "number": 4899, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDoyMzo1NVrODr0dKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDoyMzo1NVrODr0dKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3Mjc0Nzk0OnYy", "diffSide": "RIGHT", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDoyMzo1NVrOF8Y9eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMDoxNzozNlrOF8q7pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2NzgzNA==", "bodyText": "\ud83d\udc4e that is an abuse of Optional. Just making my opinion known, but as it's a style thing feel free to ignore me", "url": "https://github.com/confluentinc/ksql/pull/4899#discussion_r398867834", "createdAt": "2020-03-26T20:23:55Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "diffHunk": "@@ -44,48 +50,72 @@ private GroupByParamsFactory() {\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions\n+      final List<ExpressionMetadata> groupBys,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return expressions.size() == 1\n-        ? singleExpressionSchema(sourceSchema, expressions.get(0).getExpressionType())\n-        : multiExpressionSchema(sourceSchema);\n+    return groupBys.size() == 1\n+        ? singleExpressionSchema(sourceSchema, groupBys.get(0), ksqlConfig)\n+        : multiExpressionSchema(sourceSchema, ksqlConfig);\n   }\n \n   public static GroupByParams build(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions,\n-      final ProcessingLogger logger\n+      final List<ExpressionMetadata> groupBys,\n+      final ProcessingLogger logger,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    final Function<GenericRow, Struct> mapper = expressions.size() == 1\n-        ? new SingleExpressionGrouper(expressions.get(0), logger)::apply\n-        : new MultiExpressionGrouper(expressions, logger)::apply;\n+    if (groupBys.isEmpty()) {\n+      throw new IllegalArgumentException(\"No GROUP BY groupBys\");\n+    }\n \n-    final LogicalSchema schema = buildSchema(sourceSchema, expressions);\n+    final Function<GenericRow, Struct> mapper = groupBys.size() == 1\n+        ? new SingleExpressionGrouper(groupBys.get(0), logger)::apply\n+        : new MultiExpressionGrouper(groupBys, logger)::apply;\n+\n+    final LogicalSchema schema = buildSchema(sourceSchema, groupBys, ksqlConfig);\n \n     return new GroupByParams(schema, mapper);\n   }\n \n   private static LogicalSchema multiExpressionSchema(\n-      final LogicalSchema sourceSchema\n+      final LogicalSchema sourceSchema,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, SqlTypes.STRING);\n+    return buildSchemaWithKeyType(sourceSchema, Optional.empty(), SqlTypes.STRING, ksqlConfig);\n   }\n \n   private static LogicalSchema singleExpressionSchema(\n       final LogicalSchema sourceSchema,\n-      final SqlType keyType\n+      final ExpressionMetadata groupBy,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, keyType);\n+    final SqlType keyType = groupBy.getExpressionType();\n+\n+    final Optional<ColumnName> singleColumnName = Optional.of(groupBy.getExpression())\n+        .filter(colRef -> ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED))\n+        .filter(gb -> gb instanceof ColumnReferenceExp)\n+        .map(ColumnReferenceExp.class::cast)\n+        .map(ColumnReferenceExp::getColumnName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b0a2e0f0890ee635653a448cc29254606d88e34"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjI3Nw==", "bodyText": "I agree - I'm being super lazy and this code is going very soon.  Next PR removes this.", "url": "https://github.com/confluentinc/ksql/pull/4899#discussion_r399162277", "createdAt": "2020-03-27T10:17:36Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "diffHunk": "@@ -44,48 +50,72 @@ private GroupByParamsFactory() {\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions\n+      final List<ExpressionMetadata> groupBys,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return expressions.size() == 1\n-        ? singleExpressionSchema(sourceSchema, expressions.get(0).getExpressionType())\n-        : multiExpressionSchema(sourceSchema);\n+    return groupBys.size() == 1\n+        ? singleExpressionSchema(sourceSchema, groupBys.get(0), ksqlConfig)\n+        : multiExpressionSchema(sourceSchema, ksqlConfig);\n   }\n \n   public static GroupByParams build(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions,\n-      final ProcessingLogger logger\n+      final List<ExpressionMetadata> groupBys,\n+      final ProcessingLogger logger,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    final Function<GenericRow, Struct> mapper = expressions.size() == 1\n-        ? new SingleExpressionGrouper(expressions.get(0), logger)::apply\n-        : new MultiExpressionGrouper(expressions, logger)::apply;\n+    if (groupBys.isEmpty()) {\n+      throw new IllegalArgumentException(\"No GROUP BY groupBys\");\n+    }\n \n-    final LogicalSchema schema = buildSchema(sourceSchema, expressions);\n+    final Function<GenericRow, Struct> mapper = groupBys.size() == 1\n+        ? new SingleExpressionGrouper(groupBys.get(0), logger)::apply\n+        : new MultiExpressionGrouper(groupBys, logger)::apply;\n+\n+    final LogicalSchema schema = buildSchema(sourceSchema, groupBys, ksqlConfig);\n \n     return new GroupByParams(schema, mapper);\n   }\n \n   private static LogicalSchema multiExpressionSchema(\n-      final LogicalSchema sourceSchema\n+      final LogicalSchema sourceSchema,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, SqlTypes.STRING);\n+    return buildSchemaWithKeyType(sourceSchema, Optional.empty(), SqlTypes.STRING, ksqlConfig);\n   }\n \n   private static LogicalSchema singleExpressionSchema(\n       final LogicalSchema sourceSchema,\n-      final SqlType keyType\n+      final ExpressionMetadata groupBy,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, keyType);\n+    final SqlType keyType = groupBy.getExpressionType();\n+\n+    final Optional<ColumnName> singleColumnName = Optional.of(groupBy.getExpression())\n+        .filter(colRef -> ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED))\n+        .filter(gb -> gb instanceof ColumnReferenceExp)\n+        .map(ColumnReferenceExp.class::cast)\n+        .map(ColumnReferenceExp::getColumnName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2NzgzNA=="}, "originalCommit": {"oid": "7b0a2e0f0890ee635653a448cc29254606d88e34"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3666, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}