{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNjg1NDQ2", "number": 6085, "title": "fix: properly handle restore on CREATE OR REPLACE", "bodyText": "(also) fixes #6078\nDescription\nIn the existing code, CREATE OR REPLACE statements aren't handled correctly by the compactor because it did not account for the possibility of multiple queries with the same (valid) query ID existing.\nThis PR changes the algorithm to make it resilient to these types of changes.\nTesting done\nAdded tests to RecoveryTest, manual testing.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-08-24T18:15:49Z", "url": "https://github.com/confluentinc/ksql/pull/6085", "merged": true, "mergeCommit": {"oid": "6ef7653f6b832f84663f5cdc4d0d4ddd5e8db30f"}, "closed": true, "closedAt": "2020-08-25T00:59:20Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCHJ7mAH2gAyNDcyNjg1NDQ2OjFkMTRiNDgzMWRmY2U1OThkYzQ0ZmI0YzJmYmVkMjFkNWM1M2YxMzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCILh1gH2gAyNDcyNjg1NDQ2OmExNWNiZmM2MWZmNThiMWJkOWJiNjI1NzAxN2NkNzgyYWY0YmY5NDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "committedDate": "2020-08-24T18:45:16Z", "message": "fix: properly handle restore on CREATE OR REPLACE"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "014dd154b28164229524957509230b1ca21e3cc5", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/014dd154b28164229524957509230b1ca21e3cc5", "committedDate": "2020-08-24T18:14:05Z", "message": "fix: properly handle restore on CREATE OR REPLACE"}, "afterCommit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "committedDate": "2020-08-24T18:45:16Z", "message": "fix: properly handle restore on CREATE OR REPLACE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzY5MTYw", "url": "https://github.com/confluentinc/ksql/pull/6085#pullrequestreview-473769160", "createdAt": "2020-08-24T18:50:34Z", "commit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo1MDozNFrOHFyCCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo1MDozNFrOHFyCCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNDY0OQ==", "bodyText": "So, you create a compacted node even for the previous queries that have been replaced?", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475824649", "createdAt": "2020-08-24T18:50:34Z", "author": {"login": "vpapavas"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -50,73 +45,92 @@ private RestoreCommandsCompactor() {\n    * @return the compacted list of commands.\n    */\n   static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n-    final List<QueuedCommand> compacted = new LinkedList<>(restoreCommands);\n-\n-    final Set<QueuedCommand> terminatedQueries =\n-        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+    final Map<QueryId, CompactedNode> latestNodeWithId = new HashMap<>();\n+    CompactedNode current = null;\n+\n+    for (final QueuedCommand cmd : restoreCommands) {\n+      // Whenever a new command is processed, we check if a previous command with\n+      // the same queryID exists - in which case, we mark that command as \"shouldSkip\"\n+      // and it will not be included in the output\n+      current = CompactedNode.of(current, cmd, latestNodeWithId);\n+    }\n \n-    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+    final List<QueuedCommand> compacted = new LinkedList<>();\n+    while (current != null) {\n+      // traverse backwards and add each next node to the start of the list\n+      compact(current).ifPresent(cmd -> compacted.add(0, cmd));\n+      current = current.prev;\n+    }\n \n     return compacted;\n   }\n \n-  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n-      final List<QueuedCommand> commands\n-  ) {\n-    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n-    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    final Iterator<QueuedCommand> it = commands.iterator();\n-    while (it.hasNext()) {\n-      final QueuedCommand cmd = it.next();\n-\n-      // Find known queries:\n-      final Command command =\n-          cmd.getAndDeserializeCommand(InternalTopicSerdes.deserializer(Command.class));\n-      if (command.getPlan().isPresent()\n-          && command.getPlan().get().getQueryPlan().isPresent()\n-      ) {\n-        final QueryId queryId =\n-            command.getPlan().get().getQueryPlan().get().getQueryId();\n-        queries.putIfAbsent(queryId, cmd);\n+  private static final class CompactedNode {\n+\n+    final CompactedNode prev;\n+    final QueuedCommand queued;\n+    final Command command;\n+\n+    boolean shouldSkip = false;\n+\n+    public static CompactedNode of(\n+        final CompactedNode prev,\n+        final QueuedCommand queued,\n+        final Map<QueryId, CompactedNode> latestNodeWithId\n+    ) {\n+      final Command command = queued.getAndDeserializeCommand(\n+          InternalTopicSerdes.deserializer(Command.class)\n+      );\n+\n+      final Optional<KsqlPlan> plan = command.getPlan();\n+      if (queued.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n+        final QueryId queryId = new QueryId(queued.getAndDeserializeCommandId().getEntity());\n+        markShouldSkip(queryId, latestNodeWithId);\n+\n+        // terminate commands don't get added to the list of commands to execute\n+        // because we \"execute\" them in this class by removing query plans from\n+        // terminated queries\n+        return prev;\n+      } else if (!plan.isPresent() || !plan.get().getQueryPlan().isPresent()) {\n+        // DDL\n+        return new CompactedNode(prev, queued, command);\n       }\n \n-      // Find TERMINATE's that match known queries:\n-      if (cmd.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n-        final QueryId queryId = new QueryId(cmd.getAndDeserializeCommandId().getEntity());\n-        final QueuedCommand terminated = queries.remove(queryId);\n-        if (terminated != null) {\n-          terminatedQueries.add(terminated);\n-          it.remove();\n-        }\n-      }\n-    }\n+      final QueryId queryId = plan.get().getQueryPlan().get().getQueryId();\n+      markShouldSkip(queryId, latestNodeWithId);\n+      final CompactedNode node = new CompactedNode(prev, queued, command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzczNTQy", "url": "https://github.com/confluentinc/ksql/pull/6085#pullrequestreview-473773542", "createdAt": "2020-08-24T18:56:54Z", "commit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzc5NjEw", "url": "https://github.com/confluentinc/ksql/pull/6085#pullrequestreview-473779610", "createdAt": "2020-08-24T19:06:01Z", "commit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowNjowMVrOHFyh8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowODo0MlrOHFynng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzMjgxNg==", "bodyText": "nit: consider renaming to something like maybeAppend - I usually read of as constructing a new object", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475832816", "createdAt": "2020-08-24T19:06:01Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -50,73 +45,92 @@ private RestoreCommandsCompactor() {\n    * @return the compacted list of commands.\n    */\n   static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n-    final List<QueuedCommand> compacted = new LinkedList<>(restoreCommands);\n-\n-    final Set<QueuedCommand> terminatedQueries =\n-        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+    final Map<QueryId, CompactedNode> latestNodeWithId = new HashMap<>();\n+    CompactedNode current = null;\n+\n+    for (final QueuedCommand cmd : restoreCommands) {\n+      // Whenever a new command is processed, we check if a previous command with\n+      // the same queryID exists - in which case, we mark that command as \"shouldSkip\"\n+      // and it will not be included in the output\n+      current = CompactedNode.of(current, cmd, latestNodeWithId);\n+    }\n \n-    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+    final List<QueuedCommand> compacted = new LinkedList<>();\n+    while (current != null) {\n+      // traverse backwards and add each next node to the start of the list\n+      compact(current).ifPresent(cmd -> compacted.add(0, cmd));\n+      current = current.prev;\n+    }\n \n     return compacted;\n   }\n \n-  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n-      final List<QueuedCommand> commands\n-  ) {\n-    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n-    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    final Iterator<QueuedCommand> it = commands.iterator();\n-    while (it.hasNext()) {\n-      final QueuedCommand cmd = it.next();\n-\n-      // Find known queries:\n-      final Command command =\n-          cmd.getAndDeserializeCommand(InternalTopicSerdes.deserializer(Command.class));\n-      if (command.getPlan().isPresent()\n-          && command.getPlan().get().getQueryPlan().isPresent()\n-      ) {\n-        final QueryId queryId =\n-            command.getPlan().get().getQueryPlan().get().getQueryId();\n-        queries.putIfAbsent(queryId, cmd);\n+  private static final class CompactedNode {\n+\n+    final CompactedNode prev;\n+    final QueuedCommand queued;\n+    final Command command;\n+\n+    boolean shouldSkip = false;\n+\n+    public static CompactedNode of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzNDI3MA==", "bodyText": "consider asserting that if there is a previous stream/table with this ID, that it doesn't have a query associated with it?", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475834270", "createdAt": "2020-08-24T19:08:42Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -50,73 +45,92 @@ private RestoreCommandsCompactor() {\n    * @return the compacted list of commands.\n    */\n   static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n-    final List<QueuedCommand> compacted = new LinkedList<>(restoreCommands);\n-\n-    final Set<QueuedCommand> terminatedQueries =\n-        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+    final Map<QueryId, CompactedNode> latestNodeWithId = new HashMap<>();\n+    CompactedNode current = null;\n+\n+    for (final QueuedCommand cmd : restoreCommands) {\n+      // Whenever a new command is processed, we check if a previous command with\n+      // the same queryID exists - in which case, we mark that command as \"shouldSkip\"\n+      // and it will not be included in the output\n+      current = CompactedNode.of(current, cmd, latestNodeWithId);\n+    }\n \n-    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+    final List<QueuedCommand> compacted = new LinkedList<>();\n+    while (current != null) {\n+      // traverse backwards and add each next node to the start of the list\n+      compact(current).ifPresent(cmd -> compacted.add(0, cmd));\n+      current = current.prev;\n+    }\n \n     return compacted;\n   }\n \n-  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n-      final List<QueuedCommand> commands\n-  ) {\n-    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n-    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    final Iterator<QueuedCommand> it = commands.iterator();\n-    while (it.hasNext()) {\n-      final QueuedCommand cmd = it.next();\n-\n-      // Find known queries:\n-      final Command command =\n-          cmd.getAndDeserializeCommand(InternalTopicSerdes.deserializer(Command.class));\n-      if (command.getPlan().isPresent()\n-          && command.getPlan().get().getQueryPlan().isPresent()\n-      ) {\n-        final QueryId queryId =\n-            command.getPlan().get().getQueryPlan().get().getQueryId();\n-        queries.putIfAbsent(queryId, cmd);\n+  private static final class CompactedNode {\n+\n+    final CompactedNode prev;\n+    final QueuedCommand queued;\n+    final Command command;\n+\n+    boolean shouldSkip = false;\n+\n+    public static CompactedNode of(\n+        final CompactedNode prev,\n+        final QueuedCommand queued,\n+        final Map<QueryId, CompactedNode> latestNodeWithId\n+    ) {\n+      final Command command = queued.getAndDeserializeCommand(\n+          InternalTopicSerdes.deserializer(Command.class)\n+      );\n+\n+      final Optional<KsqlPlan> plan = command.getPlan();\n+      if (queued.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n+        final QueryId queryId = new QueryId(queued.getAndDeserializeCommandId().getEntity());\n+        markShouldSkip(queryId, latestNodeWithId);\n+\n+        // terminate commands don't get added to the list of commands to execute\n+        // because we \"execute\" them in this class by removing query plans from\n+        // terminated queries\n+        return prev;\n+      } else if (!plan.isPresent() || !plan.get().getQueryPlan().isPresent()) {\n+        // DDL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a15cbfc61ff58b1bd9bb6257017cd782af4bf948", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/a15cbfc61ff58b1bd9bb6257017cd782af4bf948", "committedDate": "2020-08-24T19:56:55Z", "message": "chore: rename method"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4732, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}