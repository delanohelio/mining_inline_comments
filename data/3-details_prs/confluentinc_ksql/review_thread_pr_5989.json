{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2ODI2OTUx", "number": 5989, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTowNjowM1rOEXq1jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToxMDozN1rOEXq95g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjU0NTQyOnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/SourceNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTowNjowM1rOG_lmRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTowNjowM1rOG_lmRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMyOTQ3OA==", "bodyText": "More normal to put the annotation on the getter when there is a getter method.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469329478", "createdAt": "2020-08-12T15:06:03Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/SourceNode.java", "diffHunk": "@@ -49,6 +50,7 @@\n   private final String type;\n   private final Optional<String> schema;\n   private final Optional<KeyFormatNode> keyFormat;\n+  @JsonInclude(JsonInclude.Include.NON_EMPTY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c58b94efcedbd01f04138576df7dad84da2078"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjU1ODk1OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/conditions/PostConditions.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTowODo1NlrOG_lupg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMToyMTo0OFrOG_zUYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMTYyMg==", "bodyText": "It's a bit odd to combine the additional sources (list of all sources from metastore) with the test-provided post condition sources, since the former should be a superset of the latter or else the test will fail. This is the existing pattern for collecting topics into the post conditions, though, so I've maintained it here. cc @big-andy-coates for context on why topics are aggregated like this.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469331622", "createdAt": "2020-08-12T15:08:56Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/conditions/PostConditions.java", "diffHunk": "@@ -75,29 +77,46 @@ public void verify(\n   }\n \n   public Optional<PostConditionsNode> asNode(\n-      final List<PostTopicNode> additional\n+      final List<PostTopicNode> additionalTopics,\n+      final List<SourceNode> additionalSources\n   ) {\n-    if (this == NONE && additional.isEmpty()) {\n+    if (this == NONE && additionalTopics.isEmpty() && additionalSources.isEmpty()) {\n       return Optional.empty();\n     }\n \n+    return Optional.of(new PostConditionsNode(\n+        withAdditionalSources(additionalSources),\n+        Optional.of(withAdditionalTopics(additionalTopics))\n+    ));\n+  }\n+\n+  private List<SourceNode> withAdditionalSources(final List<SourceNode> additionalSources) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b3b154ea9ba76ca1f45751248be000bfa198441"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzNDgwNw==", "bodyText": "What you say sounds sensible / right.  If the we're capturing all sources then we don't need to maintain any that have been added in the test.\nSame sounds true to topics.\nMaybe just debug / hack some code in to confirm its always a super set.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469334807", "createdAt": "2020-08-12T15:13:23Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/conditions/PostConditions.java", "diffHunk": "@@ -75,29 +77,46 @@ public void verify(\n   }\n \n   public Optional<PostConditionsNode> asNode(\n-      final List<PostTopicNode> additional\n+      final List<PostTopicNode> additionalTopics,\n+      final List<SourceNode> additionalSources\n   ) {\n-    if (this == NONE && additional.isEmpty()) {\n+    if (this == NONE && additionalTopics.isEmpty() && additionalSources.isEmpty()) {\n       return Optional.empty();\n     }\n \n+    return Optional.of(new PostConditionsNode(\n+        withAdditionalSources(additionalSources),\n+        Optional.of(withAdditionalTopics(additionalTopics))\n+    ));\n+  }\n+\n+  private List<SourceNode> withAdditionalSources(final List<SourceNode> additionalSources) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMTYyMg=="}, "originalCommit": {"oid": "2b3b154ea9ba76ca1f45751248be000bfa198441"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MTQ3Ng==", "bodyText": "Maybe just debug / hack some code in to confirm its always a super set.\n\nI'm not convinced this is worth it. Suppose someone writes a bad test with a topic or source in the post conditions that exists but does not validate properly (e.g., expecting a source with a particular name to be a table when it should be stream). Unless the superset check is nested (i.e., checks that fields are equal up to optionality), the code for generating historic plans will overwrite the bad test-provided post condition and the fact that the test fails on master will still be hidden in the historic plan. In other words, adding a partial superset check still leaves gaps, so I think it's better to blindly overwrite the topics and sources when generating historic plans and leave catching bad test files to QTT instead.\nI'll update the code here to overwrite topics and sources rather than trying to merge them with test-provided post conditions.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469351476", "createdAt": "2020-08-12T15:37:02Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/conditions/PostConditions.java", "diffHunk": "@@ -75,29 +77,46 @@ public void verify(\n   }\n \n   public Optional<PostConditionsNode> asNode(\n-      final List<PostTopicNode> additional\n+      final List<PostTopicNode> additionalTopics,\n+      final List<SourceNode> additionalSources\n   ) {\n-    if (this == NONE && additional.isEmpty()) {\n+    if (this == NONE && additionalTopics.isEmpty() && additionalSources.isEmpty()) {\n       return Optional.empty();\n     }\n \n+    return Optional.of(new PostConditionsNode(\n+        withAdditionalSources(additionalSources),\n+        Optional.of(withAdditionalTopics(additionalTopics))\n+    ));\n+  }\n+\n+  private List<SourceNode> withAdditionalSources(final List<SourceNode> additionalSources) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMTYyMg=="}, "originalCommit": {"oid": "2b3b154ea9ba76ca1f45751248be000bfa198441"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMDI1MA==", "bodyText": "Ah, I think I misunderstood your suggestion earlier. I think\n\nMaybe just debug / hack some code in to confirm its always a super set.\n\nmeans to sanity check offline that for existing tests, the set of all topics and sources is always a superset of what's specified in the post conditions, and then simplify the code to just replace the topics and sources with the lists of all topics and all sources. If so, this aligns with what I wrote above as well. I'll do this.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469520250", "createdAt": "2020-08-12T20:27:49Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/conditions/PostConditions.java", "diffHunk": "@@ -75,29 +77,46 @@ public void verify(\n   }\n \n   public Optional<PostConditionsNode> asNode(\n-      final List<PostTopicNode> additional\n+      final List<PostTopicNode> additionalTopics,\n+      final List<SourceNode> additionalSources\n   ) {\n-    if (this == NONE && additional.isEmpty()) {\n+    if (this == NONE && additionalTopics.isEmpty() && additionalSources.isEmpty()) {\n       return Optional.empty();\n     }\n \n+    return Optional.of(new PostConditionsNode(\n+        withAdditionalSources(additionalSources),\n+        Optional.of(withAdditionalTopics(additionalTopics))\n+    ));\n+  }\n+\n+  private List<SourceNode> withAdditionalSources(final List<SourceNode> additionalSources) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMTYyMg=="}, "originalCommit": {"oid": "2b3b154ea9ba76ca1f45751248be000bfa198441"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1NDI3NA==", "bodyText": "Confirmed that the sets of all topics and sources are always supersets of the test-provided topics and sources from the post conditions, and removed the dead code. Had to add another commit for regenerating specs since the order of the topics/sources in the specs has changed in many cases, though there are no substantive changes.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469554274", "createdAt": "2020-08-12T21:21:48Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/conditions/PostConditions.java", "diffHunk": "@@ -75,29 +77,46 @@ public void verify(\n   }\n \n   public Optional<PostConditionsNode> asNode(\n-      final List<PostTopicNode> additional\n+      final List<PostTopicNode> additionalTopics,\n+      final List<SourceNode> additionalSources\n   ) {\n-    if (this == NONE && additional.isEmpty()) {\n+    if (this == NONE && additionalTopics.isEmpty() && additionalSources.isEmpty()) {\n       return Optional.empty();\n     }\n \n+    return Optional.of(new PostConditionsNode(\n+        withAdditionalSources(additionalSources),\n+        Optional.of(withAdditionalTopics(additionalTopics))\n+    ));\n+  }\n+\n+  private List<SourceNode> withAdditionalSources(final List<SourceNode> additionalSources) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMTYyMg=="}, "originalCommit": {"oid": "2b3b154ea9ba76ca1f45751248be000bfa198441"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjU2Njc4OnYy", "diffSide": "RIGHT", "path": "ksqldb-functional-tests/src/test/resources/historical_plans/array_-_GENERATE_SERIES/5.5.0_1581572083765/spec.json", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToxMDozN1rOG_lzbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDozMDozMlrOHAORKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMjg0Ng==", "bodyText": "I wouldn't expect this serdeOptions to be included if its empty due to the @JsonInclude(JsonInclude.Include.NON_EMPTY annotation.\nDid you maybe generate there before adding annotation?\nMight be worth removing these to avoid changes if someone regenerates later. Plus it will also test the deserialization works when this field is not present.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469332846", "createdAt": "2020-08-12T15:10:37Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/array_-_GENERATE_SERIES/5.5.0_1581572083765/spec.json", "diffHunk": "@@ -73,6 +73,23 @@\n     } ],\n     \"statements\" : [ \"CREATE STREAM TEST (F0 INT, F1 INT) WITH (kafka_topic='test_topic', value_format='JSON');\", \"CREATE STREAM OUTPUT AS SELECT GENERATE_SERIES(F0, F1) FROM TEST;\" ],\n     \"post\" : {\n+      \"sources\" : [ {\n+        \"name\" : \"OUTPUT\",\n+        \"type\" : \"STREAM\",\n+        \"schema\" : \"`ROWKEY` STRING KEY, `KSQL_COL_0` ARRAY<INTEGER>\",\n+        \"keyFormat\" : {\n+          \"format\" : \"KAFKA\"\n+        },\n+        \"serdeOptions\" : [ ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "250f296157119612a22b9ab2d3c68479d7d489b4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0ODEwNQ==", "bodyText": "I wouldn't expect this serdeOptions to be included if its empty due to the @JsonInclude(JsonInclude.Include.NON_EMPTY annotation.\n\nThat's funny, I thought I added NON_NULL but it appears I added NON_EMPTY. From the new unit tests in SourceNodeTest.java, both function the same way for the optional set field, maybe because non-empty = non-null for optionals? I'll update it to NON_NULL to avoid confusion.\n\nDid you maybe generate there before adding annotation?\n\nNope, generated after. I wanted the empty serde options in the historic plan specs since lack of serde options means no validation on serde options is performed, whereas empty serde options means the test validates that the set of serde options is empty.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469348105", "createdAt": "2020-08-12T15:32:15Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/array_-_GENERATE_SERIES/5.5.0_1581572083765/spec.json", "diffHunk": "@@ -73,6 +73,23 @@\n     } ],\n     \"statements\" : [ \"CREATE STREAM TEST (F0 INT, F1 INT) WITH (kafka_topic='test_topic', value_format='JSON');\", \"CREATE STREAM OUTPUT AS SELECT GENERATE_SERIES(F0, F1) FROM TEST;\" ],\n     \"post\" : {\n+      \"sources\" : [ {\n+        \"name\" : \"OUTPUT\",\n+        \"type\" : \"STREAM\",\n+        \"schema\" : \"`ROWKEY` STRING KEY, `KSQL_COL_0` ARRAY<INTEGER>\",\n+        \"keyFormat\" : {\n+          \"format\" : \"KAFKA\"\n+        },\n+        \"serdeOptions\" : [ ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMjg0Ng=="}, "originalCommit": {"oid": "250f296157119612a22b9ab2d3c68479d7d489b4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3OTUyNQ==", "bodyText": "I think NON_EMPTY probably makes more sense, as this wouldn't output \"serdeOptions\" : [ ] where the optional was empty.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469979525", "createdAt": "2020-08-13T14:09:41Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/array_-_GENERATE_SERIES/5.5.0_1581572083765/spec.json", "diffHunk": "@@ -73,6 +73,23 @@\n     } ],\n     \"statements\" : [ \"CREATE STREAM TEST (F0 INT, F1 INT) WITH (kafka_topic='test_topic', value_format='JSON');\", \"CREATE STREAM OUTPUT AS SELECT GENERATE_SERIES(F0, F1) FROM TEST;\" ],\n     \"post\" : {\n+      \"sources\" : [ {\n+        \"name\" : \"OUTPUT\",\n+        \"type\" : \"STREAM\",\n+        \"schema\" : \"`ROWKEY` STRING KEY, `KSQL_COL_0` ARRAY<INTEGER>\",\n+        \"keyFormat\" : {\n+          \"format\" : \"KAFKA\"\n+        },\n+        \"serdeOptions\" : [ ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMjg0Ng=="}, "originalCommit": {"oid": "250f296157119612a22b9ab2d3c68479d7d489b4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk4OTgwNg==", "bodyText": "NON_EMPTY and NON_NULL behave the same way for the Optional<Set<SerdeOption>> type: both output \"serdeOptions\" : [ ] where the optional contains an empty set, and do not output serdeOptions when the optional is empty. See the new unit tests in SourceNodeTest for confirmation.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469989806", "createdAt": "2020-08-13T14:22:50Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/array_-_GENERATE_SERIES/5.5.0_1581572083765/spec.json", "diffHunk": "@@ -73,6 +73,23 @@\n     } ],\n     \"statements\" : [ \"CREATE STREAM TEST (F0 INT, F1 INT) WITH (kafka_topic='test_topic', value_format='JSON');\", \"CREATE STREAM OUTPUT AS SELECT GENERATE_SERIES(F0, F1) FROM TEST;\" ],\n     \"post\" : {\n+      \"sources\" : [ {\n+        \"name\" : \"OUTPUT\",\n+        \"type\" : \"STREAM\",\n+        \"schema\" : \"`ROWKEY` STRING KEY, `KSQL_COL_0` ARRAY<INTEGER>\",\n+        \"keyFormat\" : {\n+          \"format\" : \"KAFKA\"\n+        },\n+        \"serdeOptions\" : [ ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMjg0Ng=="}, "originalCommit": {"oid": "250f296157119612a22b9ab2d3c68479d7d489b4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTgxNg==", "bodyText": "Ah but there is a slight difference: NON_NULL outputs \"serdeOptions\": null if the Optional is empty, whereas NON_EMPTY leaves out serdeOptions entirely (which is maybe what you meant to say). That's definitely good reason for switching back to NON_EMPTY -- will do.", "url": "https://github.com/confluentinc/ksql/pull/5989#discussion_r469995816", "createdAt": "2020-08-13T14:30:32Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/array_-_GENERATE_SERIES/5.5.0_1581572083765/spec.json", "diffHunk": "@@ -73,6 +73,23 @@\n     } ],\n     \"statements\" : [ \"CREATE STREAM TEST (F0 INT, F1 INT) WITH (kafka_topic='test_topic', value_format='JSON');\", \"CREATE STREAM OUTPUT AS SELECT GENERATE_SERIES(F0, F1) FROM TEST;\" ],\n     \"post\" : {\n+      \"sources\" : [ {\n+        \"name\" : \"OUTPUT\",\n+        \"type\" : \"STREAM\",\n+        \"schema\" : \"`ROWKEY` STRING KEY, `KSQL_COL_0` ARRAY<INTEGER>\",\n+        \"keyFormat\" : {\n+          \"format\" : \"KAFKA\"\n+        },\n+        \"serdeOptions\" : [ ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMjg0Ng=="}, "originalCommit": {"oid": "250f296157119612a22b9ab2d3c68479d7d489b4"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2848, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}