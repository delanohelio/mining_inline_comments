{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0OTY2NjY1", "number": 6119, "title": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester", "bodyText": "Description\nfixes #6112 - implements this functionality into the KsqlTester\nTesting done\nadded tests in test.sql\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-08-27T21:41:03Z", "url": "https://github.com/confluentinc/ksql/pull/6119", "merged": true, "mergeCommit": {"oid": "8b9bb77613fb0fa34357c8cca645ee93c8dbc9e7"}, "closed": true, "closedAt": "2020-09-02T20:34:43Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDJddiABqjM3MDE4Mjc5NDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFDKLEgFqTQ4MTMyNDY5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee026996a9f6b8acbbf9d0c1f17a1d17f6e1a2fa", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/ee026996a9f6b8acbbf9d0c1f17a1d17f6e1a2fa", "committedDate": "2020-08-27T21:35:28Z", "message": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester"}, "afterCommit": {"oid": "a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "committedDate": "2020-08-28T00:00:13Z", "message": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODI0MjA2", "url": "https://github.com/confluentinc/ksql/pull/6119#pullrequestreview-478824206", "createdAt": "2020-08-31T17:58:35Z", "commit": {"oid": "a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo1ODozNVrOHKC0rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo1ODozNVrOHKC0rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5NDA2Mg==", "bodyText": "What about other properties that could be specified? For example, timestamp, timestamp format, or wrap single values? If we aren't planning to support validating them in the tester it'd be nice to (1) document this (apologies if I've simply missed it) and (2) fail if they're provided so the user knows they aren't valid rather than thinking they're being checked when they aren't.", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r480294062", "createdAt": "2020-08-31T17:58:35Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -122,12 +129,57 @@ private static void assertContent(\n     }\n   }\n \n-  public static void assertStream(final AssertStream assertStatement) {\n-    throw new UnsupportedOperationException();\n+  public static void assertStream(\n+      final KsqlExecutionContext engine,\n+      final AssertStream assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n+  }\n+\n+  public static void assertTable(\n+      final KsqlExecutionContext engine,\n+      final AssertTable assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n   }\n \n-  public static void assertTable(final AssertTable assertStatement) {\n-    throw new UnsupportedOperationException();\n+  private static void assertSourceMatch(\n+      final KsqlExecutionContext engine,\n+      final CreateSource statement\n+  ) {\n+    final SourceName source = statement.getName();\n+    final DataSource dataSource = engine.getMetaStore().getSource(source);\n+    final LogicalSchema actual = dataSource.getSchema();\n+    final LogicalSchema expected = statement.getElements().toLogicalSchema();\n+    if (!actual.equals(expected)) {\n+      throw new KsqlException(\n+          String.format(\n+              \"Expected schema does not match actual.%n\\tExpected: %s%n\\tActual: %s\",\n+              expected,\n+              actual\n+          )\n+      );\n+    }\n+\n+    final DataSourceType type = dataSource.getDataSourceType();\n+    if (statement instanceof CreateStream && type != DataSourceType.KSTREAM) {\n+      throw new KsqlException(\"Expected source \" + source + \" to be a STREAM but was \" + type);\n+    } else if (statement instanceof CreateTable  && type != DataSourceType.KTABLE) {\n+      throw new KsqlException(\"Expected source \" + source + \" to be a TABLE but was \" + type);\n+    }\n+\n+    final KsqlTopic topic = dataSource.getKsqlTopic();\n+    if (!topic.getKafkaTopicName().equals(statement.getProperties().getKafkaTopic())) {\n+      throw new KsqlException(\"Expected source \" + source + \" to have kafka topic \"\n+          + topic.getKafkaTopicName() + \" but was \" + statement.getProperties().getKafkaTopic());\n+    }\n+\n+    if (!topic.getValueFormat().getFormatInfo().equals(statement.getProperties().getFormatInfo())) {\n+      throw new KsqlException(\"Expected source \" + source + \" to have value format of \"\n+          + topic.getValueFormat().getFormatInfo() + \" but got \"\n+          + statement.getProperties().getFormatInfo()\n+      );\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806"}, "originalPosition": 78}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "committedDate": "2020-08-28T00:00:13Z", "message": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester"}, "afterCommit": {"oid": "13134f43fc15d07f6baea9241183e5a2d3cac7b5", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/13134f43fc15d07f6baea9241183e5a2d3cac7b5", "committedDate": "2020-08-31T23:41:13Z", "message": "chore: add more comparisons"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NzI4Nzgw", "url": "https://github.com/confluentinc/ksql/pull/6119#pullrequestreview-479728780", "createdAt": "2020-09-01T13:15:26Z", "commit": {"oid": "9426ec6d8946e3d548d1f48a73a033c2807d87f5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzoxNToyNlrOHK1vOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzoxOToxOFrOHK15bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODI1MQ==", "bodyText": "As I'm sure you're aware, this is a very fragile pattern. It's highly likely that people will forget to add things to this list when adding new fields to DataSource.\nAs a good example, getSerdeOptions was added recently and must match, but isn't in this list...\nIdeally, what we want is for this to 'just work' when new fields are added, or to fail to compile when new fields / properties are added.  OF course, this is tricky without duplicating code!\nNot sure of the right approach here.  One partial solution would be to have the code fail if it encounters a WITH clause property for which it doesn't have a rule in the above list.  You can probably achieve the same, but better, with a meta test in AssertExecutorTest that ensures there is a rule for each property defined in the CreateConfigs and CreateAsConfigs classes.", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481128251", "createdAt": "2020-09-01T13:15:26Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -47,6 +54,44 @@\n  */\n public final class AssertExecutor {\n \n+\n+  private static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n+      .add(\n+          new SourceProperty(\n+              DataSource::getSchema,\n+              cs -> cs.getElements().toLogicalSchema(),\n+              \"schema\"\n+      )).add(\n+          new SourceProperty(\n+              DataSource::getDataSourceType,\n+              cs -> cs instanceof CreateTable ? DataSourceType.KTABLE : DataSourceType.KSTREAM,\n+              \"type\"\n+      )).add(\n+          new SourceProperty(\n+              DataSource::getKafkaTopicName,\n+              cs -> cs.getProperties().getKafkaTopic(),\n+              \"kafka topic\"\n+      )).add(\n+          new SourceProperty(\n+              ds -> ds.getKsqlTopic().getValueFormat().getFormatInfo().getFormat(),\n+              cs -> cs.getProperties().getValueFormat().name(),\n+              \"value format\"\n+          )).add(new SourceProperty(\n+              DataSource::getSerdeOptions,\n+              cs -> cs.getProperties().getSerdeOptions(),\n+              \"serde options\"\n+      )).add(\n+          new SourceProperty(\n+              ds -> ds.getTimestampColumn().map(TimestampColumn::getColumn),\n+              cs -> cs.getProperties().getTimestampColumnName(),\n+              \"timestamp column\"\n+      )).add(\n+          new SourceProperty(\n+              ds -> ds.getTimestampColumn().flatMap(TimestampColumn::getFormat),\n+              cs -> cs.getProperties().getTimestampFormat(),\n+              \"timestamp format\"\n+      )).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9426ec6d8946e3d548d1f48a73a033c2807d87f5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODg4MQ==", "bodyText": "Again with the KsqlException ;).   How about AssertError?", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481128881", "createdAt": "2020-09-01T13:16:22Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -172,12 +217,61 @@ private static TabularRow fromGenericRow(\n     return TabularRow.createRow(80, contents, false, 0);\n   }\n \n-  public static void assertStream(final AssertStream assertStatement) {\n-    throw new UnsupportedOperationException();\n+  public static void assertStream(\n+      final KsqlExecutionContext engine,\n+      final AssertStream assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n+  }\n+\n+  public static void assertTable(\n+      final KsqlExecutionContext engine,\n+      final AssertTable assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n   }\n \n-  public static void assertTable(final AssertTable assertStatement) {\n-    throw new UnsupportedOperationException();\n+\n+  private static void assertSourceMatch(\n+      final KsqlExecutionContext engine,\n+      final CreateSource statement\n+  ) {\n+    final SourceName source = statement.getName();\n+    final DataSource dataSource = engine.getMetaStore().getSource(source);\n+\n+    MUST_MATCH.forEach(prop -> prop.compare(dataSource, statement));\n+  }\n+\n+  private static final class SourceProperty {\n+    final Function<DataSource, Object> extractSource;\n+    final Function<CreateSource, Object> extractStatement;\n+    final String propertyName;\n+\n+    private SourceProperty(\n+        final Function<DataSource, Object> extractSource,\n+        final Function<CreateSource, Object> extractStatement,\n+        final String propertyName\n+    ) {\n+      this.extractSource = extractSource;\n+      this.extractStatement = extractStatement;\n+      this.propertyName = propertyName;\n+    }\n+\n+    private void compare(final DataSource dataSource, final CreateSource statement) {\n+      final Object expected = extractStatement.apply(statement);\n+      final Object actual = extractSource.apply(dataSource);\n+      if (!actual.equals(expected)) {\n+        throw new KsqlException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9426ec6d8946e3d548d1f48a73a033c2807d87f5"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEzMDg2Mg==", "bodyText": "Hummm.... if the assert here needs to have the default value for wrap_single_value, then what happens when we add a new property to the WITH clause?  Will all our own and users test with asserts now fail?  This isn't ideal...", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481130862", "createdAt": "2020-09-01T13:19:18Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/resources/sql-tests/test.sql", "diffHunk": "@@ -104,3 +108,91 @@ ASSERT VALUES bar (rowtime, id, col1) VALUES (2, 2, 2);\n --@expected.message: Exception while preparing statement: FOO does not exist.\n ----------------------------------------------------------------------------------------------------\n CREATE STREAM bar AS SELECT * FROM foo;\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong schema should fail\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected schema does not match actual\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT KEY, col1 VARCHAR) WITH (kafka_topic='BAR', value_format='JSON');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong schema (key) should fail\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected schema does not match actual\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT, col1 VARCHAR) WITH (kafka_topic='BAR', value_format='JSON');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong type should fail\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected type does not match actual for source BAR\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar AS SELECT * FROM foo;\n+\n+ASSERT TABLE bar (id INT PRIMARY KEY, col1 INT) WITH (kafka_topic='BAR', value_format='JSON');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong topic should fail\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected kafka topic does not match actual for source BAR\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT KEY, col1 INT) WITH (kafka_topic='BAZ', value_format='JSON');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong topic format should fail\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected value format does not match actual for source BAR\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT KEY, col1 INT) WITH (kafka_topic='BAR', value_format='AVRO');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong timestamp column\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected timestamp column does not match actual for source BAR.\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 BIGINT, col2 BIGINT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar WITH(timestamp='col1') AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT KEY, col1 BIGINT, col2 BIGINT) WITH (kafka_topic='BAR', value_format='JSON', timestamp='col2');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong timestamp format\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected timestamp format does not match actual for source BAR.\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 VARCHAR) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar WITH(timestamp='col1', timestamp_format='yyyy') AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT KEY, col1 VARCHAR) WITH (kafka_topic='BAR', value_format='JSON', timestamp='col1', timestamp_format='mm');\n+\n+----------------------------------------------------------------------------------------------------\n+--@test: assert stream with wrong topic should fail\n+\n+--@expected.error: io.confluent.ksql.util.KsqlException\n+--@expected.message: Expected serde options does not match actual for source BAR\n+----------------------------------------------------------------------------------------------------\n+CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='foo', value_format='JSON');\n+CREATE STREAM bar AS SELECT * FROM foo;\n+\n+ASSERT STREAM bar (id INT KEY, col1 INT) WITH (kafka_topic='BAR', value_format='JSON', wrap_single_value=false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9426ec6d8946e3d548d1f48a73a033c2807d87f5"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5efe108aea3428db5ff804edf595cfd42350333", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/c5efe108aea3428db5ff804edf595cfd42350333", "committedDate": "2020-09-02T15:49:50Z", "message": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "333d763ccf3efc2b4d6cd69846f8860c39495eda", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/333d763ccf3efc2b4d6cd69846f8860c39495eda", "committedDate": "2020-09-02T15:49:50Z", "message": "chore: add more comparisons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a9c66f53369529bf78c2ea6f5e35e87b8b63ffa", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/3a9c66f53369529bf78c2ea6f5e35e87b8b63ffa", "committedDate": "2020-09-02T15:49:50Z", "message": "chore: checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDE3NDY5", "url": "https://github.com/confluentinc/ksql/pull/6119#pullrequestreview-481017469", "createdAt": "2020-09-02T16:55:42Z", "commit": {"oid": "9426ec6d8946e3d548d1f48a73a033c2807d87f5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cfdadecee046db4d47a752f79bde7f92997aa4e", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/8cfdadecee046db4d47a752f79bde7f92997aa4e", "committedDate": "2020-09-02T19:06:21Z", "message": "chore: add metatest to assert exec and change error type to AssertionError"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9426ec6d8946e3d548d1f48a73a033c2807d87f5", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/9426ec6d8946e3d548d1f48a73a033c2807d87f5", "committedDate": "2020-09-01T03:44:59Z", "message": "chore: checkstyle"}, "afterCommit": {"oid": "8cfdadecee046db4d47a752f79bde7f92997aa4e", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/8cfdadecee046db4d47a752f79bde7f92997aa4e", "committedDate": "2020-09-02T19:06:21Z", "message": "chore: add metatest to assert exec and change error type to AssertionError"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMzI0Njk5", "url": "https://github.com/confluentinc/ksql/pull/6119#pullrequestreview-481324699", "createdAt": "2020-09-02T21:47:40Z", "commit": {"oid": "8cfdadecee046db4d47a752f79bde7f92997aa4e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTo0Nzo0MFrOHMJ2uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTo0Nzo0MFrOHMJ2uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUwNjQyNw==", "bodyText": "To get the full list you need to use CreateConfigs.CONFIG_DEF and CreateAsConfigs.CONFIG_DEF.  This is currently only testing configs that are common to both.\nIf someone adds a new one to only one, it will be missed by this test.", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r482506427", "createdAt": "2020-09-02T21:47:40Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/AssertExecutorMetaTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package io.confluent.ksql.test.driver;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+\n+/**\n+ * Most test coverage for the AssertExecutor is in the sql-tests/test.sql file\n+ * which is run through the KsqlTesterTest tool. This class is here to ensure\n+ * that the class evolves properly.\n+ */\n+public class AssertExecutorMetaTest {\n+\n+  /**\n+   * These are excluded from coverage\n+   */\n+  private final Set<String> excluded = ImmutableSet.of(\n+      CommonCreateConfigs.SOURCE_NUMBER_OF_PARTITIONS, // testing tool does not support partitions\n+      CommonCreateConfigs.SOURCE_NUMBER_OF_REPLICAS    // testing tool does not support replicas\n+  );\n+\n+  @Test\n+  public void shouldCoverAllWithClauses() {\n+    // Given:\n+    final ConfigDef def = new ConfigDef();\n+    CommonCreateConfigs.addToConfigDef(def, true, true);\n+    final Set<String> allValidProps = def.names();\n+\n+    // When:\n+    final Set<String> coverage = AssertExecutor.MUST_MATCH\n+        .stream()\n+        .map(sp -> sp.withClauseName)\n+        .flatMap(Arrays::stream)\n+        .collect(Collectors.toSet());\n+\n+    // Then:\n+    assertThat(Sets.difference(allValidProps, coverage), Matchers.is(excluded));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfdadecee046db4d47a752f79bde7f92997aa4e"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4742, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}