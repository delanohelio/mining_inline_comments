{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2OTkzMTMy", "number": 6474, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToxMTo1MVrOEwjunw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToxNTo1OFrOEwjxng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzUyNDc5OnYy", "diffSide": "RIGHT", "path": "ksqldb-parser/src/main/antlr4/io/confluent/ksql/parser/SqlBase.g4", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToxMTo1MVrOHmNE-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTo1Mzo0OFrOHmNvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyMjIwMQ==", "bodyText": "is this used anywhere for this PR?", "url": "https://github.com/confluentinc/ksql/pull/6474#discussion_r509822201", "createdAt": "2020-10-22T01:11:51Z", "author": {"login": "agavra"}, "path": "ksqldb-parser/src/main/antlr4/io/confluent/ksql/parser/SqlBase.g4", "diffHunk": "@@ -566,6 +581,10 @@ TIMESTAMP_WITH_TIME_ZONE\n     : 'TIMESTAMP' WS 'WITH' WS 'TIME' WS 'ZONE'\n     ;\n \n+VARIABLE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177563a9c7f591deae8678f1ade747f59a3e2b62"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMjk5Nw==", "bodyText": "No in this PR. I used it initially, but after splitting the PR I left it by accident.\nI will leave it here. The next PR will use it anyway, so doesn't hurt.", "url": "https://github.com/confluentinc/ksql/pull/6474#discussion_r509832997", "createdAt": "2020-10-22T01:53:48Z", "author": {"login": "spena"}, "path": "ksqldb-parser/src/main/antlr4/io/confluent/ksql/parser/SqlBase.g4", "diffHunk": "@@ -566,6 +581,10 @@ TIMESTAMP_WITH_TIME_ZONE\n     : 'TIMESTAMP' WS 'WITH' WS 'TIME' WS 'ZONE'\n     ;\n \n+VARIABLE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyMjIwMQ=="}, "originalCommit": {"oid": "177563a9c7f591deae8678f1ade747f59a3e2b62"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzUyOTk0OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/ListVariablesExecutorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToxNDo0OFrOHmNH2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjowMDozMFrOHmN16A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyMjkzOA==", "bodyText": "do you need to actually run through configure etc... or can you mock out the configured statements?", "url": "https://github.com/confluentinc/ksql/pull/6474#discussion_r509822938", "createdAt": "2020-10-22T01:14:48Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/ListVariablesExecutorTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.execution;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+import io.confluent.ksql.rest.SessionProperties;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.VariablesList;\n+import io.confluent.ksql.rest.server.TemporaryEngine;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class ListVariablesExecutorTest {\n+  @Rule\n+  public final TemporaryEngine engine = new TemporaryEngine();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177563a9c7f591deae8678f1ade747f59a3e2b62"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzNDcyOA==", "bodyText": "I copied most of the code from ListTopicsExecutorTest and ListPropertiesExecutorTest. But you're right, we don't need this engine. I'll change it with a mock.", "url": "https://github.com/confluentinc/ksql/pull/6474#discussion_r509834728", "createdAt": "2020-10-22T02:00:30Z", "author": {"login": "spena"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/ListVariablesExecutorTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.execution;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+import io.confluent.ksql.rest.SessionProperties;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.VariablesList;\n+import io.confluent.ksql.rest.server.TemporaryEngine;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class ListVariablesExecutorTest {\n+  @Rule\n+  public final TemporaryEngine engine = new TemporaryEngine();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyMjkzOA=="}, "originalCommit": {"oid": "177563a9c7f591deae8678f1ade747f59a3e2b62"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzUzMjQ2OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/VariableExecutorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToxNTo1OFrOHmNJJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjowNjozMVrOHmN8CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyMzI2OQ==", "bodyText": "should we add a test on adding duplicates? we should also check to make sure that case insensitive duplicates are stilled rejected", "url": "https://github.com/confluentinc/ksql/pull/6474#discussion_r509823269", "createdAt": "2020-10-22T01:15:58Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/VariableExecutorTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.execution;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.mock;\n+\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.rest.SessionProperties;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.WarningEntity;\n+import io.confluent.ksql.rest.server.TemporaryEngine;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class VariableExecutorTest {\n+  @Rule\n+  public final TemporaryEngine engine = new TemporaryEngine();\n+\n+  private SessionProperties sessionProperties;\n+\n+  @Before\n+  public void setup() {\n+    sessionProperties = new SessionProperties(\n+        new HashMap<>(), mock(KsqlHostInfo.class), mock(URL.class), false);\n+  }\n+\n+  private void executeDefineVariable(final String sql) {\n+    final Optional<KsqlEntity> response = CustomExecutors.DEFINE_VARIABLE.execute(\n+        engine.configure(sql),\n+        sessionProperties,\n+        engine.getEngine(),\n+        engine.getServiceContext()\n+    );\n+    assertThat(response, is(Optional.empty()));\n+  }\n+\n+  private Optional<KsqlEntity> executeUndefineVariable(final String sql) {\n+    return CustomExecutors.UNDEFINE_VARIABLE.execute(\n+        engine.configure(sql),\n+        sessionProperties,\n+        engine.getEngine(),\n+        engine.getServiceContext()\n+    );\n+  }\n+\n+  @Test\n+  public void shouldSetVariables() {\n+    // When:\n+    executeDefineVariable(\"DEFINE var1 = 'John Peter';\");\n+    executeDefineVariable(\"DEFINE var2 = '''John Peter''';\");\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.size(), is(2));\n+    assertThat(variablesMap, hasEntry(\"var1\", \"John Peter\"));\n+    assertThat(variablesMap, hasEntry(\"var2\", \"'John Peter'\"));\n+  }\n+\n+  @Test\n+  public void shouldSetCaseInsensitiveVariables() {\n+    // When:\n+    executeDefineVariable(\"DEFINE A = 'val1';\");\n+    executeDefineVariable(\"DEFINE b = 'val2';\");\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.containsKey(\"a\"), is(true));\n+    assertThat(variablesMap.get(\"a\"), is(\"val1\"));\n+    assertThat(variablesMap.containsKey(\"A\"), is(true));\n+    assertThat(variablesMap.get(\"A\"), is(\"val1\"));\n+    assertThat(variablesMap.containsKey(\"b\"), is(true));\n+    assertThat(variablesMap.get(\"b\"), is(\"val2\"));\n+    assertThat(variablesMap.containsKey(\"B\"), is(true));\n+    assertThat(variablesMap.get(\"B\"), is(\"val2\"));\n+  }\n+\n+  @Test\n+  public void shouldUnsetVariables() {\n+    // Given:\n+    sessionProperties.setVariable(\"var1\", \"1\");\n+    sessionProperties.setVariable(\"var2\", \"2\");\n+\n+    // When:\n+    final Optional<KsqlEntity> response = executeUndefineVariable(\"UNDEFINE var1;\");\n+    assertThat(response, is(Optional.empty()));\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.size(), is(1));\n+    assertThat(variablesMap, hasEntry(\"var2\", \"2\"));\n+  }\n+\n+  @Test\n+  public void shouldUnsetCaseInsensitiveVariables() {\n+    // Given:\n+    sessionProperties.setVariable(\"VAR1\", \"1\");\n+\n+    // When:\n+    final Optional<KsqlEntity> response = executeUndefineVariable(\"UNDEFINE var1;\");\n+    assertThat(response, is(Optional.empty()));\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.size(), is(0));\n+  }\n+\n+  @Test\n+  public void shouldReturnWarningWhenUndefineAnUnknownVariable() {\n+    // When:\n+    final KsqlEntity response = executeUndefineVariable(\"UNDEFINE var1;\").get();\n+\n+    // Then:\n+    assertThat(((WarningEntity)response).getMessage(),\n+        containsString(\"Cannot undefine variable 'var1' which was never defined\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowOnInvalidValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177563a9c7f591deae8678f1ade747f59a3e2b62"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzNjI5Ng==", "bodyText": "Variables will be overridden (no rejected) if an existing case insensitive variable exists. I'll add a test case that verifies that.\nIt will allow us to do this:\nDEFINE var1 = '1';\nDEFINE VAR1 = '2';\nDEFINE vAr1 = '3'; // latest update", "url": "https://github.com/confluentinc/ksql/pull/6474#discussion_r509836296", "createdAt": "2020-10-22T02:06:31Z", "author": {"login": "spena"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/VariableExecutorTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.execution;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.mock;\n+\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.rest.SessionProperties;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.WarningEntity;\n+import io.confluent.ksql.rest.server.TemporaryEngine;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class VariableExecutorTest {\n+  @Rule\n+  public final TemporaryEngine engine = new TemporaryEngine();\n+\n+  private SessionProperties sessionProperties;\n+\n+  @Before\n+  public void setup() {\n+    sessionProperties = new SessionProperties(\n+        new HashMap<>(), mock(KsqlHostInfo.class), mock(URL.class), false);\n+  }\n+\n+  private void executeDefineVariable(final String sql) {\n+    final Optional<KsqlEntity> response = CustomExecutors.DEFINE_VARIABLE.execute(\n+        engine.configure(sql),\n+        sessionProperties,\n+        engine.getEngine(),\n+        engine.getServiceContext()\n+    );\n+    assertThat(response, is(Optional.empty()));\n+  }\n+\n+  private Optional<KsqlEntity> executeUndefineVariable(final String sql) {\n+    return CustomExecutors.UNDEFINE_VARIABLE.execute(\n+        engine.configure(sql),\n+        sessionProperties,\n+        engine.getEngine(),\n+        engine.getServiceContext()\n+    );\n+  }\n+\n+  @Test\n+  public void shouldSetVariables() {\n+    // When:\n+    executeDefineVariable(\"DEFINE var1 = 'John Peter';\");\n+    executeDefineVariable(\"DEFINE var2 = '''John Peter''';\");\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.size(), is(2));\n+    assertThat(variablesMap, hasEntry(\"var1\", \"John Peter\"));\n+    assertThat(variablesMap, hasEntry(\"var2\", \"'John Peter'\"));\n+  }\n+\n+  @Test\n+  public void shouldSetCaseInsensitiveVariables() {\n+    // When:\n+    executeDefineVariable(\"DEFINE A = 'val1';\");\n+    executeDefineVariable(\"DEFINE b = 'val2';\");\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.containsKey(\"a\"), is(true));\n+    assertThat(variablesMap.get(\"a\"), is(\"val1\"));\n+    assertThat(variablesMap.containsKey(\"A\"), is(true));\n+    assertThat(variablesMap.get(\"A\"), is(\"val1\"));\n+    assertThat(variablesMap.containsKey(\"b\"), is(true));\n+    assertThat(variablesMap.get(\"b\"), is(\"val2\"));\n+    assertThat(variablesMap.containsKey(\"B\"), is(true));\n+    assertThat(variablesMap.get(\"B\"), is(\"val2\"));\n+  }\n+\n+  @Test\n+  public void shouldUnsetVariables() {\n+    // Given:\n+    sessionProperties.setVariable(\"var1\", \"1\");\n+    sessionProperties.setVariable(\"var2\", \"2\");\n+\n+    // When:\n+    final Optional<KsqlEntity> response = executeUndefineVariable(\"UNDEFINE var1;\");\n+    assertThat(response, is(Optional.empty()));\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.size(), is(1));\n+    assertThat(variablesMap, hasEntry(\"var2\", \"2\"));\n+  }\n+\n+  @Test\n+  public void shouldUnsetCaseInsensitiveVariables() {\n+    // Given:\n+    sessionProperties.setVariable(\"VAR1\", \"1\");\n+\n+    // When:\n+    final Optional<KsqlEntity> response = executeUndefineVariable(\"UNDEFINE var1;\");\n+    assertThat(response, is(Optional.empty()));\n+\n+    // Then:\n+    final Map<String, String> variablesMap = sessionProperties.getSessionVariables();\n+    assertThat(variablesMap.size(), is(0));\n+  }\n+\n+  @Test\n+  public void shouldReturnWarningWhenUndefineAnUnknownVariable() {\n+    // When:\n+    final KsqlEntity response = executeUndefineVariable(\"UNDEFINE var1;\").get();\n+\n+    // Then:\n+    assertThat(((WarningEntity)response).getMessage(),\n+        containsString(\"Cannot undefine variable 'var1' which was never defined\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowOnInvalidValues() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyMzI2OQ=="}, "originalCommit": {"oid": "177563a9c7f591deae8678f1ade747f59a3e2b62"}, "originalPosition": 148}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2544, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}