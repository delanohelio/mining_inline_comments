{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3NTMxNTA2", "number": 6764, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowNDowNVrOFLEQPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjoxOTo0N1rOFLEg5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTQ4MzUwOnYy", "diffSide": "RIGHT", "path": "docs/concepts/streams.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowNDowNVrOIOCyrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowNDowNVrOIOCyrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NjcxNw==", "bodyText": "Have we standardized on \"row\", instead of \"message\", \"record\", or \"event\"?", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551596717", "createdAt": "2021-01-04T22:04:05Z", "author": {"login": "JimGalasyn"}, "path": "docs/concepts/streams.md", "diffHunk": "@@ -0,0 +1,5 @@\n+A stream is a partitioned, immutable, append-only collection that represents a series of historical facts. For example, the rows of a stream could model a sequence of financial transactions, like \"Alice sent $100 to Bob\", followed by \"Charlie sent $50 to Bob\".\n+\n+Once a row is inserted into a stream, it can never change. New rows can be appended at the end of the stream, but existing rows can never be updated or deleted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTQ5MjE2OnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/update-a-running-persistent-query.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowNzowMlrOIOC3sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowNzowMlrOIOC3sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5ODAwMA==", "bodyText": "YAML front matter?", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551598000", "createdAt": "2021-01-04T22:07:02Z", "author": {"login": "JimGalasyn"}, "path": "docs/how-to-guides/update-a-running-persistent-query.md", "diffHunk": "@@ -1,37 +1,48 @@\n----\n-layout: page\n-title: Evolving Production Queries\n-tagline: Replacing existing queries\n-description: Learn how to manage your production deployments over time\n-keywords: ksqldb, upgrade, schema evolution\n----\n-\n-Production deployments of databases are never static; they evolve as application\n-and business requirements change. To that end, all popular data stores have ways\n-of managing and manipulating existing data. For stream processing applications,\n-you may want to modify your application because of:\n-\n-- Business Requirements: requirements simply change over time\n-- Schema Evolution: the incoming data or required output has been modified\n-- Optimizations: the same application can be executed more efficiently (either\n-  by user or engine)\n-\n-ksqlDB provides various mechanisms to interact with a query that's running in\n-production.\n-\n-1. *In-place upgrades*: users modify the behavior of a query, resuming from a\n+# How to update a running persistent query", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTQ5NzIxOnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/update-a-running-persistent-query.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowOTowMlrOIOC6vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowOTowMlrOIOC6vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5ODc4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            it's not always possible to do that.\n          \n          \n            \n            this isn't always possible.", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551598783", "createdAt": "2021-01-04T22:09:02Z", "author": {"login": "JimGalasyn"}, "path": "docs/how-to-guides/update-a-running-persistent-query.md", "diffHunk": "@@ -1,37 +1,48 @@\n----\n-layout: page\n-title: Evolving Production Queries\n-tagline: Replacing existing queries\n-description: Learn how to manage your production deployments over time\n-keywords: ksqldb, upgrade, schema evolution\n----\n-\n-Production deployments of databases are never static; they evolve as application\n-and business requirements change. To that end, all popular data stores have ways\n-of managing and manipulating existing data. For stream processing applications,\n-you may want to modify your application because of:\n-\n-- Business Requirements: requirements simply change over time\n-- Schema Evolution: the incoming data or required output has been modified\n-- Optimizations: the same application can be executed more efficiently (either\n-  by user or engine)\n-\n-ksqlDB provides various mechanisms to interact with a query that's running in\n-production.\n-\n-1. *In-place upgrades*: users modify the behavior of a query, resuming from a\n+# How to update a running persistent query\n+\n+## Context\n+\n+You have a persistent query that is running and processing rows, and you want to change\n+it to do something different. You want the new version of the query to start processing rows\n+where the old version left off. This is generally known as *upgrading* a query.\n+\n+## In action\n+\n+```sql\n+-- Before\n+CREATE STREAM valid_purchases AS\n+  SELECT *\n+  FROM purchases\n+  WHERE cost > 0.00 AND quantity > 0;\n+\n+-- After\n+CREATE OR REPLACE STREAM valid_purchases AS\n+  SELECT *\n+  FROM purchases\n+  WHERE quantity > 0;\n+```\n+\n+## Upgrade types\n+\n+ksqlDB provides two mechanisms to change a query that is already running:\n+\n+1. *In-place upgrades*: you modify the behavior of a query, and it resumes from a\n    previously committed offset. The syntax that ksqlDB uses to indicate an\n    in-place upgrade is `CREATE OR REPLACE`.\n-1. *Replacing upgrades*: these upgrades require you to tear down existing\n-   queries, and start a new one from either `earliest` or `latest` offsets.\n+1. *Replacing upgrades*: you tear down an existing query,\n+   and start a new one from either `earliest` or `latest` offsets.\n    To accomplish this, users you first issue a `TERMINATE <query_id>;` and a\n    `DROP <source>` before creating the query again.\n \n ## Understanding upgrades\n \n-To better understand the different types of upgrades that exist on continuous\n-queries, we define a taxonomy on query upgrades as any combination of three\n-types of characteristics: _source query_, _upgrade_ and (optionally) _environment_.\n+Obviously, it would be preferable to always perform an in-place upgrade\n+when you change a query. But because of how streaming programs are constructed,\n+it's not always possible to do that.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTQ5ODQxOnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/update-a-running-persistent-query.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowOToyOVrOIOC7dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowOToyOVrOIOC7dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5ODk2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            queries, here is a taxonomy usin gthe combination of three\n          \n          \n            \n            queries, here's a taxonomy using the combination of three", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551598964", "createdAt": "2021-01-04T22:09:29Z", "author": {"login": "JimGalasyn"}, "path": "docs/how-to-guides/update-a-running-persistent-query.md", "diffHunk": "@@ -1,37 +1,48 @@\n----\n-layout: page\n-title: Evolving Production Queries\n-tagline: Replacing existing queries\n-description: Learn how to manage your production deployments over time\n-keywords: ksqldb, upgrade, schema evolution\n----\n-\n-Production deployments of databases are never static; they evolve as application\n-and business requirements change. To that end, all popular data stores have ways\n-of managing and manipulating existing data. For stream processing applications,\n-you may want to modify your application because of:\n-\n-- Business Requirements: requirements simply change over time\n-- Schema Evolution: the incoming data or required output has been modified\n-- Optimizations: the same application can be executed more efficiently (either\n-  by user or engine)\n-\n-ksqlDB provides various mechanisms to interact with a query that's running in\n-production.\n-\n-1. *In-place upgrades*: users modify the behavior of a query, resuming from a\n+# How to update a running persistent query\n+\n+## Context\n+\n+You have a persistent query that is running and processing rows, and you want to change\n+it to do something different. You want the new version of the query to start processing rows\n+where the old version left off. This is generally known as *upgrading* a query.\n+\n+## In action\n+\n+```sql\n+-- Before\n+CREATE STREAM valid_purchases AS\n+  SELECT *\n+  FROM purchases\n+  WHERE cost > 0.00 AND quantity > 0;\n+\n+-- After\n+CREATE OR REPLACE STREAM valid_purchases AS\n+  SELECT *\n+  FROM purchases\n+  WHERE quantity > 0;\n+```\n+\n+## Upgrade types\n+\n+ksqlDB provides two mechanisms to change a query that is already running:\n+\n+1. *In-place upgrades*: you modify the behavior of a query, and it resumes from a\n    previously committed offset. The syntax that ksqlDB uses to indicate an\n    in-place upgrade is `CREATE OR REPLACE`.\n-1. *Replacing upgrades*: these upgrades require you to tear down existing\n-   queries, and start a new one from either `earliest` or `latest` offsets.\n+1. *Replacing upgrades*: you tear down an existing query,\n+   and start a new one from either `earliest` or `latest` offsets.\n    To accomplish this, users you first issue a `TERMINATE <query_id>;` and a\n    `DROP <source>` before creating the query again.\n \n ## Understanding upgrades\n \n-To better understand the different types of upgrades that exist on continuous\n-queries, we define a taxonomy on query upgrades as any combination of three\n-types of characteristics: _source query_, _upgrade_ and (optionally) _environment_.\n+Obviously, it would be preferable to always perform an in-place upgrade\n+when you change a query. But because of how streaming programs are constructed,\n+it's not always possible to do that.\n+\n+To better understand the different types of upgrades that are allowed on persistent\n+queries, here is a taxonomy usin gthe combination of three", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTQ5OTMwOnYy", "diffSide": "RIGHT", "path": "docs/how-to-guides/update-a-running-persistent-query.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowOTo1MVrOIOC8Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjowOTo1MVrOIOC8Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5OTEwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Any in place upgrades on windowed or joined sources, as well as upgrades on\n          \n          \n            \n            Any in-place upgrades on windowed or joined sources, as well as upgrades on", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551599107", "createdAt": "2021-01-04T22:09:51Z", "author": {"login": "JimGalasyn"}, "path": "docs/how-to-guides/update-a-running-persistent-query.md", "diffHunk": "@@ -62,28 +73,40 @@ in-place upgrade.\n Any in place upgrades on windowed or joined sources, as well as upgrades on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTUwMjQxOnYy", "diffSide": "RIGHT", "path": "docs/operate-and-deploy/how-it-works.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjoxMTowNlrOIOC95g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjoxMTowNlrOIOC95g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5OTU5MA==", "bodyText": "No YAML?", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551599590", "createdAt": "2021-01-04T22:11:06Z", "author": {"login": "JimGalasyn"}, "path": "docs/operate-and-deploy/how-it-works.md", "diffHunk": "@@ -1,10 +1,3 @@\n----\n-layout: page\n-title: ksqlDB Architecture\n-tagline: Internals of ksqlDB\n-description: Quick tour under the hood of the ksqlDB engine.\n----\n-\n You can use ksqlDB to build event streaming applications from {{ site.aktm }}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTUyNjE0OnYy", "diffSide": "RIGHT", "path": "docs/concepts/queries.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjoxOTo0OFrOIODL-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjoxOTo0OFrOIODL-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwMzE5Mg==", "bodyText": "The build is flagging two broken links:\n\nAs a dual to the push query example, a pull query for a geographic...\nFor asynchronous application flows, see\nPush Query.", "url": "https://github.com/confluentinc/ksql/pull/6764#discussion_r551603192", "createdAt": "2021-01-04T22:19:48Z", "author": {"login": "JimGalasyn"}, "path": "docs/concepts/queries.md", "diffHunk": "@@ -0,0 +1,92 @@\n+There are three kinds of queries in ksqlDB: persistent, push, and pull.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54cbee0131db7737f67c8035187d86274c36b0e4"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2365, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}