{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4NzE1Njg0", "number": 4404, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMTo1Mzo1N1rODbu4vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDozNjozNFrODbxBsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNDA2MzMzOnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMTo1Mzo1N1rOFjY24Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMTo1Mzo1N1rOFjY24Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1MTc0NQ==", "bodyText": "Bit hacky, but will work for now.", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372651745", "createdAt": "2020-01-29T21:53:57Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -647,22 +657,27 @@ private static void validateProjection(\n   private static LogicalSchema selectOutputSchema(\n       final Result input,\n       final KsqlExecutionContext executionContext,\n-      final ImmutableAnalysis analysis\n+      final ImmutableAnalysis analysis,\n+      final Optional<WindowType> windowType\n   ) {\n     final Builder schemaBuilder = LogicalSchema.builder()\n         .noImplicitColumns();\n \n-    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(\n-        input.schema,\n-        executionContext.getMetaStore(),\n-        false\n-    );\n+    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n+    final LogicalSchema schema = input.schema\n+        .withMetaAndKeyColsInValue(windowType.isPresent());\n+\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(schema, executionContext.getMetaStore());\n \n     for (int idx = 0; idx < analysis.getSelectExpressions().size(); idx++) {\n       final SelectExpression select = analysis.getSelectExpressions().get(idx);\n       final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n \n-      if (input.schema.isKeyColumn(select.getAlias())) {\n+      if (input.schema.isKeyColumn(select.getAlias())\n+          || select.getAlias().equals(SchemaUtil.WINDOWSTART_NAME)\n+          || select.getAlias().equals(SchemaUtil.WINDOWEND_NAME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22239bbb730084ab53d8dd5feead9d45eacccd99"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNDQxMDM0OnYy", "diffSide": "RIGHT", "path": "ksql-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDozNDowN1rOFjcLyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMDoyMToyN1rOFjl7Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNjI0OA==", "bodyText": "please make sure to specify 'UTC' as the time zone :) it passes on your local machine, it passes on jenkins, but it breaks on our plebeian PTC machines.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"SELECT ROWKEY, TIMESTAMPTOSTRING(WINDOWSTART, 'yyyy-MM-dd HH:mm:ss Z') AS WSTART, TIMESTAMPTOSTRING(WINDOWEND, 'yyyy-MM-dd HH:mm:ss Z') AS WEND, COUNT FROM AGGREGATE WHERE ROWKEY='10';\"\n          \n          \n            \n                    \"SELECT ROWKEY, TIMESTAMPTOSTRING(WINDOWSTART, 'yyyy-MM-dd HH:mm:ss Z', 'UTC') AS WSTART, TIMESTAMPTOSTRING(WINDOWEND, 'yyyy-MM-dd HH:mm:ss Z', 'UTC') AS WEND, COUNT FROM AGGREGATE WHERE ROWKEY='10';\"", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372706248", "createdAt": "2020-01-30T00:34:07Z", "author": {"login": "agavra"}, "path": "ksql-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -955,6 +955,25 @@\n         \"message\": \"Column 'AGGREGATE.WINDOWSTART' cannot be resolved\",\n         \"status\": 400\n       }\n+    },\n+    {\n+      \"name\": \"window bounds in projection UDF\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT COUNT(1) AS COUNT FROM INPUT WINDOW TUMBLING(SIZE 1 SECOND) GROUP BY ROWKEY;\",\n+        \"SELECT ROWKEY, TIMESTAMPTOSTRING(WINDOWSTART, 'yyyy-MM-dd HH:mm:ss Z') AS WSTART, TIMESTAMPTOSTRING(WINDOWEND, 'yyyy-MM-dd HH:mm:ss Z') AS WEND, COUNT FROM AGGREGATE WHERE ROWKEY='10';\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22239bbb730084ab53d8dd5feead9d45eacccd99"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg2NTg2Ng==", "bodyText": "Good to know - will pick up in next PR.", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372865866", "createdAt": "2020-01-30T10:21:27Z", "author": {"login": "big-andy-coates"}, "path": "ksql-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -955,6 +955,25 @@\n         \"message\": \"Column 'AGGREGATE.WINDOWSTART' cannot be resolved\",\n         \"status\": 400\n       }\n+    },\n+    {\n+      \"name\": \"window bounds in projection UDF\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT COUNT(1) AS COUNT FROM INPUT WINDOW TUMBLING(SIZE 1 SECOND) GROUP BY ROWKEY;\",\n+        \"SELECT ROWKEY, TIMESTAMPTOSTRING(WINDOWSTART, 'yyyy-MM-dd HH:mm:ss Z') AS WSTART, TIMESTAMPTOSTRING(WINDOWEND, 'yyyy-MM-dd HH:mm:ss Z') AS WEND, COUNT FROM AGGREGATE WHERE ROWKEY='10';\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNjI0OA=="}, "originalCommit": {"oid": "22239bbb730084ab53d8dd5feead9d45eacccd99"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNDQxMzk0OnYy", "diffSide": "RIGHT", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDozNjozNVrOFjcOKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMDoyMTowNlrOFjl6eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNjg1OQ==", "bodyText": "just sanity checking, the reason we're adding this at 1 and 2 is so that they come after the ROWTIME but before the ROWKEY? Might help to have constants for these numbers. Also might help to add the key fields after the start/end. Super nits.", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372706859", "createdAt": "2020-01-30T00:36:35Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -559,37 +563,43 @@ private static boolean isSelectStar(final Select select) {\n       final KsqlExecutionContext executionContext,\n       final ImmutableAnalysis analysis,\n       final LogicalSchema outputSchema,\n+      final Optional<WindowType> windowType,\n       final QueryId queryId,\n       final Stacker contextStacker\n   ) {\n-    final boolean referencesRowTime = analysis.getSelectColumnRefs().stream()\n-        .anyMatch(ref -> ref.name().equals(SchemaUtil.ROWTIME_NAME));\n-\n-    final boolean referencesRowKey = analysis.getSelectColumnRefs().stream()\n-        .anyMatch(ref -> ref.name().equals(SchemaUtil.ROWKEY_NAME));\n+    final boolean noSystemColumns = analysis.getSelectColumnRefs().stream()\n+        .noneMatch(ref -> SchemaUtil.systemColumnNames().contains(ref.name()));\n \n     final LogicalSchema intermediateSchema;\n-    final PreSelectTransformer preSelectTransform;\n-    if (!referencesRowTime && !referencesRowKey) {\n+    final Function<TableRow, GenericRow> preSelectTransform;\n+    if (noSystemColumns) {\n       intermediateSchema = input.schema;\n-      preSelectTransform = (rowTime, key, value) -> value;\n+      preSelectTransform = TableRow::value;\n     } else {\n       // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      intermediateSchema = LogicalSchema.builder()\n-          .keyColumns(input.schema.key())\n-          .valueColumns(input.schema.value())\n-          .valueColumns(input.schema.metadata())\n-          .valueColumns(input.schema.key())\n-          .build();\n-\n-      preSelectTransform = (rowTime, key, value) -> {\n-        value.getColumns().add(rowTime);\n-\n-        key.schema().fields().forEach(f -> {\n-          final Object keyField = key.get(f);\n-          value.getColumns().add(keyField);\n+      final boolean windowed = windowType.isPresent();\n+\n+      intermediateSchema = input.schema\n+          .withMetaAndKeyColsInValue(windowed);\n+\n+      preSelectTransform = row -> {\n+        final Struct key = row.key();\n+        final List<Object> columns = row.value().getColumns();\n+\n+        columns.add(0, row.rowTime());\n+\n+        final List<Object> keyFields = key.schema().fields().stream()\n+            .map(key::get)\n+            .collect(Collectors.toList());\n+\n+        columns.addAll(1, keyFields);\n+\n+        row.window().ifPresent(window -> {\n+          columns.add(1, window.start().toEpochMilli());\n+          columns.add(2, window.end().toEpochMilli());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22239bbb730084ab53d8dd5feead9d45eacccd99"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg2NTY1OA==", "bodyText": "This will change in the next PR, so I'm not worried.", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372865658", "createdAt": "2020-01-30T10:21:06Z", "author": {"login": "big-andy-coates"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -559,37 +563,43 @@ private static boolean isSelectStar(final Select select) {\n       final KsqlExecutionContext executionContext,\n       final ImmutableAnalysis analysis,\n       final LogicalSchema outputSchema,\n+      final Optional<WindowType> windowType,\n       final QueryId queryId,\n       final Stacker contextStacker\n   ) {\n-    final boolean referencesRowTime = analysis.getSelectColumnRefs().stream()\n-        .anyMatch(ref -> ref.name().equals(SchemaUtil.ROWTIME_NAME));\n-\n-    final boolean referencesRowKey = analysis.getSelectColumnRefs().stream()\n-        .anyMatch(ref -> ref.name().equals(SchemaUtil.ROWKEY_NAME));\n+    final boolean noSystemColumns = analysis.getSelectColumnRefs().stream()\n+        .noneMatch(ref -> SchemaUtil.systemColumnNames().contains(ref.name()));\n \n     final LogicalSchema intermediateSchema;\n-    final PreSelectTransformer preSelectTransform;\n-    if (!referencesRowTime && !referencesRowKey) {\n+    final Function<TableRow, GenericRow> preSelectTransform;\n+    if (noSystemColumns) {\n       intermediateSchema = input.schema;\n-      preSelectTransform = (rowTime, key, value) -> value;\n+      preSelectTransform = TableRow::value;\n     } else {\n       // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      intermediateSchema = LogicalSchema.builder()\n-          .keyColumns(input.schema.key())\n-          .valueColumns(input.schema.value())\n-          .valueColumns(input.schema.metadata())\n-          .valueColumns(input.schema.key())\n-          .build();\n-\n-      preSelectTransform = (rowTime, key, value) -> {\n-        value.getColumns().add(rowTime);\n-\n-        key.schema().fields().forEach(f -> {\n-          final Object keyField = key.get(f);\n-          value.getColumns().add(keyField);\n+      final boolean windowed = windowType.isPresent();\n+\n+      intermediateSchema = input.schema\n+          .withMetaAndKeyColsInValue(windowed);\n+\n+      preSelectTransform = row -> {\n+        final Struct key = row.key();\n+        final List<Object> columns = row.value().getColumns();\n+\n+        columns.add(0, row.rowTime());\n+\n+        final List<Object> keyFields = key.schema().fields().stream()\n+            .map(key::get)\n+            .collect(Collectors.toList());\n+\n+        columns.addAll(1, keyFields);\n+\n+        row.window().ifPresent(window -> {\n+          columns.add(1, window.start().toEpochMilli());\n+          columns.add(2, window.end().toEpochMilli());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNjg1OQ=="}, "originalCommit": {"oid": "22239bbb730084ab53d8dd5feead9d45eacccd99"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2314, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}