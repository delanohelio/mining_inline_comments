{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMjQwMDUz", "number": 6173, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNTowNjoxMFrOEiKdoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyNDoxNVrOEiK-3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjU4NDY1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/RegisterTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNTowNjoxMFrOHP4nww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNTowNjoxMFrOHP4nww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxODM3MQ==", "bodyText": "Could you add this.metaStore = requireNonNull(metastore, \"metaStore\");.", "url": "https://github.com/confluentinc/ksql/pull/6173#discussion_r486418371", "createdAt": "2020-09-10T15:06:10Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/RegisterTypeFactory.java", "diffHunk": "@@ -16,16 +16,30 @@\n package io.confluent.ksql.ddl.commands;\n \n import io.confluent.ksql.execution.ddl.commands.RegisterTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.tree.RegisterType;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n \n public final class RegisterTypeFactory {\n-  RegisterTypeFactory() {\n+  private final MetaStore metaStore;\n+\n+  RegisterTypeFactory(final MetaStore metaStore) {\n+    this.metaStore = metaStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b424389fbf6abd68610a5ef3deb9b7f9fd334a61"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjY2MDg0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/RegisterTypeFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyMjoxMlrOHP5XNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyMjoxMlrOHP5XNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMDUxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldNotThrowError() {\n          \n          \n            \n              public void shouldNotThrowOnRegisterExistingTypeWhenIfNotExistsSet() {", "url": "https://github.com/confluentinc/ksql/pull/6173#discussion_r486430517", "createdAt": "2020-09-10T15:22:12Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/RegisterTypeFactoryTest.java", "diffHunk": "@@ -17,33 +17,99 @@\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.RegisterTypeCommand;\n import io.confluent.ksql.execution.expression.tree.Type;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.tree.RegisterType;\n import io.confluent.ksql.schema.ksql.types.SqlBaseType;\n import io.confluent.ksql.schema.ksql.types.SqlPrimitiveType;\n import io.confluent.ksql.schema.ksql.types.SqlStruct;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n import java.util.Optional;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class RegisterTypeFactoryTest {\n-  private final RegisterTypeFactory factory = new RegisterTypeFactory();\n+  private static final String EXISTING_TYPE = \"existing_type\";\n+  private static final String NOT_EXISTING_TYPE = \"not_existing_type\";\n+  private RegisterTypeFactory factory;\n \n-  @Test\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(EXISTING_TYPE)).thenReturn(Optional.of(customType));\n+    factory = new RegisterTypeFactory(metaStore);\n+  }\n+\n+    @Test\n   public void shouldCreateCommandForRegisterType() {\n     // Given:\n     final RegisterType ddlStatement = new RegisterType(\n         Optional.empty(),\n-        \"alias\",\n-        new Type(SqlStruct.builder().field(\"foo\", SqlPrimitiveType.of(SqlBaseType.STRING)).build())\n+        NOT_EXISTING_TYPE,\n+        new Type(SqlStruct.builder().field(\"foo\", SqlPrimitiveType.of(SqlBaseType.STRING)).build()),\n+        true\n+    );\n+\n+    // When:\n+    final RegisterTypeCommand result = factory.create(ddlStatement);\n+\n+    // Then:\n+    assertThat(result.getType(), equalTo(ddlStatement.getType().getSqlType()));\n+    assertThat(result.getTypeName(), equalTo(NOT_EXISTING_TYPE));\n+  }\n+\n+  @Test\n+  public void shouldNotThrowError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b424389fbf6abd68610a5ef3deb9b7f9fd334a61"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjY2MjI1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/RegisterTypeFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyMjozNFrOHP5YBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyMjozNFrOHP5YBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMDcyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldThrowError() {\n          \n          \n            \n              public void shouldThrowOnRegisterExistingTypeWhenIfNotExistsNotSet() {", "url": "https://github.com/confluentinc/ksql/pull/6173#discussion_r486430727", "createdAt": "2020-09-10T15:22:34Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/RegisterTypeFactoryTest.java", "diffHunk": "@@ -17,33 +17,99 @@\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.RegisterTypeCommand;\n import io.confluent.ksql.execution.expression.tree.Type;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.tree.RegisterType;\n import io.confluent.ksql.schema.ksql.types.SqlBaseType;\n import io.confluent.ksql.schema.ksql.types.SqlPrimitiveType;\n import io.confluent.ksql.schema.ksql.types.SqlStruct;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n import java.util.Optional;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class RegisterTypeFactoryTest {\n-  private final RegisterTypeFactory factory = new RegisterTypeFactory();\n+  private static final String EXISTING_TYPE = \"existing_type\";\n+  private static final String NOT_EXISTING_TYPE = \"not_existing_type\";\n+  private RegisterTypeFactory factory;\n \n-  @Test\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(EXISTING_TYPE)).thenReturn(Optional.of(customType));\n+    factory = new RegisterTypeFactory(metaStore);\n+  }\n+\n+    @Test\n   public void shouldCreateCommandForRegisterType() {\n     // Given:\n     final RegisterType ddlStatement = new RegisterType(\n         Optional.empty(),\n-        \"alias\",\n-        new Type(SqlStruct.builder().field(\"foo\", SqlPrimitiveType.of(SqlBaseType.STRING)).build())\n+        NOT_EXISTING_TYPE,\n+        new Type(SqlStruct.builder().field(\"foo\", SqlPrimitiveType.of(SqlBaseType.STRING)).build()),\n+        true\n+    );\n+\n+    // When:\n+    final RegisterTypeCommand result = factory.create(ddlStatement);\n+\n+    // Then:\n+    assertThat(result.getType(), equalTo(ddlStatement.getType().getSqlType()));\n+    assertThat(result.getTypeName(), equalTo(NOT_EXISTING_TYPE));\n+  }\n+\n+  @Test\n+  public void shouldNotThrowError() {\n+    // Given:\n+    final RegisterType ddlStatement = new RegisterType(\n+        Optional.empty(),\n+        EXISTING_TYPE,\n+        new Type(SqlStruct.builder().field(\"foo\", SqlPrimitiveType.of(SqlBaseType.STRING)).build()),\n+        true\n     );\n \n     // When:\n     final RegisterTypeCommand result = factory.create(ddlStatement);\n \n     // Then:\n     assertThat(result.getType(), equalTo(ddlStatement.getType().getSqlType()));\n-    assertThat(result.getTypeName(), equalTo(\"alias\"));\n+    assertThat(result.getTypeName(), equalTo(EXISTING_TYPE));\n+  }\n+\n+  @Test\n+  public void shouldThrowError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b424389fbf6abd68610a5ef3deb9b7f9fd334a61"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjY2OTc0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/RegisterTypeFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyNDoxNVrOHP5csQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyNDoxNVrOHP5csQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMTkyMQ==", "bodyText": "Add another test case to create a non-existing type when ifNotExists is not set. This should be used to validate we won't get errors in such scenario.", "url": "https://github.com/confluentinc/ksql/pull/6173#discussion_r486431921", "createdAt": "2020-09-10T15:24:15Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/RegisterTypeFactoryTest.java", "diffHunk": "@@ -17,33 +17,99 @@\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.RegisterTypeCommand;\n import io.confluent.ksql.execution.expression.tree.Type;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.tree.RegisterType;\n import io.confluent.ksql.schema.ksql.types.SqlBaseType;\n import io.confluent.ksql.schema.ksql.types.SqlPrimitiveType;\n import io.confluent.ksql.schema.ksql.types.SqlStruct;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n import java.util.Optional;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class RegisterTypeFactoryTest {\n-  private final RegisterTypeFactory factory = new RegisterTypeFactory();\n+  private static final String EXISTING_TYPE = \"existing_type\";\n+  private static final String NOT_EXISTING_TYPE = \"not_existing_type\";\n+  private RegisterTypeFactory factory;\n \n-  @Test\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(EXISTING_TYPE)).thenReturn(Optional.of(customType));\n+    factory = new RegisterTypeFactory(metaStore);\n+  }\n+\n+    @Test\n   public void shouldCreateCommandForRegisterType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b424389fbf6abd68610a5ef3deb9b7f9fd334a61"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2750, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}