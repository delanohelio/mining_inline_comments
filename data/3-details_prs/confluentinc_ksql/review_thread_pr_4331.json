{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNzc1OTI5", "number": 4331, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzoyN1rODYrxpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo1MzozMFrODaBm4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjA5NjM4OnYy", "diffSide": "RIGHT", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/StreamStreamJoinBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzoyN1rOFer0Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzoyN1rOFer0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxOTQ3OQ==", "bodyText": "This will likely cause a performance regression for json schemas, since the full source name will be written into the json field names (rather than just the column names). However I think this is better optimized in the json serde by dropping any prefix common to all field names, or by using our own internally generated field names for internal topics.", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r367719479", "createdAt": "2020-01-17T00:37:27Z", "author": {"login": "rodesai"}, "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/StreamStreamJoinBuilder.java", "diffHunk": "@@ -46,7 +46,7 @@ private StreamStreamJoinBuilder() {\n     final QueryContext.Stacker stacker = QueryContext.Stacker.of(queryContext);\n     final LogicalSchema leftSchema = left.getSchema();\n     final PhysicalSchema leftPhysicalSchema = PhysicalSchema.from(\n-        leftSchema.withoutAlias(),\n+        leftSchema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDc5NzMxOnYy", "diffSide": "RIGHT", "path": "ksql-common/src/main/java/io/confluent/ksql/schema/ksql/ColumnRef.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMToyMTo1NFrOFfFkiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMjo0Nzo1OFrOFhPK7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MTQ1MQ==", "bodyText": "Do we still need this class? Can we just use ColumnName wherever this class is used? (can be a follow-up)", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r368141451", "createdAt": "2020-01-17T21:21:54Z", "author": {"login": "agavra"}, "path": "ksql-common/src/main/java/io/confluent/ksql/schema/ksql/ColumnRef.java", "diffHunk": "@@ -19,69 +19,30 @@\n \n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.name.SourceName;\n-import io.confluent.ksql.util.KsqlConstants;\n-import io.confluent.ksql.util.SchemaUtil;\n import java.util.Objects;\n-import java.util.Optional;\n \n /**\n- * A reference to a column, optionally disambiguated by a qualifier indicating\n- * the source of the column.\n+ * A reference to a column.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg4MTU0Nw==", "bodyText": "I second removing ColumnRef with ColumnName. ColumnRef looks to now just be an unnecessary extra level of indirection.", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r369881547", "createdAt": "2020-01-23T00:41:19Z", "author": {"login": "big-andy-coates"}, "path": "ksql-common/src/main/java/io/confluent/ksql/schema/ksql/ColumnRef.java", "diffHunk": "@@ -19,69 +19,30 @@\n \n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.name.SourceName;\n-import io.confluent.ksql.util.KsqlConstants;\n-import io.confluent.ksql.util.SchemaUtil;\n import java.util.Objects;\n-import java.util.Optional;\n \n /**\n- * A reference to a column, optionally disambiguated by a qualifier indicating\n- * the source of the column.\n+ * A reference to a column.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MTQ1MQ=="}, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM5NTg4NA==", "bodyText": "Agreed. will punt this to a follow-up.", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r370395884", "createdAt": "2020-01-23T22:47:58Z", "author": {"login": "rodesai"}, "path": "ksql-common/src/main/java/io/confluent/ksql/schema/ksql/ColumnRef.java", "diffHunk": "@@ -19,69 +19,30 @@\n \n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.name.SourceName;\n-import io.confluent.ksql.util.KsqlConstants;\n-import io.confluent.ksql.util.SchemaUtil;\n import java.util.Objects;\n-import java.util.Optional;\n \n /**\n- * A reference to a column, optionally disambiguated by a qualifier indicating\n- * the source of the column.\n+ * A reference to a column.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MTQ1MQ=="}, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTEwMDI3OnYy", "diffSide": "RIGHT", "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDozNToyMVrOFfIeeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMjo1MDo1NVrOFhPPQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4OTA0OA==", "bodyText": "could we reuse the ColumnReferenceRewriter below? (not a biggy)", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r368189048", "createdAt": "2020-01-18T00:35:21Z", "author": {"login": "agavra"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -254,11 +275,49 @@ private FlatMapNode buildFlatMapNode(final PlanNode sourcePlanNode) {\n     return new FlatMapNode(new PlanNodeId(\"FlatMap\"), sourcePlanNode, functionRegistry, analysis);\n   }\n \n+  private PlanNode buildSourceForJoin(\n+      final AliasedDataSource source,\n+      final String side,\n+      final Expression joinExpression) {\n+    final DataSourceNode sourceNode = new DataSourceNode(\n+        new PlanNodeId(\"KafkaTopic_\" + side),\n+        source.getDataSource(),\n+        source.getAlias(),\n+        analysis.getSelectExpressions()\n+    );\n+    // it is always safe to build the repartition node - this operation will be\n+    // a no-op if a repartition is not required. if the source is a table, and\n+    // a repartition is needed, then an exception will be thrown\n+    final VisitParentExpressionVisitor<Optional<Expression>, Context<Void>> rewriter =\n+        new VisitParentExpressionVisitor<Optional<Expression>, Context<Void>>(\n+            Optional.empty()) {\n+          @Override\n+          public Optional<Expression> visitQualifiedColumnReference(\n+              final QualifiedColumnReferenceExp node,\n+              final Context<Void> ctx\n+          ) {\n+            return Optional.of(new ColumnReferenceExp(node.getReference()));\n+          }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM5Njk5NA==", "bodyText": "This rewriter needs to rewrite to the schema to drop qualifiers from qualified column references, but use the original names (not with the join prefix)", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r370396994", "createdAt": "2020-01-23T22:50:55Z", "author": {"login": "rodesai"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -254,11 +275,49 @@ private FlatMapNode buildFlatMapNode(final PlanNode sourcePlanNode) {\n     return new FlatMapNode(new PlanNodeId(\"FlatMap\"), sourcePlanNode, functionRegistry, analysis);\n   }\n \n+  private PlanNode buildSourceForJoin(\n+      final AliasedDataSource source,\n+      final String side,\n+      final Expression joinExpression) {\n+    final DataSourceNode sourceNode = new DataSourceNode(\n+        new PlanNodeId(\"KafkaTopic_\" + side),\n+        source.getDataSource(),\n+        source.getAlias(),\n+        analysis.getSelectExpressions()\n+    );\n+    // it is always safe to build the repartition node - this operation will be\n+    // a no-op if a repartition is not required. if the source is a table, and\n+    // a repartition is needed, then an exception will be thrown\n+    final VisitParentExpressionVisitor<Optional<Expression>, Context<Void>> rewriter =\n+        new VisitParentExpressionVisitor<Optional<Expression>, Context<Void>>(\n+            Optional.empty()) {\n+          @Override\n+          public Optional<Expression> visitQualifiedColumnReference(\n+              final QualifiedColumnReferenceExp node,\n+              final Context<Void> ctx\n+          ) {\n+            return Optional.of(new ColumnReferenceExp(node.getReference()));\n+          }\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4OTA0OA=="}, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTE1MDU1OnYy", "diffSide": "RIGHT", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/expression/tree/AbstractColumnReferenceExp.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTozMzozNVrOFfI7PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTozMzozNVrOFfI7PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5NjQxMw==", "bodyText": "2020 \ud83d\ude02", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r368196413", "createdAt": "2020-01-18T01:33:35Z", "author": {"login": "agavra"}, "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/expression/tree/AbstractColumnReferenceExp.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2019 Confluent Inc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NjE0ODExOnYy", "diffSide": "RIGHT", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/expression/tree/AbstractColumnReferenceExp.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo0NjoyNFrOFgv2rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo0NjoyNFrOFgv2rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg4Mjc5OA==", "bodyText": "Any objection to some renaming?\n\nAbstractColumnReferenceExp -> ColumnReferenceExp\nColumnReferenceExp -> UnqualifiedColumnReferenceExp, (with suitable rename of rewriter function etc)\n\nI think this would make the distinction clearer.", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r369882798", "createdAt": "2020-01-23T00:46:24Z", "author": {"login": "big-andy-coates"}, "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/expression/tree/AbstractColumnReferenceExp.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.expression.tree;\n+\n+import io.confluent.ksql.parser.NodeLocation;\n+import io.confluent.ksql.schema.ksql.ColumnRef;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public abstract class AbstractColumnReferenceExp extends Expression {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NjE1NzAwOnYy", "diffSide": "RIGHT", "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/RewrittenAnalysis.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo1MjoxNVrOFgv8pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo1MjoxNVrOFgv8pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg4NDMyNA==", "bodyText": "May benefit from some high level Java doc to explain what the intent of this class is.", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r369884324", "createdAt": "2020-01-23T00:52:15Z", "author": {"login": "big-andy-coates"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/RewrittenAnalysis.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import io.confluent.ksql.analyzer.Analysis.AliasedDataSource;\n+import io.confluent.ksql.analyzer.Analysis.Into;\n+import io.confluent.ksql.analyzer.Analysis.JoinInfo;\n+import io.confluent.ksql.engine.rewrite.ExpressionTreeRewriter;\n+import io.confluent.ksql.engine.rewrite.ExpressionTreeRewriter.Context;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.FunctionCall;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.parser.properties.with.CreateSourceAsProperties;\n+import io.confluent.ksql.parser.tree.WindowExpression;\n+import io.confluent.ksql.schema.ksql.ColumnRef;\n+import io.confluent.ksql.serde.SerdeOption;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalInt;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+public class RewrittenAnalysis implements ImmutableAnalysis {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NjE1OTA3OnYy", "diffSide": "RIGHT", "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/RewrittenAnalysis.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo1MzozMFrOFgv96Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwMDo1MzozMFrOFgv96Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg4NDY0OQ==", "bodyText": "how come these are not re-written? Or some of the others, e.g. getJoin(), etc?", "url": "https://github.com/confluentinc/ksql/pull/4331#discussion_r369884649", "createdAt": "2020-01-23T00:53:30Z", "author": {"login": "big-andy-coates"}, "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/RewrittenAnalysis.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import io.confluent.ksql.analyzer.Analysis.AliasedDataSource;\n+import io.confluent.ksql.analyzer.Analysis.Into;\n+import io.confluent.ksql.analyzer.Analysis.JoinInfo;\n+import io.confluent.ksql.engine.rewrite.ExpressionTreeRewriter;\n+import io.confluent.ksql.engine.rewrite.ExpressionTreeRewriter.Context;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.FunctionCall;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.parser.properties.with.CreateSourceAsProperties;\n+import io.confluent.ksql.parser.tree.WindowExpression;\n+import io.confluent.ksql.schema.ksql.ColumnRef;\n+import io.confluent.ksql.serde.SerdeOption;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalInt;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+public class RewrittenAnalysis implements ImmutableAnalysis {\n+  private final ImmutableAnalysis original;\n+  private final BiFunction<Expression, Context<Void>, Optional<Expression>> rewriter;\n+\n+  public RewrittenAnalysis(\n+      final ImmutableAnalysis original,\n+      final BiFunction<Expression, Context<Void>, Optional<Expression>> rewriter\n+  ) {\n+    this.original = Objects.requireNonNull(original, \"original\");\n+    this.rewriter = Objects.requireNonNull(rewriter ,\"rewriter\");\n+  }\n+\n+  public ImmutableAnalysis getOriginal() {\n+    return original;\n+  }\n+\n+  @Override\n+  public List<FunctionCall> getTableFunctions() {\n+    return rewriteList(original.getTableFunctions());\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return original.getSelectExpressions().stream()\n+        .map(e -> SelectExpression.of(\n+            e.getAlias(),\n+            ExpressionTreeRewriter.rewriteWith(rewriter, e.getExpression())))\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public Optional<Expression> getWhereExpression() {\n+    return rewriteOptional(original.getWhereExpression());\n+  }\n+\n+  @Override\n+  public Optional<Into> getInto() {\n+    return original.getInto();\n+  }\n+\n+  @Override\n+  public Set<ColumnRef> getSelectColumnRefs() {\n+    return original.getSelectColumnRefs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "838e1a0e9301a74cb147ab1bcb24af8768a01f45"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2240, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}