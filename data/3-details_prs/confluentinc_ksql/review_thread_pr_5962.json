{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MjQ1NTY3", "number": 5962, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo0OTo0M1rOEWPrKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo1NzowMFrOEWP2Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzYwOTM2OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DropTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo0OTo0M1rOG9c3lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowODo1M1rOG9fmew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4OTMwMQ==", "bodyText": "nit: not visible for testing only. Used by production code,, right?", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467089301", "createdAt": "2020-08-07T14:49:43Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DropTypeFactory.java", "diffHunk": "@@ -15,14 +15,32 @@\n \n package io.confluent.ksql.ddl.commands;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.DropType;\n+import io.confluent.ksql.util.KsqlException;\n+\n+import java.util.Objects;\n \n public class DropTypeFactory {\n-  DropTypeFactory() {\n+  private final MetaStore metaStore;\n+\n+  @VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDA3NQ==", "bodyText": "Right, removed.", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467134075", "createdAt": "2020-08-07T16:08:53Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DropTypeFactory.java", "diffHunk": "@@ -15,14 +15,32 @@\n \n package io.confluent.ksql.ddl.commands;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.DropType;\n+import io.confluent.ksql.util.KsqlException;\n+\n+import java.util.Objects;\n \n public class DropTypeFactory {\n-  DropTypeFactory() {\n+  private final MetaStore metaStore;\n+\n+  @VisibleForTesting", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4OTMwMQ=="}, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzYxODg0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DropTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo1MTo1OVrOG9c9YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowOTowMlrOG9fmxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5MDc4NA==", "bodyText": "No need to search the metastore when ifExists is true.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!metaStore.resolveType(typeName).isPresent()) {\n          \n          \n            \n                  if (!ifExists) {\n          \n          \n            \n                    throw new KsqlException(\"Type \" + typeName + \" does not exist.\");\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                if (!ifExists && !metaStore.resolveType(typeName).isPresent()) {\n          \n          \n            \n                  throw new KsqlException(\"Type \" + typeName + \" does not exist.\");\n          \n          \n            \n                }", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467090784", "createdAt": "2020-08-07T14:51:59Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DropTypeFactory.java", "diffHunk": "@@ -15,14 +15,32 @@\n \n package io.confluent.ksql.ddl.commands;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.DropType;\n+import io.confluent.ksql.util.KsqlException;\n+\n+import java.util.Objects;\n \n public class DropTypeFactory {\n-  DropTypeFactory() {\n+  private final MetaStore metaStore;\n+\n+  @VisibleForTesting\n+  DropTypeFactory(final MetaStore metaStore) {\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n   }\n \n   public DropTypeCommand create(final DropType statement) {\n-    return new DropTypeCommand(statement.getTypeName());\n+    final String typeName = statement.getTypeName();\n+    final boolean ifExists = statement.getIfExists();\n+\n+    if (!metaStore.resolveType(typeName).isPresent()) {\n+      if (!ifExists) {\n+        throw new KsqlException(\"Type \" + typeName + \" does not exist.\");\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDE0OA==", "bodyText": "Done", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467134148", "createdAt": "2020-08-07T16:09:02Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DropTypeFactory.java", "diffHunk": "@@ -15,14 +15,32 @@\n \n package io.confluent.ksql.ddl.commands;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.parser.DropType;\n+import io.confluent.ksql.util.KsqlException;\n+\n+import java.util.Objects;\n \n public class DropTypeFactory {\n-  DropTypeFactory() {\n+  private final MetaStore metaStore;\n+\n+  @VisibleForTesting\n+  DropTypeFactory(final MetaStore metaStore) {\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n   }\n \n   public DropTypeCommand create(final DropType statement) {\n-    return new DropTypeCommand(statement.getTypeName());\n+    final String typeName = statement.getTypeName();\n+    final boolean ifExists = statement.getIfExists();\n+\n+    if (!metaStore.resolveType(typeName).isPresent()) {\n+      if (!ifExists) {\n+        throw new KsqlException(\"Type \" + typeName + \" does not exist.\");\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5MDc4NA=="}, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzYzMzgyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo1NjowM1rOG9dGzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowOToyN1rOG9fn1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5MzE5Ng==", "bodyText": "I'm a little confused by the name of this test.   What's the OnMissingName mean?\nIt looks to test that the function returns a cmd when ifExists is true and the type does exist.  That being the case, maybe call it shouldCreateDropTypeForExistingTypeAndIfExistsSet or similar?", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467093196", "createdAt": "2020-08-07T14:56:03Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "diffHunk": "@@ -16,27 +16,79 @@\n package io.confluent.ksql.ddl.commands;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.metastore.TypeRegistry;\n import io.confluent.ksql.parser.DropType;\n import java.util.Optional;\n+\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class DropTypeFactoryTest {\n   private static final String SOME_TYPE_NAME = \"some_type\";\n \n-  private final DropTypeFactory factory = new DropTypeFactory();\n+  private DropTypeFactory factory;\n+\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(SOME_TYPE_NAME)).thenReturn(Optional.of(customType));\n+\n+    factory = new DropTypeFactory(metaStore);\n+  }\n \n   @Test\n   public void shouldCreateDropType() {\n     // Given:\n-    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME);\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, false);\n \n     // When:\n     final DropTypeCommand cmd = factory.create(dropType);\n \n     // Then:\n     assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n   }\n+\n+  @Test\n+  public void shouldCreateTypeOnMissingNameWithIfExists() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDQyMA==", "bodyText": "Done.", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467134420", "createdAt": "2020-08-07T16:09:27Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "diffHunk": "@@ -16,27 +16,79 @@\n package io.confluent.ksql.ddl.commands;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.metastore.TypeRegistry;\n import io.confluent.ksql.parser.DropType;\n import java.util.Optional;\n+\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class DropTypeFactoryTest {\n   private static final String SOME_TYPE_NAME = \"some_type\";\n \n-  private final DropTypeFactory factory = new DropTypeFactory();\n+  private DropTypeFactory factory;\n+\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(SOME_TYPE_NAME)).thenReturn(Optional.of(customType));\n+\n+    factory = new DropTypeFactory(metaStore);\n+  }\n \n   @Test\n   public void shouldCreateDropType() {\n     // Given:\n-    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME);\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, false);\n \n     // When:\n     final DropTypeCommand cmd = factory.create(dropType);\n \n     // Then:\n     assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n   }\n+\n+  @Test\n+  public void shouldCreateTypeOnMissingNameWithIfExists() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5MzE5Ng=="}, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzYzNTEwOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo1NjoyNlrOG9dHqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowOToxMVrOG9fnKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5MzQxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldFailCreateTypeOnMissingName() {\n          \n          \n            \n              public void shouldFailCreateTypeIfTypeDoesNotExist) {", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467093416", "createdAt": "2020-08-07T14:56:26Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "diffHunk": "@@ -16,27 +16,79 @@\n package io.confluent.ksql.ddl.commands;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.metastore.TypeRegistry;\n import io.confluent.ksql.parser.DropType;\n import java.util.Optional;\n+\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class DropTypeFactoryTest {\n   private static final String SOME_TYPE_NAME = \"some_type\";\n \n-  private final DropTypeFactory factory = new DropTypeFactory();\n+  private DropTypeFactory factory;\n+\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(SOME_TYPE_NAME)).thenReturn(Optional.of(customType));\n+\n+    factory = new DropTypeFactory(metaStore);\n+  }\n \n   @Test\n   public void shouldCreateDropType() {\n     // Given:\n-    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME);\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, false);\n \n     // When:\n     final DropTypeCommand cmd = factory.create(dropType);\n \n     // Then:\n     assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n   }\n+\n+  @Test\n+  public void shouldCreateTypeOnMissingNameWithIfExists() {\n+    // Given:\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, true);\n+\n+    // When:\n+    final DropTypeCommand cmd = factory.create(dropType);\n+\n+    // Then:\n+    assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n+  }\n+\n+  @Test\n+  public void shouldFailCreateTypeOnMissingName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDI1MQ==", "bodyText": "Done", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467134251", "createdAt": "2020-08-07T16:09:11Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "diffHunk": "@@ -16,27 +16,79 @@\n package io.confluent.ksql.ddl.commands;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.metastore.TypeRegistry;\n import io.confluent.ksql.parser.DropType;\n import java.util.Optional;\n+\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class DropTypeFactoryTest {\n   private static final String SOME_TYPE_NAME = \"some_type\";\n \n-  private final DropTypeFactory factory = new DropTypeFactory();\n+  private DropTypeFactory factory;\n+\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(SOME_TYPE_NAME)).thenReturn(Optional.of(customType));\n+\n+    factory = new DropTypeFactory(metaStore);\n+  }\n \n   @Test\n   public void shouldCreateDropType() {\n     // Given:\n-    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME);\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, false);\n \n     // When:\n     final DropTypeCommand cmd = factory.create(dropType);\n \n     // Then:\n     assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n   }\n+\n+  @Test\n+  public void shouldCreateTypeOnMissingNameWithIfExists() {\n+    // Given:\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, true);\n+\n+    // When:\n+    final DropTypeCommand cmd = factory.create(dropType);\n+\n+    // Then:\n+    assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n+  }\n+\n+  @Test\n+  public void shouldFailCreateTypeOnMissingName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5MzQxNg=="}, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzYzNzQyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDo1NzowMFrOG9dJFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowOToxOFrOG9fncA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5Mzc4Mg==", "bodyText": "You're missing a test to ensure it doesn't throw when the type doesn't exist and ifExists is false.", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467093782", "createdAt": "2020-08-07T14:57:00Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "diffHunk": "@@ -16,27 +16,79 @@\n package io.confluent.ksql.ddl.commands;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.metastore.TypeRegistry;\n import io.confluent.ksql.parser.DropType;\n import java.util.Optional;\n+\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class DropTypeFactoryTest {\n   private static final String SOME_TYPE_NAME = \"some_type\";\n \n-  private final DropTypeFactory factory = new DropTypeFactory();\n+  private DropTypeFactory factory;\n+\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(SOME_TYPE_NAME)).thenReturn(Optional.of(customType));\n+\n+    factory = new DropTypeFactory(metaStore);\n+  }\n \n   @Test\n   public void shouldCreateDropType() {\n     // Given:\n-    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME);\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, false);\n \n     // When:\n     final DropTypeCommand cmd = factory.create(dropType);\n \n     // Then:\n     assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n   }\n+\n+  @Test\n+  public void shouldCreateTypeOnMissingNameWithIfExists() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDMyMA==", "bodyText": "Done", "url": "https://github.com/confluentinc/ksql/pull/5962#discussion_r467134320", "createdAt": "2020-08-07T16:09:18Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DropTypeFactoryTest.java", "diffHunk": "@@ -16,27 +16,79 @@\n package io.confluent.ksql.ddl.commands;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.ddl.commands.DropTypeCommand;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.metastore.TypeRegistry;\n import io.confluent.ksql.parser.DropType;\n import java.util.Optional;\n+\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class DropTypeFactoryTest {\n   private static final String SOME_TYPE_NAME = \"some_type\";\n \n-  private final DropTypeFactory factory = new DropTypeFactory();\n+  private DropTypeFactory factory;\n+\n+  @Mock\n+  private MetaStore metaStore;\n+  @Mock\n+  private SqlType customType;\n+\n+  @Before\n+  public void setUp() {\n+    when(metaStore.resolveType(SOME_TYPE_NAME)).thenReturn(Optional.of(customType));\n+\n+    factory = new DropTypeFactory(metaStore);\n+  }\n \n   @Test\n   public void shouldCreateDropType() {\n     // Given:\n-    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME);\n+    final DropType dropType = new DropType(Optional.empty(), SOME_TYPE_NAME, false);\n \n     // When:\n     final DropTypeCommand cmd = factory.create(dropType);\n \n     // Then:\n     assertThat(cmd.getTypeName(), equalTo(SOME_TYPE_NAME));\n   }\n+\n+  @Test\n+  public void shouldCreateTypeOnMissingNameWithIfExists() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5Mzc4Mg=="}, "originalCommit": {"oid": "ad5961d5dfe6477421e6c3f796273720bc131cfe"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3053, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}