{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NTY0MDEy", "number": 6348, "title": "fix: backup files are re-created on every restart", "bodyText": "Description\nWhat behavior do you want to change, why, how does your patch achieve the changes?\nThis PR fixes an issue with backups re-created over and over again on every server restart.\nThe cause was that sometimes the command topic comes with command properties (originalProperties) with nulls and empty values. When the backup serializes those properties to write them as JSON in the file, the nulls and empty are missing. Later, when restarting the server, the command properties read from command topic are not equals from the ones found in the backup file; so a new backup file is created.\nThe fix makes sure to include nulls and empty properties in the backup file. It also adds a header to include the version of the backup file. When the backup file do not contain a version header (during an upgrade to 0.13), then the comparison will only use the commandId and the command statement (without the properties), so it the server start does not fail with degradation state.\nTesting done\nDescribe the testing strategy. Unit and integration tests are expected for any behavior changes.\nModified test cases\nVerified manually\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-10-01T21:44:59Z", "url": "https://github.com/confluentinc/ksql/pull/6348", "merged": true, "mergeCommit": {"oid": "28b84867d7e55b6ee2e27a692f42760d27fb5aca"}, "closed": true, "closedAt": "2020-10-02T19:44:21Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOYZ0jAH2gAyNDk2NTY0MDEyOmRiYjgyNWZmZjM1MDdhZDc5YTNkMGI4ODlkOWY4NTYwOGMxZDNkMTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOqFv6AH2gAyNDk2NTY0MDEyOmNmMThiYmVjMjJhYzcyYjA1ZjA5ZTA3YjdjYjBjZGQxMzUyZTA4YWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/dbb825fff3507ad79a3d0b889d9f85608c1d3d12", "committedDate": "2020-10-01T21:38:06Z", "message": "fix: backup files are re-created on every restart"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzg0MDQ0", "url": "https://github.com/confluentinc/ksql/pull/6348#pullrequestreview-500784044", "createdAt": "2020-10-01T23:35:35Z", "commit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozNTozNVrOHbdwmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzo0OTo1MFrOHbd97A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2MTE3OA==", "bodyText": "let's use JSON for the header so that we can add more things to it in the future if we want to (and we can even make it a POJO to make it easy to serde)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498561178", "createdAt": "2020-10-01T23:35:35Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -30,21 +31,84 @@\n import java.io.OutputStreamWriter;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermissions;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n /**\n  * A file that is used by the backup service to replay command_topic commands.\n  */\n-public class BackupReplayFile implements Closeable {\n-  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get();\n+public final class BackupReplayFile implements Closeable {\n+  enum Versions {\n+    NO_VERSION, V1\n+  }\n+\n+  // Current version of the Backup file\n+  private static final String BACKUP_VERSION_HEADER = \"BACKUP_VERSION\";\n+  private static final Versions DEFAULT_BACKUP_VERSION = Versions.V1;\n+\n+  // Include.ALWAYS is necessary to serialize nulls and empty values. This is required to allow\n+  // the CommandTopicBackupImpl to compare against all properties from a record read from\n+  // the command topic, which come with nulls and empty values.\n+  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get()\n+      .setSerializationInclusion(JsonInclude.Include.ALWAYS);\n+\n   private static final String KEY_VALUE_SEPARATOR = \":\";\n \n   private final File file;\n   private final BufferedWriter writer;\n+  private final Versions version;\n+\n+  public static BackupReplayFile newFile(final Path path) {\n+    final String versionHeader =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2MTMyNg==", "bodyText": "I think this will set it on the underlying instance. Instead we should create a new instance and set the serialization on the new instance (we'll need to change PlanJsonMapper to expose a newInsatcne() call)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498561326", "createdAt": "2020-10-01T23:36:13Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -30,21 +31,84 @@\n import java.io.OutputStreamWriter;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermissions;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n /**\n  * A file that is used by the backup service to replay command_topic commands.\n  */\n-public class BackupReplayFile implements Closeable {\n-  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get();\n+public final class BackupReplayFile implements Closeable {\n+  enum Versions {\n+    NO_VERSION, V1\n+  }\n+\n+  // Current version of the Backup file\n+  private static final String BACKUP_VERSION_HEADER = \"BACKUP_VERSION\";\n+  private static final Versions DEFAULT_BACKUP_VERSION = Versions.V1;\n+\n+  // Include.ALWAYS is necessary to serialize nulls and empty values. This is required to allow\n+  // the CommandTopicBackupImpl to compare against all properties from a record read from\n+  // the command topic, which come with nulls and empty values.\n+  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get()\n+      .setSerializationInclusion(JsonInclude.Include.ALWAYS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2MjI3Mg==", "bodyText": "nit: javadoc what this version means and what it's used for", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498562272", "createdAt": "2020-10-01T23:39:51Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -61,6 +125,10 @@ private static BufferedWriter createWriter(final File file) {\n     }\n   }\n \n+  public Versions getVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA==", "bodyText": "I think things get a little complicated here - if the replay file is NO_VERSION, then we need to create a new one with the newer version but restore using the existing one. I think it might just be simpler if we don't compare across versions - we didn't have this functionality until 0.13, it's probably OK to go one more deploy without it.\nthoughts @stevenpyzhang @rodesai?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498564588", "createdAt": "2020-10-01T23:49:50Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODAxNTgy", "url": "https://github.com/confluentinc/ksql/pull/6348#pullrequestreview-500801582", "createdAt": "2020-10-02T00:36:34Z", "commit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMDozNjozNFrOHbelGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMDozNjozNFrOHbelGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDYxNw==", "bodyText": "why are we dealing with the deserialized command and commandid? CommandTopic reads the records as byte[]. Why can't we just back up exactly what we read. I understand deserializing before backing up as a sanity check, but we can still write the raw byte[] from the actual backup operation.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498574617", "createdAt": "2020-10-02T00:36:34Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -120,8 +120,23 @@ private boolean isRestoring() {\n \n   private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n     final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/9b6fc95e852375d344ae0901bbfea7bd5ed9ad40", "committedDate": "2020-10-02T16:25:35Z", "message": "fix: address PR feedback\n\n- Write records directly as bytes (read from the ConsumeRecord)\n- Remove version header and attempts to read old backups (not necessary)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjc5MjQ5", "url": "https://github.com/confluentinc/ksql/pull/6348#pullrequestreview-501279249", "createdAt": "2020-10-02T16:28:02Z", "commit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODowMlrOHbz9jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODowMlrOHbz9jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNDk0MA==", "bodyText": "I had to add this because my build fails.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498924940", "createdAt": "2020-10-02T16:28:02Z", "author": {"login": "spena"}, "path": "ksqldb-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -183,6 +184,7 @@ private static RowGenerator getRowGenerator(final String schemaName) throws IOEx\n       return new RowGenerator(generator, keyField, Optional.empty());\n     }\n \n+    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjc5NDQ4", "url": "https://github.com/confluentinc/ksql/pull/6348#pullrequestreview-501279448", "createdAt": "2020-10-02T16:28:18Z", "commit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODoxOFrOHbz-IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODoxOFrOHbz-IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNTA4OA==", "bodyText": "Oops, I forgot to remove this. Could this be useful at some point?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498925088", "createdAt": "2020-10-02T16:28:18Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "diffHunk": "@@ -32,19 +32,23 @@\n \n   INSTANCE;\n \n-  private final ObjectMapper mapper = new ObjectMapper()\n-      .registerModules(\n-          new Jdk8Module(),\n-          new JavaTimeModule(),\n-          new KsqlParserSerializationModule(),\n-          new KsqlTypesSerializationModule(),\n-          new KsqlTypesDeserializationModule()\n-      )\n-      .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)\n-      .setSerializationInclusion(Include.NON_EMPTY);\n+  private final ObjectMapper mapper = newInstance();\n+\n+  public static ObjectMapper newInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjgxMzQx", "url": "https://github.com/confluentinc/ksql/pull/6348#pullrequestreview-501281341", "createdAt": "2020-10-02T16:31:04Z", "commit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjozMTowNFrOHb0DxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mzo1NVrOHb0c5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjUzMw==", "bodyText": "we don't need this change anymore, right?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498926533", "createdAt": "2020-10-02T16:31:04Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "diffHunk": "@@ -32,19 +32,23 @@\n \n   INSTANCE;\n \n-  private final ObjectMapper mapper = new ObjectMapper()\n-      .registerModules(\n-          new Jdk8Module(),\n-          new JavaTimeModule(),\n-          new KsqlParserSerializationModule(),\n-          new KsqlTypesSerializationModule(),\n-          new KsqlTypesDeserializationModule()\n-      )\n-      .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)\n-      .setSerializationInclusion(Include.NON_EMPTY);\n+  private final ObjectMapper mapper = newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjQ5MQ==", "bodyText": "let's make these error messages a little bit more meaningful (similar to what you head before, mentioning \"while backing it up from the replay file\") and also include the exception (so that we know why we can't de-serialize it)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498932491", "createdAt": "2020-10-02T16:42:59Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -118,44 +121,47 @@ private boolean isRestoring() {\n     return latestReplayIdx < latestReplay.size();\n   }\n \n-  private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n-    final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);\n-    if (record.key().equals(latestReplayRecord.left)\n-        && record.value().equals(latestReplayRecord.right)) {\n+  private boolean isRecordInLatestReplay(final ConsumerRecord<byte[], byte[]> record) {\n+    final Pair<byte[], byte[]> latestReplayRecord = latestReplay.get(latestReplayIdx);\n+\n+    if (Arrays.equals(record.key(), latestReplayRecord.getLeft())\n+        && Arrays.equals(record.value(), latestReplayRecord.getRight())) {\n       latestReplayIdx++;\n       return true;\n     }\n \n     return false;\n   }\n \n-  @Override\n-  public void writeRecord(final ConsumerRecord<byte[], byte[]> record) {\n-    final ConsumerRecord<CommandId, Command> deserializedRecord;\n+  private void throwIfInvalidRecord(final ConsumerRecord<byte[], byte[]> record) {\n     try {\n-      deserializedRecord = new ConsumerRecord<>(\n-          record.topic(),\n-          record.partition(),\n-          record.offset(),\n-          InternalTopicSerdes.deserializer(CommandId.class)\n-              .deserialize(record.topic(), record.key()),\n-          InternalTopicSerdes.deserializer(Command.class)\n-              .deserialize(record.topic(), record.value())\n-      );\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to deserialize command topic record when backing it up: {}:{}\",\n-          record.key(), record.value());\n-      return;\n+      InternalTopicSerdes.deserializer(CommandId.class).deserialize(record.topic(), record.key());\n+    } catch (final Exception e) {\n+      throw new KsqlException(String.format(\n+          \"Cannot deserialize record key: %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjk2Ng==", "bodyText": "is latestTs used anywhere?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498932966", "createdAt": "2020-10-02T16:43:55Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -209,7 +215,7 @@ private BackupReplayFile newReplayFile() {\n \n     File latestBakFile = null;\n     if (files != null) {\n-      long latestTs = 0;\n+      long latestTs = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf18bbec22ac72b05f09e07b7cb0cdd1352e08ab", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/cf18bbec22ac72b05f09e07b7cb0cdd1352e08ab", "committedDate": "2020-10-02T18:14:28Z", "message": "fix: address PR feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4617, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}