{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxODQ5ODMz", "number": 5457, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMTowMjo1N1rOD-6W3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMToxMTowOVrOD-6exA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mjk0NDI5OnYy", "diffSide": "RIGHT", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMTowMjo1N1rOGZTPgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNjo0NDoxOFrOGZdZ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4Mjg0OQ==", "bodyText": "cc @derekjn @mjsax\nChaps, I've brought the KLIP inline with the implementation in this PR.\nWe also discussed using ROWKEY as a hardcoded name for the synthesised column name.  I've added some details to the KLIP explain the complexities and challenges of doing so.\nPersonally, I don't like the idea of using a hardcoded ROWKEY and introducing the ambiguity and inconsistencies I've hopefully explained above, naming:\n\nIt's hard for a user to know if ROWKEY in a projection refers to a synthesised column or a column from the source.\nIt's inconsistent with how ksqlDB has historically supported ambiguous column names in the projection. ksqlDB currently requires any ambiguous column name to be fully qualified, however the synthetic column can not be fully qualified as it does not come from a source table/stream.\nImplementing this will be a PITA to be honest, due to the current implementation we've inherited.\n\nThe ways forward I see are (in no particular order):\n\nGo with the hardcoded name in the upcoming release, with the likely release delays that will result..\nStick with the system generated names in this PR, e.g. KSQL_COL_0.\nGo with the system generated names for the upcoming release and switch to hardcoded for the next.\nRequire the user to always provide an alias for any synthetic column, thereby avoiding the name clashing / ambiguity.  We've have to pick a new reserved column name, as ROWKEY is still the default key column name if one is not explicitly provided.  The main downside of such an approach is that a SELECT * would fail as it doesn't provide an alias.\nAdd a unique postfix to  ROWKEY to ensure its unique. Most of the time it will be ROWKEY, but if the source data contains a ROWKEY column then it will become ROWKEY_1, or some other number to ensure its unique. This is essentially the same pattern as what this PR has, just using a different name, i.e. ROWKEY rather than KSQL_COL.  This would be easy to change to.\n\nYour thoughts please gentlemen....", "url": "https://github.com/confluentinc/ksql/pull/5457#discussion_r429182849", "createdAt": "2020-05-22T11:02:57Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -541,28 +564,51 @@ The following naming strategies were rejected:\n \n #### `ROWKEY`/`JOINKEY` or other hardcoded name\n \n-The synthesised column would take on a hardcoded name. This name would need to be reserved to avoid\n-name clashes.\n+The synthesised column would take on a hardcoded name. This was rejected as an approach due to\n+complexities in the code required to avoid name clashing.  To explain this, consider the following\n+worked example.\n \n-`ROWKEY` was rejected as existing users will have sources with key columns called `ROWKEY`.\n-Reserving this name would cause the statements building these sources to fail post-upgrade.synthesised\n+First, let us remember that ksqlDB already supports including unambiguous source columns in a join's\n+projection _without_ their source qualifier, for example:\n \n-`JOINKEY` or some other hardcoded name was rejected primarliy due to the implementation issues\n-mentioned above: not only would it be possible to validate the presence of `JOINKEY` in the\n-projection, the user would also be free to use `JOINKEY` in other places, e.g. as a parameter to a\n-UDF or within a binary expression, etc.  This would not work by default and would require extra\n-effort to make work, including additional steps in the streams topology - there seems little ROI on\n-such effort or the complexity it will add to the code.\n+```sql\n+-- I1 schema: ID KEY, V0, V1\n+-- I2 schema: ID KEY, V0, V2\n+CREATE TABLE OUTPUT AS\n+   SELECT I1.ID, I2.V0, V1, V2 FROM I1 JOIN I2 ON I1.ID = I2.ID;\n+-- OUTPUT schema: I1_ID KEY, I2_V0, V1, V2\n+```\n+\n+In the above query, note how `I1.ID` and `I2.V0` must include their source to avoid being ambiguous,\n+however `V1` and `V2` do not.\n \n-#### `KSQL_COL_x`\n+Now let us consider how this would play out if synthetic join keys had a hardcoded name `ROWKEY`:\n \n-The synthesised column would take on a generated name in the form `KSQL_COL_x`, where `x` is an\n-integer and the name is guaranteed to be unique, i.e. to not clash with any other system generated\n-column names.\n+```sql\n+CREATE TABLE TABLE_WITH_ROWKEY AS\n+    SELECT * FROM I1 FULL OUTER JOIN I2 ON I1.ID = I2.ID;\n+-- T1: ROWKEY KEY, I1_ID, I1_V0, I1_V1, I2_ID, I2_V0, I2_V1\n+\n+CREATE TABLE OUTPUT AS\n+    SELECT ROWKEY, [...] FROM TABLE_WITH_ROWKEY I3 FULL OUTER JOIN I4 ON I3.ROWKEY = I4.ID;\n+```\n \n-This was rejected as the name would be hard for the user to know by looking at the query, i.e. the\n-presence of other columns with generated names may affect the name of the synthesised column. This\n-was deemed to make this solution unworkable.\n+The first statement executes without issue and results in a table with a schema that includes the\n+hardcoded `ROWKEY` column name. However, the presence of `ROWKEY` second statement's projection\n+posses a problem: does this `ROWKEY` pertain to the synthetic join key this query introduces or\n+`TABLE_WITH_ROWKEY.ROWKEY`?\n+\n+One could argue that a `ROWKEY` without a source would always refer to the newly synthesised join\n+column, and the user is free to include a qualified `TABLE_WITH_ROWKEY.ROWKEY` if they require the\n+source column.  However, this is currently rejected for the following reasons:\n+\n+  1. this breaks from the normal rules used to handle ambiguous column names, adding confusion\n+     for users.\n+  2. intuitively, users looking at the second statement would assume the `ROWKEY` in the projection\n+     came from the `TABLE_WITH_ROWKEY`, i.e. its not clear its refering to a synthesised join column.\n+  3. the current ambiguous column detection code isn't up to the job of handling this join case and\n+     enhancement would require a large degree of redesign and movement of the logic within the\n+     query analysis and planned stages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2919c6935a2e39a64d742da3bd9d05627a019d"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0OTM1OQ==", "bodyText": "Closing the loop on this ... choice made: going with option 5.", "url": "https://github.com/confluentinc/ksql/pull/5457#discussion_r429349359", "createdAt": "2020-05-22T16:44:18Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -541,28 +564,51 @@ The following naming strategies were rejected:\n \n #### `ROWKEY`/`JOINKEY` or other hardcoded name\n \n-The synthesised column would take on a hardcoded name. This name would need to be reserved to avoid\n-name clashes.\n+The synthesised column would take on a hardcoded name. This was rejected as an approach due to\n+complexities in the code required to avoid name clashing.  To explain this, consider the following\n+worked example.\n \n-`ROWKEY` was rejected as existing users will have sources with key columns called `ROWKEY`.\n-Reserving this name would cause the statements building these sources to fail post-upgrade.synthesised\n+First, let us remember that ksqlDB already supports including unambiguous source columns in a join's\n+projection _without_ their source qualifier, for example:\n \n-`JOINKEY` or some other hardcoded name was rejected primarliy due to the implementation issues\n-mentioned above: not only would it be possible to validate the presence of `JOINKEY` in the\n-projection, the user would also be free to use `JOINKEY` in other places, e.g. as a parameter to a\n-UDF or within a binary expression, etc.  This would not work by default and would require extra\n-effort to make work, including additional steps in the streams topology - there seems little ROI on\n-such effort or the complexity it will add to the code.\n+```sql\n+-- I1 schema: ID KEY, V0, V1\n+-- I2 schema: ID KEY, V0, V2\n+CREATE TABLE OUTPUT AS\n+   SELECT I1.ID, I2.V0, V1, V2 FROM I1 JOIN I2 ON I1.ID = I2.ID;\n+-- OUTPUT schema: I1_ID KEY, I2_V0, V1, V2\n+```\n+\n+In the above query, note how `I1.ID` and `I2.V0` must include their source to avoid being ambiguous,\n+however `V1` and `V2` do not.\n \n-#### `KSQL_COL_x`\n+Now let us consider how this would play out if synthetic join keys had a hardcoded name `ROWKEY`:\n \n-The synthesised column would take on a generated name in the form `KSQL_COL_x`, where `x` is an\n-integer and the name is guaranteed to be unique, i.e. to not clash with any other system generated\n-column names.\n+```sql\n+CREATE TABLE TABLE_WITH_ROWKEY AS\n+    SELECT * FROM I1 FULL OUTER JOIN I2 ON I1.ID = I2.ID;\n+-- T1: ROWKEY KEY, I1_ID, I1_V0, I1_V1, I2_ID, I2_V0, I2_V1\n+\n+CREATE TABLE OUTPUT AS\n+    SELECT ROWKEY, [...] FROM TABLE_WITH_ROWKEY I3 FULL OUTER JOIN I4 ON I3.ROWKEY = I4.ID;\n+```\n \n-This was rejected as the name would be hard for the user to know by looking at the query, i.e. the\n-presence of other columns with generated names may affect the name of the synthesised column. This\n-was deemed to make this solution unworkable.\n+The first statement executes without issue and results in a table with a schema that includes the\n+hardcoded `ROWKEY` column name. However, the presence of `ROWKEY` second statement's projection\n+posses a problem: does this `ROWKEY` pertain to the synthetic join key this query introduces or\n+`TABLE_WITH_ROWKEY.ROWKEY`?\n+\n+One could argue that a `ROWKEY` without a source would always refer to the newly synthesised join\n+column, and the user is free to include a qualified `TABLE_WITH_ROWKEY.ROWKEY` if they require the\n+source column.  However, this is currently rejected for the following reasons:\n+\n+  1. this breaks from the normal rules used to handle ambiguous column names, adding confusion\n+     for users.\n+  2. intuitively, users looking at the second statement would assume the `ROWKEY` in the projection\n+     came from the `TABLE_WITH_ROWKEY`, i.e. its not clear its refering to a synthesised join column.\n+  3. the current ambiguous column detection code isn't up to the job of handling this join case and\n+     enhancement would require a large degree of redesign and movement of the logic within the\n+     query analysis and planned stages.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4Mjg0OQ=="}, "originalCommit": {"oid": "cc2919c6935a2e39a64d742da3bd9d05627a019d"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mjk2NDUyOnYy", "diffSide": "LEFT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udf/JoinKeyUdf.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMToxMTowOVrOGZTcZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMToxMTowOVrOGZTcZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4NjE0OQ==", "bodyText": "Death to JoinKey!!!!! Whoot whoot!", "url": "https://github.com/confluentinc/ksql/pull/5457#discussion_r429186149", "createdAt": "2020-05-22T11:11:09Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udf/JoinKeyUdf.java", "diffHunk": "@@ -1,46 +0,0 @@\n-/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb304ef3b811e19ac348ed6f574b0bfb59f8ed1"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3272, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}