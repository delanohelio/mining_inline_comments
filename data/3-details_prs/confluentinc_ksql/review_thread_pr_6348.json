{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NTY0MDEy", "number": 6348, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozNTozNVrOEpqLgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mzo1NVrOEp4TDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTE4MTQ2OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozNTozNVrOHbdwmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozNTozNVrOHbdwmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2MTE3OA==", "bodyText": "let's use JSON for the header so that we can add more things to it in the future if we want to (and we can even make it a POJO to make it easy to serde)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498561178", "createdAt": "2020-10-01T23:35:35Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -30,21 +31,84 @@\n import java.io.OutputStreamWriter;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermissions;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n /**\n  * A file that is used by the backup service to replay command_topic commands.\n  */\n-public class BackupReplayFile implements Closeable {\n-  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get();\n+public final class BackupReplayFile implements Closeable {\n+  enum Versions {\n+    NO_VERSION, V1\n+  }\n+\n+  // Current version of the Backup file\n+  private static final String BACKUP_VERSION_HEADER = \"BACKUP_VERSION\";\n+  private static final Versions DEFAULT_BACKUP_VERSION = Versions.V1;\n+\n+  // Include.ALWAYS is necessary to serialize nulls and empty values. This is required to allow\n+  // the CommandTopicBackupImpl to compare against all properties from a record read from\n+  // the command topic, which come with nulls and empty values.\n+  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get()\n+      .setSerializationInclusion(JsonInclude.Include.ALWAYS);\n+\n   private static final String KEY_VALUE_SEPARATOR = \":\";\n \n   private final File file;\n   private final BufferedWriter writer;\n+  private final Versions version;\n+\n+  public static BackupReplayFile newFile(final Path path) {\n+    final String versionHeader =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTE4MjMzOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozNjoxM1rOHbdxLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozNjoxM1rOHbdxLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2MTMyNg==", "bodyText": "I think this will set it on the underlying instance. Instead we should create a new instance and set the serialization on the new instance (we'll need to change PlanJsonMapper to expose a newInsatcne() call)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498561326", "createdAt": "2020-10-01T23:36:13Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -30,21 +31,84 @@\n import java.io.OutputStreamWriter;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermissions;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n /**\n  * A file that is used by the backup service to replay command_topic commands.\n  */\n-public class BackupReplayFile implements Closeable {\n-  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get();\n+public final class BackupReplayFile implements Closeable {\n+  enum Versions {\n+    NO_VERSION, V1\n+  }\n+\n+  // Current version of the Backup file\n+  private static final String BACKUP_VERSION_HEADER = \"BACKUP_VERSION\";\n+  private static final Versions DEFAULT_BACKUP_VERSION = Versions.V1;\n+\n+  // Include.ALWAYS is necessary to serialize nulls and empty values. This is required to allow\n+  // the CommandTopicBackupImpl to compare against all properties from a record read from\n+  // the command topic, which come with nulls and empty values.\n+  private static final ObjectMapper MAPPER = PlanJsonMapper.INSTANCE.get()\n+      .setSerializationInclusion(JsonInclude.Include.ALWAYS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTE4ODM5OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozOTo1MVrOHbd04A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzozOTo1MVrOHbd04A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2MjI3Mg==", "bodyText": "nit: javadoc what this version means and what it's used for", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498562272", "createdAt": "2020-10-01T23:39:51Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/BackupReplayFile.java", "diffHunk": "@@ -61,6 +125,10 @@ private static BufferedWriter createWriter(final File file) {\n     }\n   }\n \n+  public Versions getVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTIwMjUyOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzo0OTo1MFrOHbd97A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNTowMjoyM1rOHbxEpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA==", "bodyText": "I think things get a little complicated here - if the replay file is NO_VERSION, then we need to create a new one with the newer version but restore using the existing one. I think it might just be simpler if we don't compare across versions - we didn't have this functionality until 0.13, it's probably OK to go one more deploy without it.\nthoughts @stevenpyzhang @rodesai?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498564588", "createdAt": "2020-10-01T23:49:50Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3MjQ1OQ==", "bodyText": "why do we have multiple backup files?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498572459", "createdAt": "2020-10-02T00:25:37Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NjA1OQ==", "bodyText": "Before 0.13, if the file was ever corrupted we would simply start a new one and keep the old one. This behavior is changing to fail hard if it's corrupted. After this change, if the old file was created before 0.13 we want to write it in a format that doesn't have the problems described in this PR, but we want to leave the old one in place just in case (at least that was my thoughts).\nDoes that answer your question?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498576059", "createdAt": "2020-10-02T00:44:13Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3Njg1Ng==", "bodyText": "I'm fine with dropping the older backup files for this release. We can do this by configuring a new location in cc-spec-ksql. We would be kicking the problem down the road, so at least file an issue that we need to add something to rewrite to the current version if the backup is old.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498576856", "createdAt": "2020-10-02T00:48:28Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3Nzc0Nw==", "bodyText": "so at least file an issue that we need to add something to rewrite to the current version if the backup is old.\n\nI don't think we need to do this, the backup file would be written from the beginning of the command topic so we could just ignore the old ones altogether.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498577747", "createdAt": "2020-10-02T00:53:22Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3OTE1Mw==", "bodyText": "We still need something to detect that the current version is old and then write out the new file right? (even if we don't delete the file)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498579153", "createdAt": "2020-10-02T01:01:01Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4MTY5Ng==", "bodyText": "We have two options: (1) we configure a new location in cc-spec and then the old files are as good as having never existed or (2) we use the header approach, which the very first time it starts up on 0.13 it'll write a new file, and from then on it ignores the old one. Perhaps I don't understand what you meant - what are we kicking down the road?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498581696", "createdAt": "2020-10-02T01:14:51Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4MzA3OA==", "bodyText": "This patch adds versioning to the backup. That means we need to be able to deal with the older versions. I think what you're proposing is that if the current backup file's version is old, we simply throw it away? I'm ok with this to keep things simple. These bumps should be very infrequent.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498583078", "createdAt": "2020-10-02T01:22:32Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0MjA4OA==", "bodyText": "@almog Are we still doing the versioning now we'll ignore the old backups?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498842088", "createdAt": "2020-10-02T14:03:46Z", "author": {"login": "spena"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3NzYwNg==", "bodyText": "@spena - feel free to make the call on that. The benefit of adding a header is that in the future if we ever make changes to the functionality we'll have a non-disruptive way forward. If we don't think we'll be making those changes, we can just keep it simple.\nMight also be worth thinking about the on-prem case, where users might have already enabled this feature (very unlikely). In that case, their 0.13 upgrades might fail.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498877606", "createdAt": "2020-10-02T15:02:23Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -230,7 +245,7 @@ private BackupReplayFile newReplayFile() {\n     }\n \n     return (latestBakFile != null)\n-        ? Optional.of(new BackupReplayFile(latestBakFile))\n+        ? Optional.of(BackupReplayFile.openFile(latestBakFile))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2NDU4OA=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTI2NDgyOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMDozNjozNFrOHbelGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowMjoxNVrOHbu2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDYxNw==", "bodyText": "why are we dealing with the deserialized command and commandid? CommandTopic reads the records as byte[]. Why can't we just back up exactly what we read. I understand deserializing before backing up as a sanity check, but we can still write the raw byte[] from the actual backup operation.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498574617", "createdAt": "2020-10-02T00:36:34Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -120,8 +120,23 @@ private boolean isRestoring() {\n \n   private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n     final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NjE5Ng==", "bodyText": "Are the raw bytes UTF8 encoded? What you suggest might be a really good solution. The only thing that's important to me is to make sure the backup file is human readable (which it might be if we just write the bytes of what we read anyway)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498576196", "createdAt": "2020-10-02T00:44:58Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -120,8 +120,23 @@ private boolean isRestoring() {\n \n   private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n     final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDYxNw=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3OTI3MQ==", "bodyText": "Yep, it should just be a json string.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498579271", "createdAt": "2020-10-02T01:01:38Z", "author": {"login": "rodesai"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -120,8 +120,23 @@ private boolean isRestoring() {\n \n   private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n     final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDYxNw=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4MTMxNA==", "bodyText": "\ud83d\udcaf I like your suggestion best then", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498581314", "createdAt": "2020-10-02T01:12:49Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -120,8 +120,23 @@ private boolean isRestoring() {\n \n   private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n     final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDYxNw=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0MTE5Mw==", "bodyText": "Using this deserialization in the past was unnecessary, but I just detected while fixing this PR. I initially was going with this approach of writing the string directly, but I wanted to keep things compatible with old backups. However, if the new proposal is to change the location in cc-spec-ksql to ignore them, then I'll remove the unnecessary code and write bytes directly.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498841193", "createdAt": "2020-10-02T14:02:15Z", "author": {"login": "spena"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -120,8 +120,23 @@ private boolean isRestoring() {\n \n   private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n     final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDYxNw=="}, "originalCommit": {"oid": "dbb825fff3507ad79a3d0b889d9f85608c1d3d12"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ0NTcyOnYy", "diffSide": "RIGHT", "path": "ksqldb-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODowMlrOHbz9jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODowMlrOHbz9jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNDk0MA==", "bodyText": "I had to add this because my build fails.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498924940", "createdAt": "2020-10-02T16:28:02Z", "author": {"login": "spena"}, "path": "ksqldb-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -183,6 +184,7 @@ private static RowGenerator getRowGenerator(final String schemaName) throws IOEx\n       return new RowGenerator(generator, keyField, Optional.empty());\n     }\n \n+    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ0NjYyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODoxOFrOHbz-IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjoyODoxOFrOHbz-IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNTA4OA==", "bodyText": "Oops, I forgot to remove this. Could this be useful at some point?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498925088", "createdAt": "2020-10-02T16:28:18Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "diffHunk": "@@ -32,19 +32,23 @@\n \n   INSTANCE;\n \n-  private final ObjectMapper mapper = new ObjectMapper()\n-      .registerModules(\n-          new Jdk8Module(),\n-          new JavaTimeModule(),\n-          new KsqlParserSerializationModule(),\n-          new KsqlTypesSerializationModule(),\n-          new KsqlTypesDeserializationModule()\n-      )\n-      .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)\n-      .setSerializationInclusion(Include.NON_EMPTY);\n+  private final ObjectMapper mapper = newInstance();\n+\n+  public static ObjectMapper newInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ1NTM1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjozMTowNFrOHb0DxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxNTozMlrOHb3IwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjUzMw==", "bodyText": "we don't need this change anymore, right?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498926533", "createdAt": "2020-10-02T16:31:04Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "diffHunk": "@@ -32,19 +32,23 @@\n \n   INSTANCE;\n \n-  private final ObjectMapper mapper = new ObjectMapper()\n-      .registerModules(\n-          new Jdk8Module(),\n-          new JavaTimeModule(),\n-          new KsqlParserSerializationModule(),\n-          new KsqlTypesSerializationModule(),\n-          new KsqlTypesDeserializationModule()\n-      )\n-      .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)\n-      .setSerializationInclusion(Include.NON_EMPTY);\n+  private final ObjectMapper mapper = newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3Njk2MQ==", "bodyText": "Removed.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498976961", "createdAt": "2020-10-02T18:15:32Z", "author": {"login": "spena"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/execution/json/PlanJsonMapper.java", "diffHunk": "@@ -32,19 +32,23 @@\n \n   INSTANCE;\n \n-  private final ObjectMapper mapper = new ObjectMapper()\n-      .registerModules(\n-          new Jdk8Module(),\n-          new JavaTimeModule(),\n-          new KsqlParserSerializationModule(),\n-          new KsqlTypesSerializationModule(),\n-          new KsqlTypesDeserializationModule()\n-      )\n-      .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n-      .enable(DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES)\n-      .enable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)\n-      .setSerializationInclusion(Include.NON_EMPTY);\n+  private final ObjectMapper mapper = newInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjUzMw=="}, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ5MTg2OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mjo1OVrOHb0bCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxNToyNlrOHb3IVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjQ5MQ==", "bodyText": "let's make these error messages a little bit more meaningful (similar to what you head before, mentioning \"while backing it up from the replay file\") and also include the exception (so that we know why we can't de-serialize it)", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498932491", "createdAt": "2020-10-02T16:42:59Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -118,44 +121,47 @@ private boolean isRestoring() {\n     return latestReplayIdx < latestReplay.size();\n   }\n \n-  private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n-    final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);\n-    if (record.key().equals(latestReplayRecord.left)\n-        && record.value().equals(latestReplayRecord.right)) {\n+  private boolean isRecordInLatestReplay(final ConsumerRecord<byte[], byte[]> record) {\n+    final Pair<byte[], byte[]> latestReplayRecord = latestReplay.get(latestReplayIdx);\n+\n+    if (Arrays.equals(record.key(), latestReplayRecord.getLeft())\n+        && Arrays.equals(record.value(), latestReplayRecord.getRight())) {\n       latestReplayIdx++;\n       return true;\n     }\n \n     return false;\n   }\n \n-  @Override\n-  public void writeRecord(final ConsumerRecord<byte[], byte[]> record) {\n-    final ConsumerRecord<CommandId, Command> deserializedRecord;\n+  private void throwIfInvalidRecord(final ConsumerRecord<byte[], byte[]> record) {\n     try {\n-      deserializedRecord = new ConsumerRecord<>(\n-          record.topic(),\n-          record.partition(),\n-          record.offset(),\n-          InternalTopicSerdes.deserializer(CommandId.class)\n-              .deserialize(record.topic(), record.key()),\n-          InternalTopicSerdes.deserializer(Command.class)\n-              .deserialize(record.topic(), record.value())\n-      );\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to deserialize command topic record when backing it up: {}:{}\",\n-          record.key(), record.value());\n-      return;\n+      InternalTopicSerdes.deserializer(CommandId.class).deserialize(record.topic(), record.key());\n+    } catch (final Exception e) {\n+      throw new KsqlException(String.format(\n+          \"Cannot deserialize record key: %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3Njg1NA==", "bodyText": "Done", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498976854", "createdAt": "2020-10-02T18:15:26Z", "author": {"login": "spena"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -118,44 +121,47 @@ private boolean isRestoring() {\n     return latestReplayIdx < latestReplay.size();\n   }\n \n-  private boolean isRecordInLatestReplay(final ConsumerRecord<CommandId, Command> record) {\n-    final Pair<CommandId, Command> latestReplayRecord = latestReplay.get(latestReplayIdx);\n-    if (record.key().equals(latestReplayRecord.left)\n-        && record.value().equals(latestReplayRecord.right)) {\n+  private boolean isRecordInLatestReplay(final ConsumerRecord<byte[], byte[]> record) {\n+    final Pair<byte[], byte[]> latestReplayRecord = latestReplay.get(latestReplayIdx);\n+\n+    if (Arrays.equals(record.key(), latestReplayRecord.getLeft())\n+        && Arrays.equals(record.value(), latestReplayRecord.getRight())) {\n       latestReplayIdx++;\n       return true;\n     }\n \n     return false;\n   }\n \n-  @Override\n-  public void writeRecord(final ConsumerRecord<byte[], byte[]> record) {\n-    final ConsumerRecord<CommandId, Command> deserializedRecord;\n+  private void throwIfInvalidRecord(final ConsumerRecord<byte[], byte[]> record) {\n     try {\n-      deserializedRecord = new ConsumerRecord<>(\n-          record.topic(),\n-          record.partition(),\n-          record.offset(),\n-          InternalTopicSerdes.deserializer(CommandId.class)\n-              .deserialize(record.topic(), record.key()),\n-          InternalTopicSerdes.deserializer(Command.class)\n-              .deserialize(record.topic(), record.value())\n-      );\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to deserialize command topic record when backing it up: {}:{}\",\n-          record.key(), record.value());\n-      return;\n+      InternalTopicSerdes.deserializer(CommandId.class).deserialize(record.topic(), record.key());\n+    } catch (final Exception e) {\n+      throw new KsqlException(String.format(\n+          \"Cannot deserialize record key: %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjQ5MQ=="}, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ5NDUyOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mzo1NVrOHb0c5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxNToyMVrOHb3IAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjk2Ng==", "bodyText": "is latestTs used anywhere?", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498932966", "createdAt": "2020-10-02T16:43:55Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -209,7 +215,7 @@ private BackupReplayFile newReplayFile() {\n \n     File latestBakFile = null;\n     if (files != null) {\n-      long latestTs = 0;\n+      long latestTs = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3Njc2OQ==", "bodyText": "Changed. It was a change I did in the previous commit when changing the unit tests. It's not needed anymore.", "url": "https://github.com/confluentinc/ksql/pull/6348#discussion_r498976769", "createdAt": "2020-10-02T18:15:21Z", "author": {"login": "spena"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -209,7 +215,7 @@ private BackupReplayFile newReplayFile() {\n \n     File latestBakFile = null;\n     if (files != null) {\n-      long latestTs = 0;\n+      long latestTs = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjk2Ng=="}, "originalCommit": {"oid": "9b6fc95e852375d344ae0901bbfea7bd5ed9ad40"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2648, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}