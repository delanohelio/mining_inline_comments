{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMTcyNzY4", "number": 5059, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjo1MlrODxvTew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1OToyOFrODx3VwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDgxODUxOnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjo1MlrOGFYWNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowOTozNFrOGFuh7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDk2NA==", "bodyText": "is there any reason we ignore the non-string properties? (should we be calling toString on them?)", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408294964", "createdAt": "2020-04-14T17:02:52Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -154,4 +161,15 @@ private static HttpClientOptions createClientOptions() {\n     return new HttpClientOptions().setMaxPoolSize(100);\n   }\n \n+  private static Map<String, String> toClientProps(final KsqlConfig ksqlConfig) {\n+    final Map<String, String> clientProps = new HashMap<>();\n+    for (Map.Entry<String, Object> entry : ksqlConfig.originals().entrySet()) {\n+      if (entry.getValue() instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NjEyNg==", "bodyText": "we're really only interested in the ssl config values which are all strings I think.", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408366126", "createdAt": "2020-04-14T19:00:16Z", "author": {"login": "purplefox"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -154,4 +161,15 @@ private static HttpClientOptions createClientOptions() {\n     return new HttpClientOptions().setMaxPoolSize(100);\n   }\n \n+  private static Map<String, String> toClientProps(final KsqlConfig ksqlConfig) {\n+    final Map<String, String> clientProps = new HashMap<>();\n+    for (Map.Entry<String, Object> entry : ksqlConfig.originals().entrySet()) {\n+      if (entry.getValue() instanceof String) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDk2NA=="}, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzE0NQ==", "bodyText": "I'm worried that assumption is a little brittle, at a minimum can we add a comment explaining that?", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408423145", "createdAt": "2020-04-14T20:43:31Z", "author": {"login": "agavra"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -154,4 +161,15 @@ private static HttpClientOptions createClientOptions() {\n     return new HttpClientOptions().setMaxPoolSize(100);\n   }\n \n+  private static Map<String, String> toClientProps(final KsqlConfig ksqlConfig) {\n+    final Map<String, String> clientProps = new HashMap<>();\n+    for (Map.Entry<String, Object> entry : ksqlConfig.originals().entrySet()) {\n+      if (entry.getValue() instanceof String) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDk2NA=="}, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODQxMw==", "bodyText": "Ok, I'll toString the value :)", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408658413", "createdAt": "2020-04-15T08:09:34Z", "author": {"login": "purplefox"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -154,4 +161,15 @@ private static HttpClientOptions createClientOptions() {\n     return new HttpClientOptions().setMaxPoolSize(100);\n   }\n \n+  private static Map<String, String> toClientProps(final KsqlConfig ksqlConfig) {\n+    final Map<String, String> clientProps = new HashMap<>();\n+    for (Map.Entry<String, Object> entry : ksqlConfig.originals().entrySet()) {\n+      if (entry.getValue() instanceof String) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDk2NA=="}, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjEzMjU2OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/ShowQueriesMultiNodeWithTlsFunctionalTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1ODoyNFrOGFlDaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowNjowMVrOGFuaQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzE0NA==", "bodyText": "What's the purpose of having both a TLS and a non-TLS listener? Can we just have the TLS listener?", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408503144", "createdAt": "2020-04-14T23:58:24Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/ShowQueriesMultiNodeWithTlsFunctionalTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.Matchers.is;\n+\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.Queries;\n+import io.confluent.ksql.rest.entity.RunningQuery;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.serde.FormatFactory;\n+import io.confluent.ksql.test.util.secure.ServerKeyStore;\n+import io.confluent.ksql.util.PageViewDataProvider;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.RuleChain;\n+\n+@Category({IntegrationTest.class})\n+public class ShowQueriesMultiNodeWithTlsFunctionalTest {\n+\n+  private static final PageViewDataProvider PAGE_VIEWS_PROVIDER = new PageViewDataProvider();\n+  private static final String PAGE_VIEW_TOPIC = PAGE_VIEWS_PROVIDER.topicName();\n+  private static final String PAGE_VIEW_STREAM = PAGE_VIEWS_PROVIDER.kstreamName();\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG,\n+          \"http://localhost:8088,https://localhost:8089\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NjQ0OA==", "bodyText": "I think in many cases users will have both listeners, so this validates that the right listener is used in this case.", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408656448", "createdAt": "2020-04-15T08:06:01Z", "author": {"login": "purplefox"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/ShowQueriesMultiNodeWithTlsFunctionalTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.Matchers.is;\n+\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.Queries;\n+import io.confluent.ksql.rest.entity.RunningQuery;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.serde.FormatFactory;\n+import io.confluent.ksql.test.util.secure.ServerKeyStore;\n+import io.confluent.ksql.util.PageViewDataProvider;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.RuleChain;\n+\n+@Category({IntegrationTest.class})\n+public class ShowQueriesMultiNodeWithTlsFunctionalTest {\n+\n+  private static final PageViewDataProvider PAGE_VIEWS_PROVIDER = new PageViewDataProvider();\n+  private static final String PAGE_VIEW_TOPIC = PAGE_VIEWS_PROVIDER.topicName();\n+  private static final String PAGE_VIEW_STREAM = PAGE_VIEWS_PROVIDER.kstreamName();\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG,\n+          \"http://localhost:8088,https://localhost:8089\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzE0NA=="}, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjEzNTA0OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1OToyOFrOGFlE1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowNzoxN1rOGFuczg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzUxMQ==", "bodyText": "Not directly related to this PR, but is it common practice to ignore exceptions on close? I would've expected to at least log the exception?", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408503511", "createdAt": "2020-04-14T23:59:28Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -43,75 +42,42 @@\n     JsonMapper.INSTANCE.mapper.registerModule(new KsqlTypesDeserializationModule(false));\n   }\n \n-  public static final String DISABLE_HOSTNAME_VERIFICATION_PROP_NAME\n-      = \"ksql.client.disable.hostname.verification\";\n-  public static final String TLS_ENABLED_PROP_NAME = \"ksql.client.enable.tls\";\n-\n   private final Vertx vertx;\n-  private final HttpClient httpClient;\n+  private final HttpClient httpNonTlsClient;\n+  private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n-  private final boolean isTls;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n       final HttpClientOptions httpClientOptions\n   ) {\n-    this(Vertx.vertx(), clientProps, credentials, localProperties, httpClientOptions);\n-  }\n-\n-  @VisibleForTesting\n-  KsqlClient(\n-      final HttpClient httpClient,\n-      final boolean isTls,\n-      final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n-  ) {\n-    this(null, httpClient, isTls, credentials, localProperties);\n-  }\n-\n-  private KsqlClient(\n-      final Vertx vertx,\n-      final HttpClient httpClient,\n-      final boolean isTls,\n-      final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n-  ) {\n-    this.vertx = vertx;\n-    this.httpClient = Objects.requireNonNull(httpClient, \"httpClient\");\n-    this.isTls = isTls;\n+    this.vertx = Vertx.vertx();\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n-  }\n-\n-  private KsqlClient(\n-      final Vertx vertx,\n-      final Map<String, String> clientProps,\n-      final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n-  ) {\n-    this(vertx, createHttpClient(vertx, clientProps, httpClientOptions), httpClientOptions.isSsl(),\n-        credentials, localProperties);\n+    this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n+    this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n   public KsqlTarget target(final URI server) {\n     final boolean isUriTls = server.getScheme().equalsIgnoreCase(\"https\");\n-    if (isTls != isUriTls) {\n-      throw new KsqlRestClientException(\"Cannot make request with scheme \" + server.getScheme()\n-          + \" as client is configured \" + (isTls ? \"with\" : \"without\") + \" tls\");\n-    }\n-    return new KsqlTarget(httpClient,\n+    final HttpClient client = isUriTls ? httpTlsClient : httpNonTlsClient;\n+    return new KsqlTarget(client,\n         SocketAddress.inetSocketAddress(server.getPort(), server.getHost()), localProperties,\n         basicAuthHeader);\n   }\n \n   public void close() {\n     try {\n-      httpClient.close();\n+      httpTlsClient.close();\n+    } catch (Exception ignore) {\n+      // Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NzEwMg==", "bodyText": "It's a pretty common approach if you want a clean close.", "url": "https://github.com/confluentinc/ksql/pull/5059#discussion_r408657102", "createdAt": "2020-04-15T08:07:17Z", "author": {"login": "purplefox"}, "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -43,75 +42,42 @@\n     JsonMapper.INSTANCE.mapper.registerModule(new KsqlTypesDeserializationModule(false));\n   }\n \n-  public static final String DISABLE_HOSTNAME_VERIFICATION_PROP_NAME\n-      = \"ksql.client.disable.hostname.verification\";\n-  public static final String TLS_ENABLED_PROP_NAME = \"ksql.client.enable.tls\";\n-\n   private final Vertx vertx;\n-  private final HttpClient httpClient;\n+  private final HttpClient httpNonTlsClient;\n+  private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n-  private final boolean isTls;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n       final HttpClientOptions httpClientOptions\n   ) {\n-    this(Vertx.vertx(), clientProps, credentials, localProperties, httpClientOptions);\n-  }\n-\n-  @VisibleForTesting\n-  KsqlClient(\n-      final HttpClient httpClient,\n-      final boolean isTls,\n-      final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n-  ) {\n-    this(null, httpClient, isTls, credentials, localProperties);\n-  }\n-\n-  private KsqlClient(\n-      final Vertx vertx,\n-      final HttpClient httpClient,\n-      final boolean isTls,\n-      final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n-  ) {\n-    this.vertx = vertx;\n-    this.httpClient = Objects.requireNonNull(httpClient, \"httpClient\");\n-    this.isTls = isTls;\n+    this.vertx = Vertx.vertx();\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n-  }\n-\n-  private KsqlClient(\n-      final Vertx vertx,\n-      final Map<String, String> clientProps,\n-      final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n-  ) {\n-    this(vertx, createHttpClient(vertx, clientProps, httpClientOptions), httpClientOptions.isSsl(),\n-        credentials, localProperties);\n+    this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n+    this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n   public KsqlTarget target(final URI server) {\n     final boolean isUriTls = server.getScheme().equalsIgnoreCase(\"https\");\n-    if (isTls != isUriTls) {\n-      throw new KsqlRestClientException(\"Cannot make request with scheme \" + server.getScheme()\n-          + \" as client is configured \" + (isTls ? \"with\" : \"without\") + \" tls\");\n-    }\n-    return new KsqlTarget(httpClient,\n+    final HttpClient client = isUriTls ? httpTlsClient : httpNonTlsClient;\n+    return new KsqlTarget(client,\n         SocketAddress.inetSocketAddress(server.getPort(), server.getHost()), localProperties,\n         basicAuthHeader);\n   }\n \n   public void close() {\n     try {\n-      httpClient.close();\n+      httpTlsClient.close();\n+    } catch (Exception ignore) {\n+      // Ignore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzUxMQ=="}, "originalCommit": {"oid": "a61e3cbf590a4ca01ff17ea4daafd44546f0952a"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3555, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}