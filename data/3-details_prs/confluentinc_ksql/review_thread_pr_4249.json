{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNTIyMzY1", "number": 4249, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNDozOToyM1rODWvN-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNDo0OTozNlrODWvR-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTY4ODg4OnYy", "diffSide": "RIGHT", "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNDozOToyM1rOFbqxjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNDowNDozOVrOFb22yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1NjY4Ng==", "bodyText": "What is this argument that controls whether to fail on error? Is this documented somewhere?", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364556686", "createdAt": "2020-01-09T04:39:23Z", "author": {"login": "vcrfxia"}, "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -192,20 +192,26 @@ public void setUp(final SchemaAndGenericRowState rowState) {\n     }\n   }\n \n+  @SuppressWarnings(\"MethodMayBeStatic\") // Tests can not be static\n   @Benchmark\n   public byte[] serialize(final SerdeState serdeState) {\n     return serdeState.serializer.serialize(TOPIC_NAME, serdeState.row);\n   }\n \n+  @SuppressWarnings(\"MethodMayBeStatic\") // Tests can not be static\n   @Benchmark\n   public GenericRow deserialize(final SerdeState serdeState) {\n     return serdeState.deserializer.deserialize(TOPIC_NAME, serdeState.bytes);\n   }\n \n-  public static void main(final String[] args) throws RunnerException {\n-    final Options opt = new OptionsBuilder()\n-        .include(SerdeBenchmark.class.getSimpleName())\n-        .build();\n+  public static void main(final String[] args) throws Exception {\n+\n+    final Options opt = args.length != 0\n+        ? new CommandLineOptions(args)\n+        : new OptionsBuilder()\n+            .include(SerdeBenchmark.class.getSimpleName())\n+            .shouldFailOnError(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc1NDYzNQ==", "bodyText": "Not sure where it's documented. Just means if the code under test throws exceptions it fails, which is what we want.", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364754635", "createdAt": "2020-01-09T14:04:39Z", "author": {"login": "big-andy-coates"}, "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -192,20 +192,26 @@ public void setUp(final SchemaAndGenericRowState rowState) {\n     }\n   }\n \n+  @SuppressWarnings(\"MethodMayBeStatic\") // Tests can not be static\n   @Benchmark\n   public byte[] serialize(final SerdeState serdeState) {\n     return serdeState.serializer.serialize(TOPIC_NAME, serdeState.row);\n   }\n \n+  @SuppressWarnings(\"MethodMayBeStatic\") // Tests can not be static\n   @Benchmark\n   public GenericRow deserialize(final SerdeState serdeState) {\n     return serdeState.deserializer.deserialize(TOPIC_NAME, serdeState.bytes);\n   }\n \n-  public static void main(final String[] args) throws RunnerException {\n-    final Options opt = new OptionsBuilder()\n-        .include(SerdeBenchmark.class.getSimpleName())\n-        .build();\n+  public static void main(final String[] args) throws Exception {\n+\n+    final Options opt = args.length != 0\n+        ? new CommandLineOptions(args)\n+        : new OptionsBuilder()\n+            .include(SerdeBenchmark.class.getSimpleName())\n+            .shouldFailOnError(true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1NjY4Ng=="}, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTY5ODM3OnYy", "diffSide": "RIGHT", "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNDo0ODo1NVrOFbq3bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxODozOTowNFrOFb_n_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODE4OQ==", "bodyText": "I've also increased the times on the SerdeBenchmark, as from my own experience 10 seconds is not enough time for the JVM to optimise the byte code.\n\nPardon the naivete, but isn't the point of using JMH to avoid optimizations? Why are we trying to allow the JVM time to perform optimizations? Wouldn't that be less representative of how these segments of code are used in practice?", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364558189", "createdAt": "2020-01-09T04:48:55Z", "author": {"login": "vcrfxia"}, "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -68,8 +68,8 @@\n  */\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations = 3, time = 10)\n-@Measurement(iterations = 3, time = 10)\n+@Warmup(iterations = 6, time = 30)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc1NTI5Nw==", "bodyText": "Not at all. We want to JVM to be given time to optimise the code. That's what the warm-up is all about. When KSQL is running in production it will be running for a long time and the JVM will optimise such code paths. So a meaningful benchmark needs to give the JVM time to do this before running tests.", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364755297", "createdAt": "2020-01-09T14:05:59Z", "author": {"login": "big-andy-coates"}, "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -68,8 +68,8 @@\n  */\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations = 3, time = 10)\n-@Measurement(iterations = 3, time = 10)\n+@Warmup(iterations = 6, time = 30)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODE4OQ=="}, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5ODMwMg==", "bodyText": "Perhaps my understanding gap is in JVM optimizations, then. It's true that when KSQL is running in production the JVM will have time to optimize this code, but KSQL running in production wouldn't just be running this serde code over and over again. Intuitively it feels like the JVM would be able to make stronger optimizations on the serde code if that's all that's being run, compared to the the serde code being run as part of other KSQL code. Is this not true / not a concern for benchmarking?", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364898302", "createdAt": "2020-01-09T18:39:04Z", "author": {"login": "vcrfxia"}, "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -68,8 +68,8 @@\n  */\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations = 3, time = 10)\n-@Measurement(iterations = 3, time = 10)\n+@Warmup(iterations = 6, time = 30)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODE4OQ=="}, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTY5OTEzOnYy", "diffSide": "RIGHT", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNDo0OTozNlrOFbq35g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNDowNjowOVrOFb25uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODMxMA==", "bodyText": "Very cool! I spent some time thinking about how to implement this and didn't come up with anything nearly as nice. Glad to have had the opportunity to learn from you :)", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364558310", "createdAt": "2020-01-09T04:49:36Z", "author": {"login": "vcrfxia"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "diffHunk": "@@ -82,55 +84,53 @@ public KsqlJsonDeserializer(\n   }\n \n   @Override\n-  public void configure(final Map<String, ?> map, final boolean b) {\n+  public void configure(final Map<String, ?> map, final boolean isKey) {\n+    this.target = isKey ? \"key\" : \"value\";\n   }\n \n   @Override\n   public Object deserialize(final String topic, final byte[] bytes) {\n     try {\n-      final Object value = deserialize(bytes);\n+      final JsonNode value = bytes == null\n+          ? null\n+          : MAPPER.readTree(bytes);\n+\n+      final Object coerced = enforceFieldType(\n+          \"$\",\n+          new JsonValueContext(value, physicalSchema.serializedSchema())\n+      );\n+\n       if (LOG.isTraceEnabled()) {\n-        LOG.trace(\"Deserialized value. topic:{}, row:{}\", topic, value);\n+        LOG.trace(\"Deserialized {}. topic:{}, row:{}\", target, topic, coerced);\n       }\n-      return value;\n+\n+      return coerced;\n     } catch (final Exception e) {\n       throw new SerializationException(\n-          \"Error deserializing JSON message from topic: \" + topic, e);\n-    }\n-  }\n-\n-  private Object deserialize(final byte[] bytes) {\n-    try {\n-      if (bytes == null) {\n-        return null;\n-      }\n-\n-      final JsonNode value = MAPPER.readTree(bytes);\n-      return enforceFieldType(this, physicalSchema.serializedSchema(), value);\n-    } catch (final IOException e) {\n-      throw new SerializationException(e);\n+          \"mvn \" + target + \" from topic: \" + topic, e);\n     }\n   }\n \n   private static Object enforceFieldType(\n-      final KsqlJsonDeserializer deserializer,\n-      final Schema schema,\n-      final JsonNode columnVal\n+      final String pathPart,\n+      final JsonValueContext context\n   ) {\n-    return enforceFieldType(new JsonValueContext(deserializer, schema, columnVal));\n-  }\n-\n-  private static Object enforceFieldType(final JsonValueContext context) {\n     if (context.val == null || context.val instanceof NullNode) {\n       return null;\n     }\n \n-    final Function<JsonValueContext, Object> handler = HANDLERS.getOrDefault(\n-        context.schema.type(),\n-        type -> {\n-          throw new KsqlException(\"Type is not supported: \" + type);\n-        });\n-    return handler.apply(context);\n+    try {\n+      final Function<JsonValueContext, Object> handler = HANDLERS.getOrDefault(\n+          context.schema.type(),\n+          type -> {\n+            throw new KsqlException(\"Type is not supported: \" + type);\n+          });\n+      return handler.apply(context);\n+    } catch (final CoercionException e) {\n+      throw new CoercionException(e.getRawMessage(), pathPart + e.getPath(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc1NTM4Nw==", "bodyText": ":)", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364755387", "createdAt": "2020-01-09T14:06:09Z", "author": {"login": "big-andy-coates"}, "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "diffHunk": "@@ -82,55 +84,53 @@ public KsqlJsonDeserializer(\n   }\n \n   @Override\n-  public void configure(final Map<String, ?> map, final boolean b) {\n+  public void configure(final Map<String, ?> map, final boolean isKey) {\n+    this.target = isKey ? \"key\" : \"value\";\n   }\n \n   @Override\n   public Object deserialize(final String topic, final byte[] bytes) {\n     try {\n-      final Object value = deserialize(bytes);\n+      final JsonNode value = bytes == null\n+          ? null\n+          : MAPPER.readTree(bytes);\n+\n+      final Object coerced = enforceFieldType(\n+          \"$\",\n+          new JsonValueContext(value, physicalSchema.serializedSchema())\n+      );\n+\n       if (LOG.isTraceEnabled()) {\n-        LOG.trace(\"Deserialized value. topic:{}, row:{}\", topic, value);\n+        LOG.trace(\"Deserialized {}. topic:{}, row:{}\", target, topic, coerced);\n       }\n-      return value;\n+\n+      return coerced;\n     } catch (final Exception e) {\n       throw new SerializationException(\n-          \"Error deserializing JSON message from topic: \" + topic, e);\n-    }\n-  }\n-\n-  private Object deserialize(final byte[] bytes) {\n-    try {\n-      if (bytes == null) {\n-        return null;\n-      }\n-\n-      final JsonNode value = MAPPER.readTree(bytes);\n-      return enforceFieldType(this, physicalSchema.serializedSchema(), value);\n-    } catch (final IOException e) {\n-      throw new SerializationException(e);\n+          \"mvn \" + target + \" from topic: \" + topic, e);\n     }\n   }\n \n   private static Object enforceFieldType(\n-      final KsqlJsonDeserializer deserializer,\n-      final Schema schema,\n-      final JsonNode columnVal\n+      final String pathPart,\n+      final JsonValueContext context\n   ) {\n-    return enforceFieldType(new JsonValueContext(deserializer, schema, columnVal));\n-  }\n-\n-  private static Object enforceFieldType(final JsonValueContext context) {\n     if (context.val == null || context.val instanceof NullNode) {\n       return null;\n     }\n \n-    final Function<JsonValueContext, Object> handler = HANDLERS.getOrDefault(\n-        context.schema.type(),\n-        type -> {\n-          throw new KsqlException(\"Type is not supported: \" + type);\n-        });\n-    return handler.apply(context);\n+    try {\n+      final Function<JsonValueContext, Object> handler = HANDLERS.getOrDefault(\n+          context.schema.type(),\n+          type -> {\n+            throw new KsqlException(\"Type is not supported: \" + type);\n+          });\n+      return handler.apply(context);\n+    } catch (final CoercionException e) {\n+      throw new CoercionException(e.getRawMessage(), pathPart + e.getPath(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODMxMA=="}, "originalCommit": {"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2197, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}