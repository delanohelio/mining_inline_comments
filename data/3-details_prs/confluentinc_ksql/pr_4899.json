{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODk3MTg2", "number": 4899, "title": "chore: add GROUP BY support for any key names", "bodyText": "Description\nfixes: #4898\nThis commit sees the result of a GROUP BY on a single column reference have a schema with a key column matching the name of the column, e.g.\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) AS COUNT FROM INPUT GROUP BY B;\n-- output schema: B -> COUNT\nIf the GROUP BY is on anything other than a single column reference then the key column will be a unique generated column name, e.g.\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) FROM INPUT GROUP BY B+1;\n-- output schema: KSQL_COL_1 -> KSQL_COL_0  (Both names are generated)\nBREAKING CHANGE: Existing queries that reference a single GROUP BY column in the projection would fail if they were resubmitted, due to a duplicate column. The same existing queries will continue to run if already running, i.e. this is only a change for newly submitted queries. Existing queries will use the old query semantics.\nThis PR also includes an change to the internals of how GROUP BY is handled: the name of the columns from the source in the repartition and changelog topics had names like KSQL_INTERNAL_COL_0 etc.  With this source columns retain their original names within the internal topics.  Names such as KSQL_INTERNAL_COL_0 are used only for additional columns used to track UDAF parameters.   This change is fully backwards compatible, as the plan stores the column names used in the internal topics. However, the change has meant a whole load of new historical plans needed to be generated.\nTesting done\nusual\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-03-26T00:46:11Z", "url": "https://github.com/confluentinc/ksql/pull/4899", "merged": true, "mergeCommit": {"oid": "e7cbdfcc8c9853e2ae6dfcaf670e04f07ccd5444"}, "closed": true, "closedAt": "2020-03-27T10:18:03Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRh3fEAH2gAyMzkzODk3MTg2OjdiMGEyZTBmMDg5MGVlNjM1NjUzYTQ0OGNjMjkyNTQ2MDZkODhlMzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRiFT1AFqTM4MjM4NzAwOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7b0a2e0f0890ee635653a448cc29254606d88e34", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/7b0a2e0f0890ee635653a448cc29254606d88e34", "committedDate": "2020-03-26T20:10:16Z", "message": "chore: add GROUP BY support for any key names\n\nfixes: #4898\n\nThis commit sees the result of a GROUP BY on a single column reference have a schema with a key column matching the name of the column, e.g.\n\n```sql\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) AS COUNT FROM INPUT GROUP BY B;\n-- output schema: B -> COUNT\n```\n\nIf the GROUP BY is on anything other than a single column reference then the key column will be a unique generated column name, e.g.\n\n```sql\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) FROM INPUT GROUP BY B+1;\n-- output schema: KSQL_COL_1 -> KSQL_COL_0  (Both names are generated)\n```\n\nBREAKING CHANGE: Existing queries that reference a single GROUP BY column in the projection would fail if they were resubmitted, due to a duplicate column. The same existing queries will continue to run if already running, i.e. this is only a change for newly submitted queries. Existing queries will use the old query semantics."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "467ffa30c273b615b0f13ce5da86bded1be443d8", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/467ffa30c273b615b0f13ce5da86bded1be443d8", "committedDate": "2020-03-26T20:10:42Z", "message": "test: add the historical plans"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b5312d6c4df97a19b62b5e5bee87165b3e8a592", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/confluentinc/ksql/commit/1b5312d6c4df97a19b62b5e5bee87165b3e8a592", "committedDate": "2020-03-26T00:41:12Z", "message": "chore: add GROUP BY support for any key names\n\nfixes: https://github.com/confluentinc/ksql/issues/4898\n\nThis commit sees the result of a GROUP BY on a single column reference have a schema with a key column matching the name of the column, e.g.\n\n```sql\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) AS COUNT FROM INPUT GROUP BY B;\n-- output schema: B -> COUNT\n```\n\nIf the GROUP BY is on anything other than a single column reference then the key column will be a unique generated column name, e.g.\n\n```sql\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) FROM INPUT GROUP BY B+1;\n-- output schema: KSQL_COL_1 -> KSQL_COL_0  (Both names are generated)\n```\n\nBREAKING CHANGE: Existing queries that reference a single GROUP BY column in the projection would fail if they were resubmitted, due to a duplicate column. The same existing queries will continue to run if already running, i.e. this is only a change for newly submitted queries. Existing queries will use the old query semantics."}, "afterCommit": {"oid": "467ffa30c273b615b0f13ce5da86bded1be443d8", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/467ffa30c273b615b0f13ce5da86bded1be443d8", "committedDate": "2020-03-26T20:10:42Z", "message": "test: add the historical plans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMzg3MDA4", "url": "https://github.com/confluentinc/ksql/pull/4899#pullrequestreview-382387008", "createdAt": "2020-03-26T20:23:54Z", "commit": {"oid": "7b0a2e0f0890ee635653a448cc29254606d88e34"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDoyMzo1NVrOF8Y9eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDoyMzo1NVrOF8Y9eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2NzgzNA==", "bodyText": "\ud83d\udc4e that is an abuse of Optional. Just making my opinion known, but as it's a style thing feel free to ignore me", "url": "https://github.com/confluentinc/ksql/pull/4899#discussion_r398867834", "createdAt": "2020-03-26T20:23:55Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "diffHunk": "@@ -44,48 +50,72 @@ private GroupByParamsFactory() {\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions\n+      final List<ExpressionMetadata> groupBys,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return expressions.size() == 1\n-        ? singleExpressionSchema(sourceSchema, expressions.get(0).getExpressionType())\n-        : multiExpressionSchema(sourceSchema);\n+    return groupBys.size() == 1\n+        ? singleExpressionSchema(sourceSchema, groupBys.get(0), ksqlConfig)\n+        : multiExpressionSchema(sourceSchema, ksqlConfig);\n   }\n \n   public static GroupByParams build(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions,\n-      final ProcessingLogger logger\n+      final List<ExpressionMetadata> groupBys,\n+      final ProcessingLogger logger,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    final Function<GenericRow, Struct> mapper = expressions.size() == 1\n-        ? new SingleExpressionGrouper(expressions.get(0), logger)::apply\n-        : new MultiExpressionGrouper(expressions, logger)::apply;\n+    if (groupBys.isEmpty()) {\n+      throw new IllegalArgumentException(\"No GROUP BY groupBys\");\n+    }\n \n-    final LogicalSchema schema = buildSchema(sourceSchema, expressions);\n+    final Function<GenericRow, Struct> mapper = groupBys.size() == 1\n+        ? new SingleExpressionGrouper(groupBys.get(0), logger)::apply\n+        : new MultiExpressionGrouper(groupBys, logger)::apply;\n+\n+    final LogicalSchema schema = buildSchema(sourceSchema, groupBys, ksqlConfig);\n \n     return new GroupByParams(schema, mapper);\n   }\n \n   private static LogicalSchema multiExpressionSchema(\n-      final LogicalSchema sourceSchema\n+      final LogicalSchema sourceSchema,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, SqlTypes.STRING);\n+    return buildSchemaWithKeyType(sourceSchema, Optional.empty(), SqlTypes.STRING, ksqlConfig);\n   }\n \n   private static LogicalSchema singleExpressionSchema(\n       final LogicalSchema sourceSchema,\n-      final SqlType keyType\n+      final ExpressionMetadata groupBy,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, keyType);\n+    final SqlType keyType = groupBy.getExpressionType();\n+\n+    final Optional<ColumnName> singleColumnName = Optional.of(groupBy.getExpression())\n+        .filter(colRef -> ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED))\n+        .filter(gb -> gb instanceof ColumnReferenceExp)\n+        .map(ColumnReferenceExp.class::cast)\n+        .map(ColumnReferenceExp::getColumnName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b0a2e0f0890ee635653a448cc29254606d88e34"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4928, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}