{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Nzc1ODkw", "number": 5198, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo0OTozMlrOD3HVsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo1MjozN1rOD3HaGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTE4NTE1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo0OTozMlrOGNL-bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo0OTozMlrOGNL-bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MDg3Ng==", "bodyText": "Is it worth parsing once, and failing early, rather than on each call?  Or is this not really an issue?", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416480876", "createdAt": "2020-04-28T09:49:32Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTE4NzMwOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo1MDoxM1rOGNL_4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo1MDoxM1rOGNL_4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTI0OQ==", "bodyText": "This method is getting large - consider moving this code into its own function?", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416481249", "createdAt": "2020-04-28T09:50:13Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+    } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n+      final SqlType sqlType;\n+      try {\n+        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n+      } catch (final Exception e) {\n+        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n+            + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n+      }\n+      schemaProvider = args -> sqlType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTE5NjQyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo1MjozN1rOGNMFgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjowOToyMlrOGNbzFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MjY4OA==", "bodyText": "Either a schema or schemaProvider is required, right?\n... and users may find 'schema annotation;' confusing, given the 'schema' is the name of a property of the annotation, not the name of the annotation.\nMaybe:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n          \n          \n            \n                        + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n          \n          \n            \n                    throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n          \n          \n            \n                        + javaReturnSchema + \" return type is not supported without either a schema or schemaProvider set in the annotation.\");\n          \n      \n    \n    \n  \n\nThough even better would be to pass down the type of the annotation so that the error could be explicit and say set in the @Udf annotation, or in the @Udtf annotation etc.", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416482688", "createdAt": "2020-04-28T09:52:37Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+    } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n+      final SqlType sqlType;\n+      try {\n+        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n+      } catch (final Exception e) {\n+        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n+            + javaReturnSchema + \" return type is not supported without a schema annotation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MDExNg==", "bodyText": "I changed the error to clarify, but did not pass down the annotation. I think it's clear enough without it :)", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416740116", "createdAt": "2020-04-28T16:09:22Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+    } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n+      final SqlType sqlType;\n+      try {\n+        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n+      } catch (final Exception e) {\n+        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n+            + javaReturnSchema + \" return type is not supported without a schema annotation.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MjY4OA=="}, "originalCommit": {"oid": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3488, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}