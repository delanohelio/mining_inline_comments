{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNTUzMzIy", "number": 4270, "title": "Fix building select widgets", "bodyText": "What has been done to verify that this works as intended?\nI used the form mentioned below and added automated tests.\nWhy is this the best possible solution? Were any other approaches considered?\nIt's a follow up pr which fixes rest of the cases to allow mixing different select appearances. Cases that this pr fixes are marked in yellow https://docs.google.com/spreadsheets/d/1uA6NeUbE51WACiKUjErFUxYFeJdGGWglNGKivuzei7I/edit?usp=sharing\nHow does this change affect users? Describe intentional changes to behavior and behavior that could have accidentally been affected by code changes. In other words, what are the regression risks?\nIt fixes cases that were marked in red in the form mentioned below. I find this fix pretty safe so using the attached form for testing would be enough.\nDo we need any specific form for testing your changes? If so, please attach one.\nhttps://docs.google.com/spreadsheets/d/1uA6NeUbE51WACiKUjErFUxYFeJdGGWglNGKivuzei7I/edit?usp=sharing\nDoes this change require updates to documentation? If so, please file an issue here and include the link below.\nNo.\nBefore submitting this PR, please make sure you have:\n\n run ./gradlew checkAll and confirmed all checks still pass OR confirm CircleCI build passes and run ./gradlew connectedDebugAndroidTest locally.\n verified that any code or assets from external sources are properly credited in comments and/or in the about file.\n verified that any new UI elements use theme colors. UI Components Style guidelines", "createdAt": "2020-12-04T14:01:35Z", "url": "https://github.com/getodk/collect/pull/4270", "merged": true, "mergeCommit": {"oid": "bf818f6e090ca6db19ce553bbf2dea5342f992fa"}, "closed": true, "closedAt": "2021-01-19T11:10:49Z", "author": {"login": "grzesiek2010"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdi2X5RAH2gAyNTMyNTUzMzIyOmUxMmJlZWI5MTgwZjU1YTc4OWM3Y2E4ZGE0YzA4NmIzOTIzNTQ4MWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdv2efNgFqTU2NzY2NDQ0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e12beeb9180f55a789c7ca8da4c086b39235481c", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/e12beeb9180f55a789c7ca8da4c086b39235481c", "committedDate": "2020-12-04T11:51:38Z", "message": "Fixed building select widgets"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "465eb9454539f1fe84b720de2d32c318883473b4", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/465eb9454539f1fe84b720de2d32c318883473b4", "committedDate": "2020-12-04T13:45:12Z", "message": "Added tests"}, "afterCommit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/afbe45cd6e00c35d8e34a587858591d09f61d1d7", "committedDate": "2020-12-04T14:01:21Z", "message": "Added tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjMzNDg0", "url": "https://github.com/getodk/collect/pull/4270#pullrequestreview-545233484", "createdAt": "2020-12-04T19:19:40Z", "commit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToxOTo0MFrOH_etaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToyNTo0NlrOH_e50g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNTQ4MQ==", "bodyText": "This comment should be removed. The documentation at https://xlsform.org/en/#dynamic-selects-from-pre-loaded-data also states that the search() appearance needs to come last and that can be updated.", "url": "https://github.com/getodk/collect/pull/4270#discussion_r536325481", "createdAt": "2020-12-04T19:19:40Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/widgets/WidgetFactory.java", "diffHunk": "@@ -205,13 +205,13 @@ public QuestionWidget createWidgetFromPrompt(FormEntryPrompt prompt) {\n                 // This means normal appearances should be put before search().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNzQwNg==", "bodyText": "This is a pretty bad case with two data sources. External itemsets \"win\" because they're first? Since this test is not about the two data source weirdness, I would strongly suggest removing it and just having either an external select or a search() select.", "url": "https://github.com/getodk/collect/pull/4270#discussion_r536327406", "createdAt": "2020-12-04T19:23:31Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/widgets/WidgetFactoryTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+package org.odk.collect.android.widgets;\n+\n+import android.app.Activity;\n+\n+import org.javarosa.core.model.Constants;\n+import org.javarosa.core.model.QuestionDef;\n+import org.javarosa.form.api.FormEntryPrompt;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.support.MockFormEntryPromptBuilder;\n+import org.odk.collect.android.support.RobolectricHelpers;\n+import org.odk.collect.android.support.TestScreenContextActivity;\n+import org.odk.collect.android.utilities.ActivityAvailability;\n+import org.odk.collect.android.utilities.QuestionMediaManager;\n+import org.odk.collect.android.widgets.items.LabelWidget;\n+import org.odk.collect.android.widgets.items.LikertWidget;\n+import org.odk.collect.android.widgets.items.ListMultiWidget;\n+import org.odk.collect.android.widgets.items.ListWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiImageMapWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiMinimalWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiWidget;\n+import org.odk.collect.android.widgets.items.SelectOneImageMapWidget;\n+import org.odk.collect.android.widgets.items.SelectOneMinimalWidget;\n+import org.odk.collect.android.widgets.items.SelectOneWidget;\n+import org.odk.collect.android.widgets.support.FakeQuestionMediaManager;\n+import org.odk.collect.android.widgets.support.FakeWaitingForDataRegistry;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class WidgetFactoryTest {\n+    private WidgetFactory widgetFactory;\n+\n+    @Before\n+    public void setup() {\n+        Activity activity = RobolectricHelpers.buildThemedActivity(TestScreenContextActivity.class).get();\n+        WaitingForDataRegistry waitingForDataRegistry = new FakeWaitingForDataRegistry();\n+        QuestionMediaManager questionMediaManager = new FakeQuestionMediaManager();\n+        ActivityAvailability activityAvailability = mock(ActivityAvailability.class);\n+\n+        widgetFactory = new WidgetFactory(activity,\n+                false,\n+                false,\n+                waitingForDataRegistry,\n+                questionMediaManager,\n+                null,\n+                null,\n+                activityAvailability,\n+                null);\n+    }\n+\n+    @Test\n+    public void testCreatingSelectOneMinimalWidgetWithFastExternalChoices() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyODAyNA==", "bodyText": "Same comment as above. Why use two external data features? If this is about verifying that appearances after search() are honored, no need to also have it be an external select.", "url": "https://github.com/getodk/collect/pull/4270#discussion_r536328024", "createdAt": "2020-12-04T19:24:34Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/widgets/WidgetFactoryTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+package org.odk.collect.android.widgets;\n+\n+import android.app.Activity;\n+\n+import org.javarosa.core.model.Constants;\n+import org.javarosa.core.model.QuestionDef;\n+import org.javarosa.form.api.FormEntryPrompt;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.support.MockFormEntryPromptBuilder;\n+import org.odk.collect.android.support.RobolectricHelpers;\n+import org.odk.collect.android.support.TestScreenContextActivity;\n+import org.odk.collect.android.utilities.ActivityAvailability;\n+import org.odk.collect.android.utilities.QuestionMediaManager;\n+import org.odk.collect.android.widgets.items.LabelWidget;\n+import org.odk.collect.android.widgets.items.LikertWidget;\n+import org.odk.collect.android.widgets.items.ListMultiWidget;\n+import org.odk.collect.android.widgets.items.ListWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiImageMapWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiMinimalWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiWidget;\n+import org.odk.collect.android.widgets.items.SelectOneImageMapWidget;\n+import org.odk.collect.android.widgets.items.SelectOneMinimalWidget;\n+import org.odk.collect.android.widgets.items.SelectOneWidget;\n+import org.odk.collect.android.widgets.support.FakeQuestionMediaManager;\n+import org.odk.collect.android.widgets.support.FakeWaitingForDataRegistry;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class WidgetFactoryTest {\n+    private WidgetFactory widgetFactory;\n+\n+    @Before\n+    public void setup() {\n+        Activity activity = RobolectricHelpers.buildThemedActivity(TestScreenContextActivity.class).get();\n+        WaitingForDataRegistry waitingForDataRegistry = new FakeWaitingForDataRegistry();\n+        QuestionMediaManager questionMediaManager = new FakeQuestionMediaManager();\n+        ActivityAvailability activityAvailability = mock(ActivityAvailability.class);\n+\n+        widgetFactory = new WidgetFactory(activity,\n+                false,\n+                false,\n+                waitingForDataRegistry,\n+                questionMediaManager,\n+                null,\n+                null,\n+                activityAvailability,\n+                null);\n+    }\n+\n+    @Test\n+    public void testCreatingSelectOneMinimalWidgetWithFastExternalChoices() {\n+        QuestionDef questionDef = mock(QuestionDef.class);\n+        when(questionDef.getAdditionalAttribute(null, \"query\")).thenReturn(\"instance('counties')/root/item[state= /data/state ]\");\n+\n+        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n+                .withControlType(Constants.CONTROL_INPUT)\n+                .withDataType(Constants.DATATYPE_TEXT)\n+                .withQuestion(questionDef)\n+                .withAppearance(\"search(\u2018items\u2019) LisT miNimal something\")\n+                .build();\n+\n+        QuestionWidget widget = widgetFactory.createWidgetFromPrompt(prompt);\n+        assertThat(widget, instanceOf(SelectOneMinimalWidget.class));\n+    }\n+\n+    @Test\n+    public void testCreatingLikertWidgetWithFastExternalChoices() {\n+        QuestionDef questionDef = mock(QuestionDef.class);\n+        when(questionDef.getAdditionalAttribute(null, \"query\")).thenReturn(\"instance('counties')/root/item[state= /data/state ]\");\n+\n+        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n+                .withControlType(Constants.CONTROL_INPUT)\n+                .withDataType(Constants.DATATYPE_TEXT)\n+                .withQuestion(questionDef)\n+                .withAppearance(\"search(\u2018items\u2019) LisT lIkErt something\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyODY1OA==", "bodyText": "These are really impractical appearance combinations. If you have a big enough dataset to user an external data file, why would you be building a grid?", "url": "https://github.com/getodk/collect/pull/4270#discussion_r536328658", "createdAt": "2020-12-04T19:25:46Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/widgets/WidgetFactoryTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+package org.odk.collect.android.widgets;\n+\n+import android.app.Activity;\n+\n+import org.javarosa.core.model.Constants;\n+import org.javarosa.core.model.QuestionDef;\n+import org.javarosa.form.api.FormEntryPrompt;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.support.MockFormEntryPromptBuilder;\n+import org.odk.collect.android.support.RobolectricHelpers;\n+import org.odk.collect.android.support.TestScreenContextActivity;\n+import org.odk.collect.android.utilities.ActivityAvailability;\n+import org.odk.collect.android.utilities.QuestionMediaManager;\n+import org.odk.collect.android.widgets.items.LabelWidget;\n+import org.odk.collect.android.widgets.items.LikertWidget;\n+import org.odk.collect.android.widgets.items.ListMultiWidget;\n+import org.odk.collect.android.widgets.items.ListWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiImageMapWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiMinimalWidget;\n+import org.odk.collect.android.widgets.items.SelectMultiWidget;\n+import org.odk.collect.android.widgets.items.SelectOneImageMapWidget;\n+import org.odk.collect.android.widgets.items.SelectOneMinimalWidget;\n+import org.odk.collect.android.widgets.items.SelectOneWidget;\n+import org.odk.collect.android.widgets.support.FakeQuestionMediaManager;\n+import org.odk.collect.android.widgets.support.FakeWaitingForDataRegistry;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class WidgetFactoryTest {\n+    private WidgetFactory widgetFactory;\n+\n+    @Before\n+    public void setup() {\n+        Activity activity = RobolectricHelpers.buildThemedActivity(TestScreenContextActivity.class).get();\n+        WaitingForDataRegistry waitingForDataRegistry = new FakeWaitingForDataRegistry();\n+        QuestionMediaManager questionMediaManager = new FakeQuestionMediaManager();\n+        ActivityAvailability activityAvailability = mock(ActivityAvailability.class);\n+\n+        widgetFactory = new WidgetFactory(activity,\n+                false,\n+                false,\n+                waitingForDataRegistry,\n+                questionMediaManager,\n+                null,\n+                null,\n+                activityAvailability,\n+                null);\n+    }\n+\n+    @Test\n+    public void testCreatingSelectOneMinimalWidgetWithFastExternalChoices() {\n+        QuestionDef questionDef = mock(QuestionDef.class);\n+        when(questionDef.getAdditionalAttribute(null, \"query\")).thenReturn(\"instance('counties')/root/item[state= /data/state ]\");\n+\n+        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n+                .withControlType(Constants.CONTROL_INPUT)\n+                .withDataType(Constants.DATATYPE_TEXT)\n+                .withQuestion(questionDef)\n+                .withAppearance(\"search(\u2018items\u2019) LisT miNimal something\")\n+                .build();\n+\n+        QuestionWidget widget = widgetFactory.createWidgetFromPrompt(prompt);\n+        assertThat(widget, instanceOf(SelectOneMinimalWidget.class));\n+    }\n+\n+    @Test\n+    public void testCreatingLikertWidgetWithFastExternalChoices() {\n+        QuestionDef questionDef = mock(QuestionDef.class);\n+        when(questionDef.getAdditionalAttribute(null, \"query\")).thenReturn(\"instance('counties')/root/item[state= /data/state ]\");\n+\n+        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n+                .withControlType(Constants.CONTROL_INPUT)\n+                .withDataType(Constants.DATATYPE_TEXT)\n+                .withQuestion(questionDef)\n+                .withAppearance(\"search(\u2018items\u2019) LisT lIkErt something\")\n+                .build();\n+\n+        QuestionWidget widget = widgetFactory.createWidgetFromPrompt(prompt);\n+        assertThat(widget, instanceOf(LikertWidget.class));\n+    }\n+\n+    @Test\n+    public void testCreatingSelectOneListNoLabelWidgetWithFastExternalChoices() {\n+        QuestionDef questionDef = mock(QuestionDef.class);\n+        when(questionDef.getAdditionalAttribute(null, \"query\")).thenReturn(\"instance('counties')/root/item[state= /data/state ]\");\n+\n+        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n+                .withControlType(Constants.CONTROL_INPUT)\n+                .withDataType(Constants.DATATYPE_TEXT)\n+                .withQuestion(questionDef)\n+                .withAppearance(\"search(\u2018items\u2019) LisT-nOLabeL something\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19e3633f70539531aa70db9f109f7018c60ed607", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/19e3633f70539531aa70db9f109f7018c60ed607", "committedDate": "2021-01-13T16:36:40Z", "message": "Removed redundant comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b88de30c6b8fbb532fba9d7cd00eae78dced610d", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/b88de30c6b8fbb532fba9d7cd00eae78dced610d", "committedDate": "2021-01-13T19:18:03Z", "message": "Added tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afbe45cd6e00c35d8e34a587858591d09f61d1d7", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/afbe45cd6e00c35d8e34a587858591d09f61d1d7", "committedDate": "2020-12-04T14:01:21Z", "message": "Added tests"}, "afterCommit": {"oid": "b88de30c6b8fbb532fba9d7cd00eae78dced610d", "author": {"user": {"login": "grzesiek2010", "name": "Grzegorz Orczykowski"}}, "url": "https://github.com/getodk/collect/commit/b88de30c6b8fbb532fba9d7cd00eae78dced610d", "committedDate": "2021-01-13T19:18:03Z", "message": "Added tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NjY0NDQx", "url": "https://github.com/getodk/collect/pull/4270#pullrequestreview-567664441", "createdAt": "2021-01-13T21:19:51Z", "commit": {"oid": "b88de30c6b8fbb532fba9d7cd00eae78dced610d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2498, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}