{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5MTc0NTU4", "number": 4156, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMToyMDowNlrOErIY9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo0NToyMFrOErPiIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjYxNjg1OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMToyMDowNlrOHdugdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMDo1ODozNlrOHeFSqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkzMjcyNQ==", "bodyText": "This is a fix for another issue https://console.firebase.google.com/u/0/project/api-project-322300403941/crashlytics/app/android:org.odk.collect.android/issues/8bf1ac2f771699358e0237615316760d?time=last-seven-days&versions=v1.28.1%20(3923)&sessionEventKey=5F7C02C1035300012FE4B899DA981953_1458846445087682870", "url": "https://github.com/getodk/collect/pull/4156#discussion_r500932725", "createdAt": "2020-10-07T11:20:06Z", "author": {"login": "grzesiek2010"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -141,7 +141,7 @@ public void stopLocationUpdates() {\n     public Location getLastLocation() {\n         // We need to block if the Client isn't already connected:\n         if (!googleApiClient.isConnected()) {\n-            googleApiClient.blockingConnect();\n+            new Thread(googleApiClient::blockingConnect).start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33228e2a7e483668900cb6f63b018c802636ec01"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3MTE0OQ==", "bodyText": "I'm a little concerned about this. If the client isn't connected, and we spin up a new thread to connect could that cause problems for the call to getLastLocation (as it might happen before the client is connected)?\nAlso, it's likely the testing of this in GoogleFusedLocationClientTest (using a timeout) will be flakey as the call to blockingConnect is now async (and make the behaviour of the method indeterminate).\nCould we maybe pull this fix out of the PR and look at it as a part of a different PR?", "url": "https://github.com/getodk/collect/pull/4156#discussion_r500971149", "createdAt": "2020-10-07T12:28:51Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -141,7 +141,7 @@ public void stopLocationUpdates() {\n     public Location getLastLocation() {\n         // We need to block if the Client isn't already connected:\n         if (!googleApiClient.isConnected()) {\n-            googleApiClient.blockingConnect();\n+            new Thread(googleApiClient::blockingConnect).start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkzMjcyNQ=="}, "originalCommit": {"oid": "33228e2a7e483668900cb6f63b018c802636ec01"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3NTg0NA==", "bodyText": "I tested it hardcoding googleApiClient.disconnect(); just before if (!googleApiClient.isConnected()) { and it didn't cause any crashes. @lognaturel what do you think should we exclude this fix?", "url": "https://github.com/getodk/collect/pull/4156#discussion_r500975844", "createdAt": "2020-10-07T12:36:09Z", "author": {"login": "grzesiek2010"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -141,7 +141,7 @@ public void stopLocationUpdates() {\n     public Location getLastLocation() {\n         // We need to block if the Client isn't already connected:\n         if (!googleApiClient.isConnected()) {\n-            googleApiClient.blockingConnect();\n+            new Thread(googleApiClient::blockingConnect).start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkzMjcyNQ=="}, "originalCommit": {"oid": "33228e2a7e483668900cb6f63b018c802636ec01"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMTA2Mw==", "bodyText": "If we can't block the UI thread, then this code structure doesn't makes sense. That is, like @seadowg says, if you're doing it in a different thread, that thread is blocked, but you still attempt to getLastLocation on the UI thread which could fail if the connection isn't instant. I think you could use CoroutineAndWorkManagerScheduler.immediate(background, foreground). Splitting it off to another PR sounds best to me.", "url": "https://github.com/getodk/collect/pull/4156#discussion_r501131063", "createdAt": "2020-10-07T16:02:24Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -141,7 +141,7 @@ public void stopLocationUpdates() {\n     public Location getLastLocation() {\n         // We need to block if the Client isn't already connected:\n         if (!googleApiClient.isConnected()) {\n-            googleApiClient.blockingConnect();\n+            new Thread(googleApiClient::blockingConnect).start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkzMjcyNQ=="}, "originalCommit": {"oid": "33228e2a7e483668900cb6f63b018c802636ec01"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwNjAyNA==", "bodyText": "Ok I revoked that change.", "url": "https://github.com/getodk/collect/pull/4156#discussion_r501306024", "createdAt": "2020-10-07T20:58:36Z", "author": {"login": "grzesiek2010"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -141,7 +141,7 @@ public void stopLocationUpdates() {\n     public Location getLastLocation() {\n         // We need to block if the Client isn't already connected:\n         if (!googleApiClient.isConnected()) {\n-            googleApiClient.blockingConnect();\n+            new Thread(googleApiClient::blockingConnect).start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkzMjcyNQ=="}, "originalCommit": {"oid": "33228e2a7e483668900cb6f63b018c802636ec01"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzc4NzIxOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo0NToyMFrOHd52CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMDo1Nzo1N1rOHeFRWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExODQ3Mw==", "bodyText": "I think it's possible for a locationListener to be set and googleApiClient not to be connected. In that case, locationListener would not be set to null. I think that's not a good state to be in. Just to be safe, I'd wrap only the removeLocationUpdates call.", "url": "https://github.com/getodk/collect/pull/4156#discussion_r501118473", "createdAt": "2020-10-07T15:45:20Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -120,15 +120,15 @@ public void stop() {\n \n     @SuppressLint(\"MissingPermission\") // Permission checks for location services handled in widgets\n     public void requestLocationUpdates(@NonNull LocationListener locationListener) {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() && googleApiClient.isConnected()) {\n             fusedLocationProviderApi.requestLocationUpdates(googleApiClient, createLocationRequest(), this);\n         }\n \n         this.locationListener = locationListener;\n     }\n \n     public void stopLocationUpdates() {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() || !googleApiClient.isConnected()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3aea167792492b2e3e43ea80d51c5614f29df72"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyMjk4Nw==", "bodyText": "Ah you mean that locationListener won't be cleared in such a case?", "url": "https://github.com/getodk/collect/pull/4156#discussion_r501122987", "createdAt": "2020-10-07T15:51:42Z", "author": {"login": "grzesiek2010"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -120,15 +120,15 @@ public void stop() {\n \n     @SuppressLint(\"MissingPermission\") // Permission checks for location services handled in widgets\n     public void requestLocationUpdates(@NonNull LocationListener locationListener) {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() && googleApiClient.isConnected()) {\n             fusedLocationProviderApi.requestLocationUpdates(googleApiClient, createLocationRequest(), this);\n         }\n \n         this.locationListener = locationListener;\n     }\n \n     public void stopLocationUpdates() {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() || !googleApiClient.isConnected()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExODQ3Mw=="}, "originalCommit": {"oid": "a3aea167792492b2e3e43ea80d51c5614f29df72"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1MjYwNQ==", "bodyText": "Whoops, missed this. Yes, exactly. That means isMonitoringLocation() would evaluate to true even after stopLocationUpdates has been called. I don't know if that really matters currently because I think we only stopLocationUpdates when we're closing out activities but I'd rather not risk it.", "url": "https://github.com/getodk/collect/pull/4156#discussion_r501152605", "createdAt": "2020-10-07T16:33:50Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -120,15 +120,15 @@ public void stop() {\n \n     @SuppressLint(\"MissingPermission\") // Permission checks for location services handled in widgets\n     public void requestLocationUpdates(@NonNull LocationListener locationListener) {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() && googleApiClient.isConnected()) {\n             fusedLocationProviderApi.requestLocationUpdates(googleApiClient, createLocationRequest(), this);\n         }\n \n         this.locationListener = locationListener;\n     }\n \n     public void stopLocationUpdates() {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() || !googleApiClient.isConnected()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExODQ3Mw=="}, "originalCommit": {"oid": "a3aea167792492b2e3e43ea80d51c5614f29df72"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwNTY4OQ==", "bodyText": "Fixed.", "url": "https://github.com/getodk/collect/pull/4156#discussion_r501305689", "createdAt": "2020-10-07T20:57:57Z", "author": {"login": "grzesiek2010"}, "path": "collect_app/src/main/java/org/odk/collect/android/location/client/GoogleFusedLocationClient.java", "diffHunk": "@@ -120,15 +120,15 @@ public void stop() {\n \n     @SuppressLint(\"MissingPermission\") // Permission checks for location services handled in widgets\n     public void requestLocationUpdates(@NonNull LocationListener locationListener) {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() && googleApiClient.isConnected()) {\n             fusedLocationProviderApi.requestLocationUpdates(googleApiClient, createLocationRequest(), this);\n         }\n \n         this.locationListener = locationListener;\n     }\n \n     public void stopLocationUpdates() {\n-        if (!isMonitoringLocation()) {\n+        if (!isMonitoringLocation() || !googleApiClient.isConnected()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExODQ3Mw=="}, "originalCommit": {"oid": "a3aea167792492b2e3e43ea80d51c5614f29df72"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3119, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}