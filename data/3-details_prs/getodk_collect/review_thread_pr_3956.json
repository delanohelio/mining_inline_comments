{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNjQxNDY0", "number": 3956, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoxMzowNlrOEK_Sdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTozMDo0OVrOEMP_Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTU4MTM0OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/injection/config/AppDependencyModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoxMzowNlrOGsWgtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoxMzoyOFrOGsWhVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1OTM0OQ==", "bodyText": "It felt like a good idea to bring this back as the ServerPollingJob and DownloadFormListTask were both using it and don't have a lot of tests around them. This would make it riskier to iterate on and improve the ServerFormsDetailsFetcher.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r449159349", "createdAt": "2020-07-02T17:13:06Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/injection/config/AppDependencyModule.java", "diffHunk": "@@ -135,11 +135,11 @@ WebCredentialsUtils provideWebCredentials() {\n     }\n \n     @Provides\n-    ServerFormsDetailsFetcher provideDownloadFormListDownloader(\n+    FormListDownloader formListDownloader(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8768321dbfac4961f4a51c914865c56841f6f961"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1OTUxMQ==", "bodyText": "I'll deprecate in a later commit.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r449159511", "createdAt": "2020-07-02T17:13:28Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/injection/config/AppDependencyModule.java", "diffHunk": "@@ -135,11 +135,11 @@ WebCredentialsUtils provideWebCredentials() {\n     }\n \n     @Provides\n-    ServerFormsDetailsFetcher provideDownloadFormListDownloader(\n+    FormListDownloader formListDownloader(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1OTM0OQ=="}, "originalCommit": {"oid": "8768321dbfac4961f4a51c914865c56841f6f961"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTIyNDI2OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/BlankFormsListViewModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzowMjowMlrOGsl4Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzowMjowMlrOGsl4Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMTA3OA==", "bodyText": "I think eventually this should also encapsulate DiskSyncTask, hold the list of forms that the adapter needs (probably as LiveData) and be responsible for sorting.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r449411078", "createdAt": "2020-07-03T07:02:02Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/BlankFormsListViewModel.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n+import androidx.lifecycle.ViewModel;\n+import androidx.lifecycle.ViewModelProvider;\n+\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+import org.odk.collect.android.utilities.MultiFormDownloader;\n+import org.odk.collect.async.Scheduler;\n+\n+import javax.inject.Inject;\n+\n+public class BlankFormsListViewModel extends ViewModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTIzMjUxOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/BlankFormsListViewModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzowNToxNlrOGsl9Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzowNToxNlrOGsl9Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMjM1NQ==", "bodyText": "I had completely forgotten we could do this. I'm not usually a huge fan of @Injects scattered around the place randomly building the dependency graph for the app - as much as it's terse give me a 500 line module definition any day. However, in the case of ViewModel where we have to deal with Factory classes like this I think just being able to @Inject the constructor and then injecting it in the Activity cuts down on a lot of explicit dependencies at the Activity level that only get used for ViewModel construction.\nProbably a nice trick to use elsewhere.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r449412355", "createdAt": "2020-07-03T07:05:16Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/BlankFormsListViewModel.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n+import androidx.lifecycle.ViewModel;\n+import androidx.lifecycle.ViewModelProvider;\n+\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+import org.odk.collect.android.utilities.MultiFormDownloader;\n+import org.odk.collect.async.Scheduler;\n+\n+import javax.inject.Inject;\n+\n+public class BlankFormsListViewModel extends ViewModel {\n+\n+    private final Scheduler scheduler;\n+    private final FormRepository formRepository;\n+    private final MediaFileRepository mediaFileRepository;\n+    private final FormAPI formAPI;\n+    private final MultiFormDownloader multiFormDownloader;\n+\n+    private final MutableLiveData<Boolean> syncing = new MutableLiveData<>(false);\n+\n+    public BlankFormsListViewModel(Scheduler scheduler, FormRepository formRepository, MediaFileRepository mediaFileRepository, FormAPI formAPI, MultiFormDownloader multiFormDownloader) {\n+        this.scheduler = scheduler;\n+        this.formRepository = formRepository;\n+        this.mediaFileRepository = mediaFileRepository;\n+        this.formAPI = formAPI;\n+        this.multiFormDownloader = multiFormDownloader;\n+    }\n+\n+    public LiveData<Boolean> isSyncing() {\n+        return syncing;\n+    }\n+\n+    public void syncWithServer() {\n+        syncing.setValue(true);\n+\n+        scheduler.scheduleInBackground(() -> {\n+            try {\n+                ServerFormListSynchronizer synchronizer = new ServerFormListSynchronizer(formRepository, mediaFileRepository, formAPI, multiFormDownloader);\n+                synchronizer.synchronize();\n+            } catch (FormAPIError ignored) {\n+                // Ignored\n+            }\n+\n+            return null;\n+        }, ignored -> syncing.setValue(false));\n+    }\n+\n+    public static class Factory implements ViewModelProvider.Factory {\n+\n+        private final Scheduler scheduler;\n+        private final FormRepository formRepository;\n+        private final MediaFileRepository mediaFileRepository;\n+        private final FormAPI formAPI;\n+        private final MultiFormDownloader multiFormDownloader;\n+\n+        @Inject", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODkyNzM5OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDao.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDowMDowMFrOGtqueQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDowMDowMFrOGtqueQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzOTEyOQ==", "bodyText": "typo", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450539129", "createdAt": "2020-07-07T00:00:00Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDao.java", "diffHunk": "@@ -32,7 +32,7 @@\n import java.util.List;\n \n /**\n- * This class is used to encapsulate all access to the {@link org.odk.collect.android.database.helpers.FormsDatabaseHelper#DATABASE_NAME}\n+ * This class is used to encap`sulate all access to the {@link org.odk.collect.android.database.helpers.FormsDatabaseHelper#DATABASE_NAME}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9b51a1b54068a68c55d4a5fe1fd82daf18c4248"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODk5MTE4OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/OpenRosaFormAPI.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDozNjowMVrOGtrTjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo0NDowMFrOGt01fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0ODYyMg==", "bodyText": "Should use the androidx annotations\nEdit: hmm, now I see we haven't been very consistent. I think in general we should use the androidx ones because of the android studio nullability analysis.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450548622", "createdAt": "2020-07-07T00:36:01Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/OpenRosaFormAPI.java", "diffHunk": "@@ -1,12 +1,11 @@\n package org.odk.collect.android.openrosa.api;\n \n import org.javarosa.xform.parse.XFormParser;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78ea55d10e3e61c7c651b138a8c88faa2ab5572c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwNDc2Ng==", "bodyText": "Hmmm. I think here I actually prefer the JetBrains one as this code has no other Android dependencies. Either work within Android Studio (as it's just IntelliJ under the hood). Does that sound ok?", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450704766", "createdAt": "2020-07-07T08:44:00Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/OpenRosaFormAPI.java", "diffHunk": "@@ -1,12 +1,11 @@\n package org.odk.collect.android.openrosa.api;\n \n import org.javarosa.xform.parse.XFormParser;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0ODYyMg=="}, "originalCommit": {"oid": "78ea55d10e3e61c7c651b138a8c88faa2ab5572c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTAyOTAzOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDo1OToyMVrOGtrpvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo1NjowNFrOGt1SRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NDMwMQ==", "bodyText": "I think this needs to be more analogous to InstancesRepository. For that interface, the concrete implementation is called DatabaseInstancesRepository and it lives in the instances package which I like slightly better. I don't mind this if you strongly prefer it, though, but I think the two should be the same. I think DatabaseXRepository captures what's really meaningful and contrasts from the test implementation -- that it's fetching X from a database.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450554301", "createdAt": "2020-07-07T00:59:21Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.odk.collect.android.dao;\n+\n+import android.database.Cursor;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+\n+import java.util.List;\n+\n+public class FormsDaoFormRepository implements FormRepository {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMjEzMw==", "bodyText": "I'd managed to miss/forget about InstancesRepository but totally would have followed it's pattern if I hadn't. Will make those consistent.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450712133", "createdAt": "2020-07-07T08:56:04Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.odk.collect.android.dao;\n+\n+import android.database.Cursor;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+\n+import java.util.List;\n+\n+public class FormsDaoFormRepository implements FormRepository {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NDMwMQ=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTAzNjU1OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/FormAPI.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMTowMzo1MlrOGtruRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo0Nzo1NlrOGt0_ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NTQ2Mw==", "bodyText": "API should be Api: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case\nWould you consider FormListApi? That links it more clearly to the corresponding OpenRosa standard https://docs.getodk.org/openrosa-form-list/. It makes sense to me that fetching the manifest is a subset of fetching the form list.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450555463", "createdAt": "2020-07-07T01:03:52Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/FormAPI.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.odk.collect.android.openrosa.api;\n+\n+import java.util.List;\n+\n+public interface FormAPI {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwNzMwNg==", "bodyText": "So I've had feedback when pairing with newer or English-as-a-second-language engineers that the uppercasing helps identify acronyms they don't know, so I tend to go with that. However, we do reference that style guide and I don't want to get into debating exceptions! I'll fix.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450707306", "createdAt": "2020-07-07T08:47:56Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/FormAPI.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.odk.collect.android.openrosa.api;\n+\n+import java.util.List;\n+\n+public interface FormAPI {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NTQ2Mw=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTAzNjc2OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/FormAPIError.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMTowNDowM1rOGtrudA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo0OToyNFrOGt1Cww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NTUwOA==", "bodyText": "FormApiError", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450555508", "createdAt": "2020-07-07T01:04:03Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/FormAPIError.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.odk.collect.android.openrosa.api;\n+\n+public class FormAPIError extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwODE2Mw==", "bodyText": "I'm also going to rename this to ...Exception while I'm here. I'm way to cavalier around the difference between those.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450708163", "createdAt": "2020-07-07T08:49:24Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/FormAPIError.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.odk.collect.android.openrosa.api;\n+\n+public class FormAPIError extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NTUwOA=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM3MjgyOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo0MTozM1rOGtu4Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToxMjowNlrOGuPxOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwNzEzMQ==", "bodyText": "At https://forum.getodk.org/t/have-collect-exactly-match-the-forms-on-central/23101, we had described doing a soft delete so that saved records could still be edited. Unfortunately that does need adding to the db schema, I think. Maybe something to discuss.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450607131", "createdAt": "2020-07-07T04:41:33Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.odk.collect.android.dao;\n+\n+import android.database.Cursor;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+\n+import java.util.List;\n+\n+public class FormsDaoFormRepository implements FormRepository {\n+\n+    @Override\n+    public boolean contains(String jrFormID) {\n+        try (Cursor cursor = new FormsDao().getFormsCursorForFormId(jrFormID)) {\n+            return cursor != null && cursor.getCount() > 0;\n+        }\n+    }\n+\n+    @Override\n+    public List<Form> getAll() {\n+        try (Cursor cursor = new FormsDao().getFormsCursor()) {\n+            return new FormsDao().getFormsFromCursor(cursor);\n+        }\n+    }\n+\n+    @Override\n+    public void save(Form form) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void delete(Long id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwOTYxMw==", "bodyText": "For some reason I'd assumed that was what was happening from how we were talking about. Good to add something like this at an acceptance level I think so it's really clear what we mean. I think looking at this as a separate issue would be good!", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450709613", "createdAt": "2020-07-07T08:51:54Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.odk.collect.android.dao;\n+\n+import android.database.Cursor;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+\n+import java.util.List;\n+\n+public class FormsDaoFormRepository implements FormRepository {\n+\n+    @Override\n+    public boolean contains(String jrFormID) {\n+        try (Cursor cursor = new FormsDao().getFormsCursorForFormId(jrFormID)) {\n+            return cursor != null && cursor.getCount() > 0;\n+        }\n+    }\n+\n+    @Override\n+    public List<Form> getAll() {\n+        try (Cursor cursor = new FormsDao().getFormsCursor()) {\n+            return new FormsDao().getFormsFromCursor(cursor);\n+        }\n+    }\n+\n+    @Override\n+    public void save(Form form) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void delete(Long id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwNzEzMQ=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NjA0Mw==", "bodyText": "Filed #3961. You should be able to edit the issue as needed!", "url": "https://github.com/getodk/collect/pull/3956#discussion_r451146043", "createdAt": "2020-07-07T21:12:06Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/dao/FormsDaoFormRepository.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.odk.collect.android.dao;\n+\n+import android.database.Cursor;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+\n+import java.util.List;\n+\n+public class FormsDaoFormRepository implements FormRepository {\n+\n+    @Override\n+    public boolean contains(String jrFormID) {\n+        try (Cursor cursor = new FormsDao().getFormsCursorForFormId(jrFormID)) {\n+            return cursor != null && cursor.getCount() > 0;\n+        }\n+    }\n+\n+    @Override\n+    public List<Form> getAll() {\n+        try (Cursor cursor = new FormsDao().getFormsCursor()) {\n+            return new FormsDao().getFormsFromCursor(cursor);\n+        }\n+    }\n+\n+    @Override\n+    public void save(Form form) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void delete(Long id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwNzEzMQ=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM3ODUzOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/OpenRosaXMLFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo0NTozNFrOGtu7hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo0NTozNFrOGtu7hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwODAwNA==", "bodyText": "Should be OpenRosaXmlFetcher", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450608004", "createdAt": "2020-07-07T04:45:34Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/OpenRosaXMLFetcher.java", "diffHunk": "@@ -21,15 +21,15 @@\n \n import timber.log.Timber;\n \n-public class OpenRosaAPIClient {\n+public class OpenRosaXMLFetcher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM4MTc4OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/utilities/MultiFormDownloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo0ODoxNlrOGtu9rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo1NDowOVrOGt1NzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwODU1Ng==", "bodyText": "why not in formmanagement?", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450608556", "createdAt": "2020-07-07T04:48:16Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/utilities/MultiFormDownloader.java", "diffHunk": "@@ -56,26 +58,28 @@\n import static org.odk.collect.android.utilities.FileUtils.STUB_XML;\n import static org.odk.collect.android.utilities.FileUtils.write;\n \n-public class FormDownloader {\n+public class MultiFormDownloader implements FormDownloader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMDk4OQ==", "bodyText": "I think I didn't feel like it was ready to go there yet as we still haven't taken a stab at cleaning it up? Maybe that's silly. What do you think?", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450710989", "createdAt": "2020-07-07T08:54:09Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/utilities/MultiFormDownloader.java", "diffHunk": "@@ -56,26 +58,28 @@\n import static org.odk.collect.android.utilities.FileUtils.STUB_XML;\n import static org.odk.collect.android.utilities.FileUtils.write;\n \n-public class FormDownloader {\n+public class MultiFormDownloader implements FormDownloader {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwODU1Ng=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM4NTcxOnYy", "diffSide": "RIGHT", "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/settings/MatchExactlyTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1MDo1M1rOGtvAIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo1MzoyN1rOGt1MLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwOTE4Nw==", "bodyText": "Need test and implementation to hide refresh button when setting is off.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450609187", "createdAt": "2020-07-07T04:50:53Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/settings/MatchExactlyTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.odk.collect.android.feature.settings;\n+\n+import android.Manifest;\n+import android.webkit.MimeTypeMap;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.R;\n+import org.odk.collect.android.injection.config.AppDependencyModule;\n+import org.odk.collect.android.openrosa.OpenRosaHttpInterface;\n+import org.odk.collect.android.support.CollectTestRule;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.CountingScheduler;\n+import org.odk.collect.android.support.CountingSchedulerIdlingResource;\n+import org.odk.collect.android.support.IdlingResourceRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.support.StubOpenRosaServer;\n+import org.odk.collect.async.CoroutineScheduler;\n+import org.odk.collect.async.Scheduler;\n+import org.odk.collect.utilities.UserAgentProvider;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class MatchExactlyTest {\n+\n+    public final StubOpenRosaServer server = new StubOpenRosaServer();\n+    private final CountingScheduler countingScheduler = new CountingScheduler(new CoroutineScheduler());\n+\n+    public CollectTestRule rule = new CollectTestRule();\n+\n+    @Rule\n+    public RuleChain copyFormChain = RuleChain\n+            .outerRule(GrantPermissionRule.grant(\n+                    Manifest.permission.READ_EXTERNAL_STORAGE,\n+                    Manifest.permission.WRITE_EXTERNAL_STORAGE,\n+                    Manifest.permission.READ_PHONE_STATE\n+            ))\n+            .around(new ResetStateRule(new AppDependencyModule() {\n+                @Override\n+                public OpenRosaHttpInterface provideHttpInterface(MimeTypeMap mimeTypeMap, UserAgentProvider userAgentProvider) {\n+                    return server;\n+                }\n+\n+                @Override\n+                public Scheduler providesScheduler() {\n+                    return countingScheduler;\n+                }\n+            }))\n+            .around(new IdlingResourceRule(new CountingSchedulerIdlingResource(countingScheduler)))\n+            .around(new CopyFormRule(\"one-question.xml\"))\n+            .around(new CopyFormRule(\"one-question-repeat.xml\"))\n+            .around(rule);\n+\n+    @Test\n+    public void whenMatchExactlyEnabled_clickingFillBlankForm_andClickingRefresh_getsLatestFormsFromServer() {\n+        server.addForm(\"One Question Updated\", \"one_question\", \"one-question-updated.xml\");\n+        server.addForm(\"Two Question\", \"two_question\", \"two-question.xml\");\n+\n+        rule.mainMenu()\n+                .setServer(server.getURL())\n+                .enableMatchExactly()\n+                .clickFillBlankForm()\n+                .assertText(\"One Question\")\n+                .assertText(\"One Question Repeat\")\n+                .clickRefresh()\n+                .assertText(\"Two Question\") // Check new form downloaded\n+                .assertText(\"One Question Updated\") // Check updated form updated\n+                .assertTextDoesNotExist(\"One Question Repeat\"); // Check deleted form deleted\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMDU3NQ==", "bodyText": "\ud83e\udd2d talk about getting caught up in what you're working on! Definitely needs fixed.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450710575", "createdAt": "2020-07-07T08:53:27Z", "author": {"login": "seadowg"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/settings/MatchExactlyTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.odk.collect.android.feature.settings;\n+\n+import android.Manifest;\n+import android.webkit.MimeTypeMap;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.R;\n+import org.odk.collect.android.injection.config.AppDependencyModule;\n+import org.odk.collect.android.openrosa.OpenRosaHttpInterface;\n+import org.odk.collect.android.support.CollectTestRule;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.CountingScheduler;\n+import org.odk.collect.android.support.CountingSchedulerIdlingResource;\n+import org.odk.collect.android.support.IdlingResourceRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.support.StubOpenRosaServer;\n+import org.odk.collect.async.CoroutineScheduler;\n+import org.odk.collect.async.Scheduler;\n+import org.odk.collect.utilities.UserAgentProvider;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class MatchExactlyTest {\n+\n+    public final StubOpenRosaServer server = new StubOpenRosaServer();\n+    private final CountingScheduler countingScheduler = new CountingScheduler(new CoroutineScheduler());\n+\n+    public CollectTestRule rule = new CollectTestRule();\n+\n+    @Rule\n+    public RuleChain copyFormChain = RuleChain\n+            .outerRule(GrantPermissionRule.grant(\n+                    Manifest.permission.READ_EXTERNAL_STORAGE,\n+                    Manifest.permission.WRITE_EXTERNAL_STORAGE,\n+                    Manifest.permission.READ_PHONE_STATE\n+            ))\n+            .around(new ResetStateRule(new AppDependencyModule() {\n+                @Override\n+                public OpenRosaHttpInterface provideHttpInterface(MimeTypeMap mimeTypeMap, UserAgentProvider userAgentProvider) {\n+                    return server;\n+                }\n+\n+                @Override\n+                public Scheduler providesScheduler() {\n+                    return countingScheduler;\n+                }\n+            }))\n+            .around(new IdlingResourceRule(new CountingSchedulerIdlingResource(countingScheduler)))\n+            .around(new CopyFormRule(\"one-question.xml\"))\n+            .around(new CopyFormRule(\"one-question-repeat.xml\"))\n+            .around(rule);\n+\n+    @Test\n+    public void whenMatchExactlyEnabled_clickingFillBlankForm_andClickingRefresh_getsLatestFormsFromServer() {\n+        server.addForm(\"One Question Updated\", \"one_question\", \"one-question-updated.xml\");\n+        server.addForm(\"Two Question\", \"two_question\", \"two-question.xml\");\n+\n+        rule.mainMenu()\n+                .setServer(server.getURL())\n+                .enableMatchExactly()\n+                .clickFillBlankForm()\n+                .assertText(\"One Question\")\n+                .assertText(\"One Question Repeat\")\n+                .clickRefresh()\n+                .assertText(\"Two Question\") // Check new form downloaded\n+                .assertText(\"One Question Updated\") // Check updated form updated\n+                .assertTextDoesNotExist(\"One Question Repeat\"); // Check deleted form deleted\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwOTE4Nw=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM4NzY3OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/OpenRosaFormAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1MTo0OFrOGtvBJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1MTo0OFrOGtvBJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwOTQ0NA==", "bodyText": "Consider OpenRosaFormListApi", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450609444", "createdAt": "2020-07-07T04:51:48Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/openrosa/api/OpenRosaFormAPI.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.odk.collect.android.openrosa.api;\n+\n+import org.javarosa.xform.parse.XFormParser;\n+import org.jetbrains.annotations.NotNull;\n+import org.kxml2.kdom.Element;\n+import org.odk.collect.android.openrosa.OpenRosaXMLFetcher;\n+import org.odk.collect.android.openrosa.api.FormAPIError.Type;\n+import org.odk.collect.android.utilities.DocumentFetchResult;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.odk.collect.android.openrosa.api.FormAPIError.Type.AUTH_REQUIRED;\n+import static org.odk.collect.android.openrosa.api.FormAPIError.Type.FETCH_ERROR;\n+import static org.odk.collect.android.openrosa.api.FormAPIError.Type.PARSE_ERROR;\n+\n+public class OpenRosaFormAPI implements FormAPI {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM4OTU1OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1Mjo1OVrOGtvCMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1Mjo1OVrOGtvCMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwOTcxNA==", "bodyText": "Change to w so we don't forget later? I don't think any of these would point to a software error we can fix.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450609714", "createdAt": "2020-07-07T04:52:59Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2018 Nafundi\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.odk.collect.android.formmanagement;\n+\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.logic.FormDetails;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+import org.odk.collect.android.openrosa.api.FormListItem;\n+import org.odk.collect.android.openrosa.api.ManifestFile;\n+import org.odk.collect.android.openrosa.api.MediaFile;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.MultiFormDownloader;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+public class ServerFormsDetailsFetcher {\n+\n+    private final FormRepository formRepository;\n+    private final MediaFileRepository mediaFileRepository;\n+    private final FormAPI formAPI;\n+\n+    public ServerFormsDetailsFetcher(FormRepository formRepository,\n+                                     MediaFileRepository mediaFileRepository,\n+                                     FormAPI formAPI) {\n+        this.formRepository = formRepository;\n+        this.mediaFileRepository = mediaFileRepository;\n+        this.formAPI = formAPI;\n+    }\n+\n+    public List<FormDetails> fetchFormDetails() throws FormAPIError {\n+        return fetchFormDetails(true);\n+    }\n+\n+    public List<FormDetails> fetchFormDetails(boolean checkMediaFiles) throws FormAPIError {\n+        List<FormListItem> formListItems = formAPI.fetchFormList();\n+        List<FormDetails> formDetailsList = new ArrayList<>();\n+\n+        for (FormListItem listItem : formListItems) {\n+            boolean isNewerFormVersionAvailable = false;\n+            boolean areNewerMediaFilesAvailable = false;\n+            ManifestFile manifestFile = null;\n+\n+            if (isThisFormAlreadyDownloaded(listItem.getFormID())) {\n+                isNewerFormVersionAvailable = isNewerFormVersionAvailable(MultiFormDownloader.getMd5Hash(listItem.getHashWithPrefix()));\n+                if ((!isNewerFormVersionAvailable || checkMediaFiles) && listItem.getManifestURL() != null) {\n+                    manifestFile = getManifestFile(formAPI, listItem.getManifestURL());\n+                    if (manifestFile != null) {\n+                        List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n+                        if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n+                            areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            FormDetails formDetails = FormDetails.toFormDetails(\n+                    listItem,\n+                    manifestFile != null ? manifestFile.getHash() : null,\n+                    isNewerFormVersionAvailable,\n+                    areNewerMediaFilesAvailable\n+            );\n+\n+            formDetailsList.add(formDetails);\n+        }\n+        return formDetailsList;\n+    }\n+\n+    private boolean isThisFormAlreadyDownloaded(String formId) {\n+        return formRepository.contains(formId);\n+    }\n+\n+    private ManifestFile getManifestFile(FormAPI formAPI, String manifestUrl) {\n+        if (manifestUrl == null) {\n+            return null;\n+        }\n+\n+        try {\n+            return formAPI.fetchManifest(manifestUrl);\n+        } catch (FormAPIError formAPIError) {\n+            Timber.e(formAPIError);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM5MjgyOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormListSynchronizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1NTowOVrOGtvEHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOTo1OToxOVrOGt3lNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDIwNA==", "bodyText": "This is n^2, right? Both lists are going to be relatively small in this case so I think it's ok but we should be careful if doing similar things with e.g. instances at some point. I feel like streams can hide complexity in a kind of scary way sometimes.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450610204", "createdAt": "2020-07-07T04:55:09Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormListSynchronizer.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.logic.FormDetails;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+\n+import java.util.List;\n+\n+public class ServerFormListSynchronizer {\n+\n+    private final FormRepository formRepository;\n+    private final MediaFileRepository mediaFileRepository;\n+    private final FormAPI formAPI;\n+    private final FormDownloader formDownloader;\n+\n+    public ServerFormListSynchronizer(FormRepository formRepository, MediaFileRepository mediaFileRepository, FormAPI formAPI, FormDownloader formDownloader) {\n+        this.formRepository = formRepository;\n+        this.mediaFileRepository = mediaFileRepository;\n+        this.formAPI = formAPI;\n+        this.formDownloader = formDownloader;\n+    }\n+\n+    public void synchronize() throws FormAPIError {\n+        ServerFormsDetailsFetcher listDownloader = new ServerFormsDetailsFetcher(formRepository, mediaFileRepository, formAPI);\n+        List<FormDetails> formList = listDownloader.fetchFormDetails();\n+\n+        List<Form> formsOnDevice = formRepository.getAll();\n+\n+        formsOnDevice.stream().forEach(form -> {\n+            if (formList.stream().noneMatch(f -> form.getJrFormId().equals(f.getFormId()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc0OTc1MA==", "bodyText": "Interesting. I tend to find the opposite is true as it feels clearer where the loops are happening.\nThis is set difference so without sorting I don't think we can do better than O(n^2) right? I guess maybe using a HashMap or HashSet could get us O(1) complexity (in theory) on remove operations which gives us linear time. I need more tea \u2615\ufe0f", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450749750", "createdAt": "2020-07-07T09:59:19Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormListSynchronizer.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import org.odk.collect.android.forms.Form;\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.logic.FormDetails;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+\n+import java.util.List;\n+\n+public class ServerFormListSynchronizer {\n+\n+    private final FormRepository formRepository;\n+    private final MediaFileRepository mediaFileRepository;\n+    private final FormAPI formAPI;\n+    private final FormDownloader formDownloader;\n+\n+    public ServerFormListSynchronizer(FormRepository formRepository, MediaFileRepository mediaFileRepository, FormAPI formAPI, FormDownloader formDownloader) {\n+        this.formRepository = formRepository;\n+        this.mediaFileRepository = mediaFileRepository;\n+        this.formAPI = formAPI;\n+        this.formDownloader = formDownloader;\n+    }\n+\n+    public void synchronize() throws FormAPIError {\n+        ServerFormsDetailsFetcher listDownloader = new ServerFormsDetailsFetcher(formRepository, mediaFileRepository, formAPI);\n+        List<FormDetails> formList = listDownloader.fetchFormDetails();\n+\n+        List<Form> formsOnDevice = formRepository.getAll();\n+\n+        formsOnDevice.stream().forEach(form -> {\n+            if (formList.stream().noneMatch(f -> form.getJrFormId().equals(f.getFormId()))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDIwNA=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM5NzE0OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1ODowN1rOGtvG1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo1ODowNlrOGt1XcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDkwMQ==", "bodyText": "Consider adding a repository method to get a form by md5hash? Seems clearer and more efficient.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450610901", "createdAt": "2020-07-07T04:58:07Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2018 Nafundi\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.odk.collect.android.formmanagement;\n+\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.logic.FormDetails;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+import org.odk.collect.android.openrosa.api.FormListItem;\n+import org.odk.collect.android.openrosa.api.ManifestFile;\n+import org.odk.collect.android.openrosa.api.MediaFile;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.MultiFormDownloader;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+public class ServerFormsDetailsFetcher {\n+\n+    private final FormRepository formRepository;\n+    private final MediaFileRepository mediaFileRepository;\n+    private final FormAPI formAPI;\n+\n+    public ServerFormsDetailsFetcher(FormRepository formRepository,\n+                                     MediaFileRepository mediaFileRepository,\n+                                     FormAPI formAPI) {\n+        this.formRepository = formRepository;\n+        this.mediaFileRepository = mediaFileRepository;\n+        this.formAPI = formAPI;\n+    }\n+\n+    public List<FormDetails> fetchFormDetails() throws FormAPIError {\n+        return fetchFormDetails(true);\n+    }\n+\n+    public List<FormDetails> fetchFormDetails(boolean checkMediaFiles) throws FormAPIError {\n+        List<FormListItem> formListItems = formAPI.fetchFormList();\n+        List<FormDetails> formDetailsList = new ArrayList<>();\n+\n+        for (FormListItem listItem : formListItems) {\n+            boolean isNewerFormVersionAvailable = false;\n+            boolean areNewerMediaFilesAvailable = false;\n+            ManifestFile manifestFile = null;\n+\n+            if (isThisFormAlreadyDownloaded(listItem.getFormID())) {\n+                isNewerFormVersionAvailable = isNewerFormVersionAvailable(MultiFormDownloader.getMd5Hash(listItem.getHashWithPrefix()));\n+                if ((!isNewerFormVersionAvailable || checkMediaFiles) && listItem.getManifestURL() != null) {\n+                    manifestFile = getManifestFile(formAPI, listItem.getManifestURL());\n+                    if (manifestFile != null) {\n+                        List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n+                        if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n+                            areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            FormDetails formDetails = FormDetails.toFormDetails(\n+                    listItem,\n+                    manifestFile != null ? manifestFile.getHash() : null,\n+                    isNewerFormVersionAvailable,\n+                    areNewerMediaFilesAvailable\n+            );\n+\n+            formDetailsList.add(formDetails);\n+        }\n+        return formDetailsList;\n+    }\n+\n+    private boolean isThisFormAlreadyDownloaded(String formId) {\n+        return formRepository.contains(formId);\n+    }\n+\n+    private ManifestFile getManifestFile(FormAPI formAPI, String manifestUrl) {\n+        if (manifestUrl == null) {\n+            return null;\n+        }\n+\n+        try {\n+            return formAPI.fetchManifest(manifestUrl);\n+        } catch (FormAPIError formAPIError) {\n+            Timber.e(formAPIError);\n+            return null;\n+        }\n+    }\n+\n+    private boolean isNewerFormVersionAvailable(String md5Hash) {\n+        if (md5Hash == null) {\n+            return false;\n+        }\n+\n+        return formRepository.getAll().stream().noneMatch(f -> f.getMD5Hash().equals(md5Hash));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMzQ1Ng==", "bodyText": "Yeah that seems like a nice optimization!", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450713456", "createdAt": "2020-07-07T08:58:06Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2018 Nafundi\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.odk.collect.android.formmanagement;\n+\n+import org.odk.collect.android.forms.FormRepository;\n+import org.odk.collect.android.forms.MediaFileRepository;\n+import org.odk.collect.android.logic.FormDetails;\n+import org.odk.collect.android.openrosa.api.FormAPI;\n+import org.odk.collect.android.openrosa.api.FormAPIError;\n+import org.odk.collect.android.openrosa.api.FormListItem;\n+import org.odk.collect.android.openrosa.api.ManifestFile;\n+import org.odk.collect.android.openrosa.api.MediaFile;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.MultiFormDownloader;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+public class ServerFormsDetailsFetcher {\n+\n+    private final FormRepository formRepository;\n+    private final MediaFileRepository mediaFileRepository;\n+    private final FormAPI formAPI;\n+\n+    public ServerFormsDetailsFetcher(FormRepository formRepository,\n+                                     MediaFileRepository mediaFileRepository,\n+                                     FormAPI formAPI) {\n+        this.formRepository = formRepository;\n+        this.mediaFileRepository = mediaFileRepository;\n+        this.formAPI = formAPI;\n+    }\n+\n+    public List<FormDetails> fetchFormDetails() throws FormAPIError {\n+        return fetchFormDetails(true);\n+    }\n+\n+    public List<FormDetails> fetchFormDetails(boolean checkMediaFiles) throws FormAPIError {\n+        List<FormListItem> formListItems = formAPI.fetchFormList();\n+        List<FormDetails> formDetailsList = new ArrayList<>();\n+\n+        for (FormListItem listItem : formListItems) {\n+            boolean isNewerFormVersionAvailable = false;\n+            boolean areNewerMediaFilesAvailable = false;\n+            ManifestFile manifestFile = null;\n+\n+            if (isThisFormAlreadyDownloaded(listItem.getFormID())) {\n+                isNewerFormVersionAvailable = isNewerFormVersionAvailable(MultiFormDownloader.getMd5Hash(listItem.getHashWithPrefix()));\n+                if ((!isNewerFormVersionAvailable || checkMediaFiles) && listItem.getManifestURL() != null) {\n+                    manifestFile = getManifestFile(formAPI, listItem.getManifestURL());\n+                    if (manifestFile != null) {\n+                        List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n+                        if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n+                            areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            FormDetails formDetails = FormDetails.toFormDetails(\n+                    listItem,\n+                    manifestFile != null ? manifestFile.getHash() : null,\n+                    isNewerFormVersionAvailable,\n+                    areNewerMediaFilesAvailable\n+            );\n+\n+            formDetailsList.add(formDetails);\n+        }\n+        return formDetailsList;\n+    }\n+\n+    private boolean isThisFormAlreadyDownloaded(String formId) {\n+        return formRepository.contains(formId);\n+    }\n+\n+    private ManifestFile getManifestFile(FormAPI formAPI, String manifestUrl) {\n+        if (manifestUrl == null) {\n+            return null;\n+        }\n+\n+        try {\n+            return formAPI.fetchManifest(manifestUrl);\n+        } catch (FormAPIError formAPIError) {\n+            Timber.e(formAPIError);\n+            return null;\n+        }\n+    }\n+\n+    private boolean isNewerFormVersionAvailable(String md5Hash) {\n+        if (md5Hash == null) {\n+            return false;\n+        }\n+\n+        return formRepository.getAll().stream().noneMatch(f -> f.getMD5Hash().equals(md5Hash));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDkwMQ=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTQwODY4OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/logic/FormDetails.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTowNDo1MFrOGtvNoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo1OToyOVrOGt1apA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMjY0MQ==", "bodyText": "I'm not loving all this. Isn't FormDetails a wrapper for a FormListItem that provides status information? Maybe a FormDetails should have a FormListItem field? Maybe it should be FormListItemStatus?", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450612641", "createdAt": "2020-07-07T05:04:50Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/logic/FormDetails.java", "diffHunk": "@@ -87,4 +90,48 @@ public boolean isNewerFormVersionAvailable() {\n     public boolean areNewerMediaFilesAvailable() {\n         return areNewerMediaFilesAvailable;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FormDetails that = (FormDetails) o;\n+        return isNewerFormVersionAvailable() == that.isNewerFormVersionAvailable() &&\n+                areNewerMediaFilesAvailable == that.areNewerMediaFilesAvailable &&\n+                Objects.equals(getErrorStr(), that.getErrorStr()) &&\n+                Objects.equals(getFormName(), that.getFormName()) &&\n+                Objects.equals(getDownloadUrl(), that.getDownloadUrl()) &&\n+                Objects.equals(getManifestUrl(), that.getManifestUrl()) &&\n+                Objects.equals(formID, that.formID) &&\n+                Objects.equals(getFormVersion(), that.getFormVersion()) &&\n+                Objects.equals(getHash(), that.getHash()) &&\n+                Objects.equals(getManifestFileHash(), that.getManifestFileHash());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getErrorStr(), getFormName(), getDownloadUrl(), getManifestUrl(), formID, getFormVersion(), getHash(), getManifestFileHash(), isNewerFormVersionAvailable(), areNewerMediaFilesAvailable);\n+    }\n+\n+    public static FormDetails toFormDetails(FormListItem formListItem) {\n+        return toFormDetails(formListItem, null, false, false);\n+    }\n+\n+    public static FormDetails toFormDetails(FormListItem formListItem, String manifestFileHash, boolean isNewerFormVersionAvailable, boolean areNewerMediaFilesAvailable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxNDI3Ng==", "bodyText": "Yeah actually this is something I meant to come back to. Initially I'd thought I'd be getting rid of FormDetails so this was a way of converting between those values while I worked towards that. You're right that it seems really funky now. I'll take a look at cleaning it up.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450714276", "createdAt": "2020-07-07T08:59:29Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/logic/FormDetails.java", "diffHunk": "@@ -87,4 +90,48 @@ public boolean isNewerFormVersionAvailable() {\n     public boolean areNewerMediaFilesAvailable() {\n         return areNewerMediaFilesAvailable;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FormDetails that = (FormDetails) o;\n+        return isNewerFormVersionAvailable() == that.isNewerFormVersionAvailable() &&\n+                areNewerMediaFilesAvailable == that.areNewerMediaFilesAvailable &&\n+                Objects.equals(getErrorStr(), that.getErrorStr()) &&\n+                Objects.equals(getFormName(), that.getFormName()) &&\n+                Objects.equals(getDownloadUrl(), that.getDownloadUrl()) &&\n+                Objects.equals(getManifestUrl(), that.getManifestUrl()) &&\n+                Objects.equals(formID, that.formID) &&\n+                Objects.equals(getFormVersion(), that.getFormVersion()) &&\n+                Objects.equals(getHash(), that.getHash()) &&\n+                Objects.equals(getManifestFileHash(), that.getManifestFileHash());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getErrorStr(), getFormName(), getDownloadUrl(), getManifestUrl(), formID, getFormVersion(), getHash(), getManifestFileHash(), isNewerFormVersionAvailable(), areNewerMediaFilesAvailable);\n+    }\n+\n+    public static FormDetails toFormDetails(FormListItem formListItem) {\n+        return toFormDetails(formListItem, null, false, false);\n+    }\n+\n+    public static FormDetails toFormDetails(FormListItem formListItem, String manifestFileHash, boolean isNewerFormVersionAvailable, boolean areNewerMediaFilesAvailable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMjY0MQ=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTQxNTU5OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/logic/FormDetails.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTowODo0M1rOGtvRoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOTowNjo1M1rOGt1rgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMzY2NA==", "bodyText": "Is all this really necessary? Wouldn't comparing the hash and the error string be sufficient? The download URL would also be needed if somehow you could have downloads from multiple servers going on at the same time but I don't think we have any intention of making that possible. It seems weird to compare these status objects, anyway. Where is this used? Or is it just hashing that ends up getting used?", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450613664", "createdAt": "2020-07-07T05:08:43Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/logic/FormDetails.java", "diffHunk": "@@ -87,4 +90,48 @@ public boolean isNewerFormVersionAvailable() {\n     public boolean areNewerMediaFilesAvailable() {\n         return areNewerMediaFilesAvailable;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FormDetails that = (FormDetails) o;\n+        return isNewerFormVersionAvailable() == that.isNewerFormVersionAvailable() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxODU5Mw==", "bodyText": "This is just using the Android Studio equals/hash generator. Probably good to add a comment when I do that. Generally I'd argue for \"data\" objects like this it makes sense to just compare the whole thing (like we'd get with Lombok or Kotlin) unless we have a very good reason to do otherwise.\nI generated this for testing with mockito but I ended up converting to a fake (which makes life easier) so I can just kill this code.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r450718593", "createdAt": "2020-07-07T09:06:53Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/logic/FormDetails.java", "diffHunk": "@@ -87,4 +90,48 @@ public boolean isNewerFormVersionAvailable() {\n     public boolean areNewerMediaFilesAvailable() {\n         return areNewerMediaFilesAvailable;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FormDetails that = (FormDetails) o;\n+        return isNewerFormVersionAvailable() == that.isNewerFormVersionAvailable() &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMzY2NA=="}, "originalCommit": {"oid": "7509c58681820585ebeb00737bfbb9f23250d2c5"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjc1NjEzOnYy", "diffSide": "RIGHT", "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/settings/MatchExactlyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToxNTo1MVrOGuP4iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToxNTo1MVrOGuP4iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NzkxMw==", "bodyText": "This should be whenMatchExactlyNotEnabled or whenMatchExactlyDisabled or whatever!", "url": "https://github.com/getodk/collect/pull/3956#discussion_r451147913", "createdAt": "2020-07-07T21:15:51Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/settings/MatchExactlyTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.odk.collect.android.feature.settings;\n+\n+import android.Manifest;\n+import android.webkit.MimeTypeMap;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.R;\n+import org.odk.collect.android.injection.config.AppDependencyModule;\n+import org.odk.collect.android.openrosa.OpenRosaHttpInterface;\n+import org.odk.collect.android.support.CollectTestRule;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.CountingScheduler;\n+import org.odk.collect.android.support.CountingSchedulerIdlingResource;\n+import org.odk.collect.android.support.IdlingResourceRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.support.StubOpenRosaServer;\n+import org.odk.collect.async.CoroutineScheduler;\n+import org.odk.collect.async.Scheduler;\n+import org.odk.collect.utilities.UserAgentProvider;\n+\n+import static androidx.test.espresso.Espresso.onView;\n+import static androidx.test.espresso.assertion.ViewAssertions.doesNotExist;\n+import static androidx.test.espresso.matcher.ViewMatchers.withId;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class MatchExactlyTest {\n+\n+    public final StubOpenRosaServer server = new StubOpenRosaServer();\n+    private final CountingScheduler countingScheduler = new CountingScheduler(new CoroutineScheduler());\n+\n+    public CollectTestRule rule = new CollectTestRule();\n+\n+    @Rule\n+    public RuleChain copyFormChain = RuleChain\n+            .outerRule(GrantPermissionRule.grant(\n+                    Manifest.permission.READ_EXTERNAL_STORAGE,\n+                    Manifest.permission.WRITE_EXTERNAL_STORAGE,\n+                    Manifest.permission.READ_PHONE_STATE\n+            ))\n+            .around(new ResetStateRule(new AppDependencyModule() {\n+                @Override\n+                public OpenRosaHttpInterface provideHttpInterface(MimeTypeMap mimeTypeMap, UserAgentProvider userAgentProvider) {\n+                    return server;\n+                }\n+\n+                @Override\n+                public Scheduler providesScheduler() {\n+                    return countingScheduler;\n+                }\n+            }))\n+            .around(new IdlingResourceRule(new CountingSchedulerIdlingResource(countingScheduler)))\n+            .around(new CopyFormRule(\"one-question.xml\"))\n+            .around(new CopyFormRule(\"one-question-repeat.xml\"))\n+            .around(rule);\n+\n+    @Test\n+    public void whenMatchExactlyEnabled_clickingFillBlankForm_andClickingRefresh_getsLatestFormsFromServer() {\n+        server.addForm(\"One Question Updated\", \"one_question\", \"one-question-updated.xml\");\n+        server.addForm(\"Two Question\", \"two_question\", \"two-question.xml\");\n+\n+        rule.mainMenu()\n+                .setServer(server.getURL())\n+                .enableMatchExactly()\n+                .clickFillBlankForm()\n+                .assertText(\"One Question\")\n+                .assertText(\"One Question Repeat\")\n+                .clickRefresh()\n+                .assertText(\"Two Question\") // Check new form downloaded\n+                .assertText(\"One Question Updated\") // Check updated form updated\n+                .assertTextDoesNotExist(\"One Question Repeat\"); // Check deleted form deleted\n+    }\n+\n+    @Test\n+    public void whenMatchExactlyEnabled_getBlankFormsButtonIsGone() {\n+        rule.mainMenu()\n+                .enableMatchExactly()\n+                .assertTextNotDisplayed(R.string.get_forms);\n+    }\n+\n+    @Test\n+    public void whenMatchExactlyEnabled_formManagementFormUpdateIsDisabled() {\n+        rule.mainMenu()\n+                .enableMatchExactly()\n+                .clickOnMenu()\n+                .clickGeneralSettings()\n+                .clickFormManagement()\n+                .assertDisabled(R.string.periodic_form_updates_check_title)\n+                .assertDisabled(R.string.automatic_download)\n+                .assertDisabled(R.string.hide_old_form_versions_setting_title);\n+    }\n+\n+    @Test\n+    public void whenMatchExactlyEnabled_fillBlankFormRefreshButtonIsGone() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19e081ffed9af4a6a5695fdb7e0d9cfa22dd4083"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjc4NDExOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/forms/DatabaseFormRepository.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToyNDozNVrOGuQJQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToyNDozNVrOGuQJQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1MjE5Mg==", "bodyText": "In our live review we talked about in a follow-up PR considering changing this to a Set. There's no reason for the results to be ordered and sets will make some client code cleaner. We also talked about replacing contains with a get by jrFormId (which should also return a set with potentially multiple versions). No action needed now but writing it down so we don't forget.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r451152192", "createdAt": "2020-07-07T21:24:35Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/forms/DatabaseFormRepository.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.odk.collect.android.forms;\n+\n+import android.database.Cursor;\n+\n+import org.odk.collect.android.dao.FormsDao;\n+\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+public class DatabaseFormRepository implements FormRepository {\n+\n+    @Override\n+    public boolean contains(String jrFormID) {\n+        try (Cursor cursor = new FormsDao().getFormsCursorForFormId(jrFormID)) {\n+            return cursor != null && cursor.getCount() > 0;\n+        }\n+    }\n+\n+    @Override\n+    public List<Form> getAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19e081ffed9af4a6a5695fdb7e0d9cfa22dd4083"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjc5NzI5OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/utilities/FormListDownloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToyODo1NlrOGuQRUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToyODo1NlrOGuQRUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NDI1Nw==", "bodyText": "Not actionable so let's do Timber.w or remove since it goes to the UI.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r451154257", "createdAt": "2020-07-07T21:28:56Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/utilities/FormListDownloader.java", "diffHunk": "@@ -110,213 +80,38 @@ public FormListDownloader(\n             }\n         }\n \n-        DocumentFetchResult result = openRosaAPIClient.getXML(downloadListUrl);\n-\n-        clearTemporaryCredentials(url);\n-\n-        // If we can't get the document, return the error, cancel the task\n-        if (result.errorMessage != null) {\n-            if (result.responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n-                formList.put(DL_AUTH_REQUIRED, new FormDetails(result.errorMessage));\n-            } else {\n-                formList.put(DL_ERROR_MSG, new FormDetails(result.errorMessage));\n-            }\n-            return formList;\n-        }\n-\n-        if (result.isOpenRosaResponse) {\n-            // Attempt OpenRosa 1.0 parsing\n-            Element xformsElement = result.doc.getRootElement();\n-            if (!xformsElement.getName().equals(\"xforms\")) {\n-                String error = \"root element is not <xforms> : \" + xformsElement.getName();\n-                Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                formList.put(\n-                        DL_ERROR_MSG,\n-                        new FormDetails(application.getString(\n-                                R.string.parse_openrosa_formlist_failed, error)));\n-                return formList;\n-            }\n-            String namespace = xformsElement.getNamespace();\n-            if (!isXformsListNamespacedElement(xformsElement)) {\n-                String error = \"root element namespace is incorrect:\" + namespace;\n-                Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                formList.put(\n-                        DL_ERROR_MSG,\n-                        new FormDetails(application.getString(\n-                                R.string.parse_openrosa_formlist_failed, error)));\n-                return formList;\n-            }\n-            int elements = xformsElement.getChildCount();\n-            for (int i = 0; i < elements; ++i) {\n-                if (xformsElement.getType(i) != Element.ELEMENT) {\n-                    // e.g., whitespace (text)\n-                    continue;\n-                }\n-                Element xformElement = xformsElement.getElement(i);\n-                if (!isXformsListNamespacedElement(xformElement)) {\n-                    // someone else's extension?\n-                    continue;\n-                }\n-                String name = xformElement.getName();\n-                if (!name.equalsIgnoreCase(\"xform\")) {\n-                    // someone else's extension?\n-                    continue;\n-                }\n+        OpenRosaFormListApi formAPI = new OpenRosaFormListApi(openRosaXMLFetcher, downloadListUrl, downloadPath);\n+        // We populate this with available forms from the specified server.\n+        // <formname, details>\n+        HashMap<String, ServerFormDetails> formList = new HashMap<>();\n \n-                // this is something we know how to interpret\n-                String formId = null;\n-                String formName = null;\n-                String version = null;\n-                String majorMinorVersion = null;\n-                String description = null;\n-                String downloadUrl = null;\n-                String manifestUrl = null;\n-                String hash = null;\n-                // don't process descriptionUrl\n-                int fieldCount = xformElement.getChildCount();\n-                for (int j = 0; j < fieldCount; ++j) {\n-                    if (xformElement.getType(j) != Element.ELEMENT) {\n-                        // whitespace\n-                        continue;\n-                    }\n-                    Element child = xformElement.getElement(j);\n-                    if (!isXformsListNamespacedElement(child)) {\n-                        // someone else's extension?\n-                        continue;\n-                    }\n-                    String tag = child.getName();\n-                    switch (tag) {\n-                        case \"formID\":\n-                            formId = XFormParser.getXMLText(child, true);\n-                            if (formId != null && formId.length() == 0) {\n-                                formId = null;\n-                            }\n-                            break;\n-                        case \"name\":\n-                            formName = XFormParser.getXMLText(child, true);\n-                            if (formName != null && formName.length() == 0) {\n-                                formName = null;\n-                            }\n-                            break;\n-                        case \"version\":\n-                            version = XFormParser.getXMLText(child, true);\n-                            if (version != null && version.length() == 0) {\n-                                version = null;\n-                            }\n-                            break;\n-                        case \"majorMinorVersion\":\n-                            majorMinorVersion = XFormParser.getXMLText(child, true);\n-                            if (majorMinorVersion != null && majorMinorVersion.length() == 0) {\n-                                majorMinorVersion = null;\n-                            }\n-                            break;\n-                        case \"descriptionText\":\n-                            description = XFormParser.getXMLText(child, true);\n-                            if (description != null && description.length() == 0) {\n-                                description = null;\n-                            }\n-                            break;\n-                        case \"downloadUrl\":\n-                            downloadUrl = XFormParser.getXMLText(child, true);\n-                            if (downloadUrl != null && downloadUrl.length() == 0) {\n-                                downloadUrl = null;\n-                            }\n-                            break;\n-                        case \"manifestUrl\":\n-                            manifestUrl = XFormParser.getXMLText(child, true);\n-                            if (manifestUrl != null && manifestUrl.length() == 0) {\n-                                manifestUrl = null;\n-                            }\n-                            break;\n-                        case \"hash\":\n-                            hash = XFormParser.getXMLText(child, true);\n-                            if (hash != null && hash.length() == 0) {\n-                                hash = null;\n-                            }\n-                            break;\n-                    }\n-                }\n-                if (formId == null || downloadUrl == null || formName == null) {\n-                    String error =\n-                            \"Forms list entry \" + Integer.toString(i)\n-                                    + \" has missing or empty tags: formID, name, or downloadUrl\";\n-                    Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                    formList.clear();\n-                    formList.put(\n-                            DL_ERROR_MSG,\n-                            new FormDetails(application.getString(\n-                                    R.string.parse_openrosa_formlist_failed, error)));\n-                    return formList;\n-                }\n-                boolean isNewerFormVersionAvailable = false;\n-                boolean areNewerMediaFilesAvailable = false;\n-                ManifestFile manifestFile = null;\n-                if (isThisFormAlreadyDownloaded(formId)) {\n-                    isNewerFormVersionAvailable = isNewerFormVersionAvailable(FormDownloader.getMd5Hash(hash));\n-                    if ((!isNewerFormVersionAvailable || alwaysCheckMediaFiles) && manifestUrl != null) {\n-                        manifestFile = getManifestFile(manifestUrl);\n-                        if (manifestFile != null) {\n-                            List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n-                            if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n-                                areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(formId, version, newMediaFiles);\n-                            }\n-                        }\n-                    }\n-                }\n-                formList.put(formId, new FormDetails(formName, downloadUrl, manifestUrl, formId,\n-                        (version != null) ? version : majorMinorVersion, hash,\n-                        manifestFile != null ? manifestFile.getHash() : null,\n-                        isNewerFormVersionAvailable, areNewerMediaFilesAvailable));\n+        try {\n+            ServerFormsDetailsFetcher serverFormsDetailsFetcher = new ServerFormsDetailsFetcher(formRepository, mediaFileRepository, formAPI);\n+            List<ServerFormDetails> serverFormDetailsList = serverFormsDetailsFetcher.fetchFormDetails(alwaysCheckMediaFiles);\n+            for (ServerFormDetails serverFormDetails : serverFormDetailsList) {\n+                formList.put(serverFormDetails.getFormId(), serverFormDetails);\n             }\n-        } else {\n-            // Aggregate 0.9.x mode...\n-            // populate HashMap with form names and urls\n-            Element formsElement = result.doc.getRootElement();\n-            int formsCount = formsElement.getChildCount();\n-            String formId = null;\n-            for (int i = 0; i < formsCount; ++i) {\n-                if (formsElement.getType(i) != Element.ELEMENT) {\n-                    // whitespace\n-                    continue;\n-                }\n-                Element child = formsElement.getElement(i);\n-                String tag = child.getName();\n-                if (tag.equals(\"formID\")) {\n-                    formId = XFormParser.getXMLText(child, true);\n-                    if (formId != null && formId.length() == 0) {\n-                        formId = null;\n-                    }\n-                }\n-                if (tag.equalsIgnoreCase(\"form\")) {\n-                    String formName = XFormParser.getXMLText(child, true);\n-                    if (formName != null && formName.length() == 0) {\n-                        formName = null;\n-                    }\n-                    String downloadUrl = child.getAttributeValue(null, \"url\");\n-                    downloadUrl = downloadUrl.trim();\n-                    if (downloadUrl.length() == 0) {\n-                        downloadUrl = null;\n-                    }\n-                    if (formName == null) {\n-                        String error =\n-                                \"Forms list entry \" + Integer.toString(i)\n-                                        + \" is missing form name or url attribute\";\n-                        Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                        formList.clear();\n-                        formList.put(\n-                                DL_ERROR_MSG,\n-                                new FormDetails(application.getString(\n-                                        R.string.parse_legacy_formlist_failed, error)));\n-                        return formList;\n-                    }\n-                    formList.put(formName,\n-                            new FormDetails(formName, downloadUrl, null, formId, null, null, null, false, false));\n-\n-                    formId = null;\n-                }\n+        } catch (FormApiException formApiException) {\n+            Timber.e(formApiException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19e081ffed9af4a6a5695fdb7e0d9cfa22dd4083"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjgwMjk1OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/utilities/FormListDownloader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTozMDo0OVrOGuQU5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0NDowMlrOGueKzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NTE3NQ==", "bodyText": "I couldn't really come up with a reliable and efficient way to verify that you addressed the exact same exception list when extracting OpenRosaFormListApi. That means I'm just trusting you on that and it seems like a potential source of risk.", "url": "https://github.com/getodk/collect/pull/3956#discussion_r451155175", "createdAt": "2020-07-07T21:30:49Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/utilities/FormListDownloader.java", "diffHunk": "@@ -110,213 +80,38 @@ public FormListDownloader(\n             }\n         }\n \n-        DocumentFetchResult result = openRosaAPIClient.getXML(downloadListUrl);\n-\n-        clearTemporaryCredentials(url);\n-\n-        // If we can't get the document, return the error, cancel the task\n-        if (result.errorMessage != null) {\n-            if (result.responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n-                formList.put(DL_AUTH_REQUIRED, new FormDetails(result.errorMessage));\n-            } else {\n-                formList.put(DL_ERROR_MSG, new FormDetails(result.errorMessage));\n-            }\n-            return formList;\n-        }\n-\n-        if (result.isOpenRosaResponse) {\n-            // Attempt OpenRosa 1.0 parsing\n-            Element xformsElement = result.doc.getRootElement();\n-            if (!xformsElement.getName().equals(\"xforms\")) {\n-                String error = \"root element is not <xforms> : \" + xformsElement.getName();\n-                Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                formList.put(\n-                        DL_ERROR_MSG,\n-                        new FormDetails(application.getString(\n-                                R.string.parse_openrosa_formlist_failed, error)));\n-                return formList;\n-            }\n-            String namespace = xformsElement.getNamespace();\n-            if (!isXformsListNamespacedElement(xformsElement)) {\n-                String error = \"root element namespace is incorrect:\" + namespace;\n-                Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                formList.put(\n-                        DL_ERROR_MSG,\n-                        new FormDetails(application.getString(\n-                                R.string.parse_openrosa_formlist_failed, error)));\n-                return formList;\n-            }\n-            int elements = xformsElement.getChildCount();\n-            for (int i = 0; i < elements; ++i) {\n-                if (xformsElement.getType(i) != Element.ELEMENT) {\n-                    // e.g., whitespace (text)\n-                    continue;\n-                }\n-                Element xformElement = xformsElement.getElement(i);\n-                if (!isXformsListNamespacedElement(xformElement)) {\n-                    // someone else's extension?\n-                    continue;\n-                }\n-                String name = xformElement.getName();\n-                if (!name.equalsIgnoreCase(\"xform\")) {\n-                    // someone else's extension?\n-                    continue;\n-                }\n+        OpenRosaFormListApi formAPI = new OpenRosaFormListApi(openRosaXMLFetcher, downloadListUrl, downloadPath);\n+        // We populate this with available forms from the specified server.\n+        // <formname, details>\n+        HashMap<String, ServerFormDetails> formList = new HashMap<>();\n \n-                // this is something we know how to interpret\n-                String formId = null;\n-                String formName = null;\n-                String version = null;\n-                String majorMinorVersion = null;\n-                String description = null;\n-                String downloadUrl = null;\n-                String manifestUrl = null;\n-                String hash = null;\n-                // don't process descriptionUrl\n-                int fieldCount = xformElement.getChildCount();\n-                for (int j = 0; j < fieldCount; ++j) {\n-                    if (xformElement.getType(j) != Element.ELEMENT) {\n-                        // whitespace\n-                        continue;\n-                    }\n-                    Element child = xformElement.getElement(j);\n-                    if (!isXformsListNamespacedElement(child)) {\n-                        // someone else's extension?\n-                        continue;\n-                    }\n-                    String tag = child.getName();\n-                    switch (tag) {\n-                        case \"formID\":\n-                            formId = XFormParser.getXMLText(child, true);\n-                            if (formId != null && formId.length() == 0) {\n-                                formId = null;\n-                            }\n-                            break;\n-                        case \"name\":\n-                            formName = XFormParser.getXMLText(child, true);\n-                            if (formName != null && formName.length() == 0) {\n-                                formName = null;\n-                            }\n-                            break;\n-                        case \"version\":\n-                            version = XFormParser.getXMLText(child, true);\n-                            if (version != null && version.length() == 0) {\n-                                version = null;\n-                            }\n-                            break;\n-                        case \"majorMinorVersion\":\n-                            majorMinorVersion = XFormParser.getXMLText(child, true);\n-                            if (majorMinorVersion != null && majorMinorVersion.length() == 0) {\n-                                majorMinorVersion = null;\n-                            }\n-                            break;\n-                        case \"descriptionText\":\n-                            description = XFormParser.getXMLText(child, true);\n-                            if (description != null && description.length() == 0) {\n-                                description = null;\n-                            }\n-                            break;\n-                        case \"downloadUrl\":\n-                            downloadUrl = XFormParser.getXMLText(child, true);\n-                            if (downloadUrl != null && downloadUrl.length() == 0) {\n-                                downloadUrl = null;\n-                            }\n-                            break;\n-                        case \"manifestUrl\":\n-                            manifestUrl = XFormParser.getXMLText(child, true);\n-                            if (manifestUrl != null && manifestUrl.length() == 0) {\n-                                manifestUrl = null;\n-                            }\n-                            break;\n-                        case \"hash\":\n-                            hash = XFormParser.getXMLText(child, true);\n-                            if (hash != null && hash.length() == 0) {\n-                                hash = null;\n-                            }\n-                            break;\n-                    }\n-                }\n-                if (formId == null || downloadUrl == null || formName == null) {\n-                    String error =\n-                            \"Forms list entry \" + Integer.toString(i)\n-                                    + \" has missing or empty tags: formID, name, or downloadUrl\";\n-                    Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                    formList.clear();\n-                    formList.put(\n-                            DL_ERROR_MSG,\n-                            new FormDetails(application.getString(\n-                                    R.string.parse_openrosa_formlist_failed, error)));\n-                    return formList;\n-                }\n-                boolean isNewerFormVersionAvailable = false;\n-                boolean areNewerMediaFilesAvailable = false;\n-                ManifestFile manifestFile = null;\n-                if (isThisFormAlreadyDownloaded(formId)) {\n-                    isNewerFormVersionAvailable = isNewerFormVersionAvailable(FormDownloader.getMd5Hash(hash));\n-                    if ((!isNewerFormVersionAvailable || alwaysCheckMediaFiles) && manifestUrl != null) {\n-                        manifestFile = getManifestFile(manifestUrl);\n-                        if (manifestFile != null) {\n-                            List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n-                            if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n-                                areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(formId, version, newMediaFiles);\n-                            }\n-                        }\n-                    }\n-                }\n-                formList.put(formId, new FormDetails(formName, downloadUrl, manifestUrl, formId,\n-                        (version != null) ? version : majorMinorVersion, hash,\n-                        manifestFile != null ? manifestFile.getHash() : null,\n-                        isNewerFormVersionAvailable, areNewerMediaFilesAvailable));\n+        try {\n+            ServerFormsDetailsFetcher serverFormsDetailsFetcher = new ServerFormsDetailsFetcher(formRepository, mediaFileRepository, formAPI);\n+            List<ServerFormDetails> serverFormDetailsList = serverFormsDetailsFetcher.fetchFormDetails(alwaysCheckMediaFiles);\n+            for (ServerFormDetails serverFormDetails : serverFormDetailsList) {\n+                formList.put(serverFormDetails.getFormId(), serverFormDetails);\n             }\n-        } else {\n-            // Aggregate 0.9.x mode...\n-            // populate HashMap with form names and urls\n-            Element formsElement = result.doc.getRootElement();\n-            int formsCount = formsElement.getChildCount();\n-            String formId = null;\n-            for (int i = 0; i < formsCount; ++i) {\n-                if (formsElement.getType(i) != Element.ELEMENT) {\n-                    // whitespace\n-                    continue;\n-                }\n-                Element child = formsElement.getElement(i);\n-                String tag = child.getName();\n-                if (tag.equals(\"formID\")) {\n-                    formId = XFormParser.getXMLText(child, true);\n-                    if (formId != null && formId.length() == 0) {\n-                        formId = null;\n-                    }\n-                }\n-                if (tag.equalsIgnoreCase(\"form\")) {\n-                    String formName = XFormParser.getXMLText(child, true);\n-                    if (formName != null && formName.length() == 0) {\n-                        formName = null;\n-                    }\n-                    String downloadUrl = child.getAttributeValue(null, \"url\");\n-                    downloadUrl = downloadUrl.trim();\n-                    if (downloadUrl.length() == 0) {\n-                        downloadUrl = null;\n-                    }\n-                    if (formName == null) {\n-                        String error =\n-                                \"Forms list entry \" + Integer.toString(i)\n-                                        + \" is missing form name or url attribute\";\n-                        Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                        formList.clear();\n-                        formList.put(\n-                                DL_ERROR_MSG,\n-                                new FormDetails(application.getString(\n-                                        R.string.parse_legacy_formlist_failed, error)));\n-                        return formList;\n-                    }\n-                    formList.put(formName,\n-                            new FormDetails(formName, downloadUrl, null, formId, null, null, null, false, false));\n-\n-                    formId = null;\n-                }\n+        } catch (FormApiException formApiException) {\n+            Timber.e(formApiException);\n+\n+            switch (formApiException.getType()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19e081ffed9af4a6a5695fdb7e0d9cfa22dd4083"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MTk2NQ==", "bodyText": "Yeah I agree this is a source of risk!", "url": "https://github.com/getodk/collect/pull/3956#discussion_r451381965", "createdAt": "2020-07-08T08:44:02Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/utilities/FormListDownloader.java", "diffHunk": "@@ -110,213 +80,38 @@ public FormListDownloader(\n             }\n         }\n \n-        DocumentFetchResult result = openRosaAPIClient.getXML(downloadListUrl);\n-\n-        clearTemporaryCredentials(url);\n-\n-        // If we can't get the document, return the error, cancel the task\n-        if (result.errorMessage != null) {\n-            if (result.responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n-                formList.put(DL_AUTH_REQUIRED, new FormDetails(result.errorMessage));\n-            } else {\n-                formList.put(DL_ERROR_MSG, new FormDetails(result.errorMessage));\n-            }\n-            return formList;\n-        }\n-\n-        if (result.isOpenRosaResponse) {\n-            // Attempt OpenRosa 1.0 parsing\n-            Element xformsElement = result.doc.getRootElement();\n-            if (!xformsElement.getName().equals(\"xforms\")) {\n-                String error = \"root element is not <xforms> : \" + xformsElement.getName();\n-                Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                formList.put(\n-                        DL_ERROR_MSG,\n-                        new FormDetails(application.getString(\n-                                R.string.parse_openrosa_formlist_failed, error)));\n-                return formList;\n-            }\n-            String namespace = xformsElement.getNamespace();\n-            if (!isXformsListNamespacedElement(xformsElement)) {\n-                String error = \"root element namespace is incorrect:\" + namespace;\n-                Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                formList.put(\n-                        DL_ERROR_MSG,\n-                        new FormDetails(application.getString(\n-                                R.string.parse_openrosa_formlist_failed, error)));\n-                return formList;\n-            }\n-            int elements = xformsElement.getChildCount();\n-            for (int i = 0; i < elements; ++i) {\n-                if (xformsElement.getType(i) != Element.ELEMENT) {\n-                    // e.g., whitespace (text)\n-                    continue;\n-                }\n-                Element xformElement = xformsElement.getElement(i);\n-                if (!isXformsListNamespacedElement(xformElement)) {\n-                    // someone else's extension?\n-                    continue;\n-                }\n-                String name = xformElement.getName();\n-                if (!name.equalsIgnoreCase(\"xform\")) {\n-                    // someone else's extension?\n-                    continue;\n-                }\n+        OpenRosaFormListApi formAPI = new OpenRosaFormListApi(openRosaXMLFetcher, downloadListUrl, downloadPath);\n+        // We populate this with available forms from the specified server.\n+        // <formname, details>\n+        HashMap<String, ServerFormDetails> formList = new HashMap<>();\n \n-                // this is something we know how to interpret\n-                String formId = null;\n-                String formName = null;\n-                String version = null;\n-                String majorMinorVersion = null;\n-                String description = null;\n-                String downloadUrl = null;\n-                String manifestUrl = null;\n-                String hash = null;\n-                // don't process descriptionUrl\n-                int fieldCount = xformElement.getChildCount();\n-                for (int j = 0; j < fieldCount; ++j) {\n-                    if (xformElement.getType(j) != Element.ELEMENT) {\n-                        // whitespace\n-                        continue;\n-                    }\n-                    Element child = xformElement.getElement(j);\n-                    if (!isXformsListNamespacedElement(child)) {\n-                        // someone else's extension?\n-                        continue;\n-                    }\n-                    String tag = child.getName();\n-                    switch (tag) {\n-                        case \"formID\":\n-                            formId = XFormParser.getXMLText(child, true);\n-                            if (formId != null && formId.length() == 0) {\n-                                formId = null;\n-                            }\n-                            break;\n-                        case \"name\":\n-                            formName = XFormParser.getXMLText(child, true);\n-                            if (formName != null && formName.length() == 0) {\n-                                formName = null;\n-                            }\n-                            break;\n-                        case \"version\":\n-                            version = XFormParser.getXMLText(child, true);\n-                            if (version != null && version.length() == 0) {\n-                                version = null;\n-                            }\n-                            break;\n-                        case \"majorMinorVersion\":\n-                            majorMinorVersion = XFormParser.getXMLText(child, true);\n-                            if (majorMinorVersion != null && majorMinorVersion.length() == 0) {\n-                                majorMinorVersion = null;\n-                            }\n-                            break;\n-                        case \"descriptionText\":\n-                            description = XFormParser.getXMLText(child, true);\n-                            if (description != null && description.length() == 0) {\n-                                description = null;\n-                            }\n-                            break;\n-                        case \"downloadUrl\":\n-                            downloadUrl = XFormParser.getXMLText(child, true);\n-                            if (downloadUrl != null && downloadUrl.length() == 0) {\n-                                downloadUrl = null;\n-                            }\n-                            break;\n-                        case \"manifestUrl\":\n-                            manifestUrl = XFormParser.getXMLText(child, true);\n-                            if (manifestUrl != null && manifestUrl.length() == 0) {\n-                                manifestUrl = null;\n-                            }\n-                            break;\n-                        case \"hash\":\n-                            hash = XFormParser.getXMLText(child, true);\n-                            if (hash != null && hash.length() == 0) {\n-                                hash = null;\n-                            }\n-                            break;\n-                    }\n-                }\n-                if (formId == null || downloadUrl == null || formName == null) {\n-                    String error =\n-                            \"Forms list entry \" + Integer.toString(i)\n-                                    + \" has missing or empty tags: formID, name, or downloadUrl\";\n-                    Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                    formList.clear();\n-                    formList.put(\n-                            DL_ERROR_MSG,\n-                            new FormDetails(application.getString(\n-                                    R.string.parse_openrosa_formlist_failed, error)));\n-                    return formList;\n-                }\n-                boolean isNewerFormVersionAvailable = false;\n-                boolean areNewerMediaFilesAvailable = false;\n-                ManifestFile manifestFile = null;\n-                if (isThisFormAlreadyDownloaded(formId)) {\n-                    isNewerFormVersionAvailable = isNewerFormVersionAvailable(FormDownloader.getMd5Hash(hash));\n-                    if ((!isNewerFormVersionAvailable || alwaysCheckMediaFiles) && manifestUrl != null) {\n-                        manifestFile = getManifestFile(manifestUrl);\n-                        if (manifestFile != null) {\n-                            List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n-                            if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n-                                areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(formId, version, newMediaFiles);\n-                            }\n-                        }\n-                    }\n-                }\n-                formList.put(formId, new FormDetails(formName, downloadUrl, manifestUrl, formId,\n-                        (version != null) ? version : majorMinorVersion, hash,\n-                        manifestFile != null ? manifestFile.getHash() : null,\n-                        isNewerFormVersionAvailable, areNewerMediaFilesAvailable));\n+        try {\n+            ServerFormsDetailsFetcher serverFormsDetailsFetcher = new ServerFormsDetailsFetcher(formRepository, mediaFileRepository, formAPI);\n+            List<ServerFormDetails> serverFormDetailsList = serverFormsDetailsFetcher.fetchFormDetails(alwaysCheckMediaFiles);\n+            for (ServerFormDetails serverFormDetails : serverFormDetailsList) {\n+                formList.put(serverFormDetails.getFormId(), serverFormDetails);\n             }\n-        } else {\n-            // Aggregate 0.9.x mode...\n-            // populate HashMap with form names and urls\n-            Element formsElement = result.doc.getRootElement();\n-            int formsCount = formsElement.getChildCount();\n-            String formId = null;\n-            for (int i = 0; i < formsCount; ++i) {\n-                if (formsElement.getType(i) != Element.ELEMENT) {\n-                    // whitespace\n-                    continue;\n-                }\n-                Element child = formsElement.getElement(i);\n-                String tag = child.getName();\n-                if (tag.equals(\"formID\")) {\n-                    formId = XFormParser.getXMLText(child, true);\n-                    if (formId != null && formId.length() == 0) {\n-                        formId = null;\n-                    }\n-                }\n-                if (tag.equalsIgnoreCase(\"form\")) {\n-                    String formName = XFormParser.getXMLText(child, true);\n-                    if (formName != null && formName.length() == 0) {\n-                        formName = null;\n-                    }\n-                    String downloadUrl = child.getAttributeValue(null, \"url\");\n-                    downloadUrl = downloadUrl.trim();\n-                    if (downloadUrl.length() == 0) {\n-                        downloadUrl = null;\n-                    }\n-                    if (formName == null) {\n-                        String error =\n-                                \"Forms list entry \" + Integer.toString(i)\n-                                        + \" is missing form name or url attribute\";\n-                        Timber.e(\"Parsing OpenRosa reply -- %s\", error);\n-                        formList.clear();\n-                        formList.put(\n-                                DL_ERROR_MSG,\n-                                new FormDetails(application.getString(\n-                                        R.string.parse_legacy_formlist_failed, error)));\n-                        return formList;\n-                    }\n-                    formList.put(formName,\n-                            new FormDetails(formName, downloadUrl, null, formId, null, null, null, false, false));\n-\n-                    formId = null;\n-                }\n+        } catch (FormApiException formApiException) {\n+            Timber.e(formApiException);\n+\n+            switch (formApiException.getType()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NTE3NQ=="}, "originalCommit": {"oid": "19e081ffed9af4a6a5695fdb7e0d9cfa22dd4083"}, "originalPosition": 344}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3224, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}