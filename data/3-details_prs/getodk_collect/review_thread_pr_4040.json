{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNjM5NDIy", "number": 4040, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMjozODo0MlrOEi6wHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODoxODozNVrOEsu_mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDQ5NjMxOnYy", "diffSide": "LEFT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QyMjozODo0MlrOHQ_5Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTo1MjoyMlrOHRMTAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU4NjExNQ==", "bodyText": "@seadowg and I briefly talked about whether the use of the ODK cache directory could have any significance. All files are eventually cleaned up and I don't see any reason why any particular directory has to be used. Passing in the base cache directory, whatever it is, is certainly an improvement.\nAm I understanding correctly that you've kept using storagePathProvider.getDirPath(StorageSubdirectory.CACHE) but create an enclosing directory for each form's files so that can be deleted on cancel rather than having to touch individual files? That seems fine, as would using the Android scoped cache directory.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r487586115", "createdAt": "2020-09-13T22:38:42Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "diffHunk": "@@ -339,13 +354,13 @@ FileResult downloadXform(String formName, String url, FormDownloaderListener sta\n          * SurveyCTO: The file is saved into a temp folder and is moved to the final place if everything\n          * is okay, so that garbage is not left over on cancel.\n          */\n-        private void writeFile(File file, FormDownloaderListener stateListener, InputStream inputStream)\n+        private void writeFile(File file, FormDownloaderListener stateListener, InputStream inputStream, File tempDir)\n                 throws IOException, InterruptedException {\n \n             File tempFile = File.createTempFile(\n                     file.getName(),\n                     TEMP_DOWNLOAD_EXTENSION,\n-                    new File(storagePathProvider.getDirPath(StorageSubdirectory.CACHE))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0368fa57029f6b0027f86b668872be522b244308"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4OTMxNA==", "bodyText": "Yeah that's right! I think going one step further and use the Android cache directory (directly) in the dependency declaration (AppDependencyModule) would be nice as well.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r487789314", "createdAt": "2020-09-14T09:52:22Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "diffHunk": "@@ -339,13 +354,13 @@ FileResult downloadXform(String formName, String url, FormDownloaderListener sta\n          * SurveyCTO: The file is saved into a temp folder and is moved to the final place if everything\n          * is okay, so that garbage is not left over on cancel.\n          */\n-        private void writeFile(File file, FormDownloaderListener stateListener, InputStream inputStream)\n+        private void writeFile(File file, FormDownloaderListener stateListener, InputStream inputStream, File tempDir)\n                 throws IOException, InterruptedException {\n \n             File tempFile = File.createTempFile(\n                     file.getName(),\n                     TEMP_DOWNLOAD_EXTENSION,\n-                    new File(storagePathProvider.getDirPath(StorageSubdirectory.CACHE))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU4NjExNQ=="}, "originalCommit": {"oid": "0368fa57029f6b0027f86b668872be522b244308"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDMxNjcxOnYy", "diffSide": "RIGHT", "path": ".circleci/config.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjoyMjowMVrOHaa2Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjoyMjowMVrOHaa2Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ2NDkwNw==", "bodyText": "This new job allows us to run all the submodule tests in parallel to the app tests and the quality checks which as we move more things out to submodules will hopefully keep our test CI time under control", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497464907", "createdAt": "2020-09-30T12:22:01Z", "author": {"login": "seadowg"}, "path": ".circleci/config.yml", "diffHunk": "@@ -37,7 +37,7 @@ jobs:\n           path: collect_app/build/reports\n           destination: reports\n \n-  test_unit:\n+  test_modules:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8fee5efaf9495812223eb4514d39bb0d0ac7dcf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDMxODQyOnYy", "diffSide": "LEFT", "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/formmanagement/DeleteBlankFormTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjoyMjozNFrOHaa3ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjoyMjozNFrOHaa3ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ2NTE4OQ==", "bodyText": "This is now covered in the ServerFormDownloaderTest", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497465189", "createdAt": "2020-09-30T12:22:34Z", "author": {"login": "seadowg"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/feature/formmanagement/DeleteBlankFormTest.java", "diffHunk": "@@ -63,36 +63,6 @@ public void deletingAForm_whenThereFilledForms_removesFormFromBlankFormList_butA\n                 .clickSaveAndExit();\n     }\n \n-    @Test\n-    public void afterFillingAForm_andDeletingIt_allowsFormToBeReDownloaded() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8fee5efaf9495812223eb4514d39bb0d0ac7dcf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDM3MTU5OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/FormMetadataParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozNjo0MFrOHabYzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozNjo0MFrOHabYzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3Mzc0MA==", "bodyText": "This was begging to be pulled out", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497473740", "createdAt": "2020-09-30T12:36:40Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/FormMetadataParser.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import org.javarosa.core.reference.ReferenceManager;\n+import org.javarosa.core.reference.RootTranslator;\n+import org.odk.collect.android.logic.FileReferenceFactory;\n+import org.odk.collect.android.utilities.FileUtils;\n+\n+import java.io.File;\n+import java.nio.charset.Charset;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.odk.collect.android.utilities.FileUtils.LAST_SAVED_FILENAME;\n+import static org.odk.collect.android.utilities.FileUtils.STUB_XML;\n+import static org.odk.collect.android.utilities.FileUtils.write;\n+\n+public class FormMetadataParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72546652d59309d3129bf1854709d2d5c32532bc"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDM3NTc5OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDetails.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozNzozNVrOHabbXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozNzozNVrOHabbXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NDM5Ng==", "bodyText": "We now just always include the manifest as part of the form details so logic that deals with it can be simpler (and doesn't end up fetching the manifest when it doesn't need to).", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497474396", "createdAt": "2020-09-30T12:37:35Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDetails.java", "diffHunk": "@@ -28,22 +28,22 @@\n     private final String formID;\n     private final String formVersion;\n     private final String hash;\n-    private final String manifestFileHash;\n     private final boolean isNotOnDevice;\n     private final boolean isUpdated;\n+    private final ManifestFile manifest;\n \n     public ServerFormDetails(String formName, String downloadUrl, String manifestUrl, String formID,\n-                             String formVersion, String hash, String manifestFileHash,\n-                             boolean isNotOnDevice, boolean isUpdated) {\n+                             String formVersion, String hash,\n+                             boolean isNotOnDevice, boolean isUpdated, ManifestFile manifest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72546652d59309d3129bf1854709d2d5c32532bc"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDM4MTQ3OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozODo1N1rOHabe2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozODo1N1rOHabe2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NTI5MA==", "bodyText": "The MultiFormDownloader lives on in here as pulling it apart entirely is going to be pretty time-consuming and we've already hit the core goal of getting rid of any references to it in the rest of the code.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497475290", "createdAt": "2020-09-30T12:38:57Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "diffHunk": "@@ -1,30 +1,538 @@\n package org.odk.collect.android.formmanagement;\n \n+import android.net.Uri;\n+\n+import org.javarosa.core.reference.ReferenceManager;\n import org.odk.collect.android.R;\n import org.odk.collect.android.application.Collect;\n-import org.odk.collect.android.utilities.MultiFormDownloader;\n+import org.odk.collect.android.listeners.FormDownloaderListener;\n+import org.odk.collect.android.provider.FormsProviderAPI;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.FormNameUtils;\n+import org.odk.collect.android.utilities.Validator;\n+import org.odk.collect.forms.Form;\n+import org.odk.collect.forms.FormsRepository;\n+import org.odk.collect.server.FormApiException;\n+import org.odk.collect.server.FormListApi;\n+import org.odk.collect.server.MediaFile;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n \n-import java.util.Collections;\n-import java.util.HashMap;\n+import timber.log.Timber;\n+\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.odk.collect.utilities.PathUtils.getAbsoluteFilePath;\n \n /**\n- * Provides a sarcophagus for {@link org.odk.collect.android.utilities.MultiFormDownloader} so it\n+ * Provides a sarcophagus for {@link MultiFormDownloader} so it\n  * can eventually be disposed of.\n  */\n public class ServerFormDownloader implements FormDownloader {\n \n     private final MultiFormDownloader multiFormDownloader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72546652d59309d3129bf1854709d2d5c32532bc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDQwMTI4OnYy", "diffSide": "LEFT", "path": "collect_app/src/main/java/org/odk/collect/android/storage/StoragePathProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo0Mzo1MlrOHabq2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo0Mzo1MlrOHabq2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3ODM2MQ==", "bodyText": "It was clear when working with ServerFormDownloader that this part of the interface feels like too much as the provider becomes responsible for calculations that are based on it's state but have logic (calculating a relative or absolute path) that can live separately. All the extra helpers increase the coupling on whatever object is using it.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497478361", "createdAt": "2020-09-30T12:43:52Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/storage/StoragePathProvider.java", "diffHunk": "@@ -96,10 +99,6 @@ public String getFormDbPath(String filePath) {\n         return getDbPath(getDirPath(StorageSubdirectory.FORMS), filePath);\n     }\n \n-    public String getAbsoluteFormFilePath(String filePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96fcdd1ecd26e18d9d5e626b2fa1622b21aaa2c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDQxNzYzOnYy", "diffSide": "LEFT", "path": "config/quality.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo0Nzo0NVrOHab1Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMTo0NDowOVrOHdbCSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MTAwNw==", "bodyText": "This is moved into the core collect_app module", "url": "https://github.com/getodk/collect/pull/4040#discussion_r497481007", "createdAt": "2020-09-30T12:47:45Z", "author": {"login": "seadowg"}, "path": "config/quality.gradle", "diffHunk": "@@ -46,18 +46,4 @@ tasks.register(\"pmd\", Pmd) {\n             setDestination new File(\"$reportsDir/pmd/pmd.html\")\n         }\n     }\n-}\n-\n-//------------------------Lint------------------------//\n-\n-android {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96fcdd1ecd26e18d9d5e626b2fa1622b21aaa2c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYxMzcwNQ==", "bodyText": "Doesn't this mean lint won't be run on the submodules? Shouldn't it?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500613705", "createdAt": "2020-10-06T21:44:09Z", "author": {"login": "lognaturel"}, "path": "config/quality.gradle", "diffHunk": "@@ -46,18 +46,4 @@ tasks.register(\"pmd\", Pmd) {\n             setDestination new File(\"$reportsDir/pmd/pmd.html\")\n         }\n     }\n-}\n-\n-//------------------------Lint------------------------//\n-\n-android {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MTAwNw=="}, "originalCommit": {"oid": "f96fcdd1ecd26e18d9d5e626b2fa1622b21aaa2c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDQ2MDM2OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/preferences/FormUpdateMode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToxOTo1MFrOHdaWOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjo0MToyNVrOHdxV2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwMjQyNg==", "bodyText": "What made you want this package change? It's kind of a weird one because it's for the preferences part of the formmanagement feature. Curious to know how you make that decision as we move more towards feature-based packages.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500602426", "createdAt": "2020-10-06T21:19:50Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/preferences/FormUpdateMode.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package org.odk.collect.android.formmanagement;\n+package org.odk.collect.android.preferences;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f9b3c3791e7b0635febdffeaab5152624aaad92"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3OTE2Mg==", "bodyText": "I think I bounced around on this a few times. For me it was that the actual setting of the mode is a settings/preference concern and then other parts of the app ask about it. I'm starting to think about settings as its own section of the app that provides config for everything else. In that way (in my head) it makes sense that it owns the domain objects/data models associated with it. Does that make sense?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500979162", "createdAt": "2020-10-07T12:41:25Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/preferences/FormUpdateMode.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package org.odk.collect.android.formmanagement;\n+package org.odk.collect.android.preferences;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwMjQyNg=="}, "originalCommit": {"oid": "1f9b3c3791e7b0635febdffeaab5152624aaad92"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDQ3ODY3OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToyNTo0NlrOHdahRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjo1Mjo1M1rOHdxzsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNTI1NQ==", "bodyText": "I think this changes behavior. Previously, the presence of media updates was only checked if we didn't already know new XML was available. Now, if media files are available, we ignore whether or not new XML is available and only do an update if new media is available. I think the enclosing condition can be changed to !isNewerFormVersionAvailable && manifestFile != null -- we only care to check media for updates if we already know there isn't new XML.\n    @Test\n    public void whenAFormExists_andIsUpdatedOnServer_andDoesNotHaveNewMedia_isUpdated() throws Exception {\n        formsRepository.save(new Form.Builder()\n                .id(2L)\n                .jrFormId(\"form-2\")\n                .md5Hash(\"form-2-hash-old\")\n                .build());\n\n        File localMediaFile = File.createTempFile(\"blah\", \".csv\");\n        writeToFile(localMediaFile, \"blah\");\n        when(mediaFileRepository.getAll(\"form-2\", \"server\")).thenReturn(asList(localMediaFile));\n\n        List<ServerFormDetails> serverFormDetails = fetcher.fetchFormDetails();\n        assertThat(serverFormDetails.get(1).isUpdated(), is(true));\n    }", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500605255", "createdAt": "2020-10-06T21:25:46Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "diffHunk": "@@ -71,13 +70,13 @@ public void updateFormListApi(String url, WebCredentialsUtils webCredentialsUtil\n \n             boolean thisFormAlreadyDownloaded = !formsRepository.getByJrFormIdNotDeleted(listItem.getFormID()).isEmpty();\n             if (thisFormAlreadyDownloaded) {\n-                isNewerFormVersionAvailable = isNewerFormVersionAvailable(getMd5HashWithoutPrefix(listItem.getHashWithPrefix()));\n+                isNewerFormVersionAvailable = isNewerFormVersionAvailable(listItem);\n \n                 if (manifestFile != null) {\n                     List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n \n                     if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n-                        areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);\n+                        isNewerFormVersionAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306dc0d8e20a6458b6615058a01e062e940091c1"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4NjgwMg==", "bodyText": "Ah nice. So many points for communicating the problem with a failing test.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500986802", "createdAt": "2020-10-07T12:52:53Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormsDetailsFetcher.java", "diffHunk": "@@ -71,13 +70,13 @@ public void updateFormListApi(String url, WebCredentialsUtils webCredentialsUtil\n \n             boolean thisFormAlreadyDownloaded = !formsRepository.getByJrFormIdNotDeleted(listItem.getFormID()).isEmpty();\n             if (thisFormAlreadyDownloaded) {\n-                isNewerFormVersionAvailable = isNewerFormVersionAvailable(getMd5HashWithoutPrefix(listItem.getHashWithPrefix()));\n+                isNewerFormVersionAvailable = isNewerFormVersionAvailable(listItem);\n \n                 if (manifestFile != null) {\n                     List<MediaFile> newMediaFiles = manifestFile.getMediaFiles();\n \n                     if (newMediaFiles != null && !newMediaFiles.isEmpty()) {\n-                        areNewerMediaFilesAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);\n+                        isNewerFormVersionAvailable = areNewerMediaFilesAvailable(listItem.getFormID(), listItem.getVersion(), newMediaFiles);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNTI1NQ=="}, "originalCommit": {"oid": "306dc0d8e20a6458b6615058a01e062e940091c1"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDQ4OTg3OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToyOToxOFrOHdaoTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozNzo0N1rOHdzwog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNzA1NA==", "bodyText": "Just showing \"Failure\" rather than any more specific message was already part of the match exactly changes, right? So this doesn't change behavior?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500607054", "createdAt": "2020-10-06T21:29:18Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "diffHunk": "@@ -67,7 +67,7 @@ public DownloadFormsTask(FormDownloader formDownloader) {\n \n                 results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n             } catch (FormDownloadException e) {\n-                results.put(serverFormDetails, e.getMessage());\n+                results.put(serverFormDetails, Collect.getInstance().getString(R.string.failure));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3625660fbb352099cb9408fe3760bb9827586a6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4NzMyNA==", "bodyText": "Yeah I think this might be a mistake I made during a rebase... Will fix.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500987324", "createdAt": "2020-10-07T12:53:42Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "diffHunk": "@@ -67,7 +67,7 @@ public DownloadFormsTask(FormDownloader formDownloader) {\n \n                 results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n             } catch (FormDownloadException e) {\n-                results.put(serverFormDetails, e.getMessage());\n+                results.put(serverFormDetails, Collect.getInstance().getString(R.string.failure));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNzA1NA=="}, "originalCommit": {"oid": "a3625660fbb352099cb9408fe3760bb9827586a6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxODc4Ng==", "bodyText": "No wait sorry this looks right I read the diff in reverse.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501018786", "createdAt": "2020-10-07T13:37:47Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "diffHunk": "@@ -67,7 +67,7 @@ public DownloadFormsTask(FormDownloader formDownloader) {\n \n                 results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n             } catch (FormDownloadException e) {\n-                results.put(serverFormDetails, e.getMessage());\n+                results.put(serverFormDetails, Collect.getInstance().getString(R.string.failure));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNzA1NA=="}, "originalCommit": {"oid": "a3625660fbb352099cb9408fe3760bb9827586a6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDc2MzQxOnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/utilities/PathUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMzoyMDowNVrOHddMxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjo0MjoxM1rOHdxYAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY0OTE1Ng==", "bodyText": "Really, I think we should be using Paths and relativize. For some other time.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500649156", "createdAt": "2020-10-06T23:20:05Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/utilities/PathUtils.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.odk.collect.utilities;\n+\n+import java.io.File;\n+\n+public class PathUtils {\n+\n+    private PathUtils() {\n+\n+    }\n+\n+    public static String getRelativeFilePath(String dirPath, String filePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3OTcxNA==", "bodyText": "huh. Yeah probably!", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500979714", "createdAt": "2020-10-07T12:42:13Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/utilities/PathUtils.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.odk.collect.utilities;\n+\n+import java.io.File;\n+\n+public class PathUtils {\n+\n+    private PathUtils() {\n+\n+    }\n+\n+    public static String getRelativeFilePath(String dirPath, String filePath) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY0OTE1Ng=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDc2NTY0OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/utilities/PathUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMzoyMToxMlrOHddOAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMzoyMToxMlrOHddOAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY0OTQ3Mg==", "bodyText": "Path.resolve", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500649472", "createdAt": "2020-10-06T23:21:12Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/utilities/PathUtils.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.odk.collect.utilities;\n+\n+import java.io.File;\n+\n+public class PathUtils {\n+\n+    private PathUtils() {\n+\n+    }\n+\n+    public static String getRelativeFilePath(String dirPath, String filePath) {\n+        return filePath.startsWith(dirPath)\n+                ? filePath.substring(dirPath.length() + 1)\n+                : filePath;\n+    }\n+\n+    public static String getAbsoluteFilePath(String dirPath, String filePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDgyODM1OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMzo1MjowM1rOHddy8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjo0Njo1NFrOHdxkIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1ODkzMA==", "bodyText": "Somehow I haven't noticed this signature. Why is the first param ArrayList<ServerFormDetails> rather than just ServerFormDetails? Feels unusual that doInBackground needs to access the 0th element. Did this change at some point or has it always been like this?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500658930", "createdAt": "2020-10-06T23:52:03Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "diffHunk": "@@ -33,32 +38,51 @@\n  * @author carlhartung\n  */\n public class DownloadFormsTask extends\n-        AsyncTask<ArrayList<ServerFormDetails>, String, HashMap<ServerFormDetails, String>> implements FormDownloaderListener {\n+        AsyncTask<ArrayList<ServerFormDetails>, String, Map<ServerFormDetails, String>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MjgxNw==", "bodyText": "Ah it's weirdness with AsyncTask where execute takes a varargs of Params. Generally to avoid how consfusing this ends up looking I'd leave Params as Void and pass anything I need into the constructor (as you can't reuse an AsyncTask anyway). I think we can leave this for the moment as it's existing and ideally we want to just get rid of the AsyncTask rather than improve it.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500982817", "createdAt": "2020-10-07T12:46:54Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/tasks/DownloadFormsTask.java", "diffHunk": "@@ -33,32 +38,51 @@\n  * @author carlhartung\n  */\n public class DownloadFormsTask extends\n-        AsyncTask<ArrayList<ServerFormDetails>, String, HashMap<ServerFormDetails, String>> implements FormDownloaderListener {\n+        AsyncTask<ArrayList<ServerFormDetails>, String, Map<ServerFormDetails, String>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1ODkzMA=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg1Mjg1OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDowNDoyM1rOHdeBdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToyMzo1MVrOHd428A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2MjY0NA==", "bodyText": "This is not actually possible through the UI, is it? If it is, shouldn't the status for forms that did download be updated?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500662644", "createdAt": "2020-10-07T00:04:23Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "diffHunk": "@@ -77,8 +80,18 @@\n                     if (preferencesProvider.getGeneralSharedPreferences().getBoolean(KEY_AUTOMATIC_UPDATE, false)) {\n                         changeLock.withLock(acquiredLock -> {\n                             if (acquiredLock) {\n-                                final HashMap<ServerFormDetails, String> result = multiFormDownloader.downloadForms(updatedForms, null);\n-                                notifier.onUpdatesDownloaded(result);\n+                                HashMap<ServerFormDetails, String> results = new HashMap<>();\n+                                for (ServerFormDetails serverFormDetails : updatedForms) {\n+                                    try {\n+                                        formDownloader.downloadForm(serverFormDetails, null, null);\n+                                        results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n+                                    } catch (FormDownloadException e) {\n+                                        results.put(serverFormDetails, e.getMessage());\n+                                    } catch (InterruptedException e) {\n+                                        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMjg3NQ==", "bodyText": "Yeah. This should really just be a break I think?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501022875", "createdAt": "2020-10-07T13:43:18Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "diffHunk": "@@ -77,8 +80,18 @@\n                     if (preferencesProvider.getGeneralSharedPreferences().getBoolean(KEY_AUTOMATIC_UPDATE, false)) {\n                         changeLock.withLock(acquiredLock -> {\n                             if (acquiredLock) {\n-                                final HashMap<ServerFormDetails, String> result = multiFormDownloader.downloadForms(updatedForms, null);\n-                                notifier.onUpdatesDownloaded(result);\n+                                HashMap<ServerFormDetails, String> results = new HashMap<>();\n+                                for (ServerFormDetails serverFormDetails : updatedForms) {\n+                                    try {\n+                                        formDownloader.downloadForm(serverFormDetails, null, null);\n+                                        results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n+                                    } catch (FormDownloadException e) {\n+                                        results.put(serverFormDetails, e.getMessage());\n+                                    } catch (InterruptedException e) {\n+                                        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2MjY0NA=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwMjMyMA==", "bodyText": "Yes, break sounds right.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501102320", "createdAt": "2020-10-07T15:23:51Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "diffHunk": "@@ -77,8 +80,18 @@\n                     if (preferencesProvider.getGeneralSharedPreferences().getBoolean(KEY_AUTOMATIC_UPDATE, false)) {\n                         changeLock.withLock(acquiredLock -> {\n                             if (acquiredLock) {\n-                                final HashMap<ServerFormDetails, String> result = multiFormDownloader.downloadForms(updatedForms, null);\n-                                notifier.onUpdatesDownloaded(result);\n+                                HashMap<ServerFormDetails, String> results = new HashMap<>();\n+                                for (ServerFormDetails serverFormDetails : updatedForms) {\n+                                    try {\n+                                        formDownloader.downloadForm(serverFormDetails, null, null);\n+                                        results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n+                                    } catch (FormDownloadException e) {\n+                                        results.put(serverFormDetails, e.getMessage());\n+                                    } catch (InterruptedException e) {\n+                                        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2MjY0NA=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg1ODE3OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDowNzowMVrOHdeEaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzo0Mzo0OFrOHd0CDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2MzQwMw==", "bodyText": "There will never be a message for this. I believe the only place that exception is thrown is at https://github.com/getodk/collect/pull/4040/files?file-filters%5B%5D=.gradle&file-filters%5B%5D=.java&file-filters%5B%5D=.xml#diff-8ae847a7cbae59b9a61bd5868b5c6514R65. Is the client robust to nulls? Should this maybe be the failure message?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500663403", "createdAt": "2020-10-07T00:07:01Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "diffHunk": "@@ -77,8 +80,18 @@\n                     if (preferencesProvider.getGeneralSharedPreferences().getBoolean(KEY_AUTOMATIC_UPDATE, false)) {\n                         changeLock.withLock(acquiredLock -> {\n                             if (acquiredLock) {\n-                                final HashMap<ServerFormDetails, String> result = multiFormDownloader.downloadForms(updatedForms, null);\n-                                notifier.onUpdatesDownloaded(result);\n+                                HashMap<ServerFormDetails, String> results = new HashMap<>();\n+                                for (ServerFormDetails serverFormDetails : updatedForms) {\n+                                    try {\n+                                        formDownloader.downloadForm(serverFormDetails, null, null);\n+                                        results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n+                                    } catch (FormDownloadException e) {\n+                                        results.put(serverFormDetails, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMzI0Ng==", "bodyText": "Yeah I think this should just be the failure message.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501023246", "createdAt": "2020-10-07T13:43:48Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/backgroundwork/AutoUpdateTaskSpec.java", "diffHunk": "@@ -77,8 +80,18 @@\n                     if (preferencesProvider.getGeneralSharedPreferences().getBoolean(KEY_AUTOMATIC_UPDATE, false)) {\n                         changeLock.withLock(acquiredLock -> {\n                             if (acquiredLock) {\n-                                final HashMap<ServerFormDetails, String> result = multiFormDownloader.downloadForms(updatedForms, null);\n-                                notifier.onUpdatesDownloaded(result);\n+                                HashMap<ServerFormDetails, String> results = new HashMap<>();\n+                                for (ServerFormDetails serverFormDetails : updatedForms) {\n+                                    try {\n+                                        formDownloader.downloadForm(serverFormDetails, null, null);\n+                                        results.put(serverFormDetails, Collect.getInstance().getString(R.string.success));\n+                                    } catch (FormDownloadException e) {\n+                                        results.put(serverFormDetails, e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2MzQwMw=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg4ODY0OnYy", "diffSide": "RIGHT", "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoyMjoyOVrOHdeWEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoyMjoyOVrOHdeWEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NzkyMQ==", "bodyText": "Canceled -> Cancelled", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500667921", "createdAt": "2020-10-07T00:22:29Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/formmanagement/ServerFormDownloader.java", "diffHunk": "@@ -1,31 +1,532 @@\n package org.odk.collect.android.formmanagement;\n \n+import android.net.Uri;\n+\n+import org.javarosa.core.reference.ReferenceManager;\n import org.odk.collect.android.R;\n import org.odk.collect.android.application.Collect;\n-import org.odk.collect.android.utilities.MultiFormDownloader;\n-import org.odk.collect.android.utilities.TranslationHandler;\n+import org.odk.collect.android.listeners.FormDownloaderListener;\n+import org.odk.collect.android.provider.FormsProviderAPI;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.FormNameUtils;\n+import org.odk.collect.android.utilities.Validator;\n+import org.odk.collect.forms.Form;\n+import org.odk.collect.forms.FormsRepository;\n+import org.odk.collect.server.FormApiException;\n+import org.odk.collect.server.FormListApi;\n+import org.odk.collect.server.MediaFile;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n \n-import java.util.Collections;\n-import java.util.HashMap;\n+import timber.log.Timber;\n+\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.odk.collect.utilities.PathUtils.getAbsoluteFilePath;\n \n-/**\n- * Provides a sarcophagus for {@link org.odk.collect.android.utilities.MultiFormDownloader} so it\n- * can eventually be disposed of.\n- */\n public class ServerFormDownloader implements FormDownloader {\n \n     private final MultiFormDownloader multiFormDownloader;\n+    private final FormsRepository formsRepository;\n+    private final File cacheDir;\n+    private final String formsDirPath;\n \n-    public ServerFormDownloader(MultiFormDownloader multiFormDownloader) {\n-        this.multiFormDownloader = multiFormDownloader;\n+    public ServerFormDownloader(FormListApi formListApi, FormsRepository formsRepository, File cacheDir, String formsDirPath) {\n+        this.cacheDir = cacheDir;\n+        this.formsDirPath = formsDirPath;\n+        this.multiFormDownloader = new MultiFormDownloader(formsRepository, formListApi);\n+        this.formsRepository = formsRepository;\n     }\n \n     @Override\n-    public void downloadForm(ServerFormDetails form) throws FormDownloadException {\n-        HashMap<ServerFormDetails, String> results = multiFormDownloader.downloadForms(Collections.singletonList(form), null);\n-        boolean failure = results.values().stream().anyMatch(s -> !s.equals(TranslationHandler.getString(Collect.getInstance(), R.string.success)));\n-        if (failure) {\n-            throw new FormDownloadException();\n+    public void downloadForm(ServerFormDetails form, @Nullable ProgressReporter progressReporter, @Nullable Supplier<Boolean> isCancelled) throws FormDownloadException, InterruptedException {\n+        Form formOnDevice = formsRepository.get(form.getFormId(), form.getFormVersion());\n+        if (formOnDevice != null && formOnDevice.isDeleted()) {\n+            formsRepository.restore(formOnDevice.getId());\n+        }\n+\n+        File tempDir = new File(cacheDir, \"download-\" + UUID.randomUUID().toString());\n+        tempDir.mkdirs();\n+\n+        try {\n+            FormDownloaderListener stateListener = new ProgressReporterAndSupplierStateListener(progressReporter, isCancelled);\n+            boolean result = multiFormDownloader.processOneForm(form, stateListener, tempDir, formsDirPath);\n+\n+            if (!result) {\n+                throw new FormDownloadException();\n+            }\n+        } finally {\n+            try {\n+                deleteDirectory(tempDir);\n+            } catch (IOException ignored) {\n+                // ignored\n+            }\n+        }\n+    }\n+\n+    private static class ProgressReporterAndSupplierStateListener implements FormDownloaderListener {\n+        private final ProgressReporter progressReporter;\n+        private final Supplier<Boolean> isCancelled;\n+\n+        ProgressReporterAndSupplierStateListener(ProgressReporter progressReporter, Supplier<Boolean> isCancelled) {\n+            this.progressReporter = progressReporter;\n+            this.isCancelled = isCancelled;\n+        }\n+\n+        @Override\n+        public void progressUpdate(String currentFile, String progress, String total) {\n+            if (progressReporter != null) {\n+                progressReporter.onDownloadingMediaFile(Integer.parseInt(progress));\n+            }\n+        }\n+\n+        @Override\n+        public boolean isTaskCanceled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTMzNzkyOnYy", "diffSide": "RIGHT", "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/ServerFormDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNDo0MjoxOFrOHdiXSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNDo0MjoxOFrOHdiXSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczMzc2OQ==", "bodyText": "Expected?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500733769", "createdAt": "2020-10-07T04:42:18Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/ServerFormDownloaderTest.java", "diffHunk": "@@ -0,0 +1,349 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import com.google.common.io.Files;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.odk.collect.android.support.InMemFormsRepository;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.WebCredentialsUtils;\n+import org.odk.collect.forms.Form;\n+import org.odk.collect.forms.FormsRepository;\n+import org.odk.collect.server.FormApiException;\n+import org.odk.collect.server.FormListApi;\n+import org.odk.collect.server.FormListItem;\n+import org.odk.collect.server.ManifestFile;\n+import org.odk.collect.server.MediaFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.support.FormUtils.buildForm;\n+import static org.odk.collect.android.support.FormUtils.createXForm;\n+import static org.odk.collect.android.utilities.FileUtils.read;\n+import static org.odk.collect.utilities.PathUtils.getAbsoluteFilePath;\n+\n+@SuppressWarnings(\"PMD.DoubleBraceInitialization\")\n+public class ServerFormDownloaderTest {\n+\n+    private final FormsRepository formsRepository = new InMemFormsRepository();\n+\n+    private File cacheDir;\n+    private File formsDir;\n+\n+    @Before\n+    public void setup() {\n+        cacheDir = Files.createTempDir();\n+        formsDir = Files.createTempDir();\n+    }\n+\n+    @Test\n+    public void downloadsAndSavesForm() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+    }\n+\n+    @Test\n+    public void whenFormHasMediaFiles_downloadsAndSavesFormAndMediaFiles() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file1\")).thenReturn(new ByteArrayInputStream(\"contents1\".getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file2\")).thenReturn(new ByteArrayInputStream(\"contents2\".getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+\n+        File mediaFile1 = new File(form.getFormMediaPath() + \"/file1\");\n+        assertThat(mediaFile1.exists(), is(true));\n+        assertThat(new String(read(mediaFile1)), is(\"contents1\"));\n+\n+        File mediaFile2 = new File(form.getFormMediaPath() + \"/file2\");\n+        assertThat(mediaFile2.exists(), is(true));\n+        assertThat(new String(read(mediaFile2)), is(\"contents2\"));\n+    }\n+\n+    @Test\n+    public void afterDownloadingXForm_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        CancelAfterFormDownloadFormListApi formListApi = new CancelAfterFormDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTMzODY5OnYy", "diffSide": "RIGHT", "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/ServerFormDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNDo0Mjo1MVrOHdiXyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo0Mjo0N1rOHd5uVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczMzg5Ng==", "bodyText": "Add test for media file progress?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500733896", "createdAt": "2020-10-07T04:42:51Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/ServerFormDownloaderTest.java", "diffHunk": "@@ -0,0 +1,349 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import com.google.common.io.Files;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.odk.collect.android.support.InMemFormsRepository;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.WebCredentialsUtils;\n+import org.odk.collect.forms.Form;\n+import org.odk.collect.forms.FormsRepository;\n+import org.odk.collect.server.FormApiException;\n+import org.odk.collect.server.FormListApi;\n+import org.odk.collect.server.FormListItem;\n+import org.odk.collect.server.ManifestFile;\n+import org.odk.collect.server.MediaFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.support.FormUtils.buildForm;\n+import static org.odk.collect.android.support.FormUtils.createXForm;\n+import static org.odk.collect.android.utilities.FileUtils.read;\n+import static org.odk.collect.utilities.PathUtils.getAbsoluteFilePath;\n+\n+@SuppressWarnings(\"PMD.DoubleBraceInitialization\")\n+public class ServerFormDownloaderTest {\n+\n+    private final FormsRepository formsRepository = new InMemFormsRepository();\n+\n+    private File cacheDir;\n+    private File formsDir;\n+\n+    @Before\n+    public void setup() {\n+        cacheDir = Files.createTempDir();\n+        formsDir = Files.createTempDir();\n+    }\n+\n+    @Test\n+    public void downloadsAndSavesForm() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+    }\n+\n+    @Test\n+    public void whenFormHasMediaFiles_downloadsAndSavesFormAndMediaFiles() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file1\")).thenReturn(new ByteArrayInputStream(\"contents1\".getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file2\")).thenReturn(new ByteArrayInputStream(\"contents2\".getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+\n+        File mediaFile1 = new File(form.getFormMediaPath() + \"/file1\");\n+        assertThat(mediaFile1.exists(), is(true));\n+        assertThat(new String(read(mediaFile1)), is(\"contents1\"));\n+\n+        File mediaFile2 = new File(form.getFormMediaPath() + \"/file2\");\n+        assertThat(mediaFile2.exists(), is(true));\n+        assertThat(new String(read(mediaFile2)), is(\"contents2\"));\n+    }\n+\n+    @Test\n+    public void afterDownloadingXForm_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        CancelAfterFormDownloadFormListApi formListApi = new CancelAfterFormDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");\n+        } catch (InterruptedException e) {\n+            assertThat(formsRepository.getAll(), is(empty()));\n+            assertThat(asList(new File(getCacheFilesPath()).listFiles()), is(empty()));\n+            assertThat(asList(new File(getFormFilesPath()).listFiles()), is(empty()));\n+        }\n+    }\n+\n+    @Test\n+    public void afterDownloadingMediaFile_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        CancelAfterMediaFileDownloadFormListApi formListApi = new CancelAfterMediaFileDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");\n+        } catch (InterruptedException e) {\n+            assertThat(formsRepository.getAll(), is(empty()));\n+            assertThat(asList(new File(getCacheFilesPath()).listFiles()), is(empty()));\n+\n+            // The media directory is created early for some reason\n+            assertThat(asList(new File(getFormFilesPath()).listFiles()), contains(new File(getFormFilesPath() + \"/Form-media\")));\n+        }\n+    }\n+\n+    @Test\n+    public void beforeDownloadingMediaFile_reportsProgress() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzg3MA==", "bodyText": "I'm pretty sure I ended up not needing another test to drive that out (I basically used commenting/deleting to work out adding tests). You're right that from a documentation and regression standpoint though it would be nice to have the test.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500983870", "createdAt": "2020-10-07T12:48:36Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/ServerFormDownloaderTest.java", "diffHunk": "@@ -0,0 +1,349 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import com.google.common.io.Files;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.odk.collect.android.support.InMemFormsRepository;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.WebCredentialsUtils;\n+import org.odk.collect.forms.Form;\n+import org.odk.collect.forms.FormsRepository;\n+import org.odk.collect.server.FormApiException;\n+import org.odk.collect.server.FormListApi;\n+import org.odk.collect.server.FormListItem;\n+import org.odk.collect.server.ManifestFile;\n+import org.odk.collect.server.MediaFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.support.FormUtils.buildForm;\n+import static org.odk.collect.android.support.FormUtils.createXForm;\n+import static org.odk.collect.android.utilities.FileUtils.read;\n+import static org.odk.collect.utilities.PathUtils.getAbsoluteFilePath;\n+\n+@SuppressWarnings(\"PMD.DoubleBraceInitialization\")\n+public class ServerFormDownloaderTest {\n+\n+    private final FormsRepository formsRepository = new InMemFormsRepository();\n+\n+    private File cacheDir;\n+    private File formsDir;\n+\n+    @Before\n+    public void setup() {\n+        cacheDir = Files.createTempDir();\n+        formsDir = Files.createTempDir();\n+    }\n+\n+    @Test\n+    public void downloadsAndSavesForm() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+    }\n+\n+    @Test\n+    public void whenFormHasMediaFiles_downloadsAndSavesFormAndMediaFiles() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file1\")).thenReturn(new ByteArrayInputStream(\"contents1\".getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file2\")).thenReturn(new ByteArrayInputStream(\"contents2\".getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+\n+        File mediaFile1 = new File(form.getFormMediaPath() + \"/file1\");\n+        assertThat(mediaFile1.exists(), is(true));\n+        assertThat(new String(read(mediaFile1)), is(\"contents1\"));\n+\n+        File mediaFile2 = new File(form.getFormMediaPath() + \"/file2\");\n+        assertThat(mediaFile2.exists(), is(true));\n+        assertThat(new String(read(mediaFile2)), is(\"contents2\"));\n+    }\n+\n+    @Test\n+    public void afterDownloadingXForm_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        CancelAfterFormDownloadFormListApi formListApi = new CancelAfterFormDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");\n+        } catch (InterruptedException e) {\n+            assertThat(formsRepository.getAll(), is(empty()));\n+            assertThat(asList(new File(getCacheFilesPath()).listFiles()), is(empty()));\n+            assertThat(asList(new File(getFormFilesPath()).listFiles()), is(empty()));\n+        }\n+    }\n+\n+    @Test\n+    public void afterDownloadingMediaFile_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        CancelAfterMediaFileDownloadFormListApi formListApi = new CancelAfterMediaFileDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");\n+        } catch (InterruptedException e) {\n+            assertThat(formsRepository.getAll(), is(empty()));\n+            assertThat(asList(new File(getCacheFilesPath()).listFiles()), is(empty()));\n+\n+            // The media directory is created early for some reason\n+            assertThat(asList(new File(getFormFilesPath()).listFiles()), contains(new File(getFormFilesPath() + \"/Form-media\")));\n+        }\n+    }\n+\n+    @Test\n+    public void beforeDownloadingMediaFile_reportsProgress() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczMzg5Ng=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExNjUwMw==", "bodyText": "Wait looking back at this I'm not sure what test you think is missing here? I thought I was missing media file progress but I think this test is just badly named as it covers that?", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501116503", "createdAt": "2020-10-07T15:42:47Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/ServerFormDownloaderTest.java", "diffHunk": "@@ -0,0 +1,349 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import com.google.common.io.Files;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.odk.collect.android.support.InMemFormsRepository;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.WebCredentialsUtils;\n+import org.odk.collect.forms.Form;\n+import org.odk.collect.forms.FormsRepository;\n+import org.odk.collect.server.FormApiException;\n+import org.odk.collect.server.FormListApi;\n+import org.odk.collect.server.FormListItem;\n+import org.odk.collect.server.ManifestFile;\n+import org.odk.collect.server.MediaFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.support.FormUtils.buildForm;\n+import static org.odk.collect.android.support.FormUtils.createXForm;\n+import static org.odk.collect.android.utilities.FileUtils.read;\n+import static org.odk.collect.utilities.PathUtils.getAbsoluteFilePath;\n+\n+@SuppressWarnings(\"PMD.DoubleBraceInitialization\")\n+public class ServerFormDownloaderTest {\n+\n+    private final FormsRepository formsRepository = new InMemFormsRepository();\n+\n+    private File cacheDir;\n+    private File formsDir;\n+\n+    @Before\n+    public void setup() {\n+        cacheDir = Files.createTempDir();\n+        formsDir = Files.createTempDir();\n+    }\n+\n+    @Test\n+    public void downloadsAndSavesForm() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+    }\n+\n+    @Test\n+    public void whenFormHasMediaFiles_downloadsAndSavesFormAndMediaFiles() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        FormListApi formListApi = mock(FormListApi.class);\n+        when(formListApi.fetchForm(\"http://downloadUrl\")).thenReturn(new ByteArrayInputStream(xform.getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file1\")).thenReturn(new ByteArrayInputStream(\"contents1\".getBytes()));\n+        when(formListApi.fetchMediaFile(\"http://file2\")).thenReturn(new ByteArrayInputStream(\"contents2\".getBytes()));\n+\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+        downloader.downloadForm(serverFormDetails, null, null);\n+\n+        List<Form> allForms = formsRepository.getAll();\n+        assertThat(allForms.size(), is(1));\n+        Form form = allForms.get(0);\n+        assertThat(form.getJrFormId(), is(\"id\"));\n+\n+        File formFile = new File(getAbsoluteFilePath(formsDir.getAbsolutePath(), form.getFormFilePath()));\n+        assertThat(formFile.exists(), is(true));\n+        assertThat(new String(read(formFile)), is(xform));\n+\n+        File mediaFile1 = new File(form.getFormMediaPath() + \"/file1\");\n+        assertThat(mediaFile1.exists(), is(true));\n+        assertThat(new String(read(mediaFile1)), is(\"contents1\"));\n+\n+        File mediaFile2 = new File(form.getFormMediaPath() + \"/file2\");\n+        assertThat(mediaFile2.exists(), is(true));\n+        assertThat(new String(read(mediaFile2)), is(\"contents2\"));\n+    }\n+\n+    @Test\n+    public void afterDownloadingXForm_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                null);\n+\n+        CancelAfterFormDownloadFormListApi formListApi = new CancelAfterFormDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");\n+        } catch (InterruptedException e) {\n+            assertThat(formsRepository.getAll(), is(empty()));\n+            assertThat(asList(new File(getCacheFilesPath()).listFiles()), is(empty()));\n+            assertThat(asList(new File(getFormFilesPath()).listFiles()), is(empty()));\n+        }\n+    }\n+\n+    @Test\n+    public void afterDownloadingMediaFile_cancelling_throwsInterruptedExceptionAndDoesNotSaveAnything() throws Exception {\n+        String xform = createXForm(\"id\", \"version\");\n+        ServerFormDetails serverFormDetails = new ServerFormDetails(\n+                \"Form\",\n+                \"http://downloadUrl\",\n+                \"http://manifestUrl\",\n+                \"id\",\n+                \"version\",\n+                \"md5:\" + FileUtils.getMd5Hash(new ByteArrayInputStream(xform.getBytes())),\n+                true,\n+                false,\n+                new ManifestFile(\"\", asList(\n+                        new MediaFile(\"file1\", \"hash-1\", \"http://file1\"),\n+                        new MediaFile(\"file2\", \"hash-2\", \"http://file2\")\n+                )));\n+\n+        CancelAfterMediaFileDownloadFormListApi formListApi = new CancelAfterMediaFileDownloadFormListApi(xform);\n+        ServerFormDownloader downloader = new ServerFormDownloader(formListApi, formsRepository, cacheDir, formsDir.getAbsolutePath());\n+\n+        try {\n+            downloader.downloadForm(serverFormDetails, null, formListApi);\n+            fail(\"Excepted exception\");\n+        } catch (InterruptedException e) {\n+            assertThat(formsRepository.getAll(), is(empty()));\n+            assertThat(asList(new File(getCacheFilesPath()).listFiles()), is(empty()));\n+\n+            // The media directory is created early for some reason\n+            assertThat(asList(new File(getFormFilesPath()).listFiles()), contains(new File(getFormFilesPath() + \"/Form-media\")));\n+        }\n+    }\n+\n+    @Test\n+    public void beforeDownloadingMediaFile_reportsProgress() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczMzg5Ng=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTM0NTA4OnYy", "diffSide": "LEFT", "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNDo0Njo0MlrOHdibkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTozNTozOVrOHd5Z9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDg2Ng==", "bodyText": "I think this case should get coverage somewhere. I think the CSV case can be skipped but the last-saved one should also be captured.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500734866", "createdAt": "2020-10-07T04:46:42Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4NDE5NQ==", "bodyText": "Same as the media file progress test I think. Didn't need it but I think you're right we should add it in any way.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500984195", "createdAt": "2020-10-07T12:49:09Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDg2Ng=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5OTY0Mg==", "bodyText": "It's not the same. Only external secondary instances will actually use the ReferenceManager configured by FormMetadataParser. It's really easy for code there to get removed or modified (as it had been before).", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501099642", "createdAt": "2020-10-07T15:20:31Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDg2Ng=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExMTI4NQ==", "bodyText": "Sorry I mean \"same story\", not \"same code\".", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501111285", "createdAt": "2020-10-07T15:35:39Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDg2Ng=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTM0NTc5OnYy", "diffSide": "LEFT", "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNDo0NzoxMFrOHdicCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToyMToyOVrOHd4vbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDk4NA==", "bodyText": "I think this edge case is also important to capture somewhere.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500734984", "createdAt": "2020-10-07T04:47:10Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" >\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-external-xml-instance</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-external-xml-instance\\\">\\n\" +\n-                \"                    <first/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"external-xml\\\" src=\\\"jr://file/external-data.xml\\\" />\\n\" +\n-                \"            <bind nodeset=\\\"/data/first\\\" type=\\\"select1\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <select1 ref=\\\"/data/first\\\">\\n\" +\n-                \"            <label>First</label>\\n\" +\n-                \"            <itemset nodeset=\\\"instance('external-xml')/root/item[first='']\\\">\\n\" +\n-                \"                <value ref=\\\"name\\\"/>\\n\" +\n-                \"                <label ref=\\\"label\\\"/>\\n\" +\n-                \"            </itemset>\\n\" +\n-                \"        </select1>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicExternalXmlInstance\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        when(openRosaXMLFetcher.getXML(\"https://testserver/manifest.xml\")).thenReturn(buildManifestFetchResult(\"external-data.xml\"));\n-        when(openRosaXMLFetcher.getFile(\"https://testserver/external-data.xml\",\n-                null)).thenReturn(buildXmlExternalInstanceFetchResult());\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"basic-external-xml-instance\", \"https://testserver/form.xml\",\n-                \"https://testserver/manifest.xml\", \"basic-external-xml-instance\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    @Test\n-    public void downloadingFormWithCsvExternalSecondaryInstance_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" >\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-external-csv-instance</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-external-csv-instance\\\">\\n\" +\n-                \"                    <first/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"external-csv\\\" src=\\\"jr://file-csv/external-data.csv\\\" />\\n\" +\n-                \"            <bind nodeset=\\\"/data/first\\\" type=\\\"select1\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <select1 ref=\\\"/data/first\\\">\\n\" +\n-                \"            <label>First</label>\\n\" +\n-                \"            <itemset nodeset=\\\"instance('external-csv')/root/item[first='']\\\">\\n\" +\n-                \"                <value ref=\\\"name\\\"/>\\n\" +\n-                \"                <label ref=\\\"label\\\"/>\\n\" +\n-                \"            </itemset>\\n\" +\n-                \"        </select1>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicExternalCsvInstance\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        when(openRosaXMLFetcher.getXML(\"https://testserver/manifest.xml\")).thenReturn(buildManifestFetchResult(\"external-data.csv\"));\n-        when(openRosaXMLFetcher.getFile(\"https://testserver/external-data.csv\",\n-                null)).thenReturn(buildCsvExternalInstanceFetchResult());\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"basic-external-csv-instance\", \"https://testserver/form.xml\",\n-                \"https://testserver/manifest.xml\", \"basic-external-csv-instance\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with last-saved references are a special case of external secondary instances because\n-     * last-saved doesn't come from the remote server but is generated locally.\n-     */\n-    @Test\n-    public void downloadingFormWithLastSavedReference_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-last-saved</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-last-saved\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"__last-saved\\\" src=\\\"jr://instance/last-saved\\\"/>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"           <setvalue event=\\\"odk-instance-first-load\\\" ref=\\\"/data/q1\\\" value=\\\" instance('__last-saved')/data/q1 \\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicLastSaved\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"Last Saved\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"basic-last-saved\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Edge case: a form could have an attachment with filename last-saved.xml. This will get\n-     * replaced immediately on download and this test documents that behavior. We could let it go\n-     * through but let's replace it immediately to help a user who tries this troubleshoot.\n-     * Otherwise it would only be replaced when an instance is saved so a user could think everything\n-     * is ok if they only try launching the form once.\n-     *\n-     * This is an unfortunate side effect of using the form media folder to store the contents that\n-     * jr://instance/last-saved resolves to.\n-     *\n-     * Additionally, immediately replacing a secondary instance with name last-saved.xml avoid users\n-     * exploiting this current implementation quirk as a feature to preload defaults for the first\n-     * instance.\n-     * */\n-    @Test\n-    public void downloadingFormWithExternalSecondaryInstanceNamedLastSavedXml_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4NDI0MA==", "bodyText": "Same as the media file progress test I think. Didn't need it but I think you're right we should add it in any way.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r500984240", "createdAt": "2020-10-07T12:49:14Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" >\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-external-xml-instance</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-external-xml-instance\\\">\\n\" +\n-                \"                    <first/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"external-xml\\\" src=\\\"jr://file/external-data.xml\\\" />\\n\" +\n-                \"            <bind nodeset=\\\"/data/first\\\" type=\\\"select1\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <select1 ref=\\\"/data/first\\\">\\n\" +\n-                \"            <label>First</label>\\n\" +\n-                \"            <itemset nodeset=\\\"instance('external-xml')/root/item[first='']\\\">\\n\" +\n-                \"                <value ref=\\\"name\\\"/>\\n\" +\n-                \"                <label ref=\\\"label\\\"/>\\n\" +\n-                \"            </itemset>\\n\" +\n-                \"        </select1>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicExternalXmlInstance\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        when(openRosaXMLFetcher.getXML(\"https://testserver/manifest.xml\")).thenReturn(buildManifestFetchResult(\"external-data.xml\"));\n-        when(openRosaXMLFetcher.getFile(\"https://testserver/external-data.xml\",\n-                null)).thenReturn(buildXmlExternalInstanceFetchResult());\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"basic-external-xml-instance\", \"https://testserver/form.xml\",\n-                \"https://testserver/manifest.xml\", \"basic-external-xml-instance\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    @Test\n-    public void downloadingFormWithCsvExternalSecondaryInstance_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" >\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-external-csv-instance</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-external-csv-instance\\\">\\n\" +\n-                \"                    <first/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"external-csv\\\" src=\\\"jr://file-csv/external-data.csv\\\" />\\n\" +\n-                \"            <bind nodeset=\\\"/data/first\\\" type=\\\"select1\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <select1 ref=\\\"/data/first\\\">\\n\" +\n-                \"            <label>First</label>\\n\" +\n-                \"            <itemset nodeset=\\\"instance('external-csv')/root/item[first='']\\\">\\n\" +\n-                \"                <value ref=\\\"name\\\"/>\\n\" +\n-                \"                <label ref=\\\"label\\\"/>\\n\" +\n-                \"            </itemset>\\n\" +\n-                \"        </select1>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicExternalCsvInstance\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        when(openRosaXMLFetcher.getXML(\"https://testserver/manifest.xml\")).thenReturn(buildManifestFetchResult(\"external-data.csv\"));\n-        when(openRosaXMLFetcher.getFile(\"https://testserver/external-data.csv\",\n-                null)).thenReturn(buildCsvExternalInstanceFetchResult());\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"basic-external-csv-instance\", \"https://testserver/form.xml\",\n-                \"https://testserver/manifest.xml\", \"basic-external-csv-instance\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with last-saved references are a special case of external secondary instances because\n-     * last-saved doesn't come from the remote server but is generated locally.\n-     */\n-    @Test\n-    public void downloadingFormWithLastSavedReference_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-last-saved</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-last-saved\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"__last-saved\\\" src=\\\"jr://instance/last-saved\\\"/>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"           <setvalue event=\\\"odk-instance-first-load\\\" ref=\\\"/data/q1\\\" value=\\\" instance('__last-saved')/data/q1 \\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicLastSaved\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"Last Saved\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"basic-last-saved\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Edge case: a form could have an attachment with filename last-saved.xml. This will get\n-     * replaced immediately on download and this test documents that behavior. We could let it go\n-     * through but let's replace it immediately to help a user who tries this troubleshoot.\n-     * Otherwise it would only be replaced when an instance is saved so a user could think everything\n-     * is ok if they only try launching the form once.\n-     *\n-     * This is an unfortunate side effect of using the form media folder to store the contents that\n-     * jr://instance/last-saved resolves to.\n-     *\n-     * Additionally, immediately replacing a secondary instance with name last-saved.xml avoid users\n-     * exploiting this current implementation quirk as a feature to preload defaults for the first\n-     * instance.\n-     * */\n-    @Test\n-    public void downloadingFormWithExternalSecondaryInstanceNamedLastSavedXml_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDk4NA=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwMDM5Nw==", "bodyText": "The comment is the most important part, I think. But I think it's also important to have a test around which last-saved external secondary instance gets used in that specific case.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r501100397", "createdAt": "2020-10-07T15:21:29Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/utilities/MultiFormDownloaderTest.java", "diffHunk": "@@ -1,414 +0,0 @@\n-package org.odk.collect.android.utilities;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kxml2.io.KXmlParser;\n-import org.kxml2.kdom.Document;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.odk.collect.android.formmanagement.ServerFormDetails;\n-import org.odk.collect.android.openrosa.OpenRosaXmlFetcher;\n-import org.robolectric.RobolectricTestRunner;\n-import org.xmlpull.v1.XmlPullParser;\n-\n-import java.io.BufferedWriter;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-\n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(RobolectricTestRunner.class)\n-public class MultiFormDownloaderTest {\n-    @Rule\n-    public MockitoRule mockitoRule = MockitoJUnit.rule();\n-\n-    @Mock\n-    OpenRosaXmlFetcher openRosaXMLFetcher;\n-\n-    /**\n-     * Verifies that a form without media can successfully go through the download process. Regression\n-     * test for https://github.com/getodk/collect/issues/3535.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The downloading of forms and\n-     * saving of parsed form  values are mocked (and those concerns should be separated).\n-     */\n-    @Test\n-    public void downloadingFormWithoutMedia_Succeeds() throws Exception {\n-        String basicNoMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicNoMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicNoMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"No media\", \"https://testserver/no-media.xml\",\n-                null, \"basic\", \"2019121201\",\n-                \"hash\", null, false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Companion to downloading form without media.\n-     *\n-     * The focus of this test is the form parsing behavior triggered by a download and how it\n-     * relates to a media folder that may or may not have been created. The form downloading, media\n-     * downloading and saving of parsed form values are mocked.\n-     *\n-     * Note: what's important in this test is that the manifestURL in the FormDetails object is set.\n-     * It doesn't really matter that the form definition uses media but that's included to better\n-     * match reality.\n-     */\n-    @Test\n-    public void downloadingFormWithMedia_Succeeds() throws Exception {\n-        String basicMedia = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-media</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-media\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"            <itext> \\n\" +\n-                \"                <translation default=\\\"true()\\\" lang=\\\"English\\\">\\n\" +\n-                \"                    <text id=\\\"/data/q1:label\\\"><value form=\\\"image\\\">jr://images/b.jpg</value></text>\\n\" +\n-                \"                </translation>\\n\" +\n-                \"            </itext>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicMedia\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicMedia);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails serverFormDetails = new ServerFormDetails(\"Media\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"media\", \"2019121201\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(serverFormDetails.getFormName(), serverFormDetails.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(serverFormDetails);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(serverFormDetails), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with references to external secondary instance need to have the secondary instance\n-     * available at time of form parse.\n-     *\n-     * See https://github.com/getodk/collect/issues/3635\n-     */\n-    @Test\n-    public void downloadingFormWithXmlExternalSecondaryInstance_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" >\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-external-xml-instance</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-external-xml-instance\\\">\\n\" +\n-                \"                    <first/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"external-xml\\\" src=\\\"jr://file/external-data.xml\\\" />\\n\" +\n-                \"            <bind nodeset=\\\"/data/first\\\" type=\\\"select1\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <select1 ref=\\\"/data/first\\\">\\n\" +\n-                \"            <label>First</label>\\n\" +\n-                \"            <itemset nodeset=\\\"instance('external-xml')/root/item[first='']\\\">\\n\" +\n-                \"                <value ref=\\\"name\\\"/>\\n\" +\n-                \"                <label ref=\\\"label\\\"/>\\n\" +\n-                \"            </itemset>\\n\" +\n-                \"        </select1>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicExternalXmlInstance\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        when(openRosaXMLFetcher.getXML(\"https://testserver/manifest.xml\")).thenReturn(buildManifestFetchResult(\"external-data.xml\"));\n-        when(openRosaXMLFetcher.getFile(\"https://testserver/external-data.xml\",\n-                null)).thenReturn(buildXmlExternalInstanceFetchResult());\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"basic-external-xml-instance\", \"https://testserver/form.xml\",\n-                \"https://testserver/manifest.xml\", \"basic-external-xml-instance\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    @Test\n-    public void downloadingFormWithCsvExternalSecondaryInstance_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" >\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-external-csv-instance</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-external-csv-instance\\\">\\n\" +\n-                \"                    <first/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"external-csv\\\" src=\\\"jr://file-csv/external-data.csv\\\" />\\n\" +\n-                \"            <bind nodeset=\\\"/data/first\\\" type=\\\"select1\\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <select1 ref=\\\"/data/first\\\">\\n\" +\n-                \"            <label>First</label>\\n\" +\n-                \"            <itemset nodeset=\\\"instance('external-csv')/root/item[first='']\\\">\\n\" +\n-                \"                <value ref=\\\"name\\\"/>\\n\" +\n-                \"                <label ref=\\\"label\\\"/>\\n\" +\n-                \"            </itemset>\\n\" +\n-                \"        </select1>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicExternalCsvInstance\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        when(openRosaXMLFetcher.getXML(\"https://testserver/manifest.xml\")).thenReturn(buildManifestFetchResult(\"external-data.csv\"));\n-        when(openRosaXMLFetcher.getFile(\"https://testserver/external-data.csv\",\n-                null)).thenReturn(buildCsvExternalInstanceFetchResult());\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"basic-external-csv-instance\", \"https://testserver/form.xml\",\n-                \"https://testserver/manifest.xml\", \"basic-external-csv-instance\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Forms with last-saved references are a special case of external secondary instances because\n-     * last-saved doesn't come from the remote server but is generated locally.\n-     */\n-    @Test\n-    public void downloadingFormWithLastSavedReference_Succeeds() throws Exception {\n-        String basicLastSaved = \"<h:html xmlns=\\\"http://www.w3.org/2002/xforms\\\" xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\">\\n\" +\n-                \"    <h:head>\\n\" +\n-                \"        <h:title>basic-last-saved</h:title>\\n\" +\n-                \"        <model>\\n\" +\n-                \"            <instance>\\n\" +\n-                \"                <data id=\\\"basic-last-saved\\\">\\n\" +\n-                \"                    <q1/>\\n\" +\n-                \"                </data>\\n\" +\n-                \"            </instance>\\n\" +\n-                \"            <instance id=\\\"__last-saved\\\" src=\\\"jr://instance/last-saved\\\"/>\\n\" +\n-                \"            <bind nodeset=\\\"/data/q1\\\" type=\\\"string\\\"/>\\n\" +\n-                \"           <setvalue event=\\\"odk-instance-first-load\\\" ref=\\\"/data/q1\\\" value=\\\" instance('__last-saved')/data/q1 \\\"/>\\n\" +\n-                \"        </model>\\n\" +\n-                \"    </h:head>\\n\" +\n-                \"    <h:body>\\n\" +\n-                \"        <input ref=\\\"/data/q1\\\">\\n\" +\n-                \"            <label>Question</label>\\n\" +\n-                \"        </input>\\n\" +\n-                \"    </h:body>\\n\" +\n-                \"</h:html>\";\n-        File formXml = File.createTempFile(\"basicLastSaved\", \".xml\");\n-        formXml.deleteOnExit();\n-\n-        BufferedWriter out = new BufferedWriter(new FileWriter(formXml));\n-        out.write(basicLastSaved);\n-        out.close();\n-\n-        MultiFormDownloader downloader = spy(new MultiFormDownloader(openRosaXMLFetcher));\n-        ServerFormDetails test1 = new ServerFormDetails(\"Last Saved\", \"https://testserver/media.xml\",\n-                \"https://testserver/media-manifest.xml\", \"basic-last-saved\", \"20200101\",\n-                \"hash\", \"manifestHash\", false, false);\n-        MultiFormDownloader.FileResult result = new MultiFormDownloader.FileResult(formXml, true);\n-        doReturn(result).when(downloader).downloadXform(test1.getFormName(), test1.getDownloadUrl(), null);\n-        doReturn(\"\").when(downloader).downloadManifestAndMediaFiles(any(), any(), any(), anyInt(), anyInt(), any());\n-        doReturn(true).when(downloader).installEverything(any(), any(), any());\n-\n-        List<ServerFormDetails> forms = new ArrayList<>();\n-        forms.add(test1);\n-\n-        HashMap<ServerFormDetails, String> messages = downloader.downloadForms(forms, null);\n-        assertThat(messages.get(test1), is(\"Success\"));\n-    }\n-\n-    /**\n-     * Edge case: a form could have an attachment with filename last-saved.xml. This will get\n-     * replaced immediately on download and this test documents that behavior. We could let it go\n-     * through but let's replace it immediately to help a user who tries this troubleshoot.\n-     * Otherwise it would only be replaced when an instance is saved so a user could think everything\n-     * is ok if they only try launching the form once.\n-     *\n-     * This is an unfortunate side effect of using the form media folder to store the contents that\n-     * jr://instance/last-saved resolves to.\n-     *\n-     * Additionally, immediately replacing a secondary instance with name last-saved.xml avoid users\n-     * exploiting this current implementation quirk as a feature to preload defaults for the first\n-     * instance.\n-     * */\n-    @Test\n-    public void downloadingFormWithExternalSecondaryInstanceNamedLastSavedXml_Succeeds() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDczNDk4NA=="}, "originalCommit": {"oid": "f20268809fac008e2cd3eb08dded83242fd1cefc"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzI1NDM3OnYy", "diffSide": "RIGHT", "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/FormMetadataParserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzo1MzoxM1rOHfTeaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzo1MzoxM1rOHfTeaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4Njk4NA==", "bodyText": "YES. Hadn't thought of this one. Great case to have.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r502586984", "createdAt": "2020-10-09T17:53:13Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/FormMetadataParserTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.odk.collect.android.formmanagement;\n+\n+import com.google.common.io.Files;\n+\n+import org.javarosa.core.reference.InvalidReferenceException;\n+import org.javarosa.core.reference.ReferenceManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.odk.collect.android.utilities.FileUtils;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+\n+public class FormMetadataParserTest {\n+\n+    private File mediaDir;\n+    private ReferenceManager referenceManager;\n+\n+    @Before\n+    public void setup() {\n+        referenceManager = ReferenceManager.instance();\n+        referenceManager.reset();\n+\n+        mediaDir = Files.createTempDir();\n+    }\n+\n+    @Test\n+    public void canParseFormWithExternalSecondaryInstance() throws Exception {\n+        File formXml = File.createTempFile(\"form\", \".xml\");\n+        FileUtils.write(formXml, EXTERNAL_SECONDARY_INSTANCE.getBytes());\n+\n+        File externalInstance = new File(mediaDir, \"external-data.xml\");\n+        FileUtils.write(externalInstance, EXTERNAL_INSTANCE.getBytes());\n+\n+        FormMetadataParser formMetadataParser = new FormMetadataParser(referenceManager);\n+        Map<String, String> metaData = formMetadataParser.parse(formXml, mediaDir);\n+        assertThat(metaData.get(FileUtils.FORMID), is(\"basic-external-xml-instance\"));\n+    }\n+\n+    @Test\n+    public void canParseFormWithCSVExternalSecondaryInstance() throws Exception {\n+        File formXml = File.createTempFile(\"form\", \".xml\");\n+        FileUtils.write(formXml, CSV_EXTERNAL_SECONDARY_INSTANCE.getBytes());\n+\n+        File externalInstance = new File(mediaDir, \"external-data.csv\");\n+        FileUtils.write(externalInstance, CSV_EXTERNAL_INSTANCE.getBytes());\n+\n+        FormMetadataParser formMetadataParser = new FormMetadataParser(referenceManager);\n+        Map<String, String> metaData = formMetadataParser.parse(formXml, mediaDir);\n+        assertThat(metaData.get(FileUtils.FORMID), is(\"basic-external-csv-instance\"));\n+    }\n+\n+    @Test\n+    public void canParseFormWithLastSaved() throws Exception {\n+        File formXml = File.createTempFile(\"form\", \".xml\");\n+        FileUtils.write(formXml, LAST_SAVED.getBytes());\n+\n+        FormMetadataParser formMetadataParser = new FormMetadataParser(referenceManager);\n+        Map<String, String> metaData = formMetadataParser.parse(formXml, mediaDir);\n+        assertThat(metaData.get(FileUtils.FORMID), is(\"basic-last-saved\"));\n+    }\n+\n+    @Test\n+    public void doesNotLeaveFilesInMediaDir() throws Exception {\n+        File formXml = File.createTempFile(\"form\", \".xml\");\n+        FileUtils.write(formXml, LAST_SAVED.getBytes());\n+\n+        FormMetadataParser formMetadataParser = new FormMetadataParser(referenceManager);\n+        formMetadataParser.parse(formXml, mediaDir);\n+\n+        assertThat(mediaDir.listFiles().length, is(0));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.JUnitUseExpected\")\n+    public void cleansUpReferenceManager() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d83e14805f55c5917b38ccda54620c338f4475"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzI2NzkwOnYy", "diffSide": "RIGHT", "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/FormMetadataParserTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzo1NzozMlrOHfTmyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODoxMzowMVrOHgIq5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4OTEyOQ==", "bodyText": "That's not the behavior I'd expect! The media file should be ignored and the last-saved instance should be used.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r502589129", "createdAt": "2020-10-09T17:57:32Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/FormMetadataParserTest.java", "diffHunk": "@@ -64,6 +65,32 @@ public void canParseFormWithLastSaved() throws Exception {\n         assertThat(metaData.get(FileUtils.FORMID), is(\"basic-last-saved\"));\n     }\n \n+    /**\n+     * Edge case: a form could have an attachment with filename last-saved.xml. This will get\n+     * replaced immediately on download and this test documents that behavior. We could let it go\n+     * through but let's replace it immediately to help a user who tries this troubleshoot.\n+     * Otherwise it would only be replaced when an instance is saved so a user could think everything\n+     * is ok if they only try launching the form once.\n+     *\n+     * This is an unfortunate side effect of using the form media folder to store the contents that\n+     * jr://instance/last-saved resolves to.\n+     *\n+     * Additionally, immediately replacing a secondary instance with name last-saved.xml avoid users\n+     * exploiting this current implementation quirk as a feature to preload defaults for the first\n+     * instance.\n+     * */\n+    @Test(expected = XFormParseException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95d46d8a23b7e2253acd86064dfd8dd6181e8b79"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1MTgxNw==", "bodyText": "If you look at the previous test does this not match that behaviour? The test name agrees with you but the test itself doesn't as far as I can see (it ends with assertThat(messages.get(serverFormDetails), containsString(\"Failure\")))", "url": "https://github.com/getodk/collect/pull/4040#discussion_r503151817", "createdAt": "2020-10-12T09:11:54Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/FormMetadataParserTest.java", "diffHunk": "@@ -64,6 +65,32 @@ public void canParseFormWithLastSaved() throws Exception {\n         assertThat(metaData.get(FileUtils.FORMID), is(\"basic-last-saved\"));\n     }\n \n+    /**\n+     * Edge case: a form could have an attachment with filename last-saved.xml. This will get\n+     * replaced immediately on download and this test documents that behavior. We could let it go\n+     * through but let's replace it immediately to help a user who tries this troubleshoot.\n+     * Otherwise it would only be replaced when an instance is saved so a user could think everything\n+     * is ok if they only try launching the form once.\n+     *\n+     * This is an unfortunate side effect of using the form media folder to store the contents that\n+     * jr://instance/last-saved resolves to.\n+     *\n+     * Additionally, immediately replacing a secondary instance with name last-saved.xml avoid users\n+     * exploiting this current implementation quirk as a feature to preload defaults for the first\n+     * instance.\n+     * */\n+    @Test(expected = XFormParseException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4OTEyOQ=="}, "originalCommit": {"oid": "95d46d8a23b7e2253acd86064dfd8dd6181e8b79"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1ODUzMg==", "bodyText": "Oh, that's confusing, I'm sorry! Because the external file named last-saved.xml and the primary instance have different shapes AND because the references for a dynamic select get validated at parse time, the parse crashes. So if the form definition had a different kind of query on the instance, there might not be a crash. Phew, that's clever/diabolical. You could add another comment above the parse call about how it's going to crash because the last-saved virtual instance doesn't have /root/item/name and /root/item/label paths to avoid going through this again. But maybe it's just confusing no matter what.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r503458532", "createdAt": "2020-10-12T18:13:01Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/formmanagement/FormMetadataParserTest.java", "diffHunk": "@@ -64,6 +65,32 @@ public void canParseFormWithLastSaved() throws Exception {\n         assertThat(metaData.get(FileUtils.FORMID), is(\"basic-last-saved\"));\n     }\n \n+    /**\n+     * Edge case: a form could have an attachment with filename last-saved.xml. This will get\n+     * replaced immediately on download and this test documents that behavior. We could let it go\n+     * through but let's replace it immediately to help a user who tries this troubleshoot.\n+     * Otherwise it would only be replaced when an instance is saved so a user could think everything\n+     * is ok if they only try launching the form once.\n+     *\n+     * This is an unfortunate side effect of using the form media folder to store the contents that\n+     * jr://instance/last-saved resolves to.\n+     *\n+     * Additionally, immediately replacing a secondary instance with name last-saved.xml avoid users\n+     * exploiting this current implementation quirk as a feature to preload defaults for the first\n+     * instance.\n+     * */\n+    @Test(expected = XFormParseException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4OTEyOQ=="}, "originalCommit": {"oid": "95d46d8a23b7e2253acd86064dfd8dd6181e8b79"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQyNzQ1OnYy", "diffSide": "LEFT", "path": "collect_app/src/main/java/org/odk/collect/android/activities/FormEntryActivity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODoxODozNVrOHgI1gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODoxNjo1MVrOHgaz-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2MTI0OQ==", "bodyText": "Looks like your IntelliJ settings aren't set to alphabetize imports. Would be great to revert changes to files where this is the only change so they don't get touched by this PR.", "url": "https://github.com/getodk/collect/pull/4040#discussion_r503461249", "createdAt": "2020-10-12T18:18:35Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/main/java/org/odk/collect/android/activities/FormEntryActivity.java", "diffHunk": "@@ -101,7 +101,6 @@\n import org.odk.collect.android.formentry.repeats.DeleteRepeatDialogFragment;\n import org.odk.collect.android.formentry.saving.FormSaveViewModel;\n import org.odk.collect.android.formentry.saving.SaveFormProgressDialogFragment;\n-import org.odk.collect.android.forms.FormsRepository;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c033294d0d873c648ce8c533cab937912adb349"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NTc3MA==", "bodyText": "Looks like that's default it's just that Studio doesn't do that when you move code between packages. Optimizing imports fixes it. Annoying!", "url": "https://github.com/getodk/collect/pull/4040#discussion_r503755770", "createdAt": "2020-10-13T08:16:51Z", "author": {"login": "seadowg"}, "path": "collect_app/src/main/java/org/odk/collect/android/activities/FormEntryActivity.java", "diffHunk": "@@ -101,7 +101,6 @@\n import org.odk.collect.android.formentry.repeats.DeleteRepeatDialogFragment;\n import org.odk.collect.android.formentry.saving.FormSaveViewModel;\n import org.odk.collect.android.formentry.saving.SaveFormProgressDialogFragment;\n-import org.odk.collect.android.forms.FormsRepository;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2MTI0OQ=="}, "originalCommit": {"oid": "1c033294d0d873c648ce8c533cab937912adb349"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3285, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}