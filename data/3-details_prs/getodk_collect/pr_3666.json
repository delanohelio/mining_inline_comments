{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNzUyNDQz", "number": 3666, "title": "Use an ingestion timestamp to detect whether the search/pulldata handler should re-process new data file", "bodyText": "Closes #3335\nI cherry picked @OpenDataNerd's excellent commits from https://github.com/OpenDataNerd/collect/tree/csv_external_data. The XLSForm documentation has been updated at http://xlsform.org/en/#multiple-choice-from-file to recommend using CSV external instances so it's now feeling more urgent to get this fixed.\nWhat has been done to verify that this works as intended?\nRan automated tests. Opened a form with external secondary CSV instance multiple times and one with search() multiple times. I also tried a form with an itemsets.csv file even though there should be no interaction with that feature.\nWhy is this the best possible solution? Were any other approaches considered?\nThe issue discusses alternatives. In particular, I had suggested using a file hash to identify changes. I think the time stamp solution is simpler and just as effective. We also could have considered storing the time stamps in an auxiliary file or something like that but adding a metadata table keeps things well-organized.\nHow does this change affect users? Describe intentional changes to behavior and behavior that could have accidentally been affected by code changes. In other words, what are the regression risks?\nRegression risk is around everything having to do with external data.\nDo we need any specific form for testing your changes? If so, please attach one.\nConfig for a Central project with two forms: one with a CSV external instance and one with a search() CSV:\n\nDoes this change require updates to documentation? If so, please file an issue here and include the link below.\nNo.\nBefore submitting this PR, please make sure you have:\n\n run ./gradlew checkAll and confirmed all checks still pass OR confirm CircleCI build passes and run ./gradlew connectedDebugAndroidTest locally.\n verified that any code or assets from external sources are properly credited in comments and/or in the about file.\n verified that any new UI elements use theme colors. UI Components Style guidelines", "createdAt": "2020-03-03T05:30:51Z", "url": "https://github.com/getodk/collect/pull/3666", "merged": true, "mergeCommit": {"oid": "0448e5a1803ed601e906d8192b667d5f75ae37b9"}, "closed": true, "closedAt": "2020-03-05T14:16:25Z", "author": {"login": "lognaturel"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJ18FkAH2gAyMzgyNzUyNDQzOmFjNWI5YWRkMWRkOGZiMGQ2MTI2Mzg4NGU0NjNlZTk2ZDVmZTM4ZmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKro-gAFqTM2OTU3MDQ0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ac5b9add1dd8fb0d61263884e463ee96d5fe38fc", "author": {"user": {"login": "breakbusyloop", "name": "Robert Morton"}}, "url": "https://github.com/getodk/collect/commit/ac5b9add1dd8fb0d61263884e463ee96d5fe38fc", "committedDate": "2020-03-02T23:02:00Z", "message": "Add tests that validate form loading for search/pulldata using external CSV data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dcf966f723b6d661ad67428ecb2230c0fc9dd0e", "author": {"user": {"login": "breakbusyloop", "name": "Robert Morton"}}, "url": "https://github.com/getodk/collect/commit/1dcf966f723b6d661ad67428ecb2230c0fc9dd0e", "committedDate": "2020-03-02T23:03:44Z", "message": "light refactoring of ExternalDataReaderImpl in prep for code behavior changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b97db950cae7f2add7d23227561e2ab1239c49dd", "author": {"user": {"login": "breakbusyloop", "name": "Robert Morton"}}, "url": "https://github.com/getodk/collect/commit/b97db950cae7f2add7d23227561e2ab1239c49dd", "committedDate": "2020-03-02T23:03:59Z", "message": "Add metadata table when creating external database for search/pulldata\nInitial code and tests. Still need to refactor query building and database helper methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a022532f4fd3699a47f4ffe82b834f7c921ee90", "author": {"user": {"login": "breakbusyloop", "name": "Robert Morton"}}, "url": "https://github.com/getodk/collect/commit/0a022532f4fd3699a47f4ffe82b834f7c921ee90", "committedDate": "2020-03-02T23:04:10Z", "message": "Refactor SQLite query builder and execution wrappers.\nSeparated the query string building functionality from the database-aware functionality in CustomSQLiteQueryBuilder.\nRelocate new query and execution functionality introduced for working with CSV external data."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66d968763e4380fa64ac25c1a0282a62cd01bc3d", "author": {"user": {"login": "breakbusyloop", "name": "Robert Morton"}}, "url": "https://github.com/getodk/collect/commit/66d968763e4380fa64ac25c1a0282a62cd01bc3d", "committedDate": "2020-03-02T23:27:09Z", "message": "Fix issue #3335 with renamed CSV files\n\nChange External Data mechanism for importing CSV files for search()/pulldata() functionalty so that it no longer has to rename a file to track file changes. The CSV file timestamp is now captured in a metadata table stored in the SQLite database holding the imported file. Updates to the file will cause the database to be rebuilt the next time the form is loaded. If the timestamp is unchanged, we skip importing the data.\n\nNow that the file is no longer being renamed, other ODK functionality that relies on CSV files can operate as expected without having their files disappear from under them. However, the each CSV file will still be imported into a SQLite database by the External Data functionality, since it is not implemented narrowly enough to understand which CSV files are actually referenced by the form via search()/pulldata()."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67474dc73903eefc8e82dbf4846a237c52657933", "author": {"user": {"login": "lognaturel", "name": "H\u00e9l\u00e8ne Martin"}}, "url": "https://github.com/getodk/collect/commit/67474dc73903eefc8e82dbf4846a237c52657933", "committedDate": "2020-03-03T05:15:07Z", "message": "Replace database open call introduced in API 27"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "author": {"user": {"login": "seadowg", "name": "Callum Stott"}}, "url": "https://github.com/getodk/collect/commit/1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "committedDate": "2020-03-04T14:00:07Z", "message": "Merge branch 'master' into issue-3335"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA4Mzg1", "url": "https://github.com/getodk/collect/pull/3666#pullrequestreview-369008385", "createdAt": "2020-03-04T18:14:22Z", "commit": {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNDoyMlrOFx4KnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyMTozMVrOFx4ZXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDc2NQ==", "bodyText": "Is this really ExternalDataReaderTest?", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387844765", "createdAt": "2020-03-04T18:14:22Z", "author": {"login": "seadowg"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/external/ExternalDataTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.odk.collect.android.external;\n+\n+import android.Manifest;\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExternalDataTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTc0Mw==", "bodyText": "Could this run in Robolectric instead?", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387845743", "createdAt": "2020-03-04T18:16:15Z", "author": {"login": "seadowg"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/external/ExternalDataTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.odk.collect.android.external;\n+\n+import android.Manifest;\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExternalDataTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private File csvFile;\n+    private File dbFile;\n+\n+    @Before\n+    public void setUp() {\n+        File formPath = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formPath);\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+    }\n+\n+    @Rule", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NzYwNA==", "bodyText": "These tests are pretty dense and I'm having a hard time understanding what they are driving at. I think using a different style for the names would be helpful. This test could be doImport_createsDataAndMetaDatabaseTables. That way we know what the subject is (ExternalDataReaderImpl#doImport) and what our expectation is pretty clearly.", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387847604", "createdAt": "2020-03-04T18:19:48Z", "author": {"login": "seadowg"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/external/ExternalDataTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.odk.collect.android.external;\n+\n+import android.Manifest;\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExternalDataTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private File csvFile;\n+    private File dbFile;\n+\n+    @Before\n+    public void setUp() {\n+        File formPath = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formPath);\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+    }\n+\n+    @Rule\n+    public RuleChain copyFormChain = RuleChain\n+            .outerRule(GrantPermissionRule.grant(\n+                    Manifest.permission.READ_EXTERNAL_STORAGE,\n+                    Manifest.permission.WRITE_EXTERNAL_STORAGE\n+            ))\n+            .around(new ResetStateRule())\n+            .around(new CopyFormRule(SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME, Collections.singletonList(SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME)));\n+\n+    private static Map<String, File> makeExternalDataMap(File csvFile) {\n+        Map<String, File> externalDataMap = new HashMap<>();\n+        externalDataMap.put(SIMPLE_SEARCH_EXTERNAL_CSV_NAME, csvFile);\n+        return externalDataMap;\n+    }\n+\n+    @Test\n+    public void testCreateDBonImportCSV() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0ODU0MQ==", "bodyText": "I'd love to say \"this should be Robolectric\" but I think that would involve picking the task apart. The XTaskTest classes are pretty much the prime candidates for moving out of Espresso so I'm confident that will happen later.", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387848541", "createdAt": "2020-03-04T18:21:31Z", "author": {"login": "seadowg"}, "path": "collect_app/src/androidTest/java/org/odk/collect/android/tasks/FormLoaderTaskTest.java", "diffHunk": "@@ -14,13 +15,19 @@\n \n import java.io.File;\n import java.util.Arrays;\n+import java.util.Collections;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.notNullValue;\n \n public class FormLoaderTaskTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d", "author": {"user": {"login": "lognaturel", "name": "H\u00e9l\u00e8ne Martin"}}, "url": "https://github.com/getodk/collect/commit/10ba2ee2e4758363c0cda19b979cec6139253e7d", "committedDate": "2020-03-04T23:14:07Z", "message": "Replace Espresso tests with Robolectric tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTk0Mzg4", "url": "https://github.com/getodk/collect/pull/3666#pullrequestreview-369194388", "createdAt": "2020-03-04T23:16:03Z", "commit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoxNjowM1rOFyBH0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoxNjowM1rOFyBH0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTUwNA==", "bodyText": "It's too bad to have duplicates of these test files in androidTest and test. I think it's the right thing to do the Robolectric tests with real form files, though.\nThis might actually be a good reason for all tests to live in the same source set, as the androidx libs want.", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387991504", "createdAt": "2020-03-04T23:16:03Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/androidTest/assets/forms/simple-search-external-csv.xml", "diffHunk": "@@ -0,0 +1,31 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTk2NDc5", "url": "https://github.com/getodk/collect/pull/3666#pullrequestreview-369196479", "createdAt": "2020-03-04T23:20:49Z", "commit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoyMDo1MFrOFyBOaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoyMDo1MFrOFyBOaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MzE5NQ==", "bodyText": "This work here is basically exactly what CopyFormRule and the methods in FormLoadingUtils do but they're in different sourcesets. Again, maybe a reason to have all tests in one. Or if there is an elegant way to share that code, please feel free to modify, @seadowg.", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387993195", "createdAt": "2020-03-04T23:20:50Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/external/ExternalDataReaderTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.odk.collect.android.external;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.os.Environment;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.storage.StorageInitializer;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.shadows.ShadowEnvironment;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_DATASET_FILENAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_LAST_MODIFIED;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_METADATA_TABLE_NAME;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class ExternalDataReaderTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private static final String SELECT_ALL_DATA_QUERY =  \"SELECT * FROM \" + EXTERNAL_DATA_TABLE_NAME;\n+\n+    private static File csvFile;\n+    private static File dbFile;\n+\n+    private static Map<String, File> formDefToCsvMedia;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);\n+        new StorageInitializer().createOdkDirsOnStorage();\n+\n+        File formFile = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTk3Mzky", "url": "https://github.com/getodk/collect/pull/3666#pullrequestreview-369197392", "createdAt": "2020-03-04T23:23:12Z", "commit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoyMzoxM1rOFyBRjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoyMzoxM1rOFyBRjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5Mzk5OQ==", "bodyText": "Note that this test has changed. It previously faked an update by changing the db timestamp. Now it actually tests a real file change.", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387993999", "createdAt": "2020-03-04T23:23:13Z", "author": {"login": "lognaturel"}, "path": "collect_app/src/test/java/org/odk/collect/android/external/ExternalDataReaderTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.odk.collect.android.external;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.os.Environment;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.storage.StorageInitializer;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.shadows.ShadowEnvironment;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_DATASET_FILENAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_LAST_MODIFIED;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_METADATA_TABLE_NAME;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class ExternalDataReaderTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private static final String SELECT_ALL_DATA_QUERY =  \"SELECT * FROM \" + EXTERNAL_DATA_TABLE_NAME;\n+\n+    private static File csvFile;\n+    private static File dbFile;\n+\n+    private static Map<String, File> formDefToCsvMedia;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);\n+        new StorageInitializer().createOdkDirsOnStorage();\n+\n+        File formFile = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formFile);\n+        mediaDir.mkdir();\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+        formDefToCsvMedia = makeExternalDataMap();\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"forms\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+             OutputStream output = new FileOutputStream(formFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"media\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+            OutputStream output = new FileOutputStream(csvFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+    }\n+\n+    @Test\n+    public void doImport_createsDataAndMetadataTables() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(db, is(notNullValue()));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_DATA_TABLE_NAME), is(true));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME), is(true));\n+    }\n+\n+    /**\n+     * There are multiple features that ingest CSV files so the original file should not be modified.\n+     * https://github.com/opendatakit/collect/issues/3335\n+     */\n+    @Test\n+    public void doImport_doesNotModifyOriginalCsv() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+        assertThat(csvFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void createAndPopulateMetadataTable_createsMetadataTableWithExpectedTimestamp() {\n+        final String testMetadataTable = \"testMetadataTable\";\n+\n+        SQLiteDatabase.OpenParams.Builder paramsBuilder = new SQLiteDatabase.OpenParams.Builder();\n+        SQLiteDatabase db = SQLiteDatabase.createInMemory(paramsBuilder.build());\n+        ExternalSQLiteOpenHelper.createAndPopulateMetadataTable(db, testMetadataTable, csvFile);\n+\n+        assertThat(SQLiteUtils.doesTableExist(db, testMetadataTable), is(true));\n+\n+        final String[] columnNames = {COLUMN_LAST_MODIFIED};\n+        final String selectCriteria = CustomSQLiteQueryBuilder.formatCompareEquals(\n+                COLUMN_DATASET_FILENAME,\n+                CustomSQLiteQueryBuilder.quoteStringLiteral(SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME));\n+        Cursor cursor = db.query(testMetadataTable, columnNames, selectCriteria, null, null, null, null);\n+        cursor.moveToFirst();\n+        long fileTimestamp = cursor.getLong(0);\n+\n+        assertThat(fileTimestamp, is(csvFile.lastModified()));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfDatabaseFileIsDeleted() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        dbFile.delete();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfMetadataTableIsMissing() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        // Remove the metadata table (mimicking prior versions without the metadata table)\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        SQLiteUtils.dropTable(db, EXTERNAL_METADATA_TABLE_NAME);\n+        db.close();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+        db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(\"metadata table should be recreated\", SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME));\n+        db.close();\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfFileIsUpdated() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NTcwNDQx", "url": "https://github.com/getodk/collect/pull/3666#pullrequestreview-369570441", "createdAt": "2020-03-05T13:35:07Z", "commit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzozNTowN1rOFyTqkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzozNTowN1rOFyTqkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NTMxMw==", "bodyText": "I think there is a way to fake this with fake file layer. Can't remember the name of the framework though. We can stick with this right now as I'm pretty sure it's still deterministic.", "url": "https://github.com/getodk/collect/pull/3666#discussion_r388295313", "createdAt": "2020-03-05T13:35:07Z", "author": {"login": "seadowg"}, "path": "collect_app/src/test/java/org/odk/collect/android/external/ExternalDataReaderTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.odk.collect.android.external;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.os.Environment;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.storage.StorageInitializer;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.shadows.ShadowEnvironment;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_DATASET_FILENAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_LAST_MODIFIED;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_METADATA_TABLE_NAME;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class ExternalDataReaderTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private static final String SELECT_ALL_DATA_QUERY =  \"SELECT * FROM \" + EXTERNAL_DATA_TABLE_NAME;\n+\n+    private static File csvFile;\n+    private static File dbFile;\n+\n+    private static Map<String, File> formDefToCsvMedia;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);\n+        new StorageInitializer().createOdkDirsOnStorage();\n+\n+        File formFile = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formFile);\n+        mediaDir.mkdir();\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+        formDefToCsvMedia = makeExternalDataMap();\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"forms\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+             OutputStream output = new FileOutputStream(formFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"media\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+            OutputStream output = new FileOutputStream(csvFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+    }\n+\n+    @Test\n+    public void doImport_createsDataAndMetadataTables() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(db, is(notNullValue()));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_DATA_TABLE_NAME), is(true));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME), is(true));\n+    }\n+\n+    /**\n+     * There are multiple features that ingest CSV files so the original file should not be modified.\n+     * https://github.com/opendatakit/collect/issues/3335\n+     */\n+    @Test\n+    public void doImport_doesNotModifyOriginalCsv() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+        assertThat(csvFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void createAndPopulateMetadataTable_createsMetadataTableWithExpectedTimestamp() {\n+        final String testMetadataTable = \"testMetadataTable\";\n+\n+        SQLiteDatabase.OpenParams.Builder paramsBuilder = new SQLiteDatabase.OpenParams.Builder();\n+        SQLiteDatabase db = SQLiteDatabase.createInMemory(paramsBuilder.build());\n+        ExternalSQLiteOpenHelper.createAndPopulateMetadataTable(db, testMetadataTable, csvFile);\n+\n+        assertThat(SQLiteUtils.doesTableExist(db, testMetadataTable), is(true));\n+\n+        final String[] columnNames = {COLUMN_LAST_MODIFIED};\n+        final String selectCriteria = CustomSQLiteQueryBuilder.formatCompareEquals(\n+                COLUMN_DATASET_FILENAME,\n+                CustomSQLiteQueryBuilder.quoteStringLiteral(SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME));\n+        Cursor cursor = db.query(testMetadataTable, columnNames, selectCriteria, null, null, null, null);\n+        cursor.moveToFirst();\n+        long fileTimestamp = cursor.getLong(0);\n+\n+        assertThat(fileTimestamp, is(csvFile.lastModified()));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfDatabaseFileIsDeleted() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        dbFile.delete();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfMetadataTableIsMissing() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        // Remove the metadata table (mimicking prior versions without the metadata table)\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        SQLiteUtils.dropTable(db, EXTERNAL_METADATA_TABLE_NAME);\n+        db.close();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+        db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(\"metadata table should be recreated\", SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME));\n+        db.close();\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfFileIsUpdated() throws IOException, InterruptedException {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(db.rawQuery(SELECT_ALL_DATA_QUERY, null).getCount(), is(3));\n+\n+        long originalTimestamp = csvFile.lastModified();\n+        long metadataLastModified = ExternalSQLiteOpenHelper.getLastImportTimestamp(db, EXTERNAL_METADATA_TABLE_NAME, csvFile);\n+        assertThat(metadataLastModified, is(originalTimestamp));\n+\n+        Thread.sleep(1000); // this test is so fast that we need to guarantee the modified time changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2323, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}