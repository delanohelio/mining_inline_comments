{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MDYwODM3", "number": 17449, "title": "Improve SQL index consistency checks", "bodyText": "This PR improves consistency checks for indexes when used from the SQL service:\n\nNow indexes track precisely which partitions are indexed. In addition to this, we track when a partition is being indexed (dynamic index creation, migration to the local member) or unindexed (migration from the local member)\nWhen the SQL query is in progress, we request a stamp for the partitions that are expected to be available locally. Then we validate that the stamp is still valid before returning the results. The stamp could become invalid if indexed partitions changed, or if some partition is being (un)indexed. If the stamp is invalid, an exception is thrown to prevent inconsistent results. This logic is encapsulated in the class GlobalIndexPartitionTracker that is used by global indexes (both heap and HD)\nTo support the aforementioned changes, we employ PartitionIdSet with several improvements: size() method is now O(1) because it is used heavily in the GlobalIndexPartitionTracker; also equals/hashCode methods are added", "createdAt": "2020-09-01T12:53:51Z", "url": "https://github.com/hazelcast/hazelcast/pull/17449", "merged": true, "mergeCommit": {"oid": "d90998b4ca2da143cdf3bdaac618fe3f9ae978bd"}, "closed": true, "closedAt": "2020-09-05T13:40:42Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdESh3kgH2gAyNDc3MDYwODM3OjcxNTllYTZlZTk2MTIwZjdhMjM1NjA1ZWE5OWRlZDlkMzk4ZWNiM2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFkJCxgFqTQ4MjYwMDE0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7159ea6ee96120f7a235605ea99ded9d398ecb3a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7159ea6ee96120f7a235605ea99ded9d398ecb3a", "committedDate": "2020-08-31T13:08:13Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83d1376a898b84dfade28b65f484098eb76a8748", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/83d1376a898b84dfade28b65f484098eb76a8748", "committedDate": "2020-09-01T10:13:22Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da13a86b57f6c5c23224de4c0455ec9580b7dc8e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/da13a86b57f6c5c23224de4c0455ec9580b7dc8e", "committedDate": "2020-09-01T11:23:53Z", "message": "Tests for PartitionIdSetTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44b8eb3662a6d982dc60576c85071022063d5ff7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/44b8eb3662a6d982dc60576c85071022063d5ff7", "committedDate": "2020-09-01T11:24:19Z", "message": "Tests for PartitionIdSetTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8da03d238e72cb69d2a092acaf6d5ea0a7f3075a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8da03d238e72cb69d2a092acaf6d5ea0a7f3075a", "committedDate": "2020-09-01T11:35:47Z", "message": "Tracker test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5b91c1697f9be523684c4d0a379b6166291554f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b5b91c1697f9be523684c4d0a379b6166291554f", "committedDate": "2020-09-01T11:37:23Z", "message": "Merge branch 'master' into sql-index-consistency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b2869359d3ca0768d3774bcda65e0868b6c1c93", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3b2869359d3ca0768d3774bcda65e0868b6c1c93", "committedDate": "2020-09-01T11:49:30Z", "message": "Docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f41a3e645eb8ae1d55e98bb28baae37c96dd25c5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f41a3e645eb8ae1d55e98bb28baae37c96dd25c5", "committedDate": "2020-09-01T12:09:23Z", "message": "Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "committedDate": "2020-09-01T12:45:57Z", "message": "Fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNTcxNTQy", "url": "https://github.com/hazelcast/hazelcast/pull/17449#pullrequestreview-480571542", "createdAt": "2020-09-02T07:55:09Z", "commit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzo1NTowOVrOHLh_0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMDoyNjoyOFrOHLoyjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg1MzM5NQ==", "bodyText": "Can you document every field in this class? What is the semantics behind pending field?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481853395", "createdAt": "2020-09-02T07:55:09Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void mark(int partition) {\n+        complete(partition, true);\n+    }\n+\n+    public void unmark(int partition) {\n+        complete(partition, false);\n+    }\n+\n+    private void complete(int partition, boolean mark) {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            assert oldState.pending > 0;\n+\n+            PartitionIdSet newIndexedPartitions = oldState.indexedPartitions.copy();\n+\n+            if (mark) {\n+                newIndexedPartitions.add(partition);\n+            } else {\n+                newIndexedPartitions.remove(partition);\n+            }\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                newIndexedPartitions,\n+                oldState.pending - 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void clear() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                new PartitionIdSet(partitionCount),\n+                0\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private static final class State {\n+\n+        private final long version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzIyNg==", "bodyText": "Typo: double contains", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481963226", "createdAt": "2020-09-02T10:23:53Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -75,4 +91,26 @@\n      */\n     PerIndexStats getPerIndexStats();\n \n+    /**\n+     * Get monotonically increasing stamp that confirms that the index contains contains", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDY4Nw==", "bodyText": "Minor: {@code false} otherwise", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481964687", "createdAt": "2020-09-02T10:26:28Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -75,4 +91,26 @@\n      */\n     PerIndexStats getPerIndexStats();\n \n+    /**\n+     * Get monotonically increasing stamp that confirms that the index contains contains\n+     * only expected partitions, and that there are no concurrent partition updates, and\n+     * there are no active partition updates (see {@link #beginPartitionUpdate()}).\n+     * <p>\n+     * Received stamp is used to verify that the index is still valid for the given\n+     * set of partitions through a call to {@link #validatePartitionStamp(long)}.\n+     *\n+     * @param expectedPartitionIds expected indexed partitions\n+     * @return stamp or {@code null}\n+     */\n+    Long getPartitionStamp(PartitionIdSet expectedPartitionIds);\n+\n+    /**\n+     * Verifies that the given partition stamp is still valid. It is valid iff there were\n+     * no partition updates since the call to the {@link #getPartitionStamp(PartitionIdSet)}\n+     * that produced this stamp.\n+     *\n+     * @param stamp stamp\n+     * @return {@code true} if the stamp is still valid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNjk4MTAx", "url": "https://github.com/hazelcast/hazelcast/pull/17449#pullrequestreview-480698101", "createdAt": "2020-09-02T10:44:51Z", "commit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMDo0NDo1MVrOHLpaFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMDo0NTo1OFrOHLpciQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NDgwNA==", "bodyText": "It seems we can avoid lock()/unlock() calls and use state.compareAndSet(oldState, newState) in the cycle?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481974804", "createdAt": "2020-09-02T10:44:51Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NTQzMw==", "bodyText": "The same compareAndSet logic applies here?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481975433", "createdAt": "2020-09-02T10:45:58Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void mark(int partition) {\n+        complete(partition, true);\n+    }\n+\n+    public void unmark(int partition) {\n+        complete(partition, false);\n+    }\n+\n+    private void complete(int partition, boolean mark) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "committedDate": "2020-09-02T13:18:18Z", "message": "Typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwODY5ODg2", "url": "https://github.com/hazelcast/hazelcast/pull/17449#pullrequestreview-480869886", "createdAt": "2020-09-02T14:20:38Z", "commit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNTQwMDk1", "url": "https://github.com/hazelcast/hazelcast/pull/17449#pullrequestreview-482540095", "createdAt": "2020-09-04T10:26:57Z", "commit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoyNjo1N1rOHNIZYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMTowNDowOVrOHNJZLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTEwNg==", "bodyText": "Do we need to move this up to before clearing all of the indexes? And do we need to guard it with populateIndexes like we do for other index operations?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483531106", "createdAt": "2020-09-04T10:26:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/MapReplicationStateHolder.java", "diffHunk": "@@ -167,6 +167,9 @@ void applyState() {\n \n                 long nowInMillis = Clock.currentTimeMillis();\n                 final InternalIndex[] indexesSnapshot = indexes.getIndexes();\n+\n+                Indexes.beginPartitionUpdate(indexesSnapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjA5MA==", "bodyText": "How did we not return results before this change? I guess since this operation was serialised with other index-read operations on the partition thread? Or is it because we only returned results after marking it as indexed?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483532090", "createdAt": "2020-09-04T10:29:12Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/AddIndexOperation.java", "diffHunk": "@@ -91,6 +91,8 @@ public void runInternal() {\n \n         SerializationService serializationService = getNodeEngine().getSerializationService();\n \n+        index.beginPartitionUpdate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTQ4Mw==", "bodyText": "Since you just use state.get and state.set, this can be a volatile State", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483541483", "createdAt": "2020-09-04T10:50:29Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTY5Mg==", "bodyText": "Minor: are being", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483541692", "createdAt": "2020-09-04T10:51:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void mark(int partition) {\n+        complete(partition, true);\n+    }\n+\n+    public void unmark(int partition) {\n+        complete(partition, false);\n+    }\n+\n+    private void complete(int partition, boolean mark) {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            assert oldState.pending > 0;\n+\n+            PartitionIdSet newIndexedPartitions = oldState.indexedPartitions.copy();\n+\n+            if (mark) {\n+                newIndexedPartitions.add(partition);\n+            } else {\n+                newIndexedPartitions.remove(partition);\n+            }\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                newIndexedPartitions,\n+                oldState.pending - 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void clear() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                new PartitionIdSet(partitionCount),\n+                0\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * State of the indexed partitions.\n+     */\n+    private static final class State {\n+        /** Monotonically increasing version, that is incremented on every partition info update. */\n+        private final long version;\n+\n+        /** Partitions that are currently indexed. */\n+        private final PartitionIdSet indexedPartitions;\n+\n+        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MjExNA==", "bodyText": "Minor: Why is it named marked and not e.g. indexed?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483542114", "createdAt": "2020-09-04T10:52:00Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0Mjg1OA==", "bodyText": "Why does it need to be boxed? Can we use something like Integer.MIN_VALUE or -1 instead? Can you add javadoc for future maintenance?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483542858", "createdAt": "2020-09-04T10:53:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MzI3Mw==", "bodyText": "If you want, you can double the range by starting with something like Integer.MIN_VALUE", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483543273", "createdAt": "2020-09-04T10:54:34Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NjQ2MA==", "bodyText": "Since we don't check the pending count here, is it possible we say the index partition is marked/indexed while it's being (un)populated?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483546460", "createdAt": "2020-09-04T11:01:45Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NzEwMQ==", "bodyText": "As mentioned in other comment, do we distinguish which index partition is not safe to query and which is safe to query?", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483547101", "createdAt": "2020-09-04T11:03:22Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -56,6 +57,21 @@\n      */\n     boolean allPartitionsIndexed(int ownedPartitionCount);\n \n+    /**\n+     * Notifies the index that a partition update is about to begin. Could be caused be either\n+     * partition add (e.g. migration from another member, dynamic index creation), or partition\n+     * remove (e.g. migration to another member).\n+     * <p>\n+     * While in this state, the index cannot be queried by the SQL engine safely, because it\n+     * will produce inconsistent results.\n+     * <p>\n+     * Internally this call increments the counter of active partition updates. The counter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NzQzOA==", "bodyText": "Add explanation for null or some other special value like -1 if you want to avoid boxing. It was a bit odd seeing you get a boxed Long while you can validate a primitive long.", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483547438", "createdAt": "2020-09-04T11:04:09Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -75,4 +91,26 @@\n      */\n     PerIndexStats getPerIndexStats();\n \n+    /**\n+     * Get monotonically increasing stamp that confirms that the index contains\n+     * only expected partitions, and that there are no concurrent partition updates, and\n+     * there are no active partition updates (see {@link #beginPartitionUpdate()}).\n+     * <p>\n+     * Received stamp is used to verify that the index is still valid for the given", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNTYzMjI3", "url": "https://github.com/hazelcast/hazelcast/pull/17449#pullrequestreview-482563227", "createdAt": "2020-09-04T11:07:56Z", "commit": {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49d122aa86e684d05247dad3eced499fd7b2fca6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/49d122aa86e684d05247dad3eced499fd7b2fca6", "committedDate": "2020-09-04T11:37:50Z", "message": "Merge branch 'master' into sql-index-consistency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "committedDate": "2020-09-04T11:47:50Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ee9079bfa4e37f943fd212ba55a2b12a811ecbe", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9ee9079bfa4e37f943fd212ba55a2b12a811ecbe", "committedDate": "2020-09-04T11:49:27Z", "message": "Tracker: marked -> indexed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aa819d519957c047046d5ca3c89199badbfcc42", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7aa819d519957c047046d5ca3c89199badbfcc42", "committedDate": "2020-09-04T12:03:04Z", "message": "Make stamp non-nullable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d2cd358887e31f4745be8a27a1f7005dd92f64c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8d2cd358887e31f4745be8a27a1f7005dd92f64c", "committedDate": "2020-09-04T12:08:16Z", "message": "Minor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNjAwMTQ1", "url": "https://github.com/hazelcast/hazelcast/pull/17449#pullrequestreview-482600145", "createdAt": "2020-09-04T12:13:19Z", "commit": {"oid": "8d2cd358887e31f4745be8a27a1f7005dd92f64c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3456, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}