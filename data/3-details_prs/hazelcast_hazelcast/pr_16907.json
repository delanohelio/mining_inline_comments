{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2NDY1MDcx", "number": 16907, "title": "SQL: IMap scan operator", "bodyText": "Introduced IMap scan operator. Implementation notes:\n\nThe operator accepts the name of the map as well as the list of partitions to scan\nIf some partitions are not owned by the local member, an exception is thrown\nLikewise, an exception is thrown if a concurrent migration is detected; we use migration stamps for this\nAlso, we track concurrent map destroy\nWe introduce a new infrastructure for field extraction (QueryTargetDescriptor, QueryTarget, QueryExtractor). At the moment only a simple implementation based on Extractors class is introduced. In the future we will have more implementations optimized for the specific use case (Java classes, portables, etc). These classes will be merged separately after careful testing and evaluation, and integration with the Calcite metadata.\n\nLimitations:\n\nThe operator uses batching internally, similar to Filter operator. This will be factored out in the future when we have a memory manager\nAlthough we detect concurrent map destroy, we still may end up with a situation when different members scan different maps! Consider the following sequence of events: map A is created, a query is initiated, member M1 starts a scan and finishes it quickly, map A is destroyed, map A` is created, member M2 performs the scan. In this case, no exception will be thrown. The fundamental problem is that we do not have a unique distributed object identifiers\nIn principle, it is possible to attempt full query restart in case of concurrent migration, if we know for sure that no data was returned to the user. This improves usability but adds significant complexity. Therefore, this improvement will be implemented separately, perhaps even not in 4.1.\n\nCloses #16906", "createdAt": "2020-04-21T06:23:39Z", "url": "https://github.com/hazelcast/hazelcast/pull/16907", "merged": true, "mergeCommit": {"oid": "3aa6c714887fdd325c7eba6eb0229d030c1ec49b"}, "closed": true, "closedAt": "2020-04-23T16:27:29Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZtdyPgH2gAyNDA2NDY1MDcxOjhhMzcxOTQ5MGMxNWFiMjdhNzk5ZDhkZDBhMmE2YWQ4ODJkNzZhMWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcae28sgFqTM5OTIzMjY4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8a3719490c15ab27a799d8dd0a2a6ad882d76a1a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8a3719490c15ab27a799d8dd0a2a6ad882d76a1a", "committedDate": "2020-04-21T06:12:27Z", "message": "Implemented MapScanExec operator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d4ba9286d2c0766e063622d2c0e61216f1f3256", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3d4ba9286d2c0766e063622d2c0e61216f1f3256", "committedDate": "2020-04-21T06:24:20Z", "message": "Missing change."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "153a251e623f3e8e4cc5595d69129a8fef2b8af8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/153a251e623f3e8e4cc5595d69129a8fef2b8af8", "committedDate": "2020-04-21T06:25:25Z", "message": "Minors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e7ea56a747919a6afc4ec1b2d600fed7c161130", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0e7ea56a747919a6afc4ec1b2d600fed7c161130", "committedDate": "2020-04-21T06:34:02Z", "message": "Avoid creation of record stores during iteration."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d893d2d35bb30ecae40e6a2e0a243965c354735e", "committedDate": "2020-04-21T11:49:56Z", "message": "Fixed SpotBugs."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3OTk1Mzk5", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-397995399", "createdAt": "2020-04-22T09:11:47Z", "commit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxMTo0N1rOGJsAQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxMTo0N1rOGJsAQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMTMzMQ==", "bodyText": "Looks like the same can be achieved with RecordStore.getStorage().mutationTolerantIterator(), it's also clearly indicates what kind of iterator we are getting.", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412811331", "createdAt": "2020-04-22T09:11:47Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/RecordStore.java", "diffHunk": "@@ -292,6 +294,8 @@ boolean merge(MapMergeTypes<Object, Object> mergingEntry,\n \n     void forEach(BiConsumer<Data, Record> consumer, boolean backup, boolean includeExpiredRecords);\n \n+    Iterator<Map.Entry<Data, Record>> iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3OTk3ODMw", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-397997830", "createdAt": "2020-04-22T09:14:48Z", "commit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxNDo0OFrOGJsILA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxNDo0OFrOGJsILA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMzM1Ng==", "bodyText": "getService().getMapServiceContext()?", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412813356", "createdAt": "2020-04-22T09:14:48Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxySupport.java", "diffHunk": "@@ -1379,6 +1379,10 @@ protected void handleHazelcastInstanceAwareParams(Object... objects) {\n         }\n     }\n \n+    public MapServiceContext getMapServiceContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3OTk5MDU4", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-397999058", "createdAt": "2020-04-22T09:16:14Z", "commit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxNjoxNVrOGJsMbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxNjoxNVrOGJsMbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNDQ0NQ==", "bodyText": "typo: isDestroyed", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412814445", "createdAt": "2020-04-22T09:16:15Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -390,10 +393,22 @@ public InterceptorRegistry getInterceptorRegistry() {\n         return interceptorRegistry;\n     }\n \n+    /**\n+     * Callback invoked before record store and indexes are destroyed. Ensures that if map iterator observes a non-destroyed\n+     * state, then associated data structures are still valid.\n+     */\n+    public void onBeforeDestroy() {\n+        destroyed = true;\n+    }\n+\n     // callback called when the MapContainer is de-registered from MapService and destroyed - basically on map-destroy\n     public void onDestroy() {\n     }\n \n+    public boolean isDestoyed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDIyODQ1", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-398022845", "createdAt": "2020-04-22T09:46:14Z", "commit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo0NjoxNFrOGJteIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo0NjoxNFrOGJteIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTM2Mw==", "bodyText": "Minor: it would be \"cleaner\" to do the hasNext check before checking for migration stamp and destruction. It's not clear from the contract does the hasNext interact with the underlying store or not (which potentially can be destroyed or migrated).", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412835363", "createdAt": "2020-04-22T09:46:14Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/MapScanExec.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.getters.Extractors;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.IterationResult;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.ListRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Executor for map scan.\n+ */\n+public class MapScanExec extends AbstractMapScanExec {\n+    /** Batch size. To be moved outside when the memory management is ready. */\n+    static final int BATCH_SIZE = 1024;\n+\n+    private final MapContainer map;\n+    private final PartitionIdSet partitions;\n+\n+    private int migrationStamp;\n+    private MapScanExecIterator recordIterator;\n+\n+    private List<Row> currentRows;\n+\n+    public MapScanExec(\n+        int id,\n+        MapContainer map,\n+        PartitionIdSet partitions,\n+        QueryTargetDescriptor keyDescriptor,\n+        QueryTargetDescriptor valueDescriptor,\n+        List<String> fieldNames,\n+        List<QueryDataType> fieldTypes,\n+        List<Integer> projects,\n+        Expression<Boolean> filter,\n+        InternalSerializationService serializationService\n+    ) {\n+        super(id, map.getName(), keyDescriptor, valueDescriptor, fieldNames, fieldTypes, projects, filter, serializationService);\n+\n+        this.map = map;\n+        this.partitions = partitions;\n+    }\n+\n+    @Override\n+    protected void setup1(QueryFragmentContext ctx) {\n+        migrationStamp = map.getMapServiceContext().getService().getMigrationStamp();\n+        recordIterator = MapScanExecUtils.createIterator(map, partitions);\n+    }\n+\n+    @Override\n+    public IterationResult advance0() {\n+        currentRows = null;\n+\n+        while (recordIterator.tryAdvance()) {\n+            HeapRow row = prepareRow(recordIterator.getKey(), recordIterator.getValue());\n+\n+            if (row != null) {\n+                if (currentRows == null) {\n+                    currentRows = new ArrayList<>(BATCH_SIZE);\n+                }\n+\n+                currentRows.add(row);\n+\n+                if (currentRows.size() == BATCH_SIZE) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // Check for concurrent migration\n+        if (!map.getMapServiceContext().getService().validateMigrationStamp(migrationStamp)) {\n+            throw QueryException.error(SqlErrorCode.PARTITION_MIGRATED, \"Map scan failed due to concurrent partition migration \"\n+                + \"(result consistency cannot be guaranteed)\");\n+        }\n+\n+        // Check for concurrent map destroy\n+        if (map.isDestoyed()) {\n+            throw QueryException.error(SqlErrorCode.MAP_DESTROYED, \"IMap has been destroyed concurrently: \" + mapName);\n+        }\n+\n+        boolean done = !recordIterator.hasNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDM4ODE4", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-398038818", "createdAt": "2020-04-22T10:06:32Z", "commit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowNjozMlrOGJuVRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowNjozMlrOGJuVRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0OTQ3Nw==", "bodyText": "map.getMapServiceContext().getExistingRecordStore(partitionId, map.getName())? It might be ugly, but otherwise we will duplicate all MapServiceContext methods in MapContainer sooner or later.", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412849477", "createdAt": "2020-04-22T10:06:32Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -422,6 +437,10 @@ public boolean isPersistWanReplicatedData() {\n         return persistWanReplicatedData;\n     }\n \n+    public RecordStore<?> getExistingRecordStore(int partitionId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d893d2d35bb30ecae40e6a2e0a243965c354735e"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9df077c8d02824f5f26d1ff1407aeba3293d3621", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9df077c8d02824f5f26d1ff1407aeba3293d3621", "committedDate": "2020-04-22T10:10:31Z", "message": "Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDcyMTc5", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-398072179", "createdAt": "2020-04-22T10:53:56Z", "commit": {"oid": "9df077c8d02824f5f26d1ff1407aeba3293d3621"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDo1Mzo1NlrOGJwKAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDo1Mzo1NlrOGJwKAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3OTM2Mg==", "bodyText": "AFAIU, until all involved record stores are loaded, queries (or some parts of them?) would fail with RetryableHazelcastException. Not sure how RetryableHazelcastException is handled for SQL operations, but there are automatic retries for others. Looks like we need to check the possible \"side effects\" here.", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412879362", "createdAt": "2020-04-22T10:53:56Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/MapScanExecIterator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.Clock;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.record.Record;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * Iterator over map partitions..\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapScanExecIterator {\n+\n+    private final MapContainer map;\n+    private final Iterator<Integer> partsIterator;\n+    private final long now = Clock.currentTimeMillis();\n+\n+    private RecordStore currentRecordStore;\n+    private Iterator<Map.Entry<Data, Record<Object>>> currentRecordStoreIterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapScanExecIterator(MapContainer map, Iterator<Integer> partsIterator) {\n+        this.map = map;\n+        this.partsIterator = partsIterator;\n+\n+        advance0();\n+    }\n+\n+    public boolean tryAdvance() {\n+        if (hasNext()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public boolean hasNext() {\n+        return nextKey != null;\n+    }\n+\n+    /**\n+     * Get the next key/value pair from the store.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void advance0() {\n+        while (true) {\n+            // Move to the next record store if needed.\n+            if (currentRecordStoreIterator == null) {\n+                if (!partsIterator.hasNext()) {\n+                    nextKey = null;\n+                    nextValue = null;\n+\n+                    return;\n+                } else {\n+                    int nextPart = partsIterator.next();\n+\n+                    boolean isOwned = map.getMapServiceContext().getOwnedPartitions().contains(nextPart);\n+\n+                    if (!isOwned) {\n+                        throw QueryException.error(SqlErrorCode.PARTITION_MIGRATED,\n+                            \"Partition is not owned by member: \" + nextPart);\n+                    }\n+\n+                    currentRecordStore = map.getExistingRecordStore(nextPart);\n+\n+                    if (currentRecordStore == null) {\n+                        // RecordStore might be missing if the associated partition is empty. Just skip it.\n+                        continue;\n+                    }\n+\n+                    currentRecordStore.checkIfLoaded();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df077c8d02824f5f26d1ff1407aeba3293d3621"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDk3MjIy", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-398097222", "createdAt": "2020-04-22T11:31:16Z", "commit": {"oid": "9df077c8d02824f5f26d1ff1407aeba3293d3621"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMTozMToxN1rOGJxfYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMTozMToxN1rOGJxfYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwMTIxNg==", "bodyText": "What does \"generic\" means in extractors context? Looks like all extractors are generic now.", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r412901216", "createdAt": "2020-04-22T11:31:17Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/extract/AbstractGenericExtractor.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.extract;\n+\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+/**\n+ * Base class for generic extractors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df077c8d02824f5f26d1ff1407aeba3293d3621"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MTA1NDEy", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-398105412", "createdAt": "2020-04-22T11:43:06Z", "commit": {"oid": "9df077c8d02824f5f26d1ff1407aeba3293d3621"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb089e246c1af96c47ebc88b10438592c3200ece", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fb089e246c1af96c47ebc88b10438592c3200ece", "committedDate": "2020-04-22T17:39:56Z", "message": "Merge branch 'master' into issues/16906\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/PlanNodeVisitor.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitorTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/plan/node/TestPlanNodeVisitorAdapter.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e846b698c8d94f3bfb08dbdbc33e86e4da0b6723", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e846b698c8d94f3bfb08dbdbc33e86e4da0b6723", "committedDate": "2020-04-22T17:41:36Z", "message": "Merge with master."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96d91e014a9e309e96b4355cc4f2502ab4979122", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/96d91e014a9e309e96b4355cc4f2502ab4979122", "committedDate": "2020-04-22T17:44:19Z", "message": "Special error for map loading."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad8108963951a7a0af1decfc0ee289f5dd310e2c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ad8108963951a7a0af1decfc0ee289f5dd310e2c", "committedDate": "2020-04-22T17:46:55Z", "message": "Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTUxNjk2", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-399151696", "createdAt": "2020-04-23T14:25:24Z", "commit": {"oid": "ad8108963951a7a0af1decfc0ee289f5dd310e2c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDoyNToyNFrOGKq4VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDozNzo1N1rOGKrjBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg0MTQ5Mw==", "bodyText": "Minor typo: ..", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r413841493", "createdAt": "2020-04-23T14:25:24Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/MapScanExecIterator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.Clock;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.record.Record;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.exception.RetryableHazelcastException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * Iterator over map partitions..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad8108963951a7a0af1decfc0ee289f5dd310e2c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1MjQyMg==", "bodyText": "In the old query engine we checked the migration timestamp for the whole resultSet and failed the query if the validation failed. In the new engine we rely on the iterative model, so that we may pass a portion of results to the application and it will process it. And then suddenly we throw this exception. What user can do with it? It already has processed some query results and made some critical decisions and cannot rollback that.", "url": "https://github.com/hazelcast/hazelcast/pull/16907#discussion_r413852422", "createdAt": "2020-04-23T14:37:57Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/MapScanExec.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.getters.Extractors;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.IterationResult;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.ListRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Executor for map scan.\n+ */\n+public class MapScanExec extends AbstractMapScanExec {\n+    /** Batch size. To be moved outside when the memory management is ready. */\n+    static final int BATCH_SIZE = 1024;\n+\n+    private final MapContainer map;\n+    private final PartitionIdSet partitions;\n+\n+    private int migrationStamp;\n+    private MapScanExecIterator recordIterator;\n+\n+    private List<Row> currentRows;\n+\n+    public MapScanExec(\n+        int id,\n+        MapContainer map,\n+        PartitionIdSet partitions,\n+        QueryTargetDescriptor keyDescriptor,\n+        QueryTargetDescriptor valueDescriptor,\n+        List<String> fieldNames,\n+        List<QueryDataType> fieldTypes,\n+        List<Integer> projects,\n+        Expression<Boolean> filter,\n+        InternalSerializationService serializationService\n+    ) {\n+        super(id, map.getName(), keyDescriptor, valueDescriptor, fieldNames, fieldTypes, projects, filter, serializationService);\n+\n+        this.map = map;\n+        this.partitions = partitions;\n+    }\n+\n+    @Override\n+    protected void setup1(QueryFragmentContext ctx) {\n+        migrationStamp = map.getMapServiceContext().getService().getMigrationStamp();\n+        recordIterator = MapScanExecUtils.createIterator(map, partitions);\n+    }\n+\n+    @Override\n+    public IterationResult advance0() {\n+        currentRows = null;\n+\n+        while (recordIterator.tryAdvance()) {\n+            HeapRow row = prepareRow(recordIterator.getKey(), recordIterator.getValue());\n+\n+            if (row != null) {\n+                if (currentRows == null) {\n+                    currentRows = new ArrayList<>(BATCH_SIZE);\n+                }\n+\n+                currentRows.add(row);\n+\n+                if (currentRows.size() == BATCH_SIZE) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        boolean done = !recordIterator.hasNext();\n+\n+        // Check for concurrent migration\n+        if (!map.getMapServiceContext().getService().validateMigrationStamp(migrationStamp)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad8108963951a7a0af1decfc0ee289f5dd310e2c"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bc21f05dce49b5bc45bd8e7cbac3e6120431bf5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4bc21f05dce49b5bc45bd8e7cbac3e6120431bf5", "committedDate": "2020-04-23T15:27:05Z", "message": "Typo."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MjMyNjg0", "url": "https://github.com/hazelcast/hazelcast/pull/16907#pullrequestreview-399232684", "createdAt": "2020-04-23T15:45:17Z", "commit": {"oid": "4bc21f05dce49b5bc45bd8e7cbac3e6120431bf5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3797, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}