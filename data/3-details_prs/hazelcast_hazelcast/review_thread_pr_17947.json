{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0MzY4MTc2", "number": 17947, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTozODoxOVrOFFiuog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTo0ODoyNFrOFGnkXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzU2MTk0OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastSqlToRelConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTozODoxOVrOIGGlog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyOToyMVrOIHAwFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MDMwNg==", "bodyText": "Typo: ot", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r543270306", "createdAt": "2020-12-15T11:38:19Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastSqlToRelConverter.java", "diffHunk": "@@ -57,128 +60,171 @@\n  * literals and casts with more precise types assigned during the validation.\n  */\n public class HazelcastSqlToRelConverter extends SqlToRelConverter {\n-\n-    public HazelcastSqlToRelConverter(RelOptTable.ViewExpander viewExpander, SqlValidator validator,\n-                                      Prepare.CatalogReader catalogReader, RelOptCluster cluster,\n-                                      SqlRexConvertletTable convertletTable, Config config) {\n+    /** See {@link #convertCall(SqlNode, Blackboard)} for more information. */\n+    private final Set<SqlNode> callSet = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+    public HazelcastSqlToRelConverter(\n+        RelOptTable.ViewExpander viewExpander,\n+        SqlValidator validator,\n+        Prepare.CatalogReader catalogReader,\n+        RelOptCluster cluster,\n+        SqlRexConvertletTable convertletTable,\n+        Config config\n+    ) {\n         super(viewExpander, validator, catalogReader, cluster, convertletTable, config);\n     }\n \n     @Override\n     protected RexNode convertExtendedExpression(SqlNode node, Blackboard blackboard) {\n+        // Hook into conversion of literals, casts and calls to execute our own logic.\n         if (node.getKind() == SqlKind.LITERAL) {\n             return convertLiteral((SqlLiteral) node);\n         } else if (node.getKind() == SqlKind.CAST) {\n             return convertCast((SqlCall) node, blackboard);\n+        } else if (node instanceof SqlCall) {\n+            return convertCall(node, blackboard);\n         }\n \n         return null;\n     }\n \n-    @SuppressWarnings(\"UnpredictableBigDecimalConstructorCall\")\n+    /**\n+     * Convert the literal taking in count the type that we assigned to it during validation.\n+     * Otherwise Apache Calcite will try to deduce literal type again, leading to incorrect exposed types.\n+     * <p>\n+     * For example, {@code [x:BIGINT > 1]} is interpreted as {@code [x:BIGINT > 1:BIGINT]} during the validation.\n+     * If this method is not invoked, Apache Calcite will convert it to {[@code x:BIGINT > 1:TINYINT]} instead.\n+     */\n+    private RexNode convertLiteral(SqlLiteral literal) {\n+        RelDataType type = validator.getValidatedNodeType(literal);\n+\n+        return getRexBuilder().makeLiteral(literal.getValue(), type, true);\n+    }\n+\n+    /**\n+     * Convert CAST exception fixing several Apache Calcite problems with literals along the way (see inline JavaDoc).\n+     */\n     private RexNode convertCast(SqlCall call, Blackboard blackboard) {\n+        RelDataType from = validator.getValidatedNodeType(call.operand(0));\n         RelDataType to = validator.getValidatedNodeType(call);\n-        RexNode operand = blackboard.convertExpression(call.operand(0));\n \n-        if (SqlUtil.isNullLiteral(call.operand(0), false)) {\n-            // Just generate the cast without messing with the value: it's\n-            // always NULL.\n-            return getRexBuilder().makeCast(to, operand);\n-        }\n+        QueryDataType fromType = HazelcastTypeUtils.toHazelcastType(from.getSqlTypeName());\n+        QueryDataType toType = HazelcastTypeUtils.toHazelcastType(to.getSqlTypeName());\n+\n+        Literal literal = LiteralUtils.literal(call.operand(0));\n+\n+        if (literal != null && literal.getTypeName() != NULL) {\n+            // There is a bug in RexSimplify that incorrectly converts numeric literals from one numeric type to another.\n+            // The problem is located in the RexToLixTranslator.translateLiteral. To perform a conversion, it delegates\n+            // to Primitive.number(Number) method, that does a conversion without checking for overflow. For example, the\n+            // expression [32767 AS TINYINT] is converted to -1, which is obviously incorrect.\n+            // To workaround the problem, we perform the conversion using our converters manually. If the conversion fails,\n+            // we throw an error (it would have been thrown in runtime anyway), thus preventing Apache Calcite from entering\n+            // the problematic simplification routine.\n+            // Since this workaround moves conversion errors to the parsing phase, we conduct the conversion check for all\n+            // types to ensure that we throw consistent error messages for all literal-related conversions errors.\n+            try {\n+                toType.getConverter().convertToSelf(fromType.getConverter(), literal.getValue());\n+            } catch (Exception e) {\n+                throw literalConversionException(validator, call, literal, toType, e);\n+            }\n \n-        RelDataType from = operand.getType();\n-\n-        // Use our to-string conversions for floating point types and BOOLEAN,\n-        // Calcite does conversions using its own formatting.\n-        if (operand.isA(SqlKind.LITERAL) && isChar(to)) {\n-            RexLiteral literal = (RexLiteral) operand;\n-\n-            switch (from.getSqlTypeName()) {\n-                case REAL:\n-                case DOUBLE:\n-                case DECIMAL:\n-                    BigDecimal decimalValue = literal.getValueAs(BigDecimal.class);\n-                    Converter fromConverter = SqlToQueryType.map(from.getSqlTypeName()).getConverter();\n-                    Object value = fromConverter.convertToSelf(BigDecimalConverter.INSTANCE, decimalValue);\n-                    Object valueAsString = StringConverter.INSTANCE.convertToSelf(fromConverter, value);\n-\n-                    return getRexBuilder().makeLiteral(valueAsString, to, true);\n-                case BOOLEAN:\n-                    boolean booleanValue = literal.getValueAs(Boolean.class);\n-                    String booleanAsString = BooleanConverter.INSTANCE.asVarchar(booleanValue);\n-                    return getRexBuilder().makeLiteral(booleanAsString, to, true);\n-                default:\n-                    // do nothing\n+            // Normalize BOOLEAN and DOUBLE literals when converting them to VARCHAR.\n+            // BOOLEAN literals are converted to \"true\"/\"false\" instead of \"TRUE\"/\"FALSE\".\n+            // DOUBLE literals are converted to a string with scientific conventions (e.g., 1.1E1 instead of 11.0);\n+            if (CHAR_TYPES.contains(to.getSqlTypeName())) {\n+                return getRexBuilder().makeLiteral(literal.getStringValue(), to, true);\n             }\n-        }\n \n-        // Convert REAL/DOUBLE values from BigDecimal representation to\n-        // REAL/DOUBLE and back, otherwise Calcite might think two floating-point\n-        // values having the same REAL/DOUBLE representation are distinct since\n-        // their BigDecimal representations might differ.\n-        if (operand.isA(SqlKind.LITERAL) && isNumeric(from) && APPROX_TYPES.contains(to.getSqlTypeName())) {\n-            RexLiteral literal = (RexLiteral) operand;\n-            BigDecimal value = literal.getValueAs(BigDecimal.class);\n-\n-            if (to.getSqlTypeName() == DOUBLE) {\n-                value = new BigDecimal(BigDecimalConverter.INSTANCE.asDouble(value), DECIMAL_MATH_CONTEXT);\n-            } else {\n-                assert to.getSqlTypeName() == REAL;\n-                value = new BigDecimal(BigDecimalConverter.INSTANCE.asReal(value), DECIMAL_MATH_CONTEXT);\n+            // There is a bug in RexSimplify that adds an unnecessary second. For example, the string literal \"00:00\" is\n+            // converted to 00:00:01. The problematic code is located in DateTimeUtils.timeStringToUnixDate.\n+            // To workaround the problem, we perform the conversion manually.\n+            if (CHAR_TYPES.contains(from.getSqlTypeName()) && to.getSqlTypeName() == TIME) {\n+                LocalTime time = fromType.getConverter().asTime(literal.getStringValue());\n+\n+                TimeString timeString = new TimeString(time.getHour(), time.getMinute(), time.getSecond());\n+\n+                return getRexBuilder().makeLiteral(timeString, to, true);\n             }\n \n-            return getRexBuilder().makeLiteral(value, to, false);\n+            // Apache Calcite cannot handle conversion of literals to OBJECT type properly.\n+            // Currently we use SqlTypeName.OTHER as a backing type name for the OBJECT data type. Calcite throws errors\n+            // when attempting to invoke RexBuilder.makeCast with such a type (try commenting the lines below and then\n+            // run CastFunctionIntegrationTest).\n+            // If we change the backing type name to SqlTypeName.ANY, then Apache Calcite attempts to remove the cast with the\n+            // invalid numeric conversions (similar to the above mentioned problem with RexToLixTranslator) what leads to\n+            // incorrect value. Specifically, Calcite attempts to treat any numeric literal as Long. As a result, literals\n+            // that overflow this value, are converted to the wrong value. E.g. \"new BigDecimal(Long.MAX_VALUE + \"0.1\")\" is\n+            // converted to \"-10L\".\n+            if (toType.getTypeFamily() == QueryDataTypeFamily.OBJECT) {\n+                QueryException cause = QueryException.error(\"Conversion of literals to \" + SqlColumnType.OBJECT\n+                    + \" type is not allowed (consider adding an explicit CAST to another expression part)\");\n+\n+                throw literalConversionException(validator, call, literal, toType, cause);\n+            }\n         }\n \n-        // also removes the cast if it's not required\n-        return getRexBuilder().makeCast(to, operand);\n-    }\n+        // Delegate ot Apache Calcite.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb6ba0e1202573196d34117023511380a3a3fd4e"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzI1Mw==", "bodyText": "Fixed in 28b7dca", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544223253", "createdAt": "2020-12-16T11:29:21Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastSqlToRelConverter.java", "diffHunk": "@@ -57,128 +60,171 @@\n  * literals and casts with more precise types assigned during the validation.\n  */\n public class HazelcastSqlToRelConverter extends SqlToRelConverter {\n-\n-    public HazelcastSqlToRelConverter(RelOptTable.ViewExpander viewExpander, SqlValidator validator,\n-                                      Prepare.CatalogReader catalogReader, RelOptCluster cluster,\n-                                      SqlRexConvertletTable convertletTable, Config config) {\n+    /** See {@link #convertCall(SqlNode, Blackboard)} for more information. */\n+    private final Set<SqlNode> callSet = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+    public HazelcastSqlToRelConverter(\n+        RelOptTable.ViewExpander viewExpander,\n+        SqlValidator validator,\n+        Prepare.CatalogReader catalogReader,\n+        RelOptCluster cluster,\n+        SqlRexConvertletTable convertletTable,\n+        Config config\n+    ) {\n         super(viewExpander, validator, catalogReader, cluster, convertletTable, config);\n     }\n \n     @Override\n     protected RexNode convertExtendedExpression(SqlNode node, Blackboard blackboard) {\n+        // Hook into conversion of literals, casts and calls to execute our own logic.\n         if (node.getKind() == SqlKind.LITERAL) {\n             return convertLiteral((SqlLiteral) node);\n         } else if (node.getKind() == SqlKind.CAST) {\n             return convertCast((SqlCall) node, blackboard);\n+        } else if (node instanceof SqlCall) {\n+            return convertCall(node, blackboard);\n         }\n \n         return null;\n     }\n \n-    @SuppressWarnings(\"UnpredictableBigDecimalConstructorCall\")\n+    /**\n+     * Convert the literal taking in count the type that we assigned to it during validation.\n+     * Otherwise Apache Calcite will try to deduce literal type again, leading to incorrect exposed types.\n+     * <p>\n+     * For example, {@code [x:BIGINT > 1]} is interpreted as {@code [x:BIGINT > 1:BIGINT]} during the validation.\n+     * If this method is not invoked, Apache Calcite will convert it to {[@code x:BIGINT > 1:TINYINT]} instead.\n+     */\n+    private RexNode convertLiteral(SqlLiteral literal) {\n+        RelDataType type = validator.getValidatedNodeType(literal);\n+\n+        return getRexBuilder().makeLiteral(literal.getValue(), type, true);\n+    }\n+\n+    /**\n+     * Convert CAST exception fixing several Apache Calcite problems with literals along the way (see inline JavaDoc).\n+     */\n     private RexNode convertCast(SqlCall call, Blackboard blackboard) {\n+        RelDataType from = validator.getValidatedNodeType(call.operand(0));\n         RelDataType to = validator.getValidatedNodeType(call);\n-        RexNode operand = blackboard.convertExpression(call.operand(0));\n \n-        if (SqlUtil.isNullLiteral(call.operand(0), false)) {\n-            // Just generate the cast without messing with the value: it's\n-            // always NULL.\n-            return getRexBuilder().makeCast(to, operand);\n-        }\n+        QueryDataType fromType = HazelcastTypeUtils.toHazelcastType(from.getSqlTypeName());\n+        QueryDataType toType = HazelcastTypeUtils.toHazelcastType(to.getSqlTypeName());\n+\n+        Literal literal = LiteralUtils.literal(call.operand(0));\n+\n+        if (literal != null && literal.getTypeName() != NULL) {\n+            // There is a bug in RexSimplify that incorrectly converts numeric literals from one numeric type to another.\n+            // The problem is located in the RexToLixTranslator.translateLiteral. To perform a conversion, it delegates\n+            // to Primitive.number(Number) method, that does a conversion without checking for overflow. For example, the\n+            // expression [32767 AS TINYINT] is converted to -1, which is obviously incorrect.\n+            // To workaround the problem, we perform the conversion using our converters manually. If the conversion fails,\n+            // we throw an error (it would have been thrown in runtime anyway), thus preventing Apache Calcite from entering\n+            // the problematic simplification routine.\n+            // Since this workaround moves conversion errors to the parsing phase, we conduct the conversion check for all\n+            // types to ensure that we throw consistent error messages for all literal-related conversions errors.\n+            try {\n+                toType.getConverter().convertToSelf(fromType.getConverter(), literal.getValue());\n+            } catch (Exception e) {\n+                throw literalConversionException(validator, call, literal, toType, e);\n+            }\n \n-        RelDataType from = operand.getType();\n-\n-        // Use our to-string conversions for floating point types and BOOLEAN,\n-        // Calcite does conversions using its own formatting.\n-        if (operand.isA(SqlKind.LITERAL) && isChar(to)) {\n-            RexLiteral literal = (RexLiteral) operand;\n-\n-            switch (from.getSqlTypeName()) {\n-                case REAL:\n-                case DOUBLE:\n-                case DECIMAL:\n-                    BigDecimal decimalValue = literal.getValueAs(BigDecimal.class);\n-                    Converter fromConverter = SqlToQueryType.map(from.getSqlTypeName()).getConverter();\n-                    Object value = fromConverter.convertToSelf(BigDecimalConverter.INSTANCE, decimalValue);\n-                    Object valueAsString = StringConverter.INSTANCE.convertToSelf(fromConverter, value);\n-\n-                    return getRexBuilder().makeLiteral(valueAsString, to, true);\n-                case BOOLEAN:\n-                    boolean booleanValue = literal.getValueAs(Boolean.class);\n-                    String booleanAsString = BooleanConverter.INSTANCE.asVarchar(booleanValue);\n-                    return getRexBuilder().makeLiteral(booleanAsString, to, true);\n-                default:\n-                    // do nothing\n+            // Normalize BOOLEAN and DOUBLE literals when converting them to VARCHAR.\n+            // BOOLEAN literals are converted to \"true\"/\"false\" instead of \"TRUE\"/\"FALSE\".\n+            // DOUBLE literals are converted to a string with scientific conventions (e.g., 1.1E1 instead of 11.0);\n+            if (CHAR_TYPES.contains(to.getSqlTypeName())) {\n+                return getRexBuilder().makeLiteral(literal.getStringValue(), to, true);\n             }\n-        }\n \n-        // Convert REAL/DOUBLE values from BigDecimal representation to\n-        // REAL/DOUBLE and back, otherwise Calcite might think two floating-point\n-        // values having the same REAL/DOUBLE representation are distinct since\n-        // their BigDecimal representations might differ.\n-        if (operand.isA(SqlKind.LITERAL) && isNumeric(from) && APPROX_TYPES.contains(to.getSqlTypeName())) {\n-            RexLiteral literal = (RexLiteral) operand;\n-            BigDecimal value = literal.getValueAs(BigDecimal.class);\n-\n-            if (to.getSqlTypeName() == DOUBLE) {\n-                value = new BigDecimal(BigDecimalConverter.INSTANCE.asDouble(value), DECIMAL_MATH_CONTEXT);\n-            } else {\n-                assert to.getSqlTypeName() == REAL;\n-                value = new BigDecimal(BigDecimalConverter.INSTANCE.asReal(value), DECIMAL_MATH_CONTEXT);\n+            // There is a bug in RexSimplify that adds an unnecessary second. For example, the string literal \"00:00\" is\n+            // converted to 00:00:01. The problematic code is located in DateTimeUtils.timeStringToUnixDate.\n+            // To workaround the problem, we perform the conversion manually.\n+            if (CHAR_TYPES.contains(from.getSqlTypeName()) && to.getSqlTypeName() == TIME) {\n+                LocalTime time = fromType.getConverter().asTime(literal.getStringValue());\n+\n+                TimeString timeString = new TimeString(time.getHour(), time.getMinute(), time.getSecond());\n+\n+                return getRexBuilder().makeLiteral(timeString, to, true);\n             }\n \n-            return getRexBuilder().makeLiteral(value, to, false);\n+            // Apache Calcite cannot handle conversion of literals to OBJECT type properly.\n+            // Currently we use SqlTypeName.OTHER as a backing type name for the OBJECT data type. Calcite throws errors\n+            // when attempting to invoke RexBuilder.makeCast with such a type (try commenting the lines below and then\n+            // run CastFunctionIntegrationTest).\n+            // If we change the backing type name to SqlTypeName.ANY, then Apache Calcite attempts to remove the cast with the\n+            // invalid numeric conversions (similar to the above mentioned problem with RexToLixTranslator) what leads to\n+            // incorrect value. Specifically, Calcite attempts to treat any numeric literal as Long. As a result, literals\n+            // that overflow this value, are converted to the wrong value. E.g. \"new BigDecimal(Long.MAX_VALUE + \"0.1\")\" is\n+            // converted to \"-10L\".\n+            if (toType.getTypeFamily() == QueryDataTypeFamily.OBJECT) {\n+                QueryException cause = QueryException.error(\"Conversion of literals to \" + SqlColumnType.OBJECT\n+                    + \" type is not allowed (consider adding an explicit CAST to another expression part)\");\n+\n+                throw literalConversionException(validator, call, literal, toType, cause);\n+            }\n         }\n \n-        // also removes the cast if it's not required\n-        return getRexBuilder().makeCast(to, operand);\n-    }\n+        // Delegate ot Apache Calcite.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MDMwNg=="}, "originalCommit": {"oid": "eb6ba0e1202573196d34117023511380a3a3fd4e"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDA5MjQzOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastResources.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMzo0MDo0OVrOIGLZig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo0OTozM1rOIGSTfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM0OTEzMA==", "bodyText": "Shouldn't it be in reverse? Can't apply operator/function to operands, not the operands to operator/function.", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r543349130", "createdAt": "2020-12-15T13:40:49Z", "author": {"login": "taburet"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastResources.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import org.apache.calcite.runtime.CalciteException;\n+import org.apache.calcite.runtime.Resources;\n+import org.apache.calcite.sql.validate.SqlValidatorException;\n+\n+/**\n+ * Error messages for parsing and validation stages.\n+ */\n+public interface HazelcastResources {\n+\n+    HazelcastResources RESOURCES = Resources.create(HazelcastResources.class);\n+\n+    @Resources.BaseMessage(\"Function ''{0}'' does not exist\")\n+    Resources.ExInst<CalciteException> functionDoesNotExist(String functionName);\n+\n+    @Resources.BaseMessage(\"Cannot apply {1} to the {0} operator (consider adding an explicit CAST)\")\n+    Resources.ExInst<SqlValidatorException> invalidOperatorOperands(String operatorName, String operandTypes);\n+\n+    @Resources.BaseMessage(\"Cannot apply {1} to the {0} function (consider adding an explicit CAST)\")\n+    Resources.ExInst<SqlValidatorException> invalidFunctionOperands(String functionName, String operandTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b504268d152b13d76219a0c6e1bb6daae7acbc22"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MjI3MQ==", "bodyText": "Fixed in ba60023", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r543462271", "createdAt": "2020-12-15T15:49:33Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastResources.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import org.apache.calcite.runtime.CalciteException;\n+import org.apache.calcite.runtime.Resources;\n+import org.apache.calcite.sql.validate.SqlValidatorException;\n+\n+/**\n+ * Error messages for parsing and validation stages.\n+ */\n+public interface HazelcastResources {\n+\n+    HazelcastResources RESOURCES = Resources.create(HazelcastResources.class);\n+\n+    @Resources.BaseMessage(\"Function ''{0}'' does not exist\")\n+    Resources.ExInst<CalciteException> functionDoesNotExist(String functionName);\n+\n+    @Resources.BaseMessage(\"Cannot apply {1} to the {0} operator (consider adding an explicit CAST)\")\n+    Resources.ExInst<SqlValidatorException> invalidOperatorOperands(String operatorName, String operandTypes);\n+\n+    @Resources.BaseMessage(\"Cannot apply {1} to the {0} function (consider adding an explicit CAST)\")\n+    Resources.ExInst<SqlValidatorException> invalidFunctionOperands(String functionName, String operandTypes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM0OTEzMA=="}, "originalCommit": {"oid": "b504268d152b13d76219a0c6e1bb6daae7acbc22"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTQwNTk2OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTo0NTozNlrOIG8lHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyOToxNlrOIHAv2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1NDkxMA==", "bodyText": "Why do we need nested if instead of && in the condition as was before?", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544154910", "createdAt": "2020-12-16T09:45:36Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -176,123 +144,59 @@ public void validateCall(SqlCall call, SqlValidatorScope scope) {\n         // skip it if a call has a fixed type, for instance AND always has\n         // BOOLEAN type, so operands may end up having no validated type.\n         deriveType(scope, call);\n+\n         super.validateCall(call, scope);\n     }\n \n     @Override\n     protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n         SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n \n-        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n-            // Rewrite operators to Hazelcast ones starting at every top node.\n-            // For instance, SELECT a + b is rewritten to SELECT a + b, where\n-            // the first '+' refers to the standard Calcite SqlStdOperatorTable.PLUS\n-            // operator and the second '+' refers to HazelcastSqlOperatorTable.PLUS\n-            // operator.\n-            rewritten.accept(HazelcastOperatorTableVisitor.INSTANCE);\n+        if (rewritten != null) {\n+            if (rewritten.isA(SqlKind.TOP_LEVEL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzE5Mg==", "bodyText": "The leftover. Reverted in 28b7dca", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544223192", "createdAt": "2020-12-16T11:29:16Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -176,123 +144,59 @@ public void validateCall(SqlCall call, SqlValidatorScope scope) {\n         // skip it if a call has a fixed type, for instance AND always has\n         // BOOLEAN type, so operands may end up having no validated type.\n         deriveType(scope, call);\n+\n         super.validateCall(call, scope);\n     }\n \n     @Override\n     protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n         SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n \n-        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n-            // Rewrite operators to Hazelcast ones starting at every top node.\n-            // For instance, SELECT a + b is rewritten to SELECT a + b, where\n-            // the first '+' refers to the standard Calcite SqlStdOperatorTable.PLUS\n-            // operator and the second '+' refers to HazelcastSqlOperatorTable.PLUS\n-            // operator.\n-            rewritten.accept(HazelcastOperatorTableVisitor.INSTANCE);\n+        if (rewritten != null) {\n+            if (rewritten.isA(SqlKind.TOP_LEVEL)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1NDkxMA=="}, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTQxOTU2OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/literal/Literal.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTo0ODoyNVrOIG8tEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyOTowNFrOIHAvVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk0NQ==", "bodyText": "Javadoc would be useful here.", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544156945", "createdAt": "2020-12-16T09:48:25Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/literal/Literal.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.literal;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzA2Mw==", "bodyText": "Added in 28b7dca", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544223063", "createdAt": "2020-12-16T11:29:04Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/literal/Literal.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.literal;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk0NQ=="}, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTU0NTk5OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operand/OperandCheckerProgram.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxNjowOVrOIG93zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMTo1MDozMFrOIHBhoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NjA3Nw==", "bodyText": "Once the res is false, shall we stop checking and return the result (throw an exception)?", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544176077", "createdAt": "2020-12-16T10:16:09Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operand/OperandCheckerProgram.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operand;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+\n+/**\n+ * Composite program that invokes a separate operand checker for every operand.\n+ */\n+public class OperandCheckerProgram {\n+\n+    private final OperandChecker[] checkers;\n+\n+    public OperandCheckerProgram(OperandChecker... checkers) {\n+        this.checkers = checkers;\n+    }\n+\n+    public boolean check(HazelcastCallBinding callBinding, boolean throwOnFailure) {\n+        boolean res = true;\n+\n+        for (int i = 0; i < checkers.length; i++) {\n+            boolean checkerRes = checkers[i].check(callBinding, false, i);\n+\n+            if (!checkerRes) {\n+                res = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNTkzNg==", "bodyText": "We must continue doing this till the end because otherwise, we will get the incorrect signature error as some of the operand types will not be completely resolved. E.g. some tests in SubstringFunctionIntegrationTest will fail.", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544235936", "createdAt": "2020-12-16T11:50:30Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operand/OperandCheckerProgram.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operand;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+\n+/**\n+ * Composite program that invokes a separate operand checker for every operand.\n+ */\n+public class OperandCheckerProgram {\n+\n+    private final OperandChecker[] checkers;\n+\n+    public OperandCheckerProgram(OperandChecker... checkers) {\n+        this.checkers = checkers;\n+    }\n+\n+    public boolean check(HazelcastCallBinding callBinding, boolean throwOnFailure) {\n+        boolean res = true;\n+\n+        for (int i = 0; i < checkers.length; i++) {\n+            boolean checkerRes = checkers[i].check(callBinding, false, i);\n+\n+            if (!checkerRes) {\n+                res = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NjA3Nw=="}, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTY0MjI3OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/misc/HazelcastArithmeticOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDozNzo1MVrOIG-v8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyNjo0OFrOIHAqLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5MDQ1MA==", "bodyText": "Looks like that might disable certain optimizations in Calcite.", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544190450", "createdAt": "2020-12-16T10:37:51Z", "author": {"login": "taburet"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/misc/HazelcastArithmeticOperator.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators.misc;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.BinaryOperatorOperandTypeInference;\n+import com.hazelcast.sql.impl.calcite.validate.operators.common.HazelcastBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+\n+public final class HazelcastArithmeticOperator extends HazelcastBinaryOperator {\n+\n+    public static final HazelcastArithmeticOperator PLUS = new HazelcastArithmeticOperator(SqlStdOperatorTable.PLUS);\n+    public static final HazelcastArithmeticOperator MINUS = new HazelcastArithmeticOperator(SqlStdOperatorTable.MINUS);\n+    public static final HazelcastArithmeticOperator MULTIPLY = new HazelcastArithmeticOperator(SqlStdOperatorTable.MULTIPLY);\n+    public static final HazelcastArithmeticOperator DIVIDE = new HazelcastArithmeticOperator(SqlStdOperatorTable.DIVIDE);\n+\n+    private HazelcastArithmeticOperator(SqlBinaryOperator base) {\n+        super(\n+            base.getName(),\n+            base.getKind(),\n+            base.getLeftPrec(),\n+            true,\n+            ReturnTypes.ARG0_NULLABLE,\n+            BinaryOperatorOperandTypeInference.INSTANCE\n+        );\n+    }\n+\n+    @Override\n+    public SqlOperandCountRange getOperandCountRange() {\n+        return SqlOperandCountRanges.of(2);\n+    }\n+\n+    @Override\n+    public SqlSyntax getSyntax() {\n+        return SqlSyntax.BINARY;\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(HazelcastCallBinding binding, boolean throwOnFailure) {\n+        return HazelcastArithmeticOperatorUtils.checkOperandTypes(binding, throwOnFailure, kind);\n+    }\n+\n+    @Override\n+    public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {\n+        return SqlMonotonicity.NOT_MONOTONIC;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMTc0MQ==", "bodyText": "We do not use any rules that rely on this at the moment, therefore this would be a dead code. Monotonicity handling should be a separate task when such rules are introduced (e.g. sorting, aggregations).", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544221741", "createdAt": "2020-12-16T11:26:48Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/misc/HazelcastArithmeticOperator.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators.misc;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.BinaryOperatorOperandTypeInference;\n+import com.hazelcast.sql.impl.calcite.validate.operators.common.HazelcastBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+\n+public final class HazelcastArithmeticOperator extends HazelcastBinaryOperator {\n+\n+    public static final HazelcastArithmeticOperator PLUS = new HazelcastArithmeticOperator(SqlStdOperatorTable.PLUS);\n+    public static final HazelcastArithmeticOperator MINUS = new HazelcastArithmeticOperator(SqlStdOperatorTable.MINUS);\n+    public static final HazelcastArithmeticOperator MULTIPLY = new HazelcastArithmeticOperator(SqlStdOperatorTable.MULTIPLY);\n+    public static final HazelcastArithmeticOperator DIVIDE = new HazelcastArithmeticOperator(SqlStdOperatorTable.DIVIDE);\n+\n+    private HazelcastArithmeticOperator(SqlBinaryOperator base) {\n+        super(\n+            base.getName(),\n+            base.getKind(),\n+            base.getLeftPrec(),\n+            true,\n+            ReturnTypes.ARG0_NULLABLE,\n+            BinaryOperatorOperandTypeInference.INSTANCE\n+        );\n+    }\n+\n+    @Override\n+    public SqlOperandCountRange getOperandCountRange() {\n+        return SqlOperandCountRanges.of(2);\n+    }\n+\n+    @Override\n+    public SqlSyntax getSyntax() {\n+        return SqlSyntax.BINARY;\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(HazelcastCallBinding binding, boolean throwOnFailure) {\n+        return HazelcastArithmeticOperatorUtils.checkOperandTypes(binding, throwOnFailure, kind);\n+    }\n+\n+    @Override\n+    public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {\n+        return SqlMonotonicity.NOT_MONOTONIC;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5MDQ1MA=="}, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTY3MDcyOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/predicate/HazelcastAndOrPredicate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0NDozMVrOIG_Apg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMTo1MTo1N1rOIHBlMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDcyNg==", "bodyText": "Typo: ooverride", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544194726", "createdAt": "2020-12-16T10:44:31Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/predicate/HazelcastAndOrPredicate.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators.predicate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operand.OperandCheckerProgram;\n+import com.hazelcast.sql.impl.calcite.validate.operand.OperandChecker;\n+import com.hazelcast.sql.impl.calcite.validate.operand.TypedOperandChecker;\n+import com.hazelcast.sql.impl.calcite.validate.operators.common.HazelcastBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.util.Litmus;\n+\n+import java.util.Arrays;\n+\n+public final class HazelcastAndOrPredicate extends HazelcastBinaryOperator {\n+\n+    public static final HazelcastAndOrPredicate AND = new HazelcastAndOrPredicate(\n+        \"AND\",\n+        SqlKind.AND,\n+        SqlStdOperatorTable.AND.getLeftPrec()\n+    );\n+\n+    public static final SqlBinaryOperator OR = new HazelcastAndOrPredicate(\n+        \"OR\",\n+        SqlKind.OR,\n+        SqlStdOperatorTable.OR.getLeftPrec()\n+    );\n+\n+    private HazelcastAndOrPredicate(String name, SqlKind kind, int prec) {\n+        super(\n+            name,\n+            kind,\n+            prec,\n+            true,\n+            ReturnTypes.BOOLEAN_NULLABLE,\n+            InferTypes.BOOLEAN\n+        );\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(HazelcastCallBinding binding, boolean throwOnFailure) {\n+        OperandChecker[] checkers = new OperandChecker[binding.getOperandCount()];\n+        Arrays.fill(checkers, TypedOperandChecker.BOOLEAN);\n+\n+        return new OperandCheckerProgram(checkers).check(binding, throwOnFailure);\n+    }\n+\n+    @Override\n+    public SqlOperandCountRange getOperandCountRange() {\n+        return SqlOperandCountRanges.from(2);\n+    }\n+\n+    @Override\n+    public boolean validRexOperands(int count, Litmus litmus) {\n+        // Allow for more than two operands similarly to Calcite built-in AND/OR operators.\n+        // We ooverride the method because Calcite returns \"true\" only for the instances of the original operators.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjg0OA==", "bodyText": "Fixed in 76c6428", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544236848", "createdAt": "2020-12-16T11:51:57Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/predicate/HazelcastAndOrPredicate.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators.predicate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operand.OperandCheckerProgram;\n+import com.hazelcast.sql.impl.calcite.validate.operand.OperandChecker;\n+import com.hazelcast.sql.impl.calcite.validate.operand.TypedOperandChecker;\n+import com.hazelcast.sql.impl.calcite.validate.operators.common.HazelcastBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.util.Litmus;\n+\n+import java.util.Arrays;\n+\n+public final class HazelcastAndOrPredicate extends HazelcastBinaryOperator {\n+\n+    public static final HazelcastAndOrPredicate AND = new HazelcastAndOrPredicate(\n+        \"AND\",\n+        SqlKind.AND,\n+        SqlStdOperatorTable.AND.getLeftPrec()\n+    );\n+\n+    public static final SqlBinaryOperator OR = new HazelcastAndOrPredicate(\n+        \"OR\",\n+        SqlKind.OR,\n+        SqlStdOperatorTable.OR.getLeftPrec()\n+    );\n+\n+    private HazelcastAndOrPredicate(String name, SqlKind kind, int prec) {\n+        super(\n+            name,\n+            kind,\n+            prec,\n+            true,\n+            ReturnTypes.BOOLEAN_NULLABLE,\n+            InferTypes.BOOLEAN\n+        );\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(HazelcastCallBinding binding, boolean throwOnFailure) {\n+        OperandChecker[] checkers = new OperandChecker[binding.getOperandCount()];\n+        Arrays.fill(checkers, TypedOperandChecker.BOOLEAN);\n+\n+        return new OperandCheckerProgram(checkers).check(binding, throwOnFailure);\n+    }\n+\n+    @Override\n+    public SqlOperandCountRange getOperandCountRange() {\n+        return SqlOperandCountRanges.from(2);\n+    }\n+\n+    @Override\n+    public boolean validRexOperands(int count, Litmus litmus) {\n+        // Allow for more than two operands similarly to Calcite built-in AND/OR operators.\n+        // We ooverride the method because Calcite returns \"true\" only for the instances of the original operators.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDcyNg=="}, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTcwNjcxOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/param/AbstractParameterConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo1MjoyN1rOIG_VWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMTo1MTo1OVrOIHBlWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwMDAyNA==", "bodyText": "Shall we use %d for int line, col?", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544200024", "createdAt": "2020-12-16T10:52:27Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/param/AbstractParameterConverter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.param;\n+\n+import com.hazelcast.sql.impl.ParameterConverter;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+\n+public abstract class AbstractParameterConverter implements ParameterConverter {\n+\n+    protected final int ordinal;\n+    protected final SqlParserPos parserPos;\n+    protected final QueryDataType targetType;\n+\n+    protected AbstractParameterConverter(int ordinal, SqlParserPos parserPos, QueryDataType targetType) {\n+        this.ordinal = ordinal;\n+        this.parserPos = parserPos;\n+        this.targetType = targetType;\n+    }\n+\n+    @Override\n+    public QueryDataType getTargetType() {\n+        return targetType;\n+    }\n+\n+    @Override\n+    public final Object convert(Object value) {\n+        // NULL value is always OK\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        // Validate the value\n+        Converter valueConverter = Converters.getConverter(value.getClass());\n+\n+        if (!isValid(value, valueConverter)) {\n+            String actualTypeName = valueConverter.getTypeFamily().getPublicType().name();\n+            String targetTypeName = targetType.getTypeFamily().getPublicType().name();\n+\n+            String error = String.format(\n+                \"Parameter at position %d must be of %s type, but %s was found (consider adding an explicit CAST)\",\n+                ordinal,\n+                targetTypeName,\n+                actualTypeName\n+            );\n+\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, withContext(error));\n+        }\n+\n+        // Convert the value\n+        try {\n+            return targetType.getConverter().convertToSelf(valueConverter, value);\n+        } catch (Exception e) {\n+            String error = String.format(\n+                \"Failed to convert parameter at position %d from %s to %s: %s\",\n+                ordinal,\n+                valueConverter.getTypeFamily().getPublicType(),\n+                targetType.getConverter().getTypeFamily().getPublicType(),\n+                e.getMessage()\n+            );\n+\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, withContext(error), e);\n+        }\n+    }\n+\n+    protected abstract boolean isValid(Object value, Converter valueConverter);\n+\n+    private String withContext(String message) {\n+        int line = parserPos.getLineNum();\n+        int col = parserPos.getColumnNum();\n+        int endLine = parserPos.getEndLineNum();\n+        int endCol = parserPos.getEndColumnNum();\n+\n+        String context;\n+\n+        if (line == endLine && col == endCol) {\n+            context = String.format(\"At line %s, column %s\", line, col);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjg4OQ==", "bodyText": "Fixed 76c6428", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544236889", "createdAt": "2020-12-16T11:51:59Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/param/AbstractParameterConverter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.param;\n+\n+import com.hazelcast.sql.impl.ParameterConverter;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+\n+public abstract class AbstractParameterConverter implements ParameterConverter {\n+\n+    protected final int ordinal;\n+    protected final SqlParserPos parserPos;\n+    protected final QueryDataType targetType;\n+\n+    protected AbstractParameterConverter(int ordinal, SqlParserPos parserPos, QueryDataType targetType) {\n+        this.ordinal = ordinal;\n+        this.parserPos = parserPos;\n+        this.targetType = targetType;\n+    }\n+\n+    @Override\n+    public QueryDataType getTargetType() {\n+        return targetType;\n+    }\n+\n+    @Override\n+    public final Object convert(Object value) {\n+        // NULL value is always OK\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        // Validate the value\n+        Converter valueConverter = Converters.getConverter(value.getClass());\n+\n+        if (!isValid(value, valueConverter)) {\n+            String actualTypeName = valueConverter.getTypeFamily().getPublicType().name();\n+            String targetTypeName = targetType.getTypeFamily().getPublicType().name();\n+\n+            String error = String.format(\n+                \"Parameter at position %d must be of %s type, but %s was found (consider adding an explicit CAST)\",\n+                ordinal,\n+                targetTypeName,\n+                actualTypeName\n+            );\n+\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, withContext(error));\n+        }\n+\n+        // Convert the value\n+        try {\n+            return targetType.getConverter().convertToSelf(valueConverter, value);\n+        } catch (Exception e) {\n+            String error = String.format(\n+                \"Failed to convert parameter at position %d from %s to %s: %s\",\n+                ordinal,\n+                valueConverter.getTypeFamily().getPublicType(),\n+                targetType.getConverter().getTypeFamily().getPublicType(),\n+                e.getMessage()\n+            );\n+\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, withContext(error), e);\n+        }\n+    }\n+\n+    protected abstract boolean isValid(Object value, Converter valueConverter);\n+\n+    private String withContext(String message) {\n+        int line = parserPos.getLineNum();\n+        int col = parserPos.getColumnNum();\n+        int endLine = parserPos.getEndLineNum();\n+        int endCol = parserPos.getEndColumnNum();\n+\n+        String context;\n+\n+        if (line == endLine && col == endCol) {\n+            context = String.format(\"At line %s, column %s\", line, col);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwMDAyNA=="}, "originalCommit": {"oid": "93a6a63dd8ab82d03c124cdb6cc329559e4f6f51"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDgzMDg4OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTo0NjoyNlrOIHtISg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTo1OTozM1rOIHtsBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1MDM0Ng==", "bodyText": "Field is unused", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544950346", "createdAt": "2020-12-17T09:46:26Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -428,4 +181,59 @@ private HazelcastSqlOperatorTable() {\n     public static HazelcastSqlOperatorTable instance() {\n         return INSTANCE;\n     }\n+\n+    /**\n+     * Visitor that rewrites Calcite operators with operators from this table.\n+     */\n+    public static class RewriteVisitor extends SqlBasicVisitor<Void> {\n+\n+        private final HazelcastSqlValidator validator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76c6428d60a68d33700b4ae95c17d58ef1a3f155"}, "originalPosition": 502}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1OTQ5Mw==", "bodyText": "Fixed in 65df331", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544959493", "createdAt": "2020-12-17T09:59:33Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -428,4 +181,59 @@ private HazelcastSqlOperatorTable() {\n     public static HazelcastSqlOperatorTable instance() {\n         return INSTANCE;\n     }\n+\n+    /**\n+     * Visitor that rewrites Calcite operators with operators from this table.\n+     */\n+    public static class RewriteVisitor extends SqlBasicVisitor<Void> {\n+\n+        private final HazelcastSqlValidator validator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1MDM0Ng=="}, "originalCommit": {"oid": "76c6428d60a68d33700b4ae95c17d58ef1a3f155"}, "originalPosition": 502}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDg0MDYxOnYy", "diffSide": "LEFT", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTo0ODoyNFrOIHtNxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMToyODoxOFrOIHxNIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1MTc0OA==", "bodyText": "Looks like the comment still holds.", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544951748", "createdAt": "2020-12-17T09:48:24Z", "author": {"login": "taburet"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -371,8 +381,6 @@ private RexToExpression() {\n                 break;\n \n             case BIGINT:\n-                // XXX: Calcite returns unscaled value of the internally stored", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76c6428d60a68d33700b4ae95c17d58ef1a3f155"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1OTk4Ng==", "bodyText": "Is it a problem for us? BIGINT type is resolved only when the value is within the value range of the Long type, and there are no decimal points. Therefore, unscaling should not affect us anyhow, unless I am missing something.\nIn any case, I simplified this code to just request the Long.class value, it should work well either: 65df331", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r544959986", "createdAt": "2020-12-17T10:00:15Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -371,8 +381,6 @@ private RexToExpression() {\n                 break;\n \n             case BIGINT:\n-                // XXX: Calcite returns unscaled value of the internally stored", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1MTc0OA=="}, "originalCommit": {"oid": "76c6428d60a68d33700b4ae95c17d58ef1a3f155"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNDU4OA==", "bodyText": "select cast(1.1 as bigint) now returns 11. There is obviously some gaps in the test coverage, at least for CAST, since the latest build didn't fail.", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r545004588", "createdAt": "2020-12-17T11:07:50Z", "author": {"login": "taburet"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -371,8 +381,6 @@ private RexToExpression() {\n                 break;\n \n             case BIGINT:\n-                // XXX: Calcite returns unscaled value of the internally stored", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1MTc0OA=="}, "originalCommit": {"oid": "76c6428d60a68d33700b4ae95c17d58ef1a3f155"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNzEyMw==", "bodyText": "Fixed in 7e28f0c, missing test is added", "url": "https://github.com/hazelcast/hazelcast/pull/17947#discussion_r545017123", "createdAt": "2020-12-17T11:28:18Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -371,8 +381,6 @@ private RexToExpression() {\n                 break;\n \n             case BIGINT:\n-                // XXX: Calcite returns unscaled value of the internally stored", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1MTc0OA=="}, "originalCommit": {"oid": "76c6428d60a68d33700b4ae95c17d58ef1a3f155"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4995, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}