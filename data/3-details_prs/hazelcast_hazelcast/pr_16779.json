{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMDI5Mzgz", "number": 16779, "title": "Allow to protect management operations on client protocol", "bodyText": "Upstream port of the #16759.\nPRD: https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2027029096\nThis PR introduces trusted interfaces concept to Management center connections. The approach extends the existing logic available in the Multicast join method configuration. Restrictions are based on the connection source IP address.\nThe feature can be enabled declaratively in the Man-center related part of member configuration:\nhazelcast.xml\n<hazelcast>\n    <management-center scripting-enabled=\"false\">\n        <trusted-interfaces>\n            <interface>10.10.1.*</interface>\n            <interface>10.10.2.*</interface>\n        </trusted-interfaces>\n    </management-center>\n</hazelcast>\nUsers can also enable the feature programmatically in the ManagementCenterConfig class:\nCode\nconfig.getManagementCenterConfig().addTrustedInterface(\"192.168.1.*\");", "createdAt": "2020-03-19T14:16:16Z", "url": "https://github.com/hazelcast/hazelcast/pull/16779", "merged": true, "mergeCommit": {"oid": "61bb1f9b6667d176ce2f5185f17f6f1a2efdc810"}, "closed": true, "closedAt": "2020-03-20T15:21:03Z", "author": {"login": "kwart"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPMvNFABqjMxNDU3ODAyNzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPhWqZAFqTM3ODUyOTIzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ced6cc86138faead4ed4687839f0881a5c0a6a9", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8ced6cc86138faead4ed4687839f0881a5c0a6a9", "committedDate": "2020-03-19T14:11:21Z", "message": "Allow to protect management operations on client protocol. The protection is based on client connection source IP address."}, "afterCommit": {"oid": "9af0ab05434b6c212976ec33c61aa1560afa19b7", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9af0ab05434b6c212976ec33c61aa1560afa19b7", "committedDate": "2020-03-19T14:25:04Z", "message": "Allow to protect management operations on client protocol. The protection is based on client connection source IP address."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "730711cb7d083dc9cbce8ebe8e6f4565fba3eae0", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/730711cb7d083dc9cbce8ebe8e6f4565fba3eae0", "committedDate": "2020-03-19T20:35:50Z", "message": "Allow to protect management operations on client protocol. The protection is based on client connection source IP address."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9af0ab05434b6c212976ec33c61aa1560afa19b7", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9af0ab05434b6c212976ec33c61aa1560afa19b7", "committedDate": "2020-03-19T14:25:04Z", "message": "Allow to protect management operations on client protocol. The protection is based on client connection source IP address."}, "afterCommit": {"oid": "730711cb7d083dc9cbce8ebe8e6f4565fba3eae0", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/730711cb7d083dc9cbce8ebe8e6f4565fba3eae0", "committedDate": "2020-03-19T20:35:50Z", "message": "Allow to protect management operations on client protocol. The protection is based on client connection source IP address."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4fb25bddd9bf5a83cc81e436de06bf28867b346", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f4fb25bddd9bf5a83cc81e436de06bf28867b346", "committedDate": "2020-03-20T07:29:10Z", "message": "AuthenticationException->AccessControlException"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MjgxOTQ2", "url": "https://github.com/hazelcast/hazelcast/pull/16779#pullrequestreview-378281946", "createdAt": "2020-03-20T07:56:16Z", "commit": {"oid": "f4fb25bddd9bf5a83cc81e436de06bf28867b346"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNzo1NjoxN1rOF5KKDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNzo1ODo1N1rOF5KNtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3OTU2Nw==", "bodyText": "nit: change to AccessControlException was expected.", "url": "https://github.com/hazelcast/hazelcast/pull/16779#discussion_r395479567", "createdAt": "2020-03-20T07:56:17Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/management/MCTrustedInterfacesTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.management;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import com.hazelcast.client.AuthenticationException;\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.clientside.HazelcastClientProxy;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.MCAddWanBatchPublisherConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCApplyMCConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCChangeClusterStateCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCChangeClusterVersionCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCChangeWanReplicationStateCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCCheckWanConsistencyCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCClearWanQueuesCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetCPMembersCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetClusterMetadataCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetMapConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetMemberConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetSystemPropertiesCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetThreadDumpCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetTimedMemberStateCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCInterruptHotRestartBackupCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCMatchMCConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCPollMCEventsCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCPromoteLiteMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCPromoteToCPMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRemoveCPMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCResetCPSubsystemCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRunConsoleCommandCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRunGcCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRunScriptCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCShutdownClusterCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCShutdownMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCTriggerForceStartCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCTriggerHotRestartBackupCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCTriggerPartialStartCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCUpdateMapConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCWanSyncMapCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({ QuickTest.class, ParallelJVMTest.class })\n+public class MCTrustedInterfacesTest extends HazelcastTestSupport {\n+\n+    HazelcastInstance client;\n+    HazelcastInstance member;\n+    private TestHazelcastFactory factory;\n+\n+    @Before\n+    public void setUp() {\n+        factory = new TestHazelcastFactory();\n+\n+        Config config = smallInstanceConfig();\n+        config.getManagementCenterConfig().addTrustedInterface(\"222.222.222.222\");\n+        member = factory.newHazelcastInstance(config);\n+        client = factory.newHazelcastClient();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testGetSystemPropertiesMessageTask_passing() throws Exception {\n+        HazelcastInstance client = factory.newHazelcastClient(new ClientConfig(), \"222.222.222.222\");\n+        HazelcastClientInstanceImpl clientImpl = ((HazelcastClientProxy) client).client;\n+        ClientInvocation invocation = new ClientInvocation(\n+                clientImpl,\n+                MCGetSystemPropertiesCodec.encodeRequest(),\n+                null\n+        );\n+\n+        ClientDelegatingFuture<MCGetSystemPropertiesCodec.ResponseParameters> future = new ClientDelegatingFuture<>(\n+                invocation.invoke(),\n+                clientImpl.getSerializationService(),\n+                MCGetSystemPropertiesCodec::decodeResponse\n+        );\n+\n+        MCGetSystemPropertiesCodec.ResponseParameters response = future.get(ASSERT_TRUE_EVENTUALLY_TIMEOUT, SECONDS);\n+        assertFalse(response.systemProperties.isEmpty());\n+    }\n+\n+\n+    @Test\n+    public void testAddWanBatchPublisherConfigMessageTask() throws Exception {\n+        Random random = new Random();\n+\n+        ClientMessage clientMessage = MCAddWanBatchPublisherConfigCodec.encodeRequest(randomString(), randomString(),\n+                randomString(), randomString(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(),\n+                random.nextInt(), random.nextInt());\n+\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    @Test\n+    public void testApplyMCConfigMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCApplyMCConfigCodec.encodeRequest(randomString(), 999, new ArrayList<>()));\n+    }\n+\n+    @Test\n+    public void testChangeClusterStateMessageTask() throws Exception {\n+        ClientMessage clientMessage = MCChangeClusterStateCodec.encodeRequest(888);\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    @Test\n+    public void testChangeClusterVersionMessageTask() throws Exception {\n+        ClientMessage clientMessage = MCChangeClusterVersionCodec.encodeRequest((byte) 8, (byte) 10);\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    @Test\n+    public void testChangeWanReplicationStateMessageTask() throws Exception {\n+        ClientMessage clientMessage = MCChangeWanReplicationStateCodec.encodeRequest(randomString(), randomString(),\n+                (byte) 127);\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    @Test\n+    public void testCheckWanConsistencyMessageTask() throws Exception {\n+        ClientMessage clientMessage = MCCheckWanConsistencyCodec.encodeRequest(randomString(), randomString(), randomString());\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    @Test\n+    public void testClearWanQueuesMessageTask() throws Exception {\n+        ClientMessage clientMessage = MCClearWanQueuesCodec.encodeRequest(randomString(), randomString());\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    @Test\n+    public void testGetClusterMetadataMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetClusterMetadataCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testGetCPMembersMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetCPMembersCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testGetMapConfigMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetMapConfigCodec.encodeRequest(randomString()));\n+    }\n+\n+    @Test\n+    public void testGetMemberConfigMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetMemberConfigCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testGetSystemPropertiesMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetSystemPropertiesCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testGetThreadDumpMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetThreadDumpCodec.encodeRequest(false));\n+    }\n+\n+    @Test\n+    public void testGetTimedMemberStateMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCGetTimedMemberStateCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testHotRestartInterruptBackupMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCInterruptHotRestartBackupCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testHotRestartTriggerBackupMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCTriggerHotRestartBackupCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testHotRestartTriggerForceStartMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCTriggerForceStartCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testHotRestartTriggerPartialStartMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCTriggerPartialStartCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testMatchMCConfigMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCMatchMCConfigCodec.encodeRequest(randomString()));\n+    }\n+\n+    @Test\n+    public void testPollMCEventsMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCPollMCEventsCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testPromoteLiteMemberMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCPromoteLiteMemberCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testPromoteToCPMemberMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCPromoteToCPMemberCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testRemoveCPMemberMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCRemoveCPMemberCodec.encodeRequest(UUID.randomUUID()));\n+    }\n+\n+    @Test\n+    public void testResetCPSubsystemMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCResetCPSubsystemCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testRunConsoleCommandMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCRunConsoleCommandCodec.encodeRequest(randomString(), \"help\"));\n+    }\n+\n+    @Test\n+    public void testRunGCMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCRunGcCodec.encodeRequest());\n+    }\n+\n+    @Test\n+    public void testRunScriptMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCRunScriptCodec.encodeRequest(randomString(), randomString()));\n+    }\n+\n+    @Test\n+    public void testShutdownClusterMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCShutdownClusterCodec.encodeRequest());\n+        assertTrue(member.getLifecycleService().isRunning());\n+    }\n+\n+    @Test\n+    public void testShutdownMemberMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCShutdownMemberCodec.encodeRequest());\n+        assertTrue(member.getLifecycleService().isRunning());\n+    }\n+\n+    @Test\n+    public void testUpdateMapConfigMessageTask() throws Exception {\n+        assertFailureOnUntrustedInterface(MCUpdateMapConfigCodec.encodeRequest(randomString(), 100, 200, 0, false, 100, 0));\n+    }\n+\n+    @Test\n+    public void testWanSyncMapMessageTask() throws Exception {\n+        ClientMessage clientMessage = MCWanSyncMapCodec.encodeRequest(randomString(), randomString(), 0, randomString());\n+        assertFailureOnUntrustedInterface(clientMessage);\n+    }\n+\n+    private void assertFailureOnUntrustedInterface(ClientMessage clientMessage) throws Exception {\n+        ClientInvocation invocation = new ClientInvocation(((HazelcastClientProxy) client).client, clientMessage, null);\n+        ClientInvocationFuture future = invocation.invoke();\n+        try {\n+            future.get(ASSERT_TRUE_EVENTUALLY_TIMEOUT, SECONDS);\n+            fail(\"AuthenticationException was expected.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fb25bddd9bf5a83cc81e436de06bf28867b346"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4MDUwMg==", "bodyText": "Looks like a test for MCReadMetricsCodec is missing in this test.", "url": "https://github.com/hazelcast/hazelcast/pull/16779#discussion_r395480502", "createdAt": "2020-03-20T07:58:57Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/management/MCTrustedInterfacesTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.management;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import com.hazelcast.client.AuthenticationException;\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.clientside.HazelcastClientProxy;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.MCAddWanBatchPublisherConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCApplyMCConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCChangeClusterStateCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCChangeClusterVersionCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCChangeWanReplicationStateCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCCheckWanConsistencyCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCClearWanQueuesCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetCPMembersCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetClusterMetadataCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetMapConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetMemberConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetSystemPropertiesCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetThreadDumpCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCGetTimedMemberStateCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCInterruptHotRestartBackupCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCMatchMCConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCPollMCEventsCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCPromoteLiteMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCPromoteToCPMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRemoveCPMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCResetCPSubsystemCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRunConsoleCommandCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRunGcCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCRunScriptCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCShutdownClusterCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCShutdownMemberCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCTriggerForceStartCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCTriggerHotRestartBackupCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCTriggerPartialStartCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCUpdateMapConfigCodec;\n+import com.hazelcast.client.impl.protocol.codec.MCWanSyncMapCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({ QuickTest.class, ParallelJVMTest.class })\n+public class MCTrustedInterfacesTest extends HazelcastTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fb25bddd9bf5a83cc81e436de06bf28867b346"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "850687bddf63eff2370250894f925e74851bfde5", "author": {"user": {"login": "kwart", "name": "Josef Cacek"}}, "url": "https://github.com/hazelcast/hazelcast/commit/850687bddf63eff2370250894f925e74851bfde5", "committedDate": "2020-03-20T08:21:28Z", "message": "cover comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTI5MjM4", "url": "https://github.com/hazelcast/hazelcast/pull/16779#pullrequestreview-378529238", "createdAt": "2020-03-20T14:26:34Z", "commit": {"oid": "850687bddf63eff2370250894f925e74851bfde5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3894, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}