{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxNjE3MTU5", "number": 17713, "title": "Add migration listener on client", "bodyText": "Closes #16260", "createdAt": "2020-10-12T14:31:23Z", "url": "https://github.com/hazelcast/hazelcast/pull/17713", "merged": true, "mergeCommit": {"oid": "e7d89f1b29ca67b8d129249c46c4ac413efc34c0"}, "closed": true, "closedAt": "2020-11-06T17:37:48Z", "author": {"login": "peterjot"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdR45gxgBqjM4Njc5NjEzNjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZ6iYDgFqTUyNTM2MDY4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a5b61ee54d8c6b5eed0450070bac9997f320e8f", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3a5b61ee54d8c6b5eed0450070bac9997f320e8f", "committedDate": "2020-10-06T23:03:40Z", "message": "implement add migration listener task"}, "afterCommit": {"oid": "e2a00694597c8e9258a5b988bef8f471034f304e", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e2a00694597c8e9258a5b988bef8f471034f304e", "committedDate": "2020-10-12T19:11:02Z", "message": "regenerate protocol"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d86b7548f60fb14c22fed775c3b3bc62dde7797e", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d86b7548f60fb14c22fed775c3b3bc62dde7797e", "committedDate": "2020-10-22T19:15:54Z", "message": "Add Migration State event"}, "afterCommit": {"oid": "1a347f2bf214e26aa5f35edadfbd99e410bbad5a", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1a347f2bf214e26aa5f35edadfbd99e410bbad5a", "committedDate": "2020-10-22T21:29:46Z", "message": "Test Migration Listener registration and remove"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a347f2bf214e26aa5f35edadfbd99e410bbad5a", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1a347f2bf214e26aa5f35edadfbd99e410bbad5a", "committedDate": "2020-10-22T21:29:46Z", "message": "Test Migration Listener registration and remove"}, "afterCommit": {"oid": "e16007ac5d0b7043cb1505b3b1181e3a5209d8e1", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e16007ac5d0b7043cb1505b3b1181e3a5209d8e1", "committedDate": "2020-10-28T19:45:28Z", "message": "Add Migration Listener on the client"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzAyOTU1", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-520702955", "createdAt": "2020-10-30T14:08:10Z", "commit": {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDowODoxMVrOHrQtCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDowODoxMVrOHrQtCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEyNDQ4OQ==", "bodyText": "No need to create new MigrationStateImpl object. We can pass event.getMigrationState to encode.. method", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515124489", "createdAt": "2020-10-30T14:08:11Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientAddMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_FINISHED;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_STARTED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+\n+public class AddMigrationListenerMessageTask\n+        extends AbstractAddListenerMessageTask<Boolean> {\n+\n+    public AddMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected CompletableFuture<UUID> processInternal() {\n+        IPartitionService partitionService = getService(getServiceName());\n+\n+        MigrationListener listener = createMigrationListener();\n+\n+        if (parameters) {\n+            return newCompletedFuture(partitionService.addLocalMigrationListener(listener));\n+        }\n+\n+        return partitionService.addMigrationListenerAsync(listener);\n+    }\n+\n+    private MigrationListener createMigrationListener() {\n+        return new MigrationListener() {\n+\n+                @Override\n+                public void migrationStarted(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_STARTED));\n+                }\n+\n+                @Override\n+                public void migrationFinished(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_FINISHED));\n+                }\n+\n+                @Override\n+                public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+\n+                @Override\n+                public void replicaMigrationFailed(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+            };\n+    }\n+\n+    private void sendIfAlive(ClientMessage eventMessage) {\n+        if (endpoint.isAlive()) {\n+            sendClientMessage(MIGRATION_EVENT_TOPIC_ORDER_KEY, eventMessage);\n+        }\n+    }\n+\n+    private ClientMessage encodeReplicaMigrationEvent(ReplicaMigrationEvent event) {\n+        return ClientAddMigrationListenerCodec.encodeReplicaMigrationEvent(\n+                new MigrationStateImpl(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzAzMDgz", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-520703083", "createdAt": "2020-10-30T14:08:17Z", "commit": {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDowODoxN1rOHrQtVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDowODoxN1rOHrQtVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEyNDU2NA==", "bodyText": "No need to create new MigrationStateImpl object. We can pass event.getMigrationState to encode.. method", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515124564", "createdAt": "2020-10-30T14:08:17Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientAddMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_FINISHED;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_STARTED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+\n+public class AddMigrationListenerMessageTask\n+        extends AbstractAddListenerMessageTask<Boolean> {\n+\n+    public AddMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected CompletableFuture<UUID> processInternal() {\n+        IPartitionService partitionService = getService(getServiceName());\n+\n+        MigrationListener listener = createMigrationListener();\n+\n+        if (parameters) {\n+            return newCompletedFuture(partitionService.addLocalMigrationListener(listener));\n+        }\n+\n+        return partitionService.addMigrationListenerAsync(listener);\n+    }\n+\n+    private MigrationListener createMigrationListener() {\n+        return new MigrationListener() {\n+\n+                @Override\n+                public void migrationStarted(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_STARTED));\n+                }\n+\n+                @Override\n+                public void migrationFinished(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_FINISHED));\n+                }\n+\n+                @Override\n+                public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+\n+                @Override\n+                public void replicaMigrationFailed(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+            };\n+    }\n+\n+    private void sendIfAlive(ClientMessage eventMessage) {\n+        if (endpoint.isAlive()) {\n+            sendClientMessage(MIGRATION_EVENT_TOPIC_ORDER_KEY, eventMessage);\n+        }\n+    }\n+\n+    private ClientMessage encodeReplicaMigrationEvent(ReplicaMigrationEvent event) {\n+        return ClientAddMigrationListenerCodec.encodeReplicaMigrationEvent(\n+                new MigrationStateImpl(\n+                        event.getMigrationState().getStartTime(),\n+                        event.getMigrationState().getPlannedMigrations(),\n+                        event.getMigrationState().getCompletedMigrations(),\n+                        event.getMigrationState().getTotalElapsedTime()\n+                ),\n+                event.getPartitionId(),\n+                event.getReplicaIndex(),\n+                event.getSource() != null ? event.getSource().getUuid() : null,\n+                event.getDestination() != null ? event.getDestination().getUuid() : null,\n+                event.isSuccess(),\n+                event.getElapsedTime()\n+        );\n+    }\n+\n+    private ClientMessage encodeMigrationEvent(MigrationState event, int partitionId) {\n+        return ClientAddMigrationListenerCodec.encodeMigrationEvent(\n+                new MigrationStateImpl(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f143bc5426b6a6b36566bbd022911f6628fef02", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6f143bc5426b6a6b36566bbd022911f6628fef02", "committedDate": "2020-10-30T15:32:31Z", "message": "Add Migration Listener on the client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdfec61bc81d797d53e7ab2b322e19577e13474a", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bdfec61bc81d797d53e7ab2b322e19577e13474a", "committedDate": "2020-10-30T15:32:32Z", "message": "Fix sending migration event order to the client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c79ff0cd62341b535022a1cab056c92014134c86", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c79ff0cd62341b535022a1cab056c92014134c86", "committedDate": "2020-10-30T15:32:32Z", "message": "Avoid creating MigrationStateImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "048d48b66c0e99405fbf12fe18c6dc454826f408", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/048d48b66c0e99405fbf12fe18c6dc454826f408", "committedDate": "2020-10-30T15:35:37Z", "message": "MigrationListener since 2.2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/de33c992210703192e02d52ab7fd2d13de62ce27", "committedDate": "2020-10-30T17:00:10Z", "message": "Introduce migration event type to the protocol"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b993c924545a9c1e784122ceb8d0d9af47664213", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b993c924545a9c1e784122ceb8d0d9af47664213", "committedDate": "2020-10-30T14:27:12Z", "message": "Avoid creating MigrationStateImpl"}, "afterCommit": {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/048a9fe4362fa1bd511fc376c8c38d52266603b0", "committedDate": "2020-10-29T20:41:14Z", "message": "Fix sending migration event order to the client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/048a9fe4362fa1bd511fc376c8c38d52266603b0", "committedDate": "2020-10-29T20:41:14Z", "message": "Fix sending migration event order to the client"}, "afterCommit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/de33c992210703192e02d52ab7fd2d13de62ce27", "committedDate": "2020-10-30T17:00:10Z", "message": "Introduce migration event type to the protocol"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTE5MTg5", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-521519189", "createdAt": "2020-11-02T10:47:33Z", "commit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDo0NzozM1rOHr_QBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDo0NzozM1rOHr_QBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NzExMA==", "bodyText": "Hi @peterjot\nI have just realized the reason for using the partition id here. I did not know that we are using negative values of partition id as the event type. I have internally opened up this issue with the team. And we decided that in the client protocol we want to separate the event type from the partition id. So we are on the right track.\nIf I am not mistaken, we should not need to check the partition id anymore in this path, since we already made sure on the server we will not see Migration_started -1 and migration finished -2 on the partition id's.\nWhen you remove that this class will be fairly small. Can you remove this class and move the logic to\nPartitionServiceProxy. I think we don't need a new class and redirection for a couple of lines anymore.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515887110", "createdAt": "2020-11-02T10:47:33Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.partition;\n+\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+public final class MigrationEventHandler {\n+\n+    public static final int MIGRATION_STARTED_PARTITION_ID = -1;\n+    public static final int MIGRATION_FINISHED_PARTITION_ID = -2;\n+\n+    private final MigrationListener migrationListener;\n+\n+    public MigrationEventHandler(MigrationListener migrationListener) {\n+        this.migrationListener = migrationListener;\n+    }\n+\n+    public void handleMigrationEvent(MigrationState state, MigrationEventType type) {\n+        switch (type) {\n+            case MIGRATION_STARTED:\n+                migrationListener.migrationStarted(state);\n+                break;\n+            case MIGRATION_FINISHED:\n+                migrationListener.migrationFinished(state);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid event type: \" + type);\n+        }\n+    }\n+\n+    public void handleReplicaMigrationEvent(ReplicaMigrationEvent event) {\n+        switch (event.getPartitionId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTI0MDQx", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-521524041", "createdAt": "2020-11-02T10:54:13Z", "commit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDo1NDoxM1rOHr_fGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDo1NDoxM1rOHr_fGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MDk3MQ==", "bodyText": "Leaving the default state empty make much more sense if you think about future extensions. Let's say this client connected to a new server, which has a new migration event type. Old clients should not throw an exception or log something aggressively because it is expected and old clients should just ignore it.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515890971", "createdAt": "2020-11-02T10:54:13Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.partition;\n+\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+public final class MigrationEventHandler {\n+\n+    public static final int MIGRATION_STARTED_PARTITION_ID = -1;\n+    public static final int MIGRATION_FINISHED_PARTITION_ID = -2;\n+\n+    private final MigrationListener migrationListener;\n+\n+    public MigrationEventHandler(MigrationListener migrationListener) {\n+        this.migrationListener = migrationListener;\n+    }\n+\n+    public void handleMigrationEvent(MigrationState state, MigrationEventType type) {\n+        switch (type) {\n+            case MIGRATION_STARTED:\n+                migrationListener.migrationStarted(state);\n+                break;\n+            case MIGRATION_FINISHED:\n+                migrationListener.migrationFinished(state);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid event type: \" + type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTMzNzg3", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-521533787", "createdAt": "2020-11-02T11:08:13Z", "commit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTowODoxM1rOHr_86Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTowODoxM1rOHr_86Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5ODYwMQ==", "bodyText": "I am not really sure about this but, I think,  MigrationEventType class is not necessary. We are using enum classes like this when we want to expose them to the API. In this case, an static int on MessageTask/PartitionServiceProxy could do the job as well.\nEven if this stays, it should be moved to the client package as this is a specific type for client only.\nMore specifically com.hazelcast.client.impl should be ok.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515898601", "createdAt": "2020-11-02T11:08:13Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.partition;\n+\n+\n+/**\n+ * Migration event types.\n+ * @see MigrationEventHandler\n+ */\n+public enum MigrationEventType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c89af2737b19817c43a3755d70a81ef1aad7960d", "committedDate": "2020-11-02T12:31:10Z", "message": "Remove MigrationEventHandler and MigrationEventType"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNjAzMjYy", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-521603262", "createdAt": "2020-11-02T12:57:41Z", "commit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MTY0NDQ2", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-524164446", "createdAt": "2020-11-05T11:23:08Z", "commit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMToyMzowOFrOHt-2BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMTo1ODo0N1rOHuAEDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzYwNQ==", "bodyText": "nit: should use IPartitionService.SERVICE_NAME", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517977605", "createdAt": "2020-11-05T11:23:08Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.InternalPartitionService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+public class RemoveMigrationListenerMessageTask\n+        extends AbstractRemoveListenerMessageTask<UUID> {\n+\n+    public RemoveMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Future<Boolean> deRegisterListener() {\n+        InternalPartitionService service = getService(InternalPartitionService.SERVICE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzY1Mw==", "bodyText": "nit: should use IPartitionService.SERVICE_NAME", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517977653", "createdAt": "2020-11-05T11:23:15Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.InternalPartitionService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+public class RemoveMigrationListenerMessageTask\n+        extends AbstractRemoveListenerMessageTask<UUID> {\n+\n+    public RemoveMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Future<Boolean> deRegisterListener() {\n+        InternalPartitionService service = getService(InternalPartitionService.SERVICE_NAME);\n+        return service.removeMigrationListenerAsync(parameters);\n+    }\n+\n+    @Override\n+    protected UUID getRegistrationId() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    protected UUID decodeClientMessage(ClientMessage clientMessage) {\n+        return ClientRemoveMigrationListenerCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        return ClientRemoveMigrationListenerCodec.encodeResponse((Boolean) response);\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return InternalPartitionService.SERVICE_NAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3OTc1OQ==", "bodyText": "A potentially stupid question for @sancar. Why don't we specify InternalPartitionService.MIGRATION_EVENT_TOPIC here, like we do it in AddMigrationListenerMessageTask? This way SecurityContext interceptor won't be able to handle (and potentially reject) the remove listener operation. Or I'm missing something and there is a reason to have it this way?", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517979759", "createdAt": "2020-11-05T11:27:01Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.InternalPartitionService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+public class RemoveMigrationListenerMessageTask\n+        extends AbstractRemoveListenerMessageTask<UUID> {\n+\n+    public RemoveMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Future<Boolean> deRegisterListener() {\n+        InternalPartitionService service = getService(InternalPartitionService.SERVICE_NAME);\n+        return service.removeMigrationListenerAsync(parameters);\n+    }\n+\n+    @Override\n+    protected UUID getRegistrationId() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    protected UUID decodeClientMessage(ClientMessage clientMessage) {\n+        return ClientRemoveMigrationListenerCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        return ClientRemoveMigrationListenerCodec.encodeResponse((Boolean) response);\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return InternalPartitionService.SERVICE_NAME;\n+    }\n+\n+    @Override\n+    public Permission getRequiredPermission() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getDistributedObjectName() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4Mjk5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean removeMigrationListener(UUID registrationId) {\n          \n          \n            \n                public boolean removeMigrationListener(@Nonnull UUID registrationId) {", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517982997", "createdAt": "2020-11-05T11:32:44Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java", "diffHunk": "@@ -74,21 +84,51 @@ public Partition getPartition(@Nonnull Object key) {\n     }\n \n     @Override\n-    public UUID addMigrationListener(MigrationListener migrationListener) {\n-        throw new UnsupportedOperationException();\n+    public UUID addMigrationListener(@Nonnull MigrationListener migrationListener) {\n+        checkNotNull(migrationListener, \"migrationListener can't be null\");\n+        EventHandler<ClientMessage> handler = new ClientMigrationEventHandler(migrationListener);\n+        return listenerService.registerListener(createMigrationListenerCodec(), handler);\n     }\n \n     @Override\n     public boolean removeMigrationListener(UUID registrationId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4MzQxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean removePartitionLostListener(UUID registrationId) {\n          \n          \n            \n                public boolean removePartitionLostListener(@Nonnull UUID registrationId) {", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517983413", "createdAt": "2020-11-05T11:33:32Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java", "diffHunk": "@@ -74,21 +84,51 @@ public Partition getPartition(@Nonnull Object key) {\n     }\n \n     @Override\n-    public UUID addMigrationListener(MigrationListener migrationListener) {\n-        throw new UnsupportedOperationException();\n+    public UUID addMigrationListener(@Nonnull MigrationListener migrationListener) {\n+        checkNotNull(migrationListener, \"migrationListener can't be null\");\n+        EventHandler<ClientMessage> handler = new ClientMigrationEventHandler(migrationListener);\n+        return listenerService.registerListener(createMigrationListenerCodec(), handler);\n     }\n \n     @Override\n     public boolean removeMigrationListener(UUID registrationId) {\n-        throw new UnsupportedOperationException();\n+        checkNotNull(registrationId, \"registrationId can't be null\");\n+        return listenerService.deregisterListener(registrationId);\n     }\n \n     @Override\n-    public UUID addPartitionLostListener(PartitionLostListener partitionLostListener) {\n+    public UUID addPartitionLostListener(@Nonnull PartitionLostListener partitionLostListener) {\n+        checkNotNull(partitionLostListener, \"migrationListener can't be null\");\n         EventHandler<ClientMessage> handler = new ClientPartitionLostEventHandler(partitionLostListener);\n         return listenerService.registerListener(createPartitionLostListenerCodec(), handler);\n     }\n \n+    @Override\n+    public boolean removePartitionLostListener(UUID registrationId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4MzkxNw==", "bodyText": "nit: it would be nice to leave a comment on the no-op default case here", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517983917", "createdAt": "2020-11-05T11:34:26Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java", "diffHunk": "@@ -154,4 +193,52 @@ public void handlePartitionLostEvent(int partitionId, int lostBackupCount, UUID\n         }\n     }\n \n+    private class ClientMigrationEventHandler extends ClientAddMigrationListenerCodec.AbstractEventHandler\n+            implements EventHandler<ClientMessage> {\n+\n+        private final MigrationListener listener;\n+\n+        ClientMigrationEventHandler(MigrationListener listener) {\n+            this.listener = listener;\n+        }\n+\n+        @Override\n+        public void handleMigrationEvent(MigrationState migrationState, int type) {\n+            switch (type) {\n+                case MIGRATION_STARTED:\n+                    listener.migrationStarted(migrationState);\n+                    break;\n+                case MIGRATION_FINISHED:\n+                    listener.migrationFinished(migrationState);\n+                    break;\n+                default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5Mzk5OA==", "bodyText": "Shouldn't we call sendClientMessage(null, eventMessage); here? MIGRATION_EVENT_TOPIC_ORDER_KEY constant is not a partition id. @sancar WDYT?", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517993998", "createdAt": "2020-11-05T11:52:44Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientAddMigrationListenerCodec;\n+import com.hazelcast.client.impl.proxy.PartitionServiceProxy;\n+import com.hazelcast.cluster.Member;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+import javax.annotation.Nullable;\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+\n+public class AddMigrationListenerMessageTask\n+        extends AbstractAddListenerMessageTask<Boolean> {\n+\n+    public AddMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected CompletableFuture<UUID> processInternal() {\n+        IPartitionService partitionService = getService(getServiceName());\n+\n+        MigrationListener listener = createMigrationListener();\n+\n+        if (parameters) {\n+            return newCompletedFuture(partitionService.addLocalMigrationListener(listener));\n+        }\n+\n+        return partitionService.addMigrationListenerAsync(listener);\n+    }\n+\n+    private MigrationListener createMigrationListener() {\n+        return new MigrationListener() {\n+\n+                @Override\n+                public void migrationStarted(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, PartitionServiceProxy.MIGRATION_STARTED));\n+                }\n+\n+                @Override\n+                public void migrationFinished(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, PartitionServiceProxy.MIGRATION_FINISHED));\n+                }\n+\n+                @Override\n+                public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+\n+                @Override\n+                public void replicaMigrationFailed(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+            };\n+    }\n+\n+    private void sendIfAlive(ClientMessage eventMessage) {\n+        if (endpoint.isAlive()) {\n+            sendClientMessage(MIGRATION_EVENT_TOPIC_ORDER_KEY, eventMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzU4Mg==", "bodyText": "Another stupid question for @sancar. Why don't we use event.getPartitionId() instead of MIGRATION_EVENT_TOPIC_ORDER_KEY here?\nA side note. I don't really like this implicit logic based on hash code for event order key. We may easily run into collisions between different event types without even noticing it.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517997582", "createdAt": "2020-11-05T11:58:47Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionEventManager.java", "diffHunk": "@@ -79,25 +83,25 @@ public void sendMigrationEvent(MigrationState state, MigrationInfo migrationInfo\n     }\n \n     public void sendMigrationProcessStartedEvent(MigrationState state) {\n-        ReplicaMigrationEvent event = new ReplicaMigrationEventImpl(state, MIGRATION_STARTED, 0, null, null, false, 0L);\n+        ReplicaMigrationEvent event =\n+                new ReplicaMigrationEventImpl(state, MIGRATION_STARTED_PARTITION_ID, 0, null, null, false, 0L);\n         sendMigrationEvent(event);\n     }\n \n     public void sendMigrationProcessCompletedEvent(MigrationState state) {\n-        ReplicaMigrationEvent event = new ReplicaMigrationEventImpl(state, MIGRATION_FINISHED, 0, null, null, false, 0L);\n+        ReplicaMigrationEvent event =\n+                new ReplicaMigrationEventImpl(state, MIGRATION_FINISHED_PARTITION_ID, 0, null, null, false, 0L);\n         sendMigrationEvent(event);\n     }\n \n     private void sendMigrationEvent(ReplicaMigrationEvent event) {\n         EventService eventService = nodeEngine.getEventService();\n         // All migration events are sent in order.\n-        eventService.publishEvent(SERVICE_NAME, MIGRATION_EVENT_TOPIC, event, MIGRATION_EVENT_TOPIC.hashCode());\n+        eventService.publishEvent(SERVICE_NAME, MIGRATION_EVENT_TOPIC, event, MIGRATION_EVENT_TOPIC_ORDER_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "103713afa902578c349e669802e34ee504664ca6", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/103713afa902578c349e669802e34ee504664ca6", "committedDate": "2020-11-05T22:16:27Z", "message": "Send client message with key = null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "578c6dfd25d2338dbaf01a564c84ae96102442fc", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/578c6dfd25d2338dbaf01a564c84ae96102442fc", "committedDate": "2020-11-05T22:49:53Z", "message": "Use IPartitionService instead of InternalPartitionService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "912e4e51b22d47b603930b1ef0146cb6273020ef", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/912e4e51b22d47b603930b1ef0146cb6273020ef", "committedDate": "2020-11-05T22:52:12Z", "message": "Use IPartitionService instead of InternalPartitionService"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0OTA2MTE0", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-524906114", "createdAt": "2020-11-06T07:23:01Z", "commit": {"oid": "912e4e51b22d47b603930b1ef0146cb6273020ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cd91e2bc440a86a1f1a63660225851af8615943c", "committedDate": "2020-11-06T12:36:20Z", "message": "Send client message with key = MIGRATION_EVENT_TOPIC hash code and add a test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MTI1OTM4", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-525125938", "createdAt": "2020-11-06T12:57:33Z", "commit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo1NzozM1rOHutCOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo1NzozM1rOHutCOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNDM5Mw==", "bodyText": "nit: redundant new line.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518734393", "createdAt": "2020-11-06T12:57:33Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);\n+    }\n+\n+    private <T extends MigrationListener> void testMigrationListenerInvoked(T clientListener,\n+                                              Function<MigrationListener, HazelcastInstance> clientFactory,\n+                                              Consumer<T> assertFunction) {\n+\n+        HazelcastInstance instance1 = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = clientFactory.apply(clientListener);\n+        warmUpPartitions(instance1, client);\n+\n+        // Change to NO_MIGRATION to prevent repartitioning\n+        // before 2nd member started and ready.\n+        instance1.getCluster().changeClusterState(ClusterState.NO_MIGRATION);\n+\n+        HazelcastInstance instance2 = hazelcastFactory.newHazelcastInstance();\n+\n+        changeClusterStateEventually(instance2, ClusterState.ACTIVE);\n+        waitAllForSafeState(instance2, instance1, client);\n+\n+        assertRegistrationsSizeEventually(instance1, 1);\n+        assertFunction.accept(clientListener);\n+    }\n+\n+    private void verifyMigrationListenerNeverInvoked(MigrationListener listener) {\n+        verify(listener, never()).migrationStarted(any(MigrationStateImpl.class));\n+        verify(listener, never()).migrationFinished(any(MigrationStateImpl.class));\n+        verify(listener, never()).replicaMigrationCompleted(any(ReplicaMigrationEvent.class));\n+        verify(listener, never()).replicaMigrationFailed(any(ReplicaMigrationEvent.class));\n+    }\n+\n+    private void assertMigrationProcess(PartitionMigrationListenerTest.EventCollectingMigrationListener listener) {\n+        PartitionMigrationListenerTest.MigrationEventsPack eventsPack = listener.ensureAndGetSingleEventPack();\n+        assertMigrationProcessCompleted(eventsPack);\n+        assertMigrationProcessEventsConsistent(eventsPack);\n+        assertMigrationEventsConsistentWithResult(eventsPack);\n+    }\n+\n+    private PartitionMigrationListenerTest.EventCollectingMigrationListener eventCollectingMigrationListener() {\n+        return new PartitionMigrationListenerTest.EventCollectingMigrationListener();\n+    }\n+\n+    private void assertRegistrationsSizeEventually(HazelcastInstance instance, int size) {\n+        assertTrueEventually(() -> {\n+            EventService eventService = getNode(instance).getNodeEngine().getEventService();\n+            Collection<EventRegistration> registrations = eventService\n+                    .getRegistrations(SERVICE_NAME, MIGRATION_EVENT_TOPIC);\n+            assertEquals(size, registrations.size());\n+        });\n+    }\n+\n+    static class SingleThreadMigrationListener implements MigrationListener {\n+\n+        private String threadName;\n+        private boolean finished = false;\n+\n+        @Override\n+        public void migrationStarted(MigrationState state) {\n+            assertNull(threadName);\n+            threadName = Thread.currentThread().getName();\n+        }\n+\n+        @Override\n+        public void migrationFinished(MigrationState state) {\n+            assertNotNull(threadName);\n+            assertEquals(threadName, Thread.currentThread().getName());\n+            finished = true;\n+        }\n+\n+        @Override\n+        public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+            assertNotNull(threadName);\n+            assertEquals(threadName, Thread.currentThread().getName());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MTI3MDgw", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-525127080", "createdAt": "2020-11-06T12:59:10Z", "commit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo1OToxMFrOHutFMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo1OToxMFrOHutFMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNTE1Mw==", "bodyText": "This field should be volatile.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518735153", "createdAt": "2020-11-06T12:59:10Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);\n+    }\n+\n+    private <T extends MigrationListener> void testMigrationListenerInvoked(T clientListener,\n+                                              Function<MigrationListener, HazelcastInstance> clientFactory,\n+                                              Consumer<T> assertFunction) {\n+\n+        HazelcastInstance instance1 = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = clientFactory.apply(clientListener);\n+        warmUpPartitions(instance1, client);\n+\n+        // Change to NO_MIGRATION to prevent repartitioning\n+        // before 2nd member started and ready.\n+        instance1.getCluster().changeClusterState(ClusterState.NO_MIGRATION);\n+\n+        HazelcastInstance instance2 = hazelcastFactory.newHazelcastInstance();\n+\n+        changeClusterStateEventually(instance2, ClusterState.ACTIVE);\n+        waitAllForSafeState(instance2, instance1, client);\n+\n+        assertRegistrationsSizeEventually(instance1, 1);\n+        assertFunction.accept(clientListener);\n+    }\n+\n+    private void verifyMigrationListenerNeverInvoked(MigrationListener listener) {\n+        verify(listener, never()).migrationStarted(any(MigrationStateImpl.class));\n+        verify(listener, never()).migrationFinished(any(MigrationStateImpl.class));\n+        verify(listener, never()).replicaMigrationCompleted(any(ReplicaMigrationEvent.class));\n+        verify(listener, never()).replicaMigrationFailed(any(ReplicaMigrationEvent.class));\n+    }\n+\n+    private void assertMigrationProcess(PartitionMigrationListenerTest.EventCollectingMigrationListener listener) {\n+        PartitionMigrationListenerTest.MigrationEventsPack eventsPack = listener.ensureAndGetSingleEventPack();\n+        assertMigrationProcessCompleted(eventsPack);\n+        assertMigrationProcessEventsConsistent(eventsPack);\n+        assertMigrationEventsConsistentWithResult(eventsPack);\n+    }\n+\n+    private PartitionMigrationListenerTest.EventCollectingMigrationListener eventCollectingMigrationListener() {\n+        return new PartitionMigrationListenerTest.EventCollectingMigrationListener();\n+    }\n+\n+    private void assertRegistrationsSizeEventually(HazelcastInstance instance, int size) {\n+        assertTrueEventually(() -> {\n+            EventService eventService = getNode(instance).getNodeEngine().getEventService();\n+            Collection<EventRegistration> registrations = eventService\n+                    .getRegistrations(SERVICE_NAME, MIGRATION_EVENT_TOPIC);\n+            assertEquals(size, registrations.size());\n+        });\n+    }\n+\n+    static class SingleThreadMigrationListener implements MigrationListener {\n+\n+        private String threadName;\n+        private boolean finished = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "originalPosition": 237}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MTI5MDY0", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-525129064", "createdAt": "2020-11-06T13:02:00Z", "commit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowMjowMFrOHutLCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowMjowMFrOHutLCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNjY1MA==", "bodyText": "This line exceeds 130 chars.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518736650", "createdAt": "2020-11-06T13:02:00Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MTMzNTMw", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-525133530", "createdAt": "2020-11-06T13:08:40Z", "commit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowODo0MFrOHutXxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowODo0MFrOHutXxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczOTkwOQ==", "bodyText": "This and other asserts in this and replicaMigrationFailed methods don't affect the test result, i.e. if we change this line to assertNull(threadName);, the test still passes. Maybe, it's a good idea to introduce another boolean field which will be changed to false when the listener is invoked on a different thread. Then this field could be checked in assertAllMethodsInvokedOnTheSameThread method.", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518739909", "createdAt": "2020-11-06T13:08:40Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);\n+    }\n+\n+    private <T extends MigrationListener> void testMigrationListenerInvoked(T clientListener,\n+                                              Function<MigrationListener, HazelcastInstance> clientFactory,\n+                                              Consumer<T> assertFunction) {\n+\n+        HazelcastInstance instance1 = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = clientFactory.apply(clientListener);\n+        warmUpPartitions(instance1, client);\n+\n+        // Change to NO_MIGRATION to prevent repartitioning\n+        // before 2nd member started and ready.\n+        instance1.getCluster().changeClusterState(ClusterState.NO_MIGRATION);\n+\n+        HazelcastInstance instance2 = hazelcastFactory.newHazelcastInstance();\n+\n+        changeClusterStateEventually(instance2, ClusterState.ACTIVE);\n+        waitAllForSafeState(instance2, instance1, client);\n+\n+        assertRegistrationsSizeEventually(instance1, 1);\n+        assertFunction.accept(clientListener);\n+    }\n+\n+    private void verifyMigrationListenerNeverInvoked(MigrationListener listener) {\n+        verify(listener, never()).migrationStarted(any(MigrationStateImpl.class));\n+        verify(listener, never()).migrationFinished(any(MigrationStateImpl.class));\n+        verify(listener, never()).replicaMigrationCompleted(any(ReplicaMigrationEvent.class));\n+        verify(listener, never()).replicaMigrationFailed(any(ReplicaMigrationEvent.class));\n+    }\n+\n+    private void assertMigrationProcess(PartitionMigrationListenerTest.EventCollectingMigrationListener listener) {\n+        PartitionMigrationListenerTest.MigrationEventsPack eventsPack = listener.ensureAndGetSingleEventPack();\n+        assertMigrationProcessCompleted(eventsPack);\n+        assertMigrationProcessEventsConsistent(eventsPack);\n+        assertMigrationEventsConsistentWithResult(eventsPack);\n+    }\n+\n+    private PartitionMigrationListenerTest.EventCollectingMigrationListener eventCollectingMigrationListener() {\n+        return new PartitionMigrationListenerTest.EventCollectingMigrationListener();\n+    }\n+\n+    private void assertRegistrationsSizeEventually(HazelcastInstance instance, int size) {\n+        assertTrueEventually(() -> {\n+            EventService eventService = getNode(instance).getNodeEngine().getEventService();\n+            Collection<EventRegistration> registrations = eventService\n+                    .getRegistrations(SERVICE_NAME, MIGRATION_EVENT_TOPIC);\n+            assertEquals(size, registrations.size());\n+        });\n+    }\n+\n+    static class SingleThreadMigrationListener implements MigrationListener {\n+\n+        private String threadName;\n+        private boolean finished = false;\n+\n+        @Override\n+        public void migrationStarted(MigrationState state) {\n+            assertNull(threadName);\n+            threadName = Thread.currentThread().getName();\n+        }\n+\n+        @Override\n+        public void migrationFinished(MigrationState state) {\n+            assertNotNull(threadName);\n+            assertEquals(threadName, Thread.currentThread().getName());\n+            finished = true;\n+        }\n+\n+        @Override\n+        public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+            assertNotNull(threadName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c"}, "originalPosition": 254}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "032c8a972565a6b9fa7de69900508c902a68a854", "author": {"user": {"login": "peterjot", "name": "Piotr Jasina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/032c8a972565a6b9fa7de69900508c902a68a854", "committedDate": "2020-11-06T15:04:03Z", "message": "Test migration listener invoked on a single thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzYwNjg4", "url": "https://github.com/hazelcast/hazelcast/pull/17713#pullrequestreview-525360688", "createdAt": "2020-11-06T17:37:23Z", "commit": {"oid": "032c8a972565a6b9fa7de69900508c902a68a854"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3255, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}