{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MjUyOTEw", "number": 16736, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo1ODo0OFrODnHNag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjoxOTo0NFrODp2LGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzM5MTc4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/Immutable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo1ODo0OFrOF060cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo1ODo0OFrOF060cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMzk2OA==", "bodyText": "Needs javadoc. You can check out this PR for inspiration - #11479", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391033968", "createdAt": "2020-03-11T14:58:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/Immutable.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.hazelcast.map;\n+\n+public interface Immutable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQwODUxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMjoyMFrOF06-8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMjoyMFrOF06-8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNjY1OQ==", "bodyText": "Why do you need to cast here?", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391036659", "createdAt": "2020-03-11T15:02:20Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "diffHunk": "@@ -170,11 +170,14 @@ public MapKeysWithCursor fetchKeys(int tableIndex, int size) {\n     public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {\n         List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n-        List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());\n+        List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = entry.getValue();\n-            Data dataValue = serializationService.toData(record.getValue());\n-            entriesData.add(new AbstractMap.SimpleEntry<Data, Data>(entry.getKey(), dataValue));\n+            R record = (R)(Record)entry.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQxMjkxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMzoxN1rOF07Bww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMzoxN1rOF07Bww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNzM3OQ==", "bodyText": "No need to cast to Data. Also, add generics to remove the type warning - new AbstractMap.SimpleEntry<Data, Object>.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391037379", "createdAt": "2020-03-11T15:03:17Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "diffHunk": "@@ -170,11 +170,14 @@ public MapKeysWithCursor fetchKeys(int tableIndex, int size) {\n     public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {\n         List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n-        List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());\n+        List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = entry.getValue();\n-            Data dataValue = serializationService.toData(record.getValue());\n-            entriesData.add(new AbstractMap.SimpleEntry<Data, Data>(entry.getKey(), dataValue));\n+            R record = (R)(Record)entry.getValue();\n+            Object value = record.getValue();\n+            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?\n+                    value :\n+                    serializationService.toData(value);\n+            entriesData.add(new AbstractMap.SimpleEntry((Data)entry.getKey(), dataValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQxNTIxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMzo0NVrOF07DNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMzo0NVrOF07DNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNzc0OA==", "bodyText": "You can import this to avoid the fully-qualified class name. You can also change the variable name since this is no longer dataValue.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391037748", "createdAt": "2020-03-11T15:03:45Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "diffHunk": "@@ -170,11 +170,14 @@ public MapKeysWithCursor fetchKeys(int tableIndex, int size) {\n     public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {\n         List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n-        List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());\n+        List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = entry.getValue();\n-            Data dataValue = serializationService.toData(record.getValue());\n-            entriesData.add(new AbstractMap.SimpleEntry<Data, Data>(entry.getKey(), dataValue));\n+            R record = (R)(Record)entry.getValue();\n+            Object value = record.getValue();\n+            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQ0NDQ0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMDoyNVrOF07WMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMDoyNVrOF07WMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MjYxMQ==", "bodyText": "No need to cast here.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391042611", "createdAt": "2020-03-11T15:10:25Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java", "diffHunk": "@@ -33,26 +33,31 @@\n  *\n  * @see com.hazelcast.map.impl.proxy.MapProxyImpl#iterator\n  */\n-public class MapEntriesWithCursor extends AbstractCursor<Map.Entry<Data, Data>> {\n+public class MapEntriesWithCursor extends AbstractCursor<Map.Entry<Data, Object>> {\n \n     public MapEntriesWithCursor() {\n     }\n \n-    public MapEntriesWithCursor(List<Map.Entry<Data, Data>> entries, int nextTableIndexToReadFrom) {\n+    public MapEntriesWithCursor(List<Map.Entry<Data, Object>> entries, int nextTableIndexToReadFrom) {\n         super(entries, nextTableIndexToReadFrom);\n     }\n \n     @Override\n-    void writeElement(ObjectDataOutput out, Entry<Data, Data> entry) throws IOException {\n-        out.writeData(entry.getKey());\n-        out.writeData(entry.getValue());\n+    void writeElement(ObjectDataOutput out, Entry<Data, Object> entry) throws IOException {\n+        out.writeData((Data)entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQ1MTQwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMjowMlrOF07a0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMjowMlrOF07a0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0Mzc5NA==", "bodyText": "You can replace the full class name with an import.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391043794", "createdAt": "2020-03-11T15:12:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -25,20 +25,20 @@\n \n public final class GetOperation extends ReadonlyKeyBasedMapOperation implements BlockingOperation {\n \n-    private Data result;\n+    private Object result;\n \n     public GetOperation() {\n     }\n \n     public GetOperation(String name, Data dataKey) {\n         super(name, dataKey);\n-\n         this.dataKey = dataKey;\n     }\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object value = this.recordStore.get(this.dataKey, false, getCallerAddress());\n+        this.result = (value instanceof com.hazelcast.map.Immutable) ? value : this.mapServiceContext.toData(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQ1MzkwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMjozOFrOF07cgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMjozOFrOF07cgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0NDIyNg==", "bodyText": "No need for this. prefixes here and in line below.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391044226", "createdAt": "2020-03-11T15:12:38Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -25,20 +25,20 @@\n \n public final class GetOperation extends ReadonlyKeyBasedMapOperation implements BlockingOperation {\n \n-    private Data result;\n+    private Object result;\n \n     public GetOperation() {\n     }\n \n     public GetOperation(String name, Data dataKey) {\n         super(name, dataKey);\n-\n         this.dataKey = dataKey;\n     }\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object value = this.recordStore.get(this.dataKey, false, getCallerAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzQ4MTAwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxODo0MFrOF07t5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMDoyNzozMVrOF3WIcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA==", "bodyText": "I believe this will create a class cast exception when being used from the client. We're going to have to release this changed - https://github.com/hazelcast/hazelcast-client-protocol/blob/1.8.z/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/template/ResponseTemplate.java#L219-L225.\ncc @asimarslan @sancar", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391048678", "createdAt": "2020-03-11T15:18:40Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ1MDA4Ng==", "bodyText": "The casting here looks confusing but it will not cause any cast exception. So no need for any protocol change.\ngetBatch  methods always returns List<Map.Entry<Data, Data>> , it is just not clear from the method signature.\nI think the problem arises from usage of the generics on AbstractCursor. We are using the generic for both the stored object on construction, and also for the object that we read. Their types are actually different. I also don't see a strong reason for AbstractConstructor to know the type. Child classes can keep the reference themselves and override read,write methods so that AbstractConstructor does not know the type.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391450086", "createdAt": "2020-03-12T07:55:09Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2NTE2NA==", "bodyText": "I've modified the AbstractMapPartitionIteratorTest#test_HasNext_Returns_True_On_NonEmptyPartition test to use OBJECT in-memory format and to add Immutable objects as values to the map. This forces the issue and I've been able to get the exception:\njava.lang.ClassCastException: com.hazelcast.client.map.AbstractMapPartitionIteratorTest$Lala cannot be cast to com.hazelcast.nio.serialization.Data\n\n\tat com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec$ResponseParameters.calculateDataSize(MapFetchEntriesCodec.java:107)\n\tat com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec.encodeResponse(MapFetchEntriesCodec.java:119)\n\tat com.hazelcast.client.impl.protocol.task.map.MapFetchEntriesMessageTask.encodeResponse(MapFetchEntriesMessageTask.java:56)\n\tat com.hazelcast.client.impl.protocol.task.AbstractMessageTask.sendResponse(AbstractMessageTask.java:195)\n\tat com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.onResponse(AbstractPartitionMessageTask.java:89)\n\tat com.hazelcast.spi.impl.AbstractInvocationFuture$1.run(AbstractInvocationFuture.java:256)\n\tat com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.execute(AbstractPartitionMessageTask.java:78)\n\tat com.hazelcast.spi.impl.AbstractInvocationFuture.unblock(AbstractInvocationFuture.java:247)\n\tat com.hazelcast.spi.impl.AbstractInvocationFuture.andThen(AbstractInvocationFuture.java:223)\n\tat com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.processMessage(AbstractPartitionMessageTask.java:69)\n\tat com.hazelcast.client.impl.protocol.task.AbstractMessageTask.initializeAndProcessMessage(AbstractMessageTask.java:129)\n\tat com.hazelcast.client.impl.protocol.task.AbstractMessageTask.run(AbstractMessageTask.java:109)\n\tat com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:163)\n\tat com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:159)\n\tat com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:127)\n\tat com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.run(OperationThread.java:110)\n\nThis is because previously, MapEntriesWithCursor could only contain a list of serialized keys and values. The MapFetchEntriesCodec#encodeResponse method expects these to be Data to be able to calculate the data size and prepare the response. But now, due to the fact that we want to avoid having extra copies on reads, the MapEntriesWithCursor can also contain references to actual user objects in some cases, which is why it contains a list of Map.Entry<Data, Object>. In some cases, the value will be Data and in other cases it will be the user object. But now MapFetchEntriesCodec#encodeResponse fails to prepare the response in cases where the value is not serialised. The same issue is in the EE repo.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391665164", "createdAt": "2020-03-12T14:36:34Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5MTY1OQ==", "bodyText": "I don't  know why but I was thinking that AbstractCursor will always come from remote.\nIn that case, we need to convert to proper type before passing to encodeResponse.\nProbably in MapFetchEntriesMessageTask.encodeResponse  code.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391691659", "createdAt": "2020-03-12T15:14:27Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5Njg3Mg==", "bodyText": "Hi mmedanjak,\nThis is Rajeev from Adobe. I was the original author of these changes. A little bit of context around this patch:\n\n\nThis patch is intended and tailor made for our use case(s) and in no way meant to be a general purpose, comprehensive all-encompassing feature covering all use cases and apis. At one point, I did try to address this holistically but quickly realized that it would be a much larger effort and outside of our concern.\n\n\nAs described in the design doc, we are addressing a very narrow subset of our use cases. The whole intent was to minimize redundant copy on read and thus minimizing memory usage.\n\n\nYou are right about the classcastexception that would happen when the iterator api is accessed from the clientproxy. I had realized this side effect of the patch. That would mean not being able to use the ClientMapProxy::iterator api (with object format on) which is anyways not exposed on the IMap interface (and we dont use direct Apis on the proxy).\n\n\nSo overall, yes the patch breaks an api (with object format) which we dont use. (even if we were to use that api, in that topology we would use the binary format) as a trade off against optimization of memory usage. We would like to accept and work within these caveats and proceed with the patch after addressing the other feedback.\n\n\nRe: benchmark\nWe havent done any benchmark. We did add test to confirm the patch functionality works and COR is disabled for local access of immutable types. Intuitively & naively, the performance should improve for the targeted use case and remain the same otherwise.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391796872", "createdAt": "2020-03-12T17:58:45Z", "author": {"login": "rajivgandhi1"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NTMyMA==", "bodyText": "The fix is quite simple actually here as @sancar pointed out. The collection will need to be serialised either way as we're transmitting it from the member back to the client. So, you can simply fix this by going over the collection and serialising the values.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r392075320", "createdAt": "2020-03-13T07:54:27Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2ODk2MA==", "bodyText": "Thanks @mmedenjak @sancar Yes we will fix this issue.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r392368960", "createdAt": "2020-03-13T17:25:33Z", "author": {"login": "rajivgandhi1"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU3ODYxMA==", "bodyText": "Looks good, thanks!", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r393578610", "createdAt": "2020-03-17T10:27:31Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, "originalCommit": {"oid": "fc898a101e01de3e596505d092b501317f40fe40"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTk5MDcyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/Immutable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNzo1NTo1MVrOF16aJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNzo1NTo1MVrOF16aJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NTgxMw==", "bodyText": "Can you remove mentioning of Adobe and simply say that it is a hint that this object is effectively immutable and can be shared safely between threads?", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r392075813", "createdAt": "2020-03-13T07:55:51Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/Immutable.java", "diffHunk": "@@ -1,4 +1,23 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package com.hazelcast.map;\n \n+/**\n+ * This is just a marker interface for Adobe Entities so that we can disable Copy on Read for this type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89b8a93367020c8e819de4c299b8fb3d80195be"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjA1Nzg2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjoxOTo0NFrOF5ReZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToxMDoxNVrOGBqA1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5OTQ2MA==", "bodyText": "Having immutable only makes sense if your application accesses it over its local embedded node, otherwise serialization will happen if you reach data over client or over remote nodes to the application. Is this what you want? Or maybe you can consider using near cache for this case, it will be much faster.", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r395599460", "createdAt": "2020-03-20T12:19:44Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -38,7 +39,10 @@ public GetOperation(String name, Data dataKey) {\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object currentValue = recordStore.get(dataKey, false, getCallerAddress());\n+        result = (currentValue instanceof Immutable)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1c75491cb4eea0990ff73afd1d72a8222382499"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MDEwMQ==", "bodyText": "Think about use cases with Jet (access happening node locally from with a Jet pipeline)", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r404390101", "createdAt": "2020-04-06T21:10:15Z", "author": {"login": "rajivgandhi1"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -38,7 +39,10 @@ public GetOperation(String name, Data dataKey) {\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object currentValue = recordStore.get(dataKey, false, getCallerAddress());\n+        result = (currentValue instanceof Immutable)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5OTQ2MA=="}, "originalCommit": {"oid": "d1c75491cb4eea0990ff73afd1d72a8222382499"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 735, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}