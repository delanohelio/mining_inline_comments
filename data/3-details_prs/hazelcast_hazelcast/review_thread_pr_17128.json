{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5ODA4MTEz", "number": 17128, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNzo1NTowMVrOELlDHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNzo1NjowM1rOELlEfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTc2Nzk3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNzo1NTowMVrOGtMoYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTozOToxMVrOGtTvlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NjA1MA==", "bodyText": "Isn't System.currentTimeMillis enough here? (though, I do not know any performance difference between nano and millis\nThe last line in this method calls hasNext which is blocking as well. Therefore, the idea of early return doesn't really work in this prototype. Instead, the method should return as soon as the very first call to hasNext returned something", "url": "https://github.com/hazelcast/hazelcast/pull/17128#discussion_r450046050", "createdAt": "2020-07-06T07:55:01Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -100,14 +102,16 @@ private boolean fetchPage(\n         int cursorBufferSize,\n         InternalSerializationService serializationService\n     ) {\n+        long endTime = System.nanoTime() + SECONDS.toNanos(1);\n         while (iterator.hasNext()) {\n             SqlRow row = iterator.next();\n             Row rowInternal = ((SqlRowImpl) row).getDelegate();\n             Data rowData = serializationService.toData(rowInternal);\n \n             page.add(rowData);\n \n-            if (page.size() == cursorBufferSize) {\n+            // TODO we call nanoTime for each item - use batching\n+            if (page.size() == cursorBufferSize || System.nanoTime() >= endTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be909d84e31189d9629d1ca7c43c79f24f1724b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjM3NA==", "bodyText": "nanoTime() should always be used for elapsed time. CTM isn't monotonic in rare cases, doesn't run at constant speed. Performance differs by OS and JVM implementation, but I think on Linux they are comparable. IIRC on Windows CTM is faster, but also much less precise (~15ms resolution)", "url": "https://github.com/hazelcast/hazelcast/pull/17128#discussion_r450162374", "createdAt": "2020-07-06T11:38:40Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -100,14 +102,16 @@ private boolean fetchPage(\n         int cursorBufferSize,\n         InternalSerializationService serializationService\n     ) {\n+        long endTime = System.nanoTime() + SECONDS.toNanos(1);\n         while (iterator.hasNext()) {\n             SqlRow row = iterator.next();\n             Row rowInternal = ((SqlRowImpl) row).getDelegate();\n             Data rowData = serializationService.toData(rowInternal);\n \n             page.add(rowData);\n \n-            if (page.size() == cursorBufferSize) {\n+            // TODO we call nanoTime for each item - use batching\n+            if (page.size() == cursorBufferSize || System.nanoTime() >= endTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NjA1MA=="}, "originalCommit": {"oid": "1be909d84e31189d9629d1ca7c43c79f24f1724b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjU4MA==", "bodyText": "problem #2: fixed", "url": "https://github.com/hazelcast/hazelcast/pull/17128#discussion_r450162580", "createdAt": "2020-07-06T11:39:11Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -100,14 +102,16 @@ private boolean fetchPage(\n         int cursorBufferSize,\n         InternalSerializationService serializationService\n     ) {\n+        long endTime = System.nanoTime() + SECONDS.toNanos(1);\n         while (iterator.hasNext()) {\n             SqlRow row = iterator.next();\n             Row rowInternal = ((SqlRowImpl) row).getDelegate();\n             Data rowData = serializationService.toData(rowInternal);\n \n             page.add(rowData);\n \n-            if (page.size() == cursorBufferSize) {\n+            // TODO we call nanoTime for each item - use batching\n+            if (page.size() == cursorBufferSize || System.nanoTime() >= endTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NjA1MA=="}, "originalCommit": {"oid": "1be909d84e31189d9629d1ca7c43c79f24f1724b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTc3MTQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNzo1NjowM1rOGtMqkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNzo1NjowM1rOGtMqkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NjYxMQ==", "bodyText": "Let's avoid Runnable and introduce a separate interface with proper name.", "url": "https://github.com/hazelcast/hazelcast/pull/17128#discussion_r450046611", "createdAt": "2020-07-06T07:56:03Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -35,7 +34,7 @@\n     private final InternalIterator iterator = new InternalIterator();\n \n     /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    private volatile Runnable scheduleCallback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be909d84e31189d9629d1ca7c43c79f24f1724b"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 394, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}