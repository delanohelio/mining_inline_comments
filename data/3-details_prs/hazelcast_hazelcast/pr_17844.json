{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NDk0NjA3", "number": 17844, "title": "Prevent client ending up with two addresses to same node when node is behind a private network", "bodyText": "Background :\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define a single member on the client-side.\nHow bug happens:\nWhen a client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\ndoConnectToCandidateCluster logic. It connects to a random address\nprovided in the config. This one can use public address of the member.\nIn the meantime, we have a periodic task ConnectToAllClusterMembersTask\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  private address\nBoth of them uses getOrConnect and doConnectToCandidateCluster\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\nHow to fix:\n\nuuid will be used as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections parallelly from\ndoConnectToCandidateCluster path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in activeConnection.\n\nPeriodic ConnectToAllClusterMembersTask will not try to connect\nan already connected member.And it will use uuid to decide that.\n\nThese two paths will not use the same method getOrConnect to simplify\nthe logic. One will be based on the address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address.", "createdAt": "2020-11-10T13:37:56Z", "url": "https://github.com/hazelcast/hazelcast/pull/17844", "merged": true, "mergeCommit": {"oid": "4b8fc6496eb442407e4dbd4dc592baa757211054"}, "closed": true, "closedAt": "2020-11-25T07:39:56Z", "author": {"login": "sancar"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbc5fwABqjM5ODM1NjIwMzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfpmytABqjQwMzI3NjcwMzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "888c8e3383eecd896b0ef9d92c5c75d8c16cb14f", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/888c8e3383eecd896b0ef9d92c5c75d8c16cb14f", "committedDate": "2020-11-10T13:36:55Z", "message": "WIP"}, "afterCommit": {"oid": "5de2677e53427dba2cbde5055b1de0a2cd786279", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5de2677e53427dba2cbde5055b1de0a2cd786279", "committedDate": "2020-11-11T11:50:47Z", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5de2677e53427dba2cbde5055b1de0a2cd786279", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5de2677e53427dba2cbde5055b1de0a2cd786279", "committedDate": "2020-11-11T11:50:47Z", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address."}, "afterCommit": {"oid": "a5af78e6a6f259c540f7d22bd3d7687066826617", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a5af78e6a6f259c540f7d22bd3d7687066826617", "committedDate": "2020-11-17T09:59:12Z", "message": "refactored connectToAllClusterMembers"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a5af78e6a6f259c540f7d22bd3d7687066826617", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a5af78e6a6f259c540f7d22bd3d7687066826617", "committedDate": "2020-11-17T09:59:12Z", "message": "refactored connectToAllClusterMembers"}, "afterCommit": {"oid": "c9b951d36dedd834e4bb254dd1c305019a7106f8", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c9b951d36dedd834e4bb254dd1c305019a7106f8", "committedDate": "2020-11-17T13:58:46Z", "message": "refactored connectToAllClusterMembers"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9b951d36dedd834e4bb254dd1c305019a7106f8", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c9b951d36dedd834e4bb254dd1c305019a7106f8", "committedDate": "2020-11-17T13:58:46Z", "message": "refactored connectToAllClusterMembers"}, "afterCommit": {"oid": "1afc840af3bcf2d9c143ba18f0f1f540c504064e", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1afc840af3bcf2d9c143ba18f0f1f540c504064e", "committedDate": "2020-11-17T17:21:21Z", "message": "refactored connectToAllClusterMembers"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1afc840af3bcf2d9c143ba18f0f1f540c504064e", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1afc840af3bcf2d9c143ba18f0f1f540c504064e", "committedDate": "2020-11-17T17:21:21Z", "message": "refactored connectToAllClusterMembers"}, "afterCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "committedDate": "2020-11-18T14:30:13Z", "message": "refactored connectToAllClusterMembers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NDU4MTE4", "url": "https://github.com/hazelcast/hazelcast/pull/17844#pullrequestreview-536458118", "createdAt": "2020-11-23T13:11:52Z", "commit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzoxMTo1MlrOH4M0ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzoyNzo1OVrOH4Na5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5MjQxOQ==", "bodyText": "can tryConnectToAllClusterMembers  be called multiple times? if so, multiple scheduled tasks?", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528692419", "createdAt": "2020-11-23T13:11:52Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -299,23 +300,24 @@ public synchronized void start() {\n \n         heartbeat.start();\n         connectToCluster();\n-        if (isSmartRoutingEnabled) {\n-            executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);\n-        }\n     }\n \n-    public void connectToAllClusterMembers() {\n+    public void tryConnectToAllClusterMembers(boolean sync) {\n         if (!isSmartRoutingEnabled) {\n             return;\n         }\n \n-        for (Member member : client.getClientClusterService().getMemberList()) {\n-            try {\n-                getOrConnect(member.getAddress());\n-            } catch (Exception e) {\n-                EmptyStatement.ignore(e);\n+        if (sync) {\n+            for (Member member : client.getClientClusterService().getMemberList()) {\n+                try {\n+                    getOrConnectToMember(member);\n+                } catch (Exception e) {\n+                    EmptyStatement.ignore(e);\n+                }\n             }\n         }\n+\n+        executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ==", "bodyText": "you gave extra responsibility to the method authenticateOnCluster, rather than simply just authentication. Hence, you needed to put this explanation for the implicit returned connection. I would prefer this method to just do authentication and do existing connection check at getOrConnectToAddress. you also can close the connection at the same method rather than at handleSuccessfulAuth . This is more understandable to me, separation of concerns.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528699319", "createdAt": "2020-11-23T13:23:23Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -808,10 +807,17 @@ private ClientConnection getConnectionFromLoadBalancer(boolean dataMember) {\n             return null;\n         }\n \n-        return getConnection(member.getUuid());\n+        return activeConnections.get(member.getUuid());\n     }\n \n-    private void authenticateOnCluster(TcpClientConnection connection) {\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwMjE4MQ==", "bodyText": "I hate to keep an extra state connectingAddresses  when i already have activeConnections . How important an optimization is it to prevent multiple connection opening attempts when we can not avoid it 100% of the time. For code simplicity, I would chose not to add this extra state.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528702181", "createdAt": "2020-11-23T13:27:59Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -1018,36 +1031,40 @@ public void onError(Channel channel, Throwable cause) {\n \n     private class ConnectToAllClusterMembersTask implements Runnable {\n \n-        private Set<Address> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+        private Set<UUID> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n \n         @Override\n         public void run() {\n+\n             if (!client.getLifecycleService().isRunning()) {\n                 return;\n             }\n \n             for (Member member : client.getClientClusterService().getMemberList()) {\n-                Address address = member.getAddress();\n-\n-                if (client.getLifecycleService().isRunning() && getConnection(address) == null\n-                        && connectingAddresses.add(address)) {\n-                    // submit a task for this address only if there is no\n-                    // another connection attempt for it\n-                    executor.submit(() -> {\n-                        try {\n-                            if (!client.getLifecycleService().isRunning()) {\n-                                return;\n-                            }\n-                            if (getConnection(member.getUuid()) == null) {\n-                                getOrConnect(address);\n-                            }\n-                        } catch (Exception e) {\n-                            EmptyStatement.ignore(e);\n-                        } finally {\n-                            connectingAddresses.remove(address);\n-                        }\n-                    });\n+                UUID uuid = member.getUuid();\n+\n+                if (activeConnections.get(uuid) != null) {\n+                    continue;\n                 }\n+\n+                if (!connectingAddresses.add(uuid)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 304}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NTExOTM1", "url": "https://github.com/hazelcast/hazelcast/pull/17844#pullrequestreview-536511935", "createdAt": "2020-11-23T14:17:25Z", "commit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoxNzoyNVrOH4PV1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoxNzoyNVrOH4PV1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMzY1NQ==", "bodyText": "There is a slight behavior change here but I think this is not big a problem. If some of the member addresses are the same as the addresses configured, then we were not trying to connect the same address twice, but we are doing it right now.\nTo get the same behavior, maybe we could store the member addresses on the triedTargets, and while iterating over the configured addresses, check the contents of it to see whether we tried to connect or not.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528733655", "createdAt": "2020-11-23T14:17:25Z", "author": {"login": "mdumandag"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -444,16 +446,30 @@ private void fireLifecycleEvent(LifecycleState state) {\n     }\n \n     private boolean doConnectToCandidateCluster(CandidateClusterContext context) {\n-        Set<Address> triedAddresses = new HashSet<>();\n+        Set<Object> triedTargets = new HashSet<>();\n         try {\n             waitStrategy.reset();\n             do {\n-                Collection<Address> addresses = getPossibleMemberAddresses(context.getAddressProvider());\n-                for (Address address : addresses) {\n+                List<Member> memberList = new ArrayList<>(client.getClientClusterService().getMemberList());\n+                if (shuffleMemberList) {\n+                    Collections.shuffle(memberList);\n+                }\n+                //try to connect to a member in the member list first\n+                for (Member member : memberList) {\n                     checkClientActive();\n-                    triedAddresses.add(address);\n+                    triedTargets.add(member);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df3b19faeab7e43907cea2680712a0bc55f59f7a", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/df3b19faeab7e43907cea2680712a0bc55f59f7a", "committedDate": "2020-11-24T10:55:46Z", "message": "seperate authenticate and onAuthenticate functions."}, "afterCommit": {"oid": "0fb989dc16df65a23d76aa27228647ada87dda56", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0fb989dc16df65a23d76aa27228647ada87dda56", "committedDate": "2020-11-24T11:49:08Z", "message": "seperate authenticate and onAuthenticate functions."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDIzNjU1", "url": "https://github.com/hazelcast/hazelcast/pull/17844#pullrequestreview-537423655", "createdAt": "2020-11-24T12:03:04Z", "commit": {"oid": "0fb989dc16df65a23d76aa27228647ada87dda56"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDU2NDE0", "url": "https://github.com/hazelcast/hazelcast/pull/17844#pullrequestreview-537456414", "createdAt": "2020-11-24T12:47:29Z", "commit": {"oid": "0fb989dc16df65a23d76aa27228647ada87dda56"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "committedDate": "2020-11-24T13:16:43Z", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0fb989dc16df65a23d76aa27228647ada87dda56", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0fb989dc16df65a23d76aa27228647ada87dda56", "committedDate": "2020-11-24T11:49:08Z", "message": "seperate authenticate and onAuthenticate functions."}, "afterCommit": {"oid": "858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "committedDate": "2020-11-24T13:16:43Z", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3128, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}