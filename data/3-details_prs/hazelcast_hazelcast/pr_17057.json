{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NDY2MTYx", "number": 17057, "title": "SQL: Optimization rules for Project/Filter (#17045)", "bodyText": "This PR introduces optimization rules for Project and Filter operators:\n\nApache Calcite rules: eliminate and merge LogicalProject and LogicalFilter when possible\nCustom rules: a) push the LogicalFilter into the LogicalTableScan, b) trim unused LogicalTableScan columns based on the content of the parent LogicalProject\n\nCloses #17045", "createdAt": "2020-06-05T13:54:31Z", "url": "https://github.com/hazelcast/hazelcast/pull/17057", "merged": true, "mergeCommit": {"oid": "5ead5da9357df6b992aebb385129c13a9a4a3bb6"}, "closed": true, "closedAt": "2020-06-16T14:01:20Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoS_GcAH2gAyNDI4NDY2MTYxOjEzMDEyYTAzMWJiODU0MjQwZjA0ZGRmZWNmMTIxYTc3NGUyNzMzNTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsKXaBAFqTQzMjQzNTExNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "13012a031bb854240f04ddfecf121a774e273358", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/13012a031bb854240f04ddfecf121a774e273358", "committedDate": "2020-06-05T13:50:16Z", "message": "SQL: Optimization rules for Project/Filter."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f7b2c4d28f1a2d8e79673fa936812903f0dbdd3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5f7b2c4d28f1a2d8e79673fa936812903f0dbdd3", "committedDate": "2020-06-05T13:55:21Z", "message": "Tabulation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d049536a57d971a1f497a9c285804df27b5bcf6f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d049536a57d971a1f497a9c285804df27b5bcf6f", "committedDate": "2020-06-05T14:03:02Z", "message": "Typo."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2962ff75a97b33f279f801bc7be654b5c019d04a", "committedDate": "2020-06-05T14:03:18Z", "message": "Typo."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88b4604155749c129781a0f3abf56ca1766af5aa", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/88b4604155749c129781a0f3abf56ca1766af5aa", "committedDate": "2020-06-06T09:01:58Z", "message": "Fix typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f979cba823839cf6421e64e67e649bcd19da756", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4f979cba823839cf6421e64e67e649bcd19da756", "committedDate": "2020-06-06T09:02:52Z", "message": "Simplify code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee99a32c6810472f5b3f3a1b6a8e9c4d1e0d429e", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ee99a32c6810472f5b3f3a1b6a8e9c4d1e0d429e", "committedDate": "2020-06-06T09:03:41Z", "message": "Add test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69f597446ce846bfca29dece1bf05f3b7754aba4", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/69f597446ce846bfca29dece1bf05f3b7754aba4", "committedDate": "2020-06-06T09:15:04Z", "message": "Use 0-based indexes for field names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b64f0d16dab03448949f21f2f3b5e301d246550", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8b64f0d16dab03448949f21f2f3b5e301d246550", "committedDate": "2020-06-06T09:16:48Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTA3MjI2", "url": "https://github.com/hazelcast/hazelcast/pull/17057#pullrequestreview-425507226", "createdAt": "2020-06-05T17:55:44Z", "commit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1NTo0NFrOGf38pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwODoyNjoyMVrOGgCn2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4Nw==", "bodyText": "This method is never overridden, do you plan that in the future?", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r436075687", "createdAt": "2020-06-05T17:55:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -17,109 +17,65 @@\n package com.hazelcast.sql.impl.calcite.opt;\n \n import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n import org.apache.calcite.plan.RelOptCluster;\n import org.apache.calcite.plan.RelOptCost;\n import org.apache.calcite.plan.RelOptPlanner;\n import org.apache.calcite.plan.RelOptTable;\n import org.apache.calcite.plan.RelTraitSet;\n-import org.apache.calcite.rel.RelWriter;\n import org.apache.calcite.rel.metadata.RelMetadataQuery;\n-import org.apache.calcite.rex.RexNode;\n-\n-import java.util.List;\n \n /**\n  * Base class for map scans.\n  */\n public abstract class AbstractMapScanRel extends AbstractScanRel {\n-    /** Filter. */\n-    protected final RexNode filter;\n-\n     public AbstractMapScanRel(\n         RelOptCluster cluster,\n         RelTraitSet traitSet,\n-        RelOptTable table,\n-        List<Integer> projects,\n-        RexNode filter\n+        RelOptTable table\n     ) {\n-        super(cluster, traitSet, table, projects);\n-\n-        this.filter = filter;\n-    }\n-\n-    public List<Integer> getProjects() {\n-        return projects != null ? projects : identity();\n-    }\n-\n-    public RexNode getFilter() {\n-        return filter;\n+        super(cluster, traitSet, table);\n     }\n \n     public AbstractMapTable getMap() {\n         return getTableUnwrapped().getTarget();\n     }\n \n-    @Override\n-    public RelWriter explainTerms(RelWriter pw) {\n-        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n-    }\n-\n-    @Override\n-    public final double estimateRowCount(RelMetadataQuery mq) {\n-        double rowCount = super.estimateRowCount(mq);\n-\n-        if (filter != null) {\n-            double selectivity = mq.getSelectivity(this, filter);\n-\n-            rowCount = rowCount * selectivity;\n-        }\n-\n-        return rowCount;\n-    }\n-\n     @Override\n     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+        HazelcastTable table0 = getTableUnwrapped();\n+\n         return computeSelfCost(\n             planner,\n-            mq,\n+            table0.getTotalRowCount(),\n+            CostUtils.TABLE_SCAN_CPU_MULTIPLIER, table0.getFilter() != null,\n             table.getRowCount(),\n-            filter,\n-            getProjects().size(),\n-            CostUtils.TABLE_SCAN_CPU_MULTIPLIER\n+            table0.getProjects().size()\n         );\n     }\n \n     protected RelOptCost computeSelfCost(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjUyNA==", "bodyText": "Shouldn't we set use projects=[] for the scan? It should be able to handle zero fields...", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r436106524", "createdAt": "2020-06-05T18:53:55Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/ProjectIntoScanLogicalRule.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.core.TableScan;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexVisitorImpl;\n+import org.apache.calcite.util.mapping.Mapping;\n+import org.apache.calcite.util.mapping.Mappings;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Logical rule that pushes down a column references from a {@link Project} into a {@link TableScan} to allow for constrained\n+ * scans. See {@link HazelcastTable} for more information about constrained scans.\n+ * <p>\n+ * <b>Case 1: </b>projects that have only column expressions are eliminated completely, unused columns returned from the\n+ * {@code TableScan} are trimmed.\n+ * <p>\n+ * Before:\n+ * <pre>\n+ * LogicalProject[projects=[$2, $1]]]\n+ *   LogicalTableScan[table[projects=[0, 1, 2]]]\n+ * </pre>\n+ * After:\n+ * <pre>\n+ * LogicalTableScan[table[projects=[2, 1]]]\n+ * </pre>\n+ * <b>Case 2: </b>projects with non-column expressions trim the unused columns only.\n+ * <p>\n+ * Before:\n+ * <pre>\n+ * LogicalProject[projects=[+$2, $0]]]\n+ *   LogicalTableScan[table[projects=[0, 1, 2]]]\n+ * </pre>\n+ * After:\n+ * <pre>\n+ * LogicalProject[projects=[+$0, $1]]]\n+ *   LogicalTableScan[table[projects=[2, 0]]]\n+ * </pre>\n+ */\n+public final class ProjectIntoScanLogicalRule extends RelOptRule {\n+\n+    public static final ProjectIntoScanLogicalRule INSTANCE = new ProjectIntoScanLogicalRule();\n+\n+    private ProjectIntoScanLogicalRule() {\n+        super(\n+            operand(LogicalProject.class,\n+                operandJ(LogicalTableScan.class, null, OptUtils::isHazelcastTable, none())),\n+            RelFactories.LOGICAL_BUILDER,\n+            ProjectIntoScanLogicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+        Project project = call.rel(0);\n+        TableScan scan = call.rel(1);\n+\n+        Mappings.TargetMapping mapping = project.getMapping();\n+\n+        if (mapping != null) {\n+            processSimple(call, mapping, scan);\n+        } else {\n+            processComplex(call, project, scan);\n+        }\n+    }\n+\n+    /**\n+     * Process simple case when all project expressions are direct field access. The {@code Project} is eliminated completely.\n+     *\n+     * @param mapping Projects mapping.\n+     * @param scan Scan.\n+     */\n+    private static void processSimple(RelOptRuleCall call, Mappings.TargetMapping mapping, TableScan scan) {\n+        // Get columns defined in the original TableScan.\n+        HazelcastTable originalTable = OptUtils.getHazelcastTable(scan);\n+\n+        List<Integer> originalProjects = originalTable.getProjects();\n+\n+        // Remap columns from the Project. The result is the projects that will be pushed down to the new TableScan.\n+        // E.g. consider the table \"t[f0, f1, f2]\" and the SQL query \"SELECT f2, f0\":\n+        //   Original projects: [0(f0), 1(f1), 2(f2)]\n+        //   New projects:      [2(f2), 0(f0)]\n+        List<Integer> newProjects = Mappings.apply((Mapping) mapping, originalProjects);\n+\n+        // Construct the new TableScan with adjusted columns.\n+        LogicalTableScan newScan = OptUtils.createLogicalScanWithNewTable(\n+            scan,\n+            originalTable.withProject(newProjects)\n+        );\n+\n+        call.transformTo(newScan);\n+    }\n+\n+    /**\n+     * Process the complex project with expressions. The {@code Project} operator will remain, but the number and the order of\n+     * columns returned from the {@code TableScan} is adjusted.\n+     *\n+     * @param project Project.\n+     * @param scan Scan.\n+     */\n+    private void processComplex(RelOptRuleCall call, Project project, TableScan scan) {\n+        HazelcastTable originalTable = OptUtils.getHazelcastTable(scan);\n+\n+        // Map projected field references to real scan fields.\n+        ProjectFieldVisitor projectFieldVisitor = new ProjectFieldVisitor(originalTable.getProjects());\n+\n+        for (RexNode projectExp : project.getProjects()) {\n+            projectExp.accept(projectFieldVisitor);\n+        }\n+\n+        // Get new scan fields. These are the only fields that are accessed by the project operator.\n+        List<Integer> newScanProjects = projectFieldVisitor.createNewScanProjects();\n+\n+        if (newScanProjects.isEmpty()) {\n+            // No TableScan columns are referenced from within a project, i.e. the Project doesn't depend on column values\n+            // of the TableScan. E.g. \"SELECT CURRENT_TIME() FROM t\". In future we will introduce a special optimizer operator\n+            // for that case that will not do a real scan. It is not trivial, because we should take in count whether the\n+            // Project expressions are deterministic or not. Therefore, we simply ignore that case for now.\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MDU4Ng==", "bodyText": "Shouldn't we allow empty projects as distinct from null. I guess null means \"all the table fields\", empty projects would mean no columns are actually selected. For the query SELECT current_date() FORM map", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r436250586", "createdAt": "2020-06-06T08:26:21Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -41,19 +50,83 @@\n  * <ul>\n  *     <li>Maps field types defined in the {@code core} module to Calcite types</li>\n  *     <li>Provides access to the underlying table and statistics</li>\n+ *     <li>Encapsulates projects and filter to allow for constained scans</li>\n  * </ul>\n+ * <p>\n+ * <h2>Constrained scans</h2>\n+ * For a sequence of logical project/filter/scan operators, we would like to ensure that the resulting relational tree is as\n+ * flat as possible because this minimizes processing overhead and memory usage. To achieve this we try to push projects and\n+ * filters into the table using {@link ProjectIntoScanLogicalRule} and {@link FilterIntoScanLogicalRule} rules. These rules\n+ * reduce the amount of data returned from the table during scanning. Pushed down projection ensures that only columns required\n+ * by parent operators are returned, thus implementing field trimming. Pushed down filter reduces the number of returned rows.\n+ * <p>\n+ * Projects are indexes of table fields that are returned. Initial projection (i.e. before optimization) returns all the columns.\n+ * After project pushdown the number and order of columns may change. For example, for the table {@code t[f1, f2, f3]} the\n+ * initial projection is {@code [0, 1, 2]}. After pushdown of a {@code \"SELECT f3, f1\"} the projection becomes {@code [2, 0]}\n+ * which means that the columns {@code [f3, f1]} are returned in that order.\n+ * <p>\n+ * Filter is a conjunctive expression that references table fields via their original indexes. That is, {@code [f3]} is\n+ * referenced as {@code [2]} even if it is projected as the first field in the example above. This is needed to allow for\n+ * projections and filters on disjoint sets of attributes.\n+ * <p>\n+ * Consider the following SQL statement:\n+ * <pre>\n+ * SELECT f3, f1 FROM t WHERE f2 > ?\n+ * </pre>\n+ * In this case {@code projects=[2, 0]}, {@code filter=[>$1,?]}.\n+ * <p>\n+ * We do not pushdown the project expressions other than columns because in this case it will be difficult to pushdown\n+ * filters, as it will require non-trivial rewrite of the filter expression to match to original scan columns.\n  */\n public class HazelcastTable extends AbstractTable {\n \n     private final Table target;\n     private final Statistic statistic;\n+    private final List<Integer> projects;\n+    private final RexNode filter;\n \n     private RelDataType rowType;\n     private Set<String> hiddenFieldNames;\n \n     public HazelcastTable(Table target, Statistic statistic) {\n+        this(target, statistic, null, null);\n+    }\n+\n+    private HazelcastTable(Table target, Statistic statistic, List<Integer> projects, RexNode filter) {\n         this.target = target;\n         this.statistic = statistic;\n+        this.projects = projects;\n+        this.filter = filter;\n+    }\n+\n+    public HazelcastTable withProject(List<Integer> projects) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public HazelcastTable withFilter(RexNode filter) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public List<Integer> getProjects() {\n+        assert projects == null || !projects.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aef605262fbc43aa20022e18a726eed5f7cc00a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7aef605262fbc43aa20022e18a726eed5f7cc00a", "committedDate": "2020-06-15T06:58:41Z", "message": "Merge branch 'master' into issues/17045"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e59686c12447f1bc63f89037733abae26399ab8c", "committedDate": "2020-06-15T07:43:32Z", "message": "Added support for empty project list for scan when parent operator do not use any columns (e.g. SELECT GET_DATE FROM person)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNDcwNDE0", "url": "https://github.com/hazelcast/hazelcast/pull/17057#pullrequestreview-430470414", "createdAt": "2020-06-15T09:25:57Z", "commit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOToyNTo1N1rOGjqPSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo0OToxNlrOGjrEoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0NTM4Ng==", "bodyText": "Maybe we can annotate this method as @Nonnull", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440045386", "createdAt": "2020-06-15T09:25:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -17,43 +17,118 @@\n package com.hazelcast.sql.impl.calcite.schema;\n \n import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.calcite.opt.logical.FilterIntoScanLogicalRule;\n+import com.hazelcast.sql.impl.calcite.opt.logical.ProjectIntoScanLogicalRule;\n import com.hazelcast.sql.impl.schema.Table;\n import com.hazelcast.sql.impl.schema.TableField;\n import com.hazelcast.sql.impl.type.QueryDataType;\n import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelDistribution;\n+import org.apache.calcite.rel.RelReferentialConstraint;\n+import org.apache.calcite.rel.metadata.RelMdUtil;\n import org.apache.calcite.rel.type.RelDataType;\n import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n import org.apache.calcite.rel.type.StructKind;\n+import org.apache.calcite.rex.RexNode;\n import org.apache.calcite.schema.Statistic;\n import org.apache.calcite.schema.impl.AbstractTable;\n import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.util.ImmutableBitSet;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n+import java.util.StringJoiner;\n+\n+import static java.util.stream.Collectors.joining;\n \n /**\n  * Base class for all tables in the Calcite integration:\n  * <ul>\n  *     <li>Maps field types defined in the {@code core} module to Calcite types</li>\n  *     <li>Provides access to the underlying table and statistics</li>\n+ *     <li>Encapsulates projects and filter to allow for constrained scans</li>\n  * </ul>\n+ * <p>\n+ * <h2>Constrained scans</h2>\n+ * For a sequence of logical project/filter/scan operators we would like to ensure that the resulting relational tree is as\n+ * flat as possible because this minimizes the processing overhead and memory usage. To achieve this we try to push projects and\n+ * filters into the table using {@link ProjectIntoScanLogicalRule} and {@link FilterIntoScanLogicalRule}. These rules\n+ * reduce the amount of data returned from the table during scanning. Pushed-down projection ensures that only columns required\n+ * by parent operators are returned, thus implementing field trimming. Pushed-down filter reduces the number of returned rows.\n+ * <p>\n+ * Projects are indexes of table fields that are returned. Initial projection (i.e. before optimization) returns all the columns.\n+ * After project pushdown the number and order of columns may change. For example, for the table {@code t[f0, f1, f2]} the\n+ * initial projection is {@code [0, 1, 2]}. After pushdown of a {@code \"SELECT f2, f0\"} the projection becomes {@code [2, 0]}\n+ * which means that the columns {@code [f2, f0]} are returned, in that order.\n+ * <p>\n+ * Filter is a conjunctive expression that references table fields via their original indexes. That is, {@code [f2]} is\n+ * referenced as {@code [2]} even if it is projected as the first field in the example above. This is needed to allow for\n+ * projections and filters on disjoint sets of attributes.\n+ * <p>\n+ * Consider the following SQL statement:\n+ * <pre>\n+ * SELECT f2, f0 FROM t WHERE f1 > ?\n+ * </pre>\n+ * In this case {@code projects=[2, 0]}, {@code filter=[>$1, ?]}.\n+ * <p>\n+ * We do not pushdown the project expressions other than columns because in this case it will be difficult to pushdown\n+ * filters, as it will require non-trivial rewrite of the filter expression to match to original scan columns.\n  */\n public class HazelcastTable extends AbstractTable {\n \n     private final Table target;\n     private final Statistic statistic;\n+    private final List<Integer> projects;\n+    private final RexNode filter;\n \n     private RelDataType rowType;\n     private Set<String> hiddenFieldNames;\n \n     public HazelcastTable(Table target, Statistic statistic) {\n+        this(target, statistic, null, null);\n+    }\n+\n+    private HazelcastTable(Table target, Statistic statistic, List<Integer> projects, RexNode filter) {\n         this.target = target;\n         this.statistic = statistic;\n+        this.projects = projects;\n+        this.filter = filter;\n+    }\n+\n+    public HazelcastTable withProject(List<Integer> projects) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public HazelcastTable withFilter(RexNode filter) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public List<Integer> getProjects() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0OTk2NA==", "bodyText": "Now we always add the projects, even if it's identity. StringBuilder can now be easier:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringJoiner res = new StringJoiner(\", \", \"[\", \"]\");\n          \n          \n            \n                    res.setEmptyValue(\"\");\n          \n          \n            \n            \n          \n          \n            \n                    res.add(\"projects=\" + getProjects().stream().map(Objects::toString).collect(joining(\", \", \"[\", \"]\")));\n          \n          \n            \n            \n          \n          \n            \n                    if (filter != null) {\n          \n          \n            \n                        res.add(\"filter=\" + filter);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return res.toString();\n          \n          \n            \n                    StringBuilder res = new StringBuilder();\n          \n          \n            \n                    res.add(\"[projects=\");\n          \n          \n            \n                    res.add(getProjects().stream().map(Objects::toString).collect(joining(\", \", \"[\", \"]\")));\n          \n          \n            \n                    if (filter != null) {\n          \n          \n            \n                        res.add(\", filter=\").add(filter);\n          \n          \n            \n                    }\n          \n          \n            \n                    return res.add(']').toString();", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440049964", "createdAt": "2020-06-15T09:33:49Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -102,12 +179,90 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n \n     @Override\n     public Statistic getStatistic() {\n-        return statistic;\n+        if (filter == null) {\n+            return statistic;\n+        } else {\n+            Double selectivity = RelMdUtil.guessSelectivity(filter);\n+\n+            double rowCount = CostUtils.adjustFilteredRowCount(statistic.getRowCount(), selectivity);\n+\n+            return new AdjustedStatistic(rowCount);\n+        }\n+    }\n+\n+    public double getTotalRowCount() {\n+        return statistic.getRowCount();\n     }\n \n     public boolean isHidden(String fieldName) {\n         assert hiddenFieldNames != null;\n \n         return hiddenFieldNames.contains(fieldName);\n     }\n+\n+    public int getOriginalFieldCount() {\n+        return target.getFieldCount();\n+    }\n+\n+    /**\n+     * Constructs a signature for the table.\n+     * <p>\n+     * See {@link HazelcastRelOptTable} for more information.\n+     *\n+     * @return Signature.\n+     */\n+    public String getSignature() {\n+        StringJoiner res = new StringJoiner(\", \", \"[\", \"]\");\n+        res.setEmptyValue(\"\");\n+\n+        res.add(\"projects=\" + getProjects().stream().map(Objects::toString).collect(joining(\", \", \"[\", \"]\")));\n+\n+        if (filter != null) {\n+            res.add(\"filter=\" + filter);\n+        }\n+\n+        return res.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NDUxNw==", "bodyText": "Doesn't matter much, but we should throw IndexOutOfBoundsException(\"index=\" + index). The operation doesn't have a missing implementation - it's implemented, but there's no valid index it can be called with.\nSame in EmptyRowBatch.getRow()", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440054517", "createdAt": "2020-06-15T09:41:40Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/row/EmptyRow.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.row;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Row with no columns. It may appear when the downstream operator doesn't need any columns from\n+ * the upstream, and only the number of returned rows is important.\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * SELECT GET_DATE() FROM person\n+ * </pre>\n+ */\n+public class EmptyRow implements Row, IdentifiedDataSerializable {\n+\n+    public static final EmptyRow INSTANCE = new EmptyRow();\n+\n+    public EmptyRow() {\n+        // No-op.\n+    }\n+\n+    @Override\n+    public <T> T get(int index) {\n+        throw new UnsupportedOperationException(\"Should not be called.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1OTA0MA==", "bodyText": "This might be easier to read:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Get local partition\n          \n          \n            \n                    int partitionId = 0;\n          \n          \n            \n            \n          \n          \n            \n                    for (Partition partition : instance1.getPartitionService().getPartitions()) {\n          \n          \n            \n                        if (instance1.getLocalEndpoint().getUuid().equals(partition.getOwner().getUuid())) {\n          \n          \n            \n                            partitionId = partition.getPartitionId();\n          \n          \n            \n            \n          \n          \n            \n                            break;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    // Get some local partition\n          \n          \n            \n                    int partitionId = instance1.getPartitionService().getPartitions().stream()\n          \n          \n            \n                            .filter(p -> instance1.getLocalEndpoint().getUuid().equals(p.getOwner().getUuid()))\n          \n          \n            \n                            .findAny().get()\n          \n          \n            \n                            .getPartitionId();", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440059040", "createdAt": "2020-06-15T09:49:16Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/MapScanExecTest.java", "diffHunk": "@@ -111,6 +112,77 @@ public void testNormal_Binary() {\n         checkNormal(instance1.getMap(MAP_BINARY));\n     }\n \n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    @Test\n+    public void testEmptyRow() {\n+        MapProxyImpl<TestKey, TestValue> map = (MapProxyImpl) instance1.getMap(MAP_OBJECT);\n+\n+        // Get local partition\n+        int partitionId = 0;\n+\n+        for (Partition partition : instance1.getPartitionService().getPartitions()) {\n+            if (instance1.getLocalEndpoint().getUuid().equals(partition.getOwner().getUuid())) {\n+                partitionId = partition.getPartitionId();\n+\n+                break;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDE2NzQ3", "url": "https://github.com/hazelcast/hazelcast/pull/17057#pullrequestreview-431416747", "createdAt": "2020-06-16T11:40:00Z", "commit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "395173ab884e0b19d326299e6505cf6b41816bdb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/395173ab884e0b19d326299e6505cf6b41816bdb", "committedDate": "2020-06-16T12:29:33Z", "message": "Merge branch 'master' into issues/17045"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da452920002ebe6ff98bde156f53db107aa7c7e4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/da452920002ebe6ff98bde156f53db107aa7c7e4", "committedDate": "2020-06-16T12:43:29Z", "message": "Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDk2MzAx", "url": "https://github.com/hazelcast/hazelcast/pull/17057#pullrequestreview-431496301", "createdAt": "2020-06-16T13:23:02Z", "commit": {"oid": "da452920002ebe6ff98bde156f53db107aa7c7e4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "429e4c8cd3ccf4b0877cc2d671974474c522f4a3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/429e4c8cd3ccf4b0877cc2d671974474c522f4a3", "committedDate": "2020-06-16T14:00:36Z", "message": "JavaDoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNDM1MTE2", "url": "https://github.com/hazelcast/hazelcast/pull/17057#pullrequestreview-432435116", "createdAt": "2020-06-17T14:03:22Z", "commit": {"oid": "429e4c8cd3ccf4b0877cc2d671974474c522f4a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowMzoyMlrOGlHTyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowMzoyMlrOGlHTyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3MDI1MQ==", "bodyText": "It's never empty...", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r441570251", "createdAt": "2020-06-17T14:03:22Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -102,12 +181,91 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n \n     @Override\n     public Statistic getStatistic() {\n-        return statistic;\n+        if (filter == null) {\n+            return statistic;\n+        } else {\n+            Double selectivity = RelMdUtil.guessSelectivity(filter);\n+\n+            double rowCount = CostUtils.adjustFilteredRowCount(statistic.getRowCount(), selectivity);\n+\n+            return new AdjustedStatistic(rowCount);\n+        }\n+    }\n+\n+    public double getTotalRowCount() {\n+        return statistic.getRowCount();\n     }\n \n     public boolean isHidden(String fieldName) {\n         assert hiddenFieldNames != null;\n \n         return hiddenFieldNames.contains(fieldName);\n     }\n+\n+    public int getOriginalFieldCount() {\n+        return target.getFieldCount();\n+    }\n+\n+    /**\n+     * Constructs a signature for the table.\n+     * <p>\n+     * See {@link HazelcastRelOptTable} for more information.\n+     *\n+     * @return Signature.\n+     */\n+    public String getSignature() {\n+        StringJoiner res = new StringJoiner(\", \", \"[\", \"]\");\n+\n+        res.setEmptyValue(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429e4c8cd3ccf4b0877cc2d671974474c522f4a3"}, "originalPosition": 177}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3671, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}