{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODU5NTE1", "number": 17183, "title": "Add basic SQL expressions support", "bodyText": "This commit adds support for the following SQL types:\n\n\nInteger types: TINYINT, SMALLINT, (INT)EGER and BIGINT.\nThe implementation always tries to select the narrowest integer type\npossible to represent integer literals and results of operators\nreturning integer values. At the same time, the implementation\nperforms the widening of operator result types to avoid arithmetic\noverflows. This all achieved by providing a custom Calcite type:\nHazelcastIntegerType.\n\n\nFloating-point types: REAL (Java's float), DOUBLE and DECIMAL.\nThe implementation never assigns DECIMAL type to literals,\nparameters and operator result types if there are no DECIMAL columns\nor explicit casts to DECIMAL involved in the expression.\n\n\nString types: VARCHAR and CHAR. Where possible, string types are\nnormalized to VARCHAR, but, for instance, string literals still\nhave CHAR type as required by Calcite. Such CHAR usages are purely\ninternal and not accessible by users: CAST(foo AS CHAR) is invalid.\n\n\nBOOLEAN type. The usual SQL ternary boolean logic type.\n\n\nNULL type. The implementation follows the standard Calcite approach\non assigning more specific types than just NULL to operands of\nexpressions. For instance, consider the following expression:\n1 + NULL, the NULL literal would receive nullable TINYINT type.\nBut in some cases it's impossible to assign a more specific type, so\nthe raw NULL type may appear: SELECT NULL FROM table, the NULL\nliteral doesn't have any specific type in this example.\n\n\nOBJECT type currently mapped to ANY Calcite type, that mapping\nmight change in the future. The only reason for such mapping is that\nANY type transparently passes through all validation, type inference\nand coercion stages without producing obscure errors, so more concise\nerrors can be reported for operators that don't support OBJECT as\nan input.\n\n\nThe following expressions are supported for the types listed above:\n\n\nArithmetics: binary and unary +, binary and unary -, *, /.\n\n\nComparison: =, !=, <, >, <=, >=.\n\n\nLogic: AND, OR, NOT.\n\n\nIS predicates: IS [NOT] TRUE, IS [NOT] FALSE, IS [NOT] NULL.\n\n\nCAST and CASE.\n\n\nAll expressions, including columns, literals and parameters, are\nstatically typed: their types are assigned once during query plan\ncreation and never change. This allows to avoid unnecessary type\nconversion and overflow checks during query execution. Necessary\nimplicit type conversions are still performed according to the type\nconversion rules defined in the type system design document. Type\nprecedence defined in the document is also respected while selecting\nan appropriate overload provided by a certain operator.\nSome initial support for temporal types is added as well, but currently\nthere are no operators and functions supporting temporal operands.", "createdAt": "2020-07-06T15:49:00Z", "url": "https://github.com/hazelcast/hazelcast/pull/17183", "merged": true, "mergeCommit": {"oid": "efab6d9d21989a972e7e3e6565ec5b20be55f9cb"}, "closed": true, "closedAt": "2020-08-12T09:20:04Z", "author": {"login": "taburet"}, "timelineItems": {"totalCount": 164, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc92MKKgH2gAyNDQ0ODU5NTE1OjBiYTE5OGFiMGUwMTUwYWRiY2E5OGVkMjQyMTBiMWVkMTQ1Y2M2MzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-HyZRAFqTQ2NTczNDE2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0ba198ab0e0150adbca98ed24210b1ed145cc636", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0ba198ab0e0150adbca98ed24210b1ed145cc636", "committedDate": "2020-08-11T12:43:37Z", "message": "simplify asserts\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "826a52c3a017e21254e8a59bda5228fb5063f278", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/826a52c3a017e21254e8a59bda5228fb5063f278", "committedDate": "2020-08-11T12:43:37Z", "message": "simplify CASE rewriting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cdd96adf606b599e3e19611b2ca02e81598f754", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2cdd96adf606b599e3e19611b2ca02e81598f754", "committedDate": "2020-08-11T12:43:37Z", "message": "use IdentityHashMap instead of HashMap for node type tracking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "committedDate": "2020-08-11T12:43:37Z", "message": "simplify javadoc wording\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5765c88ab53240721dbfa3cbc5d48234c1d218f", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f5765c88ab53240721dbfa3cbc5d48234c1d218f", "committedDate": "2020-08-11T12:43:37Z", "message": "check for edge case values in ConvertersTest for double and float"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ad02e79ebe38a2c94e0b9fdd4f299a0e0ca476e", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2ad02e79ebe38a2c94e0b9fdd4f299a0e0ca476e", "committedDate": "2020-08-11T12:43:37Z", "message": "add more details to parameter conversion exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4ffb4baa6712a6995f66e2b405d60a225d698bc", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f4ffb4baa6712a6995f66e2b405d60a225d698bc", "committedDate": "2020-08-11T12:43:37Z", "message": "make toDecimal conversion faster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9622df65a60ef773dfda9d8556e43f942615b574", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9622df65a60ef773dfda9d8556e43f942615b574", "committedDate": "2020-08-11T12:43:38Z", "message": "change rounding mode to HALF_UP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e29fd56f6cf0201e27c780874bd3962872c8d837", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e29fd56f6cf0201e27c780874bd3962872c8d837", "committedDate": "2020-08-11T12:43:38Z", "message": "expand javadoc on DECIMAL_MATH_CONTEXT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74852892d3a65d18aa6eeb9cb29971ff44b0e990", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/74852892d3a65d18aa6eeb9cb29971ff44b0e990", "committedDate": "2020-08-11T12:43:38Z", "message": "mention \"numeric\" in overflow error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46f1731041351c1741dac8b5d1657e8f10bcb17b", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/46f1731041351c1741dac8b5d1657e8f10bcb17b", "committedDate": "2020-08-11T12:43:38Z", "message": "add UDT for OBJECT as an alias for ANY and disallow direct use of ANY"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "350d6d8688893778ee7439463a694eb05107455b", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/350d6d8688893778ee7439463a694eb05107455b", "committedDate": "2020-08-11T12:43:38Z", "message": "add comments on overflow detection in float and double converters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "032c6f70bc6397cee1bd22fc42059f10ef34a05c", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/032c6f70bc6397cee1bd22fc42059f10ef34a05c", "committedDate": "2020-08-11T12:43:38Z", "message": "document possible values of NULL type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f65c6c1252574806022ec6d6a093dbf63e4c6c7c", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f65c6c1252574806022ec6d6a093dbf63e4c6c7c", "committedDate": "2020-08-11T12:43:38Z", "message": "fix hashCode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d90a606693da537cad5699bc120862a6c7717322", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d90a606693da537cad5699bc120862a6c7717322", "committedDate": "2020-08-11T12:43:38Z", "message": "verify return types after conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dd24552cf8438aa8aa0a474d0fd0ef0881e71be", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0dd24552cf8438aa8aa0a474d0fd0ef0881e71be", "committedDate": "2020-08-11T12:43:38Z", "message": "literal end-to-end tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01bfa3e4d92413747dde9eed7bebffb209eaef11", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/01bfa3e4d92413747dde9eed7bebffb209eaef11", "committedDate": "2020-08-11T12:43:39Z", "message": "parameter end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3617986802b14265dd71d48db72d4f959d0bfad8", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3617986802b14265dd71d48db72d4f959d0bfad8", "committedDate": "2020-08-11T12:43:39Z", "message": "column expression end-to-end tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aac21d4f61c4b81bb264ce358bf1b9bb7753cd2b", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/aac21d4f61c4b81bb264ce358bf1b9bb7753cd2b", "committedDate": "2020-08-11T12:43:39Z", "message": "cast expression end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "452e431632d85dcf275b836692303c1ae97e6170", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/452e431632d85dcf275b836692303c1ae97e6170", "committedDate": "2020-08-11T12:43:39Z", "message": "proper name for cast end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae76893b76c855f16a76d2d413a370dbe427230a", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ae76893b76c855f16a76d2d413a370dbe427230a", "committedDate": "2020-08-11T12:43:39Z", "message": "plus end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23a3fbd49d39a52b53e174a6444ee811e44b6934", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/23a3fbd49d39a52b53e174a6444ee811e44b6934", "committedDate": "2020-08-11T12:43:39Z", "message": "port 83996e1313ddc8d80991e1bb3068d86cee30e599"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4654afd0ef5d35138d273cbe2caadac527b30bbe", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4654afd0ef5d35138d273cbe2caadac527b30bbe", "committedDate": "2020-08-11T12:43:40Z", "message": "test non-canonical parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f68c2d5d4f0783440b6aefeb10d1f9f9ceab2d21", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f68c2d5d4f0783440b6aefeb10d1f9f9ceab2d21", "committedDate": "2020-08-11T12:43:40Z", "message": "minsu end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b9451b714a1f139452bded8a80121a796631dc", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/63b9451b714a1f139452bded8a80121a796631dc", "committedDate": "2020-08-11T12:43:40Z", "message": "add HZ OBJECT type + remove unneeded tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d642bd1c926b3e545526f5a27d2da2ea0de085d", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3d642bd1c926b3e545526f5a27d2da2ea0de085d", "committedDate": "2020-08-11T12:43:40Z", "message": "assign OBJECT type to parameters of IS [NOT] NULL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7d6f93f63c498bf64e6cee961681c21d5e40722", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a7d6f93f63c498bf64e6cee961681c21d5e40722", "committedDate": "2020-08-11T12:43:40Z", "message": "simplify if-assert logic in ConstantExpression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40bb767eed1a76052d4d2a8c9e77a1c5abdcc36d", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/40bb767eed1a76052d4d2a8c9e77a1c5abdcc36d", "committedDate": "2020-08-11T12:43:40Z", "message": "move InvalidExpressionTest tests to ParserOperationsTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31c85affa8c760fdd22d86aa1fb4d1a67c3e4351", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/31c85affa8c760fdd22d86aa1fb4d1a67c3e4351", "committedDate": "2020-08-11T12:43:40Z", "message": "remove temporal types support from RexToExpression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "190a854f4eb7a7fd868124c00be29962b830df4b", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/190a854f4eb7a7fd868124c00be29962b830df4b", "committedDate": "2020-08-11T12:43:40Z", "message": "remove temporal types support from UnsupportedOperationVisitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b54b2a93ee3be5422253836d86365b0357990363", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b54b2a93ee3be5422253836d86365b0357990363", "committedDate": "2020-08-11T12:43:40Z", "message": "document how exactly our behavior differs from Calcite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "683795c7ffc19b4842d7357434ee1f727b01c08e", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/683795c7ffc19b4842d7357434ee1f727b01c08e", "committedDate": "2020-08-11T12:43:41Z", "message": "clarify the purpose of HazelcastOperatorTableVisitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "196a087a4f51d9042a5080457d8cb150f2dbb4d1", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/196a087a4f51d9042a5080457d8cb150f2dbb4d1", "committedDate": "2020-08-11T12:43:41Z", "message": "fix monotonicity for HazelcastSqlBinaryOperator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8690fb9d606d4a9d2d85cacf9aa9a2cd4150d7f7", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8690fb9d606d4a9d2d85cacf9aa9a2cd4150d7f7", "committedDate": "2020-08-11T12:43:41Z", "message": "remove useless null logic for 'else' result of CaseExpression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5f70630bf872e146dfcc27ce28cf4890e28e7f9", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e5f70630bf872e146dfcc27ce28cf4890e28e7f9", "committedDate": "2020-08-11T12:43:41Z", "message": "opimize away synthetic CASTs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e81d393bcd4d28d1decbec8d1b2414d0e322c2d", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7e81d393bcd4d28d1decbec8d1b2414d0e322c2d", "committedDate": "2020-08-11T12:43:41Z", "message": "clarify the purpose of HazelcastSqlValidator.knownNodeTypes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a01f204b9b715c2a8656d3450b168c96889d75e", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1a01f204b9b715c2a8656d3450b168c96889d75e", "committedDate": "2020-08-11T12:43:41Z", "message": "remove type ineference for offset-limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05faf0864dafae68156bda42723eced832e0510e", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/05faf0864dafae68156bda42723eced832e0510e", "committedDate": "2020-08-11T12:43:41Z", "message": "remove DDL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84feba0499fcd9cdf6efc0e1727ceac0a23d99d4", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/84feba0499fcd9cdf6efc0e1727ceac0a23d99d4", "committedDate": "2020-08-11T12:43:41Z", "message": "clarify rewtiting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea483ee33ee089b8770168f87d5824fe5441a6f6", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ea483ee33ee089b8770168f87d5824fe5441a6f6", "committedDate": "2020-08-11T12:43:41Z", "message": "support exact and approximate floating point literals"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9571edf300ea1a97fac9a5f62942a5202ff1ddb9", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9571edf300ea1a97fac9a5f62942a5202ff1ddb9", "committedDate": "2020-08-11T12:43:42Z", "message": "remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00ad4708074fb1ae51ef69f26d0bea6e8c82bff1", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/00ad4708074fb1ae51ef69f26d0bea6e8c82bff1", "committedDate": "2020-08-11T12:43:42Z", "message": "remove dead code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c7129166ef03edcdb3c9c75b4a038f4b78869a4", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8c7129166ef03edcdb3c9c75b4a038f4b78869a4", "committedDate": "2020-08-11T12:43:42Z", "message": "remove dead code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5737897a8557649b70d6ae799ded85c4d88ae6a1", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5737897a8557649b70d6ae799ded85c4d88ae6a1", "committedDate": "2020-08-11T12:43:42Z", "message": "rename INT to INTEGER"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6372dff050bb2f3f1f2725cf656a165b1881b6c", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c6372dff050bb2f3f1f2725cf656a165b1881b6c", "committedDate": "2020-08-11T12:43:42Z", "message": "fix a typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98edf085ecaf6ce27216d4113de555f11d84335a", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/98edf085ecaf6ce27216d4113de555f11d84335a", "committedDate": "2020-08-11T12:43:42Z", "message": "rebase and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ac530fe4ea3fdd1ad8a5610171441284ef32506", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7ac530fe4ea3fdd1ad8a5610171441284ef32506", "committedDate": "2020-08-11T12:43:42Z", "message": "simplify BiExpressionWithType.equals"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f09814a0ecadbe3820b781ac44783f0dcfcd28fd", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f09814a0ecadbe3820b781ac44783f0dcfcd28fd", "committedDate": "2020-08-11T12:43:42Z", "message": "avoid hardcoded operator precedence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ee75a995e29dd2ff7f7b1024e3578dff5981d1", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a8ee75a995e29dd2ff7f7b1024e3578dff5981d1", "committedDate": "2020-08-11T12:43:42Z", "message": "document NULL type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fecec42622a3a5ad8a5ba4b41fcf6f9b41503af", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1fecec42622a3a5ad8a5ba4b41fcf6f9b41503af", "committedDate": "2020-08-11T12:43:42Z", "message": "catch more exceptions during parameter conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00e59bbefd1cdb74950fd1a141c0b0930f1b86aa", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/00e59bbefd1cdb74950fd1a141c0b0930f1b86aa", "committedDate": "2020-08-11T12:43:43Z", "message": "more precise error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413526ab68c0a677105d0869c47d9ddf24c3276f", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/413526ab68c0a677105d0869c47d9ddf24c3276f", "committedDate": "2020-08-11T12:43:43Z", "message": "more detailed error messages for arithmetic operators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5409eca7502ece5e69ea92279e885431955e810e", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5409eca7502ece5e69ea92279e885431955e810e", "committedDate": "2020-08-11T12:43:43Z", "message": "more detailed error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b6159d344703bdda317fd2f675320b96a677969", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7b6159d344703bdda317fd2f675320b96a677969", "committedDate": "2020-08-11T12:43:43Z", "message": "more precise bit width calculation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53fd6bbbc74702110eb61ad4cff9a80d6be9b631", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/53fd6bbbc74702110eb61ad4cff9a80d6be9b631", "committedDate": "2020-08-11T12:43:43Z", "message": "test standalone parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d10d2bb0c27cce8675022c5e52a3e514d1021d6", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8d10d2bb0c27cce8675022c5e52a3e514d1021d6", "committedDate": "2020-08-11T12:43:43Z", "message": "more detailed parameter conversion error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3af9fc7778ead880e2834bfaf036e0376846a1a5", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3af9fc7778ead880e2834bfaf036e0376846a1a5", "committedDate": "2020-08-11T12:43:43Z", "message": "add multiply end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d39f010a5cced023ed897ecab46da32b64aedbb", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8d39f010a5cced023ed897ecab46da32b64aedbb", "committedDate": "2020-08-11T12:43:43Z", "message": "add divide end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dcda63a3b6d4fabb0500435bb52f3bb8ecfe587", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6dcda63a3b6d4fabb0500435bb52f3bb8ecfe587", "committedDate": "2020-08-11T12:43:44Z", "message": "add unary plus end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88efcd37f3ca342174d1f080be460b288a76f4d", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d88efcd37f3ca342174d1f080be460b288a76f4d", "committedDate": "2020-08-11T12:43:44Z", "message": "add unary minus end-to-end test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02fdd8fd63a7ffa3c867e7c4f0480aeb32bea11c", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/02fdd8fd63a7ffa3c867e7c4f0480aeb32bea11c", "committedDate": "2020-08-11T12:43:44Z", "message": "test for BigInteger in unary plus and minus tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e2d056d9213c5e9f22774338c92a9b03072d58c", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0e2d056d9213c5e9f22774338c92a9b03072d58c", "committedDate": "2020-08-11T12:43:44Z", "message": "improve type system docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6445dd5ec40fb914cf170f8aaa7b6b5f04f3681e", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6445dd5ec40fb914cf170f8aaa7b6b5f04f3681e", "committedDate": "2020-08-11T12:43:44Z", "message": "document edge case values for HazelcastIntegerType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f4a3a8ddd8d0f8718ef68ae6a05c25a5f509409", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0f4a3a8ddd8d0f8718ef68ae6a05c25a5f509409", "committedDate": "2020-08-11T12:43:44Z", "message": "remove values from error messages + test for more values in case test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1f6135b32558453e010cda651b7cae4f319b479", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a1f6135b32558453e010cda651b7cae4f319b479", "committedDate": "2020-08-11T12:43:44Z", "message": "remove case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "386eb743f6550a106bfb9babdf82fc3779ff6fa6", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/386eb743f6550a106bfb9babdf82fc3779ff6fa6", "committedDate": "2020-08-11T12:43:44Z", "message": "remove case part #2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6f3eae722fc375debc4700be52ee78deb5b6572", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d6f3eae722fc375debc4700be52ee78deb5b6572", "committedDate": "2020-08-11T12:43:44Z", "message": "better division by zero for floats and doubles"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "084c08a2d61de582664c629d7412d31dac006e86", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/084c08a2d61de582664c629d7412d31dac006e86", "committedDate": "2020-08-11T11:52:17Z", "message": "better division by zero for floats and doubles"}, "afterCommit": {"oid": "d6f3eae722fc375debc4700be52ee78deb5b6572", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d6f3eae722fc375debc4700be52ee78deb5b6572", "committedDate": "2020-08-11T12:43:44Z", "message": "better division by zero for floats and doubles"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzM0MTYw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-465734160", "createdAt": "2020-08-12T09:13:46Z", "commit": {"oid": "d6f3eae722fc375debc4700be52ee78deb5b6572"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTU2NjA5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-443956609", "createdAt": "2020-07-07T14:37:55Z", "commit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDozNzo1NVrOGuBrew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDo1Njo1MFrOGuPTQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTE5NQ==", "bodyText": "XXX?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450915195", "createdAt": "2020-07-07T14:37:55Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastRexBuilder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+\n+/**\n+ * Custom Hazelcast expression builder.\n+ * <p>\n+ * Currently, this custom expression builder is used just to workaround quirks\n+ * of the default Calcite expression builder.\n+ */\n+public final class HazelcastRexBuilder extends RexBuilder {\n+\n+    public HazelcastRexBuilder(RelDataTypeFactory typeFactory) {\n+        super(typeFactory);\n+        assert typeFactory instanceof HazelcastTypeFactory;\n+    }\n+\n+    @Override\n+    public RexNode makeLiteral(Object value, RelDataType type, boolean allowCast) {\n+        // XXX: Calcite evaluates casts like CAST(0 AS ANY) statically and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkzMTI1Mw==", "bodyText": "We can have the case CHAR: just before the default:, this comment is easier to miss.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450931253", "createdAt": "2020-07-07T14:58:54Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -106,16 +125,46 @@ public Void visit(SqlIdentifier id) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n     @Override\n     public Void visit(SqlDataTypeSpec type) {\n-        throw error(type, RESOURCE.custom(\"Type specification is not supported\"));\n+        if (!(type.getTypeNameSpec() instanceof SqlBasicTypeNameSpec)) {\n+            throw error(type, RESOURCE.custom(\"Complex type specifications are not supported\"));\n+        }\n+\n+        SqlTypeName typeName = SqlTypeName.get(type.getTypeName().getSimple());\n+        switch (typeName) {\n+            case BOOLEAN:\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case DOUBLE:\n+            case VARCHAR:\n+            // CHAR is missing here intentionally, to avoid constructs like\n+            // CAST(foo as CHAR).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0NjEzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assert resolvedOperators.isEmpty() || resolvedOperators.size() == 1;\n          \n          \n            \n            \n          \n          \n            \n                        if (!resolvedOperators.isEmpty()) {\n          \n          \n            \n                            basicCall.setOperator(resolvedOperators.get(0));\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        if (!resolvedOperators.isEmpty()) {\n          \n          \n            \n                            assert resolvedOperators.size() == 1;\n          \n          \n            \n                            basicCall.setOperator(resolvedOperators.get(0));\n          \n          \n            \n                        }", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450946135", "createdAt": "2020-07-07T15:19:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastOperatorTableVisitor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCase;\n+import org.apache.calcite.sql.SqlBasicCall;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.validate.SqlNameMatcher;\n+import org.apache.calcite.sql.validate.SqlNameMatchers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Rewrites operators in SqlNode tree from Calcite ones to Hazelcast ones.\n+ *\n+ * @see SqlStdOperatorTable\n+ * @see HazelcastSqlOperatorTable\n+ */\n+public final class HazelcastOperatorTableVisitor extends SqlBasicVisitor<Void> {\n+\n+    /**\n+     * Shared Hazelcast operator visitor instance.\n+     */\n+    public static final SqlBasicVisitor<Void> INSTANCE = new HazelcastOperatorTableVisitor();\n+\n+    private static final SqlNameMatcher NAME_MATCHER = SqlNameMatchers.withCaseSensitive(false);\n+\n+    private HazelcastOperatorTableVisitor() {\n+    }\n+\n+    @Override\n+    public Void visit(SqlCall call) {\n+        rewriteCall(call);\n+        return super.visit(call);\n+    }\n+\n+    @Override\n+    public Void visit(SqlNodeList nodeList) {\n+        rewriteNodeList(nodeList);\n+        return super.visit(nodeList);\n+    }\n+\n+    private static void rewriteCall(SqlCall call) {\n+        List<SqlNode> operands = call.getOperandList();\n+        for (int i = 0; i < operands.size(); ++i) {\n+            SqlNode operand = operands.get(i);\n+            if (!(operand instanceof SqlCase) || operand instanceof HazelcastSqlCase) {\n+                continue;\n+            }\n+\n+            SqlCase sqlCase = (SqlCase) operand;\n+            HazelcastSqlCase hazelcastSqlCase =\n+                    new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n+                            sqlCase.getThenOperands(), sqlCase.getElseOperand());\n+            call.setOperand(i, hazelcastSqlCase);\n+        }\n+\n+        if (call instanceof SqlBasicCall) {\n+            SqlBasicCall basicCall = (SqlBasicCall) call;\n+            SqlOperator operator = basicCall.getOperator();\n+\n+            List<SqlOperator> resolvedOperators = new ArrayList<>();\n+            HazelcastSqlOperatorTable.instance().lookupOperatorOverloads(operator.getNameAsId(), null, operator.getSyntax(),\n+                    resolvedOperators, NAME_MATCHER);\n+            assert resolvedOperators.isEmpty() || resolvedOperators.size() == 1;\n+\n+            if (!resolvedOperators.isEmpty()) {\n+                basicCall.setOperator(resolvedOperators.get(0));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MTEyNw==", "bodyText": "The method tryRewriteSqlCase can be reused in rewriteCall:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static void rewriteNodeList(SqlNodeList nodeList) {\n          \n          \n            \n                    for (int i = 0; i < nodeList.size(); ++i) {\n          \n          \n            \n                        SqlNode node = nodeList.get(i);\n          \n          \n            \n                        if (!(node instanceof SqlCase) || node instanceof HazelcastSqlCase) {\n          \n          \n            \n                            continue;\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        SqlCase sqlCase = (SqlCase) node;\n          \n          \n            \n                        HazelcastSqlCase hazelcastSqlCase =\n          \n          \n            \n                                new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n          \n          \n            \n                                        sqlCase.getThenOperands(), sqlCase.getElseOperand());\n          \n          \n            \n                        nodeList.set(i, hazelcastSqlCase);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private static void rewriteNodeList(SqlNodeList nodeList) {\n          \n          \n            \n                    for (int i = 0; i < nodeList.size(); ++i) {\n          \n          \n            \n                        nodeList.set(i,\n          \n          \n            \n                                tryRewriteSqlCase(nodeList.get(i)));\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static SqlNode tryRewriteSqlCase(SqlNode node) {\n          \n          \n            \n                    if (node instanceof SqlCase && !(node instanceof HazelcastSqlCase)) {\n          \n          \n            \n                        SqlCase sqlCase = (SqlCase) node;\n          \n          \n            \n                        HazelcastSqlCase hazelcastSqlCase =\n          \n          \n            \n                                new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n          \n          \n            \n                                        sqlCase.getThenOperands(), sqlCase.getElseOperand());\n          \n          \n            \n            \n          \n          \n            \n                        return hazelcastSqlCase;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return node;\n          \n          \n            \n                }", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450951127", "createdAt": "2020-07-07T15:26:06Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastOperatorTableVisitor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCase;\n+import org.apache.calcite.sql.SqlBasicCall;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.validate.SqlNameMatcher;\n+import org.apache.calcite.sql.validate.SqlNameMatchers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Rewrites operators in SqlNode tree from Calcite ones to Hazelcast ones.\n+ *\n+ * @see SqlStdOperatorTable\n+ * @see HazelcastSqlOperatorTable\n+ */\n+public final class HazelcastOperatorTableVisitor extends SqlBasicVisitor<Void> {\n+\n+    /**\n+     * Shared Hazelcast operator visitor instance.\n+     */\n+    public static final SqlBasicVisitor<Void> INSTANCE = new HazelcastOperatorTableVisitor();\n+\n+    private static final SqlNameMatcher NAME_MATCHER = SqlNameMatchers.withCaseSensitive(false);\n+\n+    private HazelcastOperatorTableVisitor() {\n+    }\n+\n+    @Override\n+    public Void visit(SqlCall call) {\n+        rewriteCall(call);\n+        return super.visit(call);\n+    }\n+\n+    @Override\n+    public Void visit(SqlNodeList nodeList) {\n+        rewriteNodeList(nodeList);\n+        return super.visit(nodeList);\n+    }\n+\n+    private static void rewriteCall(SqlCall call) {\n+        List<SqlNode> operands = call.getOperandList();\n+        for (int i = 0; i < operands.size(); ++i) {\n+            SqlNode operand = operands.get(i);\n+            if (!(operand instanceof SqlCase) || operand instanceof HazelcastSqlCase) {\n+                continue;\n+            }\n+\n+            SqlCase sqlCase = (SqlCase) operand;\n+            HazelcastSqlCase hazelcastSqlCase =\n+                    new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n+                            sqlCase.getThenOperands(), sqlCase.getElseOperand());\n+            call.setOperand(i, hazelcastSqlCase);\n+        }\n+\n+        if (call instanceof SqlBasicCall) {\n+            SqlBasicCall basicCall = (SqlBasicCall) call;\n+            SqlOperator operator = basicCall.getOperator();\n+\n+            List<SqlOperator> resolvedOperators = new ArrayList<>();\n+            HazelcastSqlOperatorTable.instance().lookupOperatorOverloads(operator.getNameAsId(), null, operator.getSyntax(),\n+                    resolvedOperators, NAME_MATCHER);\n+            assert resolvedOperators.isEmpty() || resolvedOperators.size() == 1;\n+\n+            if (!resolvedOperators.isEmpty()) {\n+                basicCall.setOperator(resolvedOperators.get(0));\n+            }\n+        }\n+    }\n+\n+    private static void rewriteNodeList(SqlNodeList nodeList) {\n+        for (int i = 0; i < nodeList.size(); ++i) {\n+            SqlNode node = nodeList.get(i);\n+            if (!(node instanceof SqlCase) || node instanceof HazelcastSqlCase) {\n+                continue;\n+            }\n+\n+            SqlCase sqlCase = (SqlCase) node;\n+            HazelcastSqlCase hazelcastSqlCase =\n+                    new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n+                            sqlCase.getThenOperands(), sqlCase.getElseOperand());\n+            nodeList.set(i, hazelcastSqlCase);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NTA3MA==", "bodyText": "SqlNode doesn't implement hashCode, it might be better to use IdentityHashMap to show the intent.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450955070", "createdAt": "2020-07-07T15:31:35Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NjQ1Mw==", "bodyText": "Took me a while to get this comment, this might be better:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sets a known type of the given node to the given type in this validator.\n          \n          \n            \n                 * Sets {@code type} as the known type for {@code node}.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450956453", "createdAt": "2020-07-07T15:33:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new HashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets a known type of the given node to the given type in this validator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNzM3OA==", "bodyText": "What's this?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451017378", "createdAt": "2020-07-07T17:09:56Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -16,13 +16,257 @@\n \n package com.hazelcast.sql.impl.calcite.validate;\n \n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCaseOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCastFunction;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlMonotonicBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastReturnTypes;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlPostfixOperator;\n+import org.apache.calcite.sql.SqlPrefixOperator;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n import org.apache.calcite.sql.util.ReflectiveSqlOperatorTable;\n \n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAllNull;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n /**\n- * An additional functions that are resolved during query parsing/validation.\n+ * Custom functions and operators.\n  */\n public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable {\n \n+    //@formatter:off", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzODM2OQ==", "bodyText": "We test a value that's too big for BIGINT. We should test a value that's too big for TINYINT, that is Byte.MAX_VALUE + 1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451138369", "createdAt": "2020-07-07T20:56:50Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java", "diffHunk": "@@ -313,13 +337,18 @@ public void testDoubleConverter() {\n         checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, OBJECT);\n \n         double val = 1.1d;\n+        double bigValue = Long.MAX_VALUE * 2.5d;\n \n         assertEquals(\"1.1\", converter.asVarchar(val));\n \n         assertEquals(1, converter.asTinyint(val));\n+        checkDataException(() -> converter.asTinyint(bigValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fb741905b091cfa877a05823a92b6d7175df389"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDg3MTYz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444487163", "createdAt": "2020-07-08T07:40:14Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzo0MDoxNFrOGub4xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzo0MDoxNFrOGub4xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw==", "bodyText": "What does CAST X as ANY mean from the user perspective? We do not have ANY type that is exposed to a user, do we?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451344583", "createdAt": "2020-07-08T07:40:14Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastRexBuilder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+\n+/**\n+ * Custom Hazelcast expression builder.\n+ * <p>\n+ * Currently, this custom expression builder is used just to workaround quirks\n+ * of the default Calcite expression builder.\n+ */\n+public final class HazelcastRexBuilder extends RexBuilder {\n+\n+    public HazelcastRexBuilder(RelDataTypeFactory typeFactory) {\n+        super(typeFactory);\n+        assert typeFactory instanceof HazelcastTypeFactory;\n+    }\n+\n+    @Override\n+    public RexNode makeLiteral(Object value, RelDataType type, boolean allowCast) {\n+        // XXX: Calcite evaluates casts like CAST(0 AS ANY) statically and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTEwNzU3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444510757", "createdAt": "2020-07-08T08:12:36Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoxMjozN1rOGudA0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoxMjozN1rOGudA0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzAyNg==", "bodyText": "This code produces a generic data exception. We will not be able to map it properly to SQLSTATE codes for JDBC in the future. ANSI SQL declares a family of error codes for data exceptions, with numeric value out of range being a special separate code.\nI am not sure that we should introduce many sub-codes for data exception at the moment, because we do not have JDBC. But at the very least the error message should reflect that overflow happened. This is not the case now since we throw an abstract Cannot convert ..., without explaining why the conversion is not possible.\nThis applicable to all numeric converters, not only ShortConverter.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451363026", "createdAt": "2020-07-08T08:12:37Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/ShortConverter.java", "diffHunk": "@@ -38,7 +40,14 @@ private ShortConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        short casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != casted) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTEzOTk2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444513996", "createdAt": "2020-07-08T08:16:52Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoxNjo1M1rOGudKNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoxNjo1M1rOGudKNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2NTQyOA==", "bodyText": "Is there a specific reason why we picked HALF_DOWN here, and not HALF_UP or HALF_EVEN? Can we have JavaDoc explaining this decision?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451365428", "createdAt": "2020-07-08T08:16:53Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/ExpressionMath.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+\n+import java.math.MathContext;\n+import java.math.RoundingMode;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.MAX_DECIMAL_PRECISION;\n+\n+/**\n+ * Utility methods for math functions.\n+ */\n+public final class ExpressionMath {\n+\n+    /**\n+     * Math context used by expressions while doing math on BigDecimal values.\n+     */\n+    public static final MathContext DECIMAL_MATH_CONTEXT = new MathContext(MAX_DECIMAL_PRECISION, RoundingMode.HALF_DOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTE4ODEw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444518810", "createdAt": "2020-07-08T08:23:10Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyMzoxMFrOGudY3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyMzoxMFrOGudY3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTE4MQ==", "bodyText": "Why do we cast to int here to check for overflow, but cast to long in the asInt method?\nIs it possible that due to overflow castedInt != castedLong but castedInt == castedShort?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451369181", "createdAt": "2020-07-08T08:23:10Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/FloatConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private FloatConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        float casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        float casted = cast(val);\n+        short converted = (short) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTIxMDU3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444521057", "createdAt": "2020-07-08T08:26:01Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyNjowMVrOGudfnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyNjowMVrOGudfnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDkxMQ==", "bodyText": "The (String val, MathContext mc) constructor is really heavy. Is there a reason why we cannot use (Double val, MathContext mc) here?\nI look at asDouble implementation, and there are no additional checks there.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451370911", "createdAt": "2020-07-08T08:26:01Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/FloatConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private FloatConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        float casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        float casted = cast(val);\n+        short converted = (short) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        float casted = cast(val);\n+        int converted = (int) casted;\n+\n+        if (converted != (long) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        float casted = cast(val);\n+        float truncated = (float) (casted > 0.0 ? Math.floor(casted) : Math.ceil(casted));\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((float) converted != truncated) {\n+            throw cannotConvert(QueryDataTypeFamily.BIGINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public BigDecimal asDecimal(Object val) {\n-        return BigDecimal.valueOf(cast(val));\n+        return new BigDecimal(Float.toString(cast(val)), DECIMAL_MATH_CONTEXT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTIzNTAy", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444523502", "createdAt": "2020-07-08T08:29:09Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyOTowOVrOGudnIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyOTowOVrOGudnIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MjgzNQ==", "bodyText": "Same concern as in the FloatConverter", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451372835", "createdAt": "2020-07-08T08:29:09Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/DoubleConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private DoubleConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        double casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Double.isFinite(casted)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTIzNjEy", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444523612", "createdAt": "2020-07-08T08:29:18Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyOToxOFrOGudnfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyOToxOFrOGudnfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MjkyNA==", "bodyText": "Same concern as in the FloatConverter", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451372924", "createdAt": "2020-07-08T08:29:18Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/DoubleConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private DoubleConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        double casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        double casted = cast(val);\n+        short converted = (short) casted;\n+\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        double casted = cast(val);\n+        int converted = (int) casted;\n+\n+        if (converted != (long) casted || !Double.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        double casted = cast(val);\n+        double truncated = casted > 0.0 ? Math.floor(casted) : Math.ceil(casted);\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((double) converted != truncated) {\n+            throw cannotConvert(QueryDataTypeFamily.BIGINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public BigDecimal asDecimal(Object val) {\n-        return BigDecimal.valueOf(cast(val));\n+        return new BigDecimal(Double.toString(cast(val)), DECIMAL_MATH_CONTEXT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTM1OTk1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444535995", "createdAt": "2020-07-08T08:45:04Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0NTowNFrOGueNbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0NTowNFrOGueNbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MjYzOA==", "bodyText": "What if conversion fails here? Users should receive a proper exception that a parameter on the position N of type T1 cannot be converted to a type T2. Looks like this is not the case.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451382638", "createdAt": "2020-07-08T08:45:04Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -195,4 +195,27 @@ public QueryStateRegistry getStateRegistry() {\n     public QueryOperationHandlerImpl getOperationHandler() {\n         return operationHandler;\n     }\n+\n+    private void prepareParameters(Plan plan, List<Object> params) {\n+        assert params != null;\n+        QueryParameterMetadata parameterMetadata = plan.getParameterMetadata();\n+\n+        int parameterCount = parameterMetadata.getParameterCount();\n+        if (parameterCount != params.size()) {\n+            throw QueryException.error(\"Unexpected parameter count: expected \" + parameterCount + \", got \" + params.size());\n+        }\n+\n+        for (int i = 0; i < params.size(); ++i) {\n+            Object value = params.get(i);\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            Converter valueConverter = Converters.getConverter(value.getClass());\n+            Converter typeConverter = parameterMetadata.getParameterType(i).getConverter();\n+            value = typeConverter.convertToSelf(valueConverter, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTM3NzA1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444537705", "createdAt": "2020-07-08T08:47:10Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0NzoxMFrOGueSpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0NzoxMFrOGueSpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4Mzk3Mg==", "bodyText": "Can we add a note to JavaDoc that returned value is always null?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451383972", "createdAt": "2020-07-08T08:47:10Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "diffHunk": "@@ -67,7 +67,12 @@\n     TIMESTAMP_WITH_TIME_ZONE(OffsetDateTime.class),\n \n     /** OBJECT type, could be represented by any Java class. */\n-    OBJECT(Object.class);\n+    OBJECT(Object.class),\n+\n+    /**\n+     * The type of the generic SQL {@code NULL} literal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTUwNTQz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444550543", "createdAt": "2020-07-08T09:03:16Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTowMzoxNlrOGue50A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTowMzoxNlrOGue50A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NDAwMA==", "bodyText": "The chosen approach with generated cases is extremely difficult to follow. I cannot reason on whether the coverage is sufficient or not, because looking at thousands of invocations requires too much time. Neither I can understand how to deal with it in the future - what should I do as a developer when a new expression is introduced, or when a failure is observed? And how do I ensure that the test framework itself is correct when it is filled with complicated logic?\nI would propose two things:\n\nWe need detailed documentation about the testing framework, so that other developers know how to deal with it\nGiven that the complexity of the framework is high, we'd better rely on a set of simple manually written end-to-end tests to get quick understanding of the behavior in common cases, and use this framework to cover the edge cases", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451394000", "createdAt": "2020-07-08T09:03:16Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java", "diffHunk": "@@ -0,0 +1,1190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.internal.util.RuntimeAvailableProcessors;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.calcite.OptimizerContext;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchemaUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.schema.MapTableStatistic;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.TestStringUtils;\n+import org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlIntervalQualifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.junit.After;\n+\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.sql.impl.calcite.SqlToQueryType.mapRowType;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static java.util.Collections.singletonMap;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.FRACTIONAL_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.INT_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public abstract class ExpressionTestBase extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTU3MTUx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444557151", "createdAt": "2020-07-08T09:12:06Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToxMjowNlrOGufNKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToxMjowNlrOGufNKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODk1NQ==", "bodyText": "Can we propagate ID here to facilitate debugging?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451398955", "createdAt": "2020-07-08T09:12:06Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java", "diffHunk": "@@ -0,0 +1,1190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.internal.util.RuntimeAvailableProcessors;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.calcite.OptimizerContext;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchemaUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.schema.MapTableStatistic;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.TestStringUtils;\n+import org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlIntervalQualifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.junit.After;\n+\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.sql.impl.calcite.SqlToQueryType.mapRowType;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static java.util.Collections.singletonMap;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.FRACTIONAL_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.INT_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public abstract class ExpressionTestBase extends SqlTestSupport {\n+\n+    private static final boolean VERIFY_EVALUATION = true;\n+\n+    private static final boolean TRACE = true;\n+    private static final boolean LOG_ON_SUCCESS = false;\n+\n+    protected static final RelDataType UNKNOWN_TYPE = null;\n+    protected static final SqlTypeName UNKNOWN_TYPE_NAME = null;\n+\n+    protected static final Object UNKNOWN_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"UNKNOWN\";\n+        }\n+    };\n+\n+    protected static final Object INVALID_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"INVALID\";\n+        }\n+    };\n+    protected static final BigDecimal INVALID_NUMERIC_VALUE = new BigDecimal(0);\n+    @SuppressWarnings({\"checkstyle:IllegalInstantiation\", \"UnnecessaryBoxing\", \"BooleanConstructorCall\"})\n+    protected static final Boolean INVALID_BOOLEAN_VALUE = new Boolean(true);\n+\n+    public static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    protected static final List<Operand> COLUMNS = new ArrayList<>();\n+    protected static final List<Operand> LITERALS = new ArrayList<>();\n+    protected static final List<Operand> PARAMETERS = new ArrayList<>();\n+    protected static final List<Operand> TYPES = new ArrayList<>();\n+\n+    protected static final List<Operand> BOOLEAN_COLUMN = new ArrayList<>();\n+\n+    protected static final SqlOperator IDENTITY = new SqlOperator(\"\", SqlKind.OTHER, 0, 0, null, null, null) {\n+        @Override\n+        public SqlSyntax getSyntax() {\n+            return SqlSyntax.PREFIX;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return SqlOperandCountRanges.of(1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"IDENTITY\";\n+        }\n+    };\n+\n+    private static final SqlTypeName[] TYPE_NAMES;\n+\n+    static {\n+        TYPE_NAMES = new SqlTypeName[]{VARCHAR, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, REAL, DOUBLE, ANY, NULL};\n+    }\n+\n+    private static final Map<String, QueryDataType> FIELDS;\n+    private static final Map<String, Integer> FIELD_TO_INDEX;\n+    private static final PlanNodeSchema SCHEMA;\n+\n+    static {\n+        Map<String, QueryDataType> fields = new LinkedHashMap<>();\n+        for (SqlTypeName type : TYPE_NAMES) {\n+            if (type == NULL) {\n+                // null is synthetic internal type\n+                continue;\n+            }\n+\n+            fields.put(type.getName().toLowerCase() + \"1\", SqlToQueryType.map(type));\n+            fields.put(type.getName().toLowerCase() + \"2\", SqlToQueryType.map(type));\n+        }\n+\n+        FIELDS = Collections.unmodifiableMap(fields);\n+        SCHEMA = new PlanNodeSchema(new ArrayList<>(FIELDS.values()));\n+\n+        FIELD_TO_INDEX = new HashMap<>();\n+        int i = 0;\n+        for (String field : FIELDS.keySet()) {\n+            FIELD_TO_INDEX.put(field, i++);\n+        }\n+    }\n+\n+    static {\n+        // Literals.\n+\n+        LITERALS.add(numericLiteral(0));\n+        LITERALS.add(numericLiteral(1));\n+        LITERALS.add(numericLiteral(-1));\n+        LITERALS.add(numericLiteral(10));\n+        LITERALS.add(numericLiteral(-10));\n+\n+        long byteMax = Byte.MAX_VALUE;\n+        long byteMin = Byte.MIN_VALUE;\n+        LITERALS.add(numericLiteral(byteMax));\n+        LITERALS.add(numericLiteral(byteMax - 1));\n+        LITERALS.add(numericLiteral(byteMax + 1));\n+        LITERALS.add(numericLiteral(byteMax - 2));\n+        LITERALS.add(numericLiteral(byteMax + 2));\n+        LITERALS.add(numericLiteral(byteMin));\n+        LITERALS.add(numericLiteral(byteMin - 1));\n+        LITERALS.add(numericLiteral(byteMin + 1));\n+        LITERALS.add(numericLiteral(byteMin - 2));\n+        LITERALS.add(numericLiteral(byteMin + 2));\n+\n+        long shortMax = Short.MAX_VALUE;\n+        long shortMin = Short.MIN_VALUE;\n+        LITERALS.add(numericLiteral(shortMax));\n+        LITERALS.add(numericLiteral(shortMax - 1));\n+        LITERALS.add(numericLiteral(shortMax + 1));\n+        LITERALS.add(numericLiteral(shortMax - 2));\n+        LITERALS.add(numericLiteral(shortMax + 2));\n+        LITERALS.add(numericLiteral(shortMin));\n+        LITERALS.add(numericLiteral(shortMin - 1));\n+        LITERALS.add(numericLiteral(shortMin + 1));\n+        LITERALS.add(numericLiteral(shortMin - 2));\n+        LITERALS.add(numericLiteral(shortMin + 2));\n+\n+        long intMax = Integer.MAX_VALUE;\n+        long intMin = Integer.MIN_VALUE;\n+        LITERALS.add(numericLiteral(intMax));\n+        LITERALS.add(numericLiteral(intMax - 1));\n+        LITERALS.add(numericLiteral(intMax + 1));\n+        LITERALS.add(numericLiteral(intMax - 2));\n+        LITERALS.add(numericLiteral(intMax + 2));\n+        LITERALS.add(numericLiteral(intMin));\n+        LITERALS.add(numericLiteral(intMin - 1));\n+        LITERALS.add(numericLiteral(intMin + 1));\n+        LITERALS.add(numericLiteral(intMin - 2));\n+        LITERALS.add(numericLiteral(intMin + 2));\n+\n+        BigInteger longMax = BigInteger.valueOf(Long.MAX_VALUE);\n+        BigInteger longMin = BigInteger.valueOf(Long.MIN_VALUE);\n+        LITERALS.add(numericLiteral(longMax));\n+        LITERALS.add(numericLiteral(longMax.subtract(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMax.add(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMax.subtract(BigInteger.valueOf(2))));\n+        LITERALS.add(numericLiteral(longMax.add(BigInteger.valueOf(2))));\n+        LITERALS.add(numericLiteral(longMin));\n+        LITERALS.add(numericLiteral(longMin.subtract(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMin.add(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMin.subtract(BigInteger.valueOf(2))));\n+        LITERALS.add(numericLiteral(longMin.add(BigInteger.valueOf(2))));\n+\n+        LITERALS.add(numericLiteral(\"0.0\"));\n+        LITERALS.add(numericLiteral(\"1.0\"));\n+        LITERALS.add(numericLiteral(\"10.01\"));\n+        LITERALS.add(numericLiteral(\"-10.01\"));\n+        LITERALS.add(numericLiteral(\"9223372036854775808.01\"));\n+\n+        LITERALS.add(numericLiteral(\"1\" + TestStringUtils.repeat(\"0\", HazelcastTypeSystem.MAX_DECIMAL_PRECISION)));\n+        LITERALS.add(numericLiteral(\"1\" + TestStringUtils.repeat(\"0\", HazelcastTypeSystem.MAX_DECIMAL_PRECISION) + \".01\"));\n+\n+        LITERALS.add(new Operand(TYPE_FACTORY.createSqlType(BOOLEAN), false, \"FALSE\"));\n+        LITERALS.add(new Operand(TYPE_FACTORY.createSqlType(BOOLEAN), true, \"TRUE\"));\n+\n+        // produce string representations of the literals added above\n+        int size = LITERALS.size();\n+        for (int i = 0; i < size; ++i) {\n+            LITERALS.add(stringLiteral(LITERALS.get(i).text));\n+        }\n+\n+        LITERALS.add(new Operand(TYPE_FACTORY.createSqlType(NULL), null, \"NULL\"));\n+        LITERALS.add(stringLiteral(\"abc\"));\n+\n+        // Columns and types as seen in CASTs.\n+\n+        for (SqlTypeName typeName : TYPE_NAMES) {\n+            if (typeName == NULL) {\n+                // null is synthetic internal type\n+                continue;\n+            }\n+\n+            RelDataType type;\n+            switch (typeName) {\n+                case INTERVAL_YEAR_MONTH:\n+                    type = TYPE_FACTORY.createSqlIntervalType(\n+                            new SqlIntervalQualifier(TimeUnit.YEAR, TimeUnit.MONTH, SqlParserPos.ZERO));\n+                    break;\n+                case INTERVAL_DAY_SECOND:\n+                    type = TYPE_FACTORY.createSqlIntervalType(\n+                            new SqlIntervalQualifier(TimeUnit.DAY, TimeUnit.SECOND, SqlParserPos.ZERO));\n+                    break;\n+                default:\n+                    type = TYPE_FACTORY.createSqlType(typeName);\n+                    break;\n+            }\n+\n+            TYPES.add(new Operand(UNKNOWN_TYPE, type, unparse(type)));\n+\n+            type = TYPE_FACTORY.createTypeWithNullability(type, true);\n+            COLUMNS.add(new Operand(type, UNKNOWN_VALUE, typeName.getName().toLowerCase() + \"1\"));\n+            COLUMNS.add(new Operand(type, UNKNOWN_VALUE, typeName.getName().toLowerCase() + \"2\"));\n+\n+            if (typeName == BOOLEAN) {\n+                BOOLEAN_COLUMN.add(new Operand(type, UNKNOWN_VALUE, typeName.getName().toLowerCase() + \"1\"));\n+            }\n+        }\n+\n+        // Parameters: one is enough, every occurrence produces a new parameter.\n+\n+        PARAMETERS.add(new Operand(UNKNOWN_TYPE, UNKNOWN_VALUE, \"?\"));\n+    }\n+\n+    protected static final List<Operand> ALL = combine(COLUMNS, LITERALS, PARAMETERS);\n+\n+    private final ExecutorService executor = Executors.newWorkStealingPool(RuntimeAvailableProcessors.get());\n+\n+    @FunctionalInterface\n+    protected interface ExpectedTypes {\n+\n+        RelDataType[] compute(Operand[] operands);\n+\n+    }\n+\n+    @FunctionalInterface\n+    protected interface ExpectedValues {\n+\n+        Object compute(Operand[] operands, RelDataType[] types, Object[] args);\n+\n+    }\n+\n+    @After\n+    public void after() {\n+        // ease the pains of thread deallocation\n+        executor.shutdown();\n+    }\n+\n+    @SafeVarargs\n+    protected final void verify(SqlOperator operator, ExpectedTypes expectedTypes, ExpectedValues expectedValues,\n+                                List<Operand>... operands) {\n+        verify(operator, -1, -1, expectedTypes, expectedValues, operands);\n+    }\n+\n+    @SafeVarargs\n+    protected final void verify(SqlOperator operator, ExpectedTypes expectedTypes, ExpectedValues expectedValues, String format,\n+                                List<Operand>... operands) {\n+        verify(operator, -1, -1, expectedTypes, expectedValues, format, operands);\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"SameParameterValue\")\n+    protected final void verify(SqlOperator operator, int invocationId, int evaluationId, ExpectedTypes expectedTypes,\n+                                ExpectedValues expectedValues, List<Operand>... operands) {\n+        String format;\n+        switch (operator.getSyntax()) {\n+            case PREFIX:\n+                assert operands.length == 1;\n+                format = operator.getName() + \"(%s)\";\n+                break;\n+\n+            case BINARY:\n+                assert operands.length == 2;\n+                format = \"%s \" + operator.getName() + \" %s\";\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"unexpected syntax: \" + operator.getSyntax());\n+        }\n+\n+        verify(operator, invocationId, evaluationId, expectedTypes, expectedValues, format, operands);\n+    }\n+\n+    @SafeVarargs\n+    protected final void verify(SqlOperator operator, int invocationId, int evaluationId, ExpectedTypes expectedTypes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 392}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTY0MTg5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444564189", "createdAt": "2020-07-08T09:20:55Z", "commit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToyMDo1NlrOGufh9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToyMDo1NlrOGufh9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNDI3OA==", "bodyText": "I am really worried with the chosen testing approach. We rely on system behavior instead of our explicit claims.\nConsider that we have a bug in the HazelcastTypeSystem.canCast that returns false for a pair of types that indeed should be castable. The query will fail in the ExpressionTestBase.verify (bug fires the for the first time). Then the control is passed here, the bug is fired for the second time, and the test pass.\nI propose to rethink the whole testing approach. The \"expected\" part of expression tests cannot rely on the logic being tested, because it defeats the whole purpose of unit testing.\nThe alternative approach I saw in other systems (Calcite, CockroachDB), is to write test cases in text files. In this case, it is very easy to reason on what is actually tested, and we do not depend on the system behavior for the \"expected\" part. We may use the framework to generate those files, to avoid writing thousands of tests manually.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451404278", "createdAt": "2020-07-08T09:20:56Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.CAST;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.DOUBLE;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where cast(int1 as double) < 1500\"), keyRange(0, 500, 5000, 6000));\n+        assertRows(query(sql, \"select __key, cast(__key as decimal) + 1.5 from records\"), keyRange(0, 1000, 5000, 6000),\n+                k -> BigDecimal.valueOf(k).add(BigDecimal.valueOf(1.5)));\n+        assertQueryThrows(sql, \"select * from records where cast(string1 as integer) = 0\", \"cannot convert varchar to int\");\n+        assertQueryThrows(sql, \"select __key, cast(int1 as null) from records\", \"was expecting one of\");\n+        assertQueryThrows(sql, \"select __key, cast('foo' as char) from records\", \"char is not supported\");\n+    }\n+\n+    @Test\n+    public void verify() {\n+        verify(CAST, CastTest::expectedTypes, CastTest::expectedValues, \"CAST(%s AS %s)\", ALL, TYPES);\n+    }\n+\n+    @Test\n+    public void testCreationAndEval() {\n+        CastExpression<?> expression = CastExpression.create(ConstantExpression.create(1, INT), BIGINT);\n+        assertEquals(BIGINT, expression.getType());\n+        assertEquals(1L, expression.eval(row(\"foo\"), SimpleExpressionEvalContext.create()));\n+    }\n+\n+    @Test\n+    public void testEquality() {\n+        checkEquals(CastExpression.create(ConstantExpression.create(1, INT), BIGINT),\n+                CastExpression.create(ConstantExpression.create(1, INT), BIGINT), true);\n+\n+        checkEquals(CastExpression.create(ConstantExpression.create(1, INT), BIGINT),\n+                CastExpression.create(ConstantExpression.create(1, INT), DOUBLE), false);\n+\n+        checkEquals(CastExpression.create(ConstantExpression.create(1, INT), BIGINT),\n+                CastExpression.create(ConstantExpression.create(2, INT), BIGINT), false);\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n+        CastExpression<?> original = CastExpression.create(ConstantExpression.create(1, INT), BIGINT);\n+        CastExpression<?> restored = serializeAndCheck(original, SqlDataSerializerHook.EXPRESSION_CAST);\n+\n+        checkEquals(original, restored, true);\n+    }\n+\n+    private static RelDataType[] expectedTypes(Operand[] operands) {\n+        Operand operand = operands[0];\n+        RelDataType from = operand.type;\n+\n+        assert operands[1].isType();\n+        RelDataType to = (RelDataType) operands[1].value;\n+        // Calcite treats target types as NOT NULL\n+        assert !to.isNullable();\n+\n+        // Handle NULL.\n+\n+        if (isNull(from)) {\n+            return new RelDataType[]{from, to, TYPE_FACTORY.createTypeWithNullability(to, true)};\n+        }\n+\n+        RelDataType returnType = to;\n+\n+        // Assign type for parameters.\n+\n+        if (operand.isParameter()) {\n+            from = TYPE_FACTORY.createTypeWithNullability(to, true);\n+        }\n+\n+        // Assign type to numeric literals.\n+\n+        BigDecimal numeric = operand.numericValue();\n+\n+        if (isNumeric(to) || isNumeric(from)) {\n+            //noinspection NumberEquality\n+            if (numeric == INVALID_NUMERIC_VALUE) {\n+                return null;\n+            }\n+\n+            if (numeric != null) {\n+                from = narrowestTypeFor(numeric, typeName(to));\n+            }\n+        }\n+\n+        // Validate the cast.\n+\n+        if (!HazelcastTypeSystem.canCast(from, to)) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a48cce0b0f2034cb9555df84780a00cccdc1c15d"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjU2MDA0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444656004", "createdAt": "2020-07-08T11:33:33Z", "commit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozMzozM1rOGujyXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozMzozM1rOGujyXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NDAxNQ==", "bodyText": "One of the produced test cases:\nquery:  SELECT ? IS NULL FROM t\nAt line 1, column 8: Illegal use of dynamic parameter\n\nWhat is the reason of this query to fail? It looks valid to me", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451474015", "createdAt": "2020-07-08T11:33:33Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/IsNullTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ColumnExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.IS_NULL;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class IsNullTest extends ExpressionTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjU5NDYw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444659460", "createdAt": "2020-07-08T11:39:03Z", "commit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozOTowM1rOGuj88g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozOTowM1rOGuj88g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg==", "bodyText": "Incorrect error messages is produced for some tests:\nid: 69\nquery:  SELECT NOT 9223372036854775808.01 FROM t\nFrom line 1, column 8 to line 1, column 33: Cannot apply 'NOT' to arguments of type 'NOT<DOUBLE>'. Supported form(s): 'NOT<BOOLEAN>'", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451476722", "createdAt": "2020-07-08T11:39:03Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/NotTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.NOT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class NotTest extends ExpressionTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjYxMzkw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444661390", "createdAt": "2020-07-08T11:42:02Z", "commit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MjowMlrOGukC1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MjowMlrOGukC1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3ODIyOA==", "bodyText": "These and many others testEndToEnd tests in other classes validate only values, but do not validate the metadata. Also, they mostly do not check expressions in the SELECT list.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451478228", "createdAt": "2020-07-08T11:42:02Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/NotTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.NOT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class NotTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where not boolean1\"), keyRange(0, 500));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0Njc3NjQ1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444677645", "createdAt": "2020-07-08T11:54:10Z", "commit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo1NDoxMVrOGukamQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo1NDoxMVrOGukamQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ4NDMxMw==", "bodyText": "It seems that certain types are not tested: character, big integer", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451484313", "createdAt": "2020-07-08T11:54:11Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java", "diffHunk": "@@ -0,0 +1,1190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.internal.util.RuntimeAvailableProcessors;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.calcite.OptimizerContext;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchemaUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.schema.MapTableStatistic;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.TestStringUtils;\n+import org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlIntervalQualifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.junit.After;\n+\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.sql.impl.calcite.SqlToQueryType.mapRowType;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static java.util.Collections.singletonMap;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.FRACTIONAL_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.INT_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public abstract class ExpressionTestBase extends SqlTestSupport {\n+\n+    private static final boolean VERIFY_EVALUATION = true;\n+\n+    private static final boolean TRACE = true;\n+    private static final boolean LOG_ON_SUCCESS = false;\n+\n+    protected static final RelDataType UNKNOWN_TYPE = null;\n+    protected static final SqlTypeName UNKNOWN_TYPE_NAME = null;\n+\n+    protected static final Object UNKNOWN_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"UNKNOWN\";\n+        }\n+    };\n+\n+    protected static final Object INVALID_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"INVALID\";\n+        }\n+    };\n+    protected static final BigDecimal INVALID_NUMERIC_VALUE = new BigDecimal(0);\n+    @SuppressWarnings({\"checkstyle:IllegalInstantiation\", \"UnnecessaryBoxing\", \"BooleanConstructorCall\"})\n+    protected static final Boolean INVALID_BOOLEAN_VALUE = new Boolean(true);\n+\n+    public static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    protected static final List<Operand> COLUMNS = new ArrayList<>();\n+    protected static final List<Operand> LITERALS = new ArrayList<>();\n+    protected static final List<Operand> PARAMETERS = new ArrayList<>();\n+    protected static final List<Operand> TYPES = new ArrayList<>();\n+\n+    protected static final List<Operand> BOOLEAN_COLUMN = new ArrayList<>();\n+\n+    protected static final SqlOperator IDENTITY = new SqlOperator(\"\", SqlKind.OTHER, 0, 0, null, null, null) {\n+        @Override\n+        public SqlSyntax getSyntax() {\n+            return SqlSyntax.PREFIX;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return SqlOperandCountRanges.of(1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"IDENTITY\";\n+        }\n+    };\n+\n+    private static final SqlTypeName[] TYPE_NAMES;\n+\n+    static {\n+        TYPE_NAMES = new SqlTypeName[]{VARCHAR, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, REAL, DOUBLE, ANY, NULL};\n+    }\n+\n+    private static final Map<String, QueryDataType> FIELDS;\n+    private static final Map<String, Integer> FIELD_TO_INDEX;\n+    private static final PlanNodeSchema SCHEMA;\n+\n+    static {\n+        Map<String, QueryDataType> fields = new LinkedHashMap<>();\n+        for (SqlTypeName type : TYPE_NAMES) {\n+            if (type == NULL) {\n+                // null is synthetic internal type\n+                continue;\n+            }\n+\n+            fields.put(type.getName().toLowerCase() + \"1\", SqlToQueryType.map(type));\n+            fields.put(type.getName().toLowerCase() + \"2\", SqlToQueryType.map(type));\n+        }\n+\n+        FIELDS = Collections.unmodifiableMap(fields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzAyNzQ4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-444702748", "createdAt": "2020-07-08T12:12:48Z", "commit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjoxMjo0OFrOGulE1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjoxMjo0OFrOGulE1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5NTEyNQ==", "bodyText": "This line is a good example of why such test automation is dangerous. I can break binaryIntegerPlus function, e.g. by adding one additional increment to the width, and all tests in this class will pass still, even though the produced behavior is wrong.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451495125", "createdAt": "2020-07-08T12:12:48Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/PlusTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastReturnTypes;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.PLUS;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType.canOverflow;\n+import static com.hazelcast.sql.impl.expression.math.ExpressionMath.DECIMAL_MATH_CONTEXT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class PlusTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where int1 + 100 > 0\"), keyRange(0, 1000));\n+        assertRows(query(sql, \"select __key, double1 + ? from records where __key < 1000\", \"2.1\"), keyRange(0, 1000),\n+                k -> (k + 2000.1) + 2.1);\n+        assertRows(query(sql, \"select __key, double1 + null from records\"), keyRange(0, 1000, 5000, 6000), k -> null);\n+        assertQueryThrows(sql, \"select ? + int1 from records\", \"bigint overflow\", Long.MAX_VALUE);\n+    }\n+\n+    @Test\n+    public void verify() {\n+        verify(PLUS, PlusTest::expectedTypes, PlusTest::expectedValues, ALL, ALL);\n+    }\n+\n+    @Test\n+    public void testCreationAndEval() {\n+        PlusFunction<?> expression =\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT);\n+        assertEquals(INT, expression.getType());\n+        assertEquals(5, expression.eval(row(\"foo\"), SimpleExpressionEvalContext.create()));\n+    }\n+\n+    @Test\n+    public void testEquality() {\n+        checkEquals(PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT),\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT), true);\n+\n+        checkEquals(PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT),\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), BIGINT), false);\n+\n+        checkEquals(PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT),\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(100, INT), INT), false);\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n+        PlusFunction<?> original = PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT);\n+        PlusFunction<?> restored = serializeAndCheck(original, SqlDataSerializerHook.EXPRESSION_PLUS);\n+\n+        checkEquals(original, restored, true);\n+    }\n+\n+    private static RelDataType[] expectedTypes(Operand[] operands) {\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(operands, true);\n+        if (types == null) {\n+            return null;\n+        }\n+        RelDataType commonType = types[2];\n+\n+        // Validate, coerce and infer return type.\n+\n+        if (!isNumeric(commonType)) {\n+            return null;\n+        }\n+\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            Operand operand = operands[i];\n+            RelDataType type = types[i];\n+\n+            if (!isNumeric(type) && !isNull(type)) {\n+                return null;\n+            }\n+\n+            if (operand.isLiteral() && !canRepresentLiteral(operand, type)) {\n+                return null;\n+            }\n+        }\n+\n+        if (isInteger(commonType)) {\n+            types[2] = HazelcastReturnTypes.binaryIntegerPlus(types[0], types[1]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDMzNTg0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445433584", "createdAt": "2020-07-09T09:14:31Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToxNDozMVrOGvIrfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToxNDozMVrOGvIrfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA3ODQ2MA==", "bodyText": "verify doesn't add much value here, because it generates only several invocations. Given that this is a foundational expression, we need to cover it with classical tests extensively, to ensure that the behavior is as expected. This includes, but not limited to:\n\nChecking all types and their metadata, including BigInteger, Character, custom objects - we need to ensure that they are converted properly\nChecking unexpected types - this may happen in case the plan was created for one model, but then the user loaded another model. In this case, the proper exception should be thrown from the target of field extractor\nChecking __key and this of different types - primitives, composite objects\nChecking different targets - Serializable, DS, IDS, Portable", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452078460", "createdAt": "2020-07-09T09:14:31Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ColumnTest.java", "diffHunk": "@@ -16,47 +16,76 @@\n \n package com.hazelcast.sql.impl.expression;\n \n+import com.hazelcast.sql.SqlService;\n import com.hazelcast.sql.impl.SqlDataSerializerHook;\n-import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.row.HeapRow;\n-import com.hazelcast.sql.impl.type.QueryDataType;\n import com.hazelcast.test.HazelcastParallelClassRunner;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n \n-import static groovy.util.GroovyTestCase.assertEquals;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ColumnExpressionTest extends SqlTestSupport {\n+public class ColumnTest extends ExpressionTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDM2OTIz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445436923", "createdAt": "2020-07-09T09:18:55Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToxODo1NVrOGvI1nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToxODo1NVrOGvI1nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4MTA1NQ==", "bodyText": "Minor: this if-statement could be replaced with the following snippet placed after the if (value == null) block:\n assert type.getTypeFamily() != QueryDataTypeFamily.NULL", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452081055", "createdAt": "2020-07-09T09:18:55Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/ConstantExpression.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Constant expression.\n+ *\n+ * @param <T> Return type.\n+ */\n+public final class ConstantExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private QueryDataType type;\n+    private T value;\n+\n+    public ConstantExpression() {\n+        // No-op.\n+    }\n+\n+    private ConstantExpression(T value, QueryDataType type) {\n+        this.type = type;\n+        this.value = value;\n+    }\n+\n+    public static ConstantExpression<?> create(Object value, QueryDataType type) {\n+        if (type.getTypeFamily() == QueryDataTypeFamily.NULL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDQxNDI0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445441424", "createdAt": "2020-07-09T09:24:27Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyNDoyOFrOGvJDFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyNDoyOFrOGvJDFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NDUwMg==", "bodyText": "Do we have tests that simulate an exception that happened during this conversion? What would the user receive in this case?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452084502", "createdAt": "2020-07-09T09:24:28Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/ConstantExpression.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Constant expression.\n+ *\n+ * @param <T> Return type.\n+ */\n+public final class ConstantExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private QueryDataType type;\n+    private T value;\n+\n+    public ConstantExpression() {\n+        // No-op.\n+    }\n+\n+    private ConstantExpression(T value, QueryDataType type) {\n+        this.type = type;\n+        this.value = value;\n+    }\n+\n+    public static ConstantExpression<?> create(Object value, QueryDataType type) {\n+        if (type.getTypeFamily() == QueryDataTypeFamily.NULL) {\n+            assert value == null;\n+            return new ConstantExpression<>(null, QueryDataType.NULL);\n+        }\n+\n+        if (value == null) {\n+            return new ConstantExpression<>(null, type);\n+        }\n+\n+        Converter valueConverter = Converters.getConverter(value.getClass());\n+        Converter typeConverter = type.getConverter();\n+        value = typeConverter.convertToSelf(valueConverter, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDQ0MTEy", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445444112", "createdAt": "2020-07-09T09:28:00Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyODowMFrOGvJK-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyODowMFrOGvJK-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NjUyMA==", "bodyText": "Constant is another foundational expression for us (the other two are column and parameter). We need exhaustive coverage with precise checks for returned values and types.\nAlso, AFAIK, we may face a constant not only in literals but also due to expression simplification (e.g. '1 + 1.1', or a predicate simplified to TRUE/FALSE). Such tests should be added as well.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452086520", "createdAt": "2020-07-09T09:28:00Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/LiteralTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class LiteralTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDQ1NDE0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445445414", "createdAt": "2020-07-09T09:29:40Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyOTo0MFrOGvJOzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyOTo0MFrOGvJOzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NzUwMw==", "bodyText": "Type is not used for hash code calculation but is used in equals.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452087503", "createdAt": "2020-07-09T09:29:40Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/ParameterExpression.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Dynamic parameter expression.\n+ */\n+public final class ParameterExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private int index;\n+    private QueryDataType type;\n+\n+    public ParameterExpression() {\n+        // No-op.\n+    }\n+\n+    private ParameterExpression(int index, QueryDataType type) {\n+        this.index = index;\n+        this.type = type;\n+    }\n+\n+    public static ParameterExpression<?> create(int index, QueryDataType type) {\n+        return new ParameterExpression<>(index, type);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_PARAMETER;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        return (T) context.getArgument(index);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeInt(index);\n+        out.writeObject(type);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        index = in.readInt();\n+        type = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDQ4OTQ3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445448947", "createdAt": "2020-07-09T09:34:19Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozNDoxOVrOGvJZlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozNDoxOVrOGvJZlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MDI2MA==", "bodyText": "Similarly to columns and constants - we need exhaustive coverage here. Note that verify doesn't test anything at all here - only one invocation is generated.\n\nTests for every combination of input object type vs expected type: proper exceptions and return values/types should be checked.\nTest for cases, where type inference is non-trivial. For example, SELECT ? FROM t. Currently, it throws an exception, but why? I doubt other databases do the same.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452090260", "createdAt": "2020-07-09T09:34:19Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ParameterTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ParameterTest extends ExpressionTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDUwNjg5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445450689", "createdAt": "2020-07-09T09:36:33Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozNjozM1rOGvJerQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozNjozM1rOGvJerQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MTU2NQ==", "bodyText": "Supported and unsupported exceptions are currently tested in ParserOperationsTest.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452091565", "createdAt": "2020-07-09T09:36:33Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/InvalidExpressionTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class InvalidExpressionTest extends ExpressionTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDU0OTE1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445454915", "createdAt": "2020-07-09T09:42:14Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTo0MjoxNVrOGvJsIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTo0MjoxNVrOGvJsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NTAxMQ==", "bodyText": "This part of the class is not tested at all, therefore we do not know whether it works or not. Given that this PR is not concerned with temporal types, we'd better not to merge this code at all.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452095011", "createdAt": "2020-07-09T09:42:15Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -17,39 +17,272 @@\n package com.hazelcast.sql.impl.calcite.opt.physical.visitor;\n \n import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.expression.CastExpression;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.math.DivideFunction;\n+import com.hazelcast.sql.impl.expression.math.MinusFunction;\n+import com.hazelcast.sql.impl.expression.math.MultiplyFunction;\n+import com.hazelcast.sql.impl.expression.math.PlusFunction;\n+import com.hazelcast.sql.impl.expression.math.UnaryMinusFunction;\n+import com.hazelcast.sql.impl.expression.predicate.AndPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.CaseExpression;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonMode;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotTruePredicate;\n import com.hazelcast.sql.impl.expression.predicate.IsNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsTruePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.NotPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.OrPredicate;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+import java.util.Calendar;\n \n /**\n  * Utility methods for REX to Hazelcast expression conversion.\n  */\n public final class RexToExpression {\n+\n     private RexToExpression() {\n         // No-op.\n     }\n \n+    /**\n+     * Converts the given REX literal to runtime {@link ConstantExpression\n+     * constant expression}.\n+     *\n+     * @param literal the literal to convert.\n+     * @return the resulting constant expression.\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public static Expression<?> convertLiteral(RexLiteral literal) {\n+        SqlTypeName type = literal.getType().getSqlTypeName();\n+\n+        switch (type) {\n+            case BOOLEAN:\n+                return convertBooleanLiteral(literal, type);\n+\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case FLOAT:\n+            case DOUBLE:\n+                return convertNumericLiteral(literal, type);\n+\n+            case CHAR:\n+            case VARCHAR:\n+                return convertStringLiteral(literal, type);\n+\n+            case DATE:\n+            case TIME:\n+            case TIME_WITH_LOCAL_TIME_ZONE:\n+            case TIMESTAMP:\n+            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n+                return convertTemporalLiteral(literal, type);\n+\n+            case NULL:\n+                return ConstantExpression.create(null, QueryDataType.NULL);\n+\n+            case ANY:\n+                // currently, the only possible literal of ANY type is NULL\n+                assert literal.getValueAs(Object.class) == null;\n+                return ConstantExpression.create(null, QueryDataType.OBJECT);\n+\n+            default:\n+                throw QueryException.error(\"Unsupported literal: \" + literal);\n+        }\n+    }\n+\n     /**\n      * Converts a {@link RexCall} to {@link Expression}.\n      *\n      * @param call the call to convert.\n      * @return the resulting expression.\n      * @throws QueryException if the given {@link RexCall} can't be\n-     *                               converted.\n+     *                        converted.\n      */\n-    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n+    @SuppressWarnings({\"checkstyle:ReturnCount\", \"checkstyle:CyclomaticComplexity\"})\n     public static Expression<?> convertCall(RexCall call, Expression<?>[] operands) {\n         SqlOperator operator = call.getOperator();\n+        QueryDataType resultType = SqlToQueryType.map(call.getType().getSqlTypeName());\n \n         switch (operator.getKind()) {\n+            case CAST:\n+                return CastExpression.create(operands[0], resultType);\n+\n+            case CASE:\n+                return CaseExpression.create(operands, resultType);\n+\n+            case AND:\n+                return AndPredicate.create(operands);\n+\n+            case OR:\n+                return OrPredicate.create(operands);\n+\n+            case NOT:\n+                return NotPredicate.create(operands[0]);\n+\n+            case PLUS:\n+                return PlusFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS:\n+                return MinusFunction.create(operands[0], operands[1], resultType);\n+\n+            case TIMES:\n+                return MultiplyFunction.create(operands[0], operands[1], resultType);\n+\n+            case DIVIDE:\n+                return DivideFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS_PREFIX:\n+                return UnaryMinusFunction.create(operands[0], resultType);\n+\n+            case PLUS_PREFIX:\n+                return operands[0];\n+\n+            case EQUALS:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.EQUALS);\n+\n+            case NOT_EQUALS:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.NOT_EQUALS);\n+\n+            case GREATER_THAN:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.GREATER_THAN);\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.GREATER_THAN_OR_EQUAL);\n+\n+            case LESS_THAN:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.LESS_THAN);\n+\n+            case LESS_THAN_OR_EQUAL:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.LESS_THAN_OR_EQUAL);\n+\n+            case IS_TRUE:\n+                return IsTruePredicate.create(operands[0]);\n+\n+            case IS_NOT_TRUE:\n+                return IsNotTruePredicate.create(operands[0]);\n+\n+            case IS_FALSE:\n+                return IsFalsePredicate.create(operands[0]);\n+\n+            case IS_NOT_FALSE:\n+                return IsNotFalsePredicate.create(operands[0]);\n+\n             case IS_NULL:\n                 return IsNullPredicate.create(operands[0]);\n \n+            case IS_NOT_NULL:\n+                return IsNotNullPredicate.create(operands[0]);\n+\n             default:\n                 break;\n         }\n \n         throw QueryException.error(\"Unsupported operator: \" + operator);\n     }\n+\n+    private static Expression<?> convertBooleanLiteral(RexLiteral literal, SqlTypeName type) {\n+        assert type == SqlTypeName.BOOLEAN;\n+        Boolean value = literal.getValueAs(Boolean.class);\n+        return ConstantExpression.create(value, SqlToQueryType.map(type));\n+    }\n+\n+    private static Expression<?> convertNumericLiteral(RexLiteral literal, SqlTypeName type) {\n+        Object value;\n+        switch (type) {\n+            case TINYINT:\n+                value = literal.getValueAs(Byte.class);\n+                break;\n+\n+            case SMALLINT:\n+                value = literal.getValueAs(Short.class);\n+                break;\n+\n+            case INTEGER:\n+                value = literal.getValueAs(Integer.class);\n+                break;\n+\n+            case BIGINT:\n+                value = literal.getValueAs(Long.class);\n+                break;\n+\n+            case DECIMAL:\n+                value = literal.getValueAs(BigDecimal.class);\n+                break;\n+\n+            case REAL:\n+                value = literal.getValueAs(Float.class);\n+                break;\n+\n+            case DOUBLE:\n+                value = literal.getValueAs(Double.class);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported literal type: \" + type);\n+        }\n+\n+        return ConstantExpression.create(value, SqlToQueryType.map(type));\n+    }\n+\n+    private static Expression<?> convertStringLiteral(RexLiteral literal, SqlTypeName type) {\n+        Object value;\n+        switch (type) {\n+            case CHAR:\n+            case VARCHAR:\n+                value = literal.getValueAs(String.class);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported literal type: \" + type);\n+        }\n+\n+        return ConstantExpression.create(value, SqlToQueryType.map(type));\n+    }\n+\n+    private static Expression<?> convertTemporalLiteral(RexLiteral literal, SqlTypeName type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 244}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDU1NTM1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445455535", "createdAt": "2020-07-09T09:43:04Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTo0MzowNFrOGvJt1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTo0MzowNFrOGvJt1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NTQ0NA==", "bodyText": "This branch is not tested.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452095444", "createdAt": "2020-07-09T09:43:04Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -17,39 +17,272 @@\n package com.hazelcast.sql.impl.calcite.opt.physical.visitor;\n \n import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.expression.CastExpression;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.math.DivideFunction;\n+import com.hazelcast.sql.impl.expression.math.MinusFunction;\n+import com.hazelcast.sql.impl.expression.math.MultiplyFunction;\n+import com.hazelcast.sql.impl.expression.math.PlusFunction;\n+import com.hazelcast.sql.impl.expression.math.UnaryMinusFunction;\n+import com.hazelcast.sql.impl.expression.predicate.AndPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.CaseExpression;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonMode;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotTruePredicate;\n import com.hazelcast.sql.impl.expression.predicate.IsNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsTruePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.NotPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.OrPredicate;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+import java.util.Calendar;\n \n /**\n  * Utility methods for REX to Hazelcast expression conversion.\n  */\n public final class RexToExpression {\n+\n     private RexToExpression() {\n         // No-op.\n     }\n \n+    /**\n+     * Converts the given REX literal to runtime {@link ConstantExpression\n+     * constant expression}.\n+     *\n+     * @param literal the literal to convert.\n+     * @return the resulting constant expression.\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public static Expression<?> convertLiteral(RexLiteral literal) {\n+        SqlTypeName type = literal.getType().getSqlTypeName();\n+\n+        switch (type) {\n+            case BOOLEAN:\n+                return convertBooleanLiteral(literal, type);\n+\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case FLOAT:\n+            case DOUBLE:\n+                return convertNumericLiteral(literal, type);\n+\n+            case CHAR:\n+            case VARCHAR:\n+                return convertStringLiteral(literal, type);\n+\n+            case DATE:\n+            case TIME:\n+            case TIME_WITH_LOCAL_TIME_ZONE:\n+            case TIMESTAMP:\n+            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n+                return convertTemporalLiteral(literal, type);\n+\n+            case NULL:\n+                return ConstantExpression.create(null, QueryDataType.NULL);\n+\n+            case ANY:\n+                // currently, the only possible literal of ANY type is NULL\n+                assert literal.getValueAs(Object.class) == null;\n+                return ConstantExpression.create(null, QueryDataType.OBJECT);\n+\n+            default:\n+                throw QueryException.error(\"Unsupported literal: \" + literal);\n+        }\n+    }\n+\n     /**\n      * Converts a {@link RexCall} to {@link Expression}.\n      *\n      * @param call the call to convert.\n      * @return the resulting expression.\n      * @throws QueryException if the given {@link RexCall} can't be\n-     *                               converted.\n+     *                        converted.\n      */\n-    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n+    @SuppressWarnings({\"checkstyle:ReturnCount\", \"checkstyle:CyclomaticComplexity\"})\n     public static Expression<?> convertCall(RexCall call, Expression<?>[] operands) {\n         SqlOperator operator = call.getOperator();\n+        QueryDataType resultType = SqlToQueryType.map(call.getType().getSqlTypeName());\n \n         switch (operator.getKind()) {\n+            case CAST:\n+                return CastExpression.create(operands[0], resultType);\n+\n+            case CASE:\n+                return CaseExpression.create(operands, resultType);\n+\n+            case AND:\n+                return AndPredicate.create(operands);\n+\n+            case OR:\n+                return OrPredicate.create(operands);\n+\n+            case NOT:\n+                return NotPredicate.create(operands[0]);\n+\n+            case PLUS:\n+                return PlusFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS:\n+                return MinusFunction.create(operands[0], operands[1], resultType);\n+\n+            case TIMES:\n+                return MultiplyFunction.create(operands[0], operands[1], resultType);\n+\n+            case DIVIDE:\n+                return DivideFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS_PREFIX:\n+                return UnaryMinusFunction.create(operands[0], resultType);\n+\n+            case PLUS_PREFIX:\n+                return operands[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTc4Mjgz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445578283", "createdAt": "2020-07-09T12:43:44Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo0Mzo0NFrOGvPbJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo0Mzo0NFrOGvPbJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE4ODk2NA==", "bodyText": "Do we really need to handle temporal types in this PR, provided that they are not supported?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452188964", "createdAt": "2020-07-09T12:43:44Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -106,16 +125,46 @@ public Void visit(SqlIdentifier id) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n     @Override\n     public Void visit(SqlDataTypeSpec type) {\n-        throw error(type, RESOURCE.custom(\"Type specification is not supported\"));\n+        if (!(type.getTypeNameSpec() instanceof SqlBasicTypeNameSpec)) {\n+            throw error(type, RESOURCE.custom(\"Complex type specifications are not supported\"));\n+        }\n+\n+        SqlTypeName typeName = SqlTypeName.get(type.getTypeName().getSimple());\n+        switch (typeName) {\n+            case BOOLEAN:\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case DOUBLE:\n+            case VARCHAR:\n+            case ANY:\n+            case NULL:\n+            case TIME:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTgzMjg2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445583286", "createdAt": "2020-07-09T12:50:30Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1MDozMVrOGvPqIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1MDozMVrOGvPqIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5MjgwMA==", "bodyText": "This case might be slightly misleading to users:\n\nSELECT too_wide_value produces \"Numeric overflow\" exception\nBut\n\nSELECT `too_wide_value`\n\n... produces \"cannot convert to BIGDECIMAL\" exception.\nIt would be great to confine both cases to a similar overflow exception.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452192800", "createdAt": "2020-07-09T12:50:31Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {\n+\n+    private SqlNodeUtil() {\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlDynamicParam\n+     * dynamic parameter}, {@code false} otherwise.\n+     */\n+    public static boolean isParameter(SqlNode node) {\n+        return node.getKind() == SqlKind.DYNAMIC_PARAM;\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlLiteral literal},\n+     * {@code false} otherwise.\n+     */\n+    public static boolean isLiteral(SqlNode node) {\n+        return node.getKind() == SqlKind.LITERAL;\n+    }\n+\n+    /**\n+     * Obtains a numeric value of the given node if it's a numeric or string\n+     * {@linkplain SqlLiteral literal}.\n+     *\n+     * @param node the node to obtain the numeric value of.\n+     * @return the obtained numeric value or {@code null} if the given node is\n+     * not a numeric or string literal.\n+     * @throws CalciteContextException if the given node is a string literal\n+     *                                 that doesn't have a valid numeric\n+     *                                 representation.\n+     */\n+    public static BigDecimal numericValue(SqlNode node) {\n+        if (node.getKind() != SqlKind.LITERAL) {\n+            return null;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) node;\n+\n+        if (CHAR_TYPES.contains(literal.getTypeName())) {\n+            try {\n+                return StringConverter.INSTANCE.asDecimal(literal.getValueAs(String.class));\n+            } catch (QueryException e) {\n+                assert e.getCode() == SqlErrorCode.DATA_EXCEPTION;\n+                throw SqlUtil.newContextException(literal.getParserPosition(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTg0OTIw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445584920", "createdAt": "2020-07-09T12:52:41Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1Mjo0MVrOGvPvTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1Mjo0MVrOGvPvTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NDEyNA==", "bodyText": "Can we document how exactly our behavior differs from Calcite?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452194124", "createdAt": "2020-07-09T12:52:41Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlCastFunction.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.fun.SqlCastFunction;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Custom Hazelcast {@link SqlCastFunction} to override the default operand type\n+ * checking strategy to make sure the casting behaviour is exactly the same as\n+ * defined by {@link Converter}s.\n+ */\n+public final class HazelcastSqlCastFunction extends SqlCastFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTg1OTIz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445585923", "createdAt": "2020-07-09T12:54:00Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1NDowMVrOGvPyGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1NDowMVrOGvPyGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NDg0MA==", "bodyText": "I think we should document literal processing in the 01-type-system.md.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452194840", "createdAt": "2020-07-09T12:54:01Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTg3MTAz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445587103", "createdAt": "2020-07-09T12:55:32Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1NTozM1rOGvP1vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1NTozM1rOGvP1vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NTc3NQ==", "bodyText": "If we agree to expose objects as ANY, then this should be reflected in the 01-type-system.md", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452195775", "createdAt": "2020-07-09T12:55:33Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlToQueryType.java", "diffHunk": "@@ -69,6 +72,9 @@\n \n         HZ_TO_CALCITE.put(QueryDataTypeFamily.OBJECT, SqlTypeName.ANY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTkwMzc3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445590377", "createdAt": "2020-07-09T12:59:42Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1OTo0MlrOGvQAEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjo1OTo0MlrOGvQAEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5ODQxNg==", "bodyText": "Can we document why we rewrite CASE and do the overload lookup? What would happen if we do not have this class?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452198416", "createdAt": "2020-07-09T12:59:42Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastOperatorTableVisitor.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCase;\n+import org.apache.calcite.sql.SqlBasicCall;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.validate.SqlNameMatcher;\n+import org.apache.calcite.sql.validate.SqlNameMatchers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Rewrites operators in SqlNode tree from Calcite ones to Hazelcast ones.\n+ *\n+ * @see SqlStdOperatorTable\n+ * @see HazelcastSqlOperatorTable\n+ */\n+public final class HazelcastOperatorTableVisitor extends SqlBasicVisitor<Void> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTk2MDc4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445596078", "createdAt": "2020-07-09T13:06:58Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzowNjo1OVrOGvQREg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzowNjo1OVrOGvQREg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwMjc3MA==", "bodyText": "Could you please clarify the purpose of this method? I understand why it is constant for DIVIDE. But as far as AND and OR - does NULL on the one side guarantee monotonicity anyhow? They may return FALSE/NULL and TRUE/NULL respectively, which doesn't seem monotonic to me.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452202770", "createdAt": "2020-07-09T13:06:59Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlBinaryOperator.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+import org.apache.calcite.util.Litmus;\n+\n+/**\n+ * The same as {@link SqlBinaryOperator}, but supports monotonicity for NULL\n+ * literals and operators from our custom {@link HazelcastSqlOperatorTable}.\n+ */\n+public class HazelcastSqlBinaryOperator extends SqlBinaryOperator {\n+\n+    public HazelcastSqlBinaryOperator(String name, SqlKind kind, int prec, boolean leftAssoc,\n+                                      SqlReturnTypeInference returnTypeInference, SqlOperandTypeInference operandTypeInference,\n+                                      SqlOperandTypeChecker operandTypeChecker) {\n+        super(name, kind, prec, leftAssoc, returnTypeInference, operandTypeInference, operandTypeChecker);\n+    }\n+\n+    @Override\n+    public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {\n+        if (call.isOperandNull(0, true) || call.isOperandNull(1, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NTk2NTcw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445596570", "createdAt": "2020-07-09T13:07:35Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzowNzozNlrOGvQSpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzowNzozNlrOGvQSpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwMzE3Mg==", "bodyText": "Is it correct that DIVIDE uses this class and not HazelcastSqlMonotonicBinaryOperator?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452203172", "createdAt": "2020-07-09T13:07:36Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlBinaryOperator.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+import org.apache.calcite.util.Litmus;\n+\n+/**\n+ * The same as {@link SqlBinaryOperator}, but supports monotonicity for NULL\n+ * literals and operators from our custom {@link HazelcastSqlOperatorTable}.\n+ */\n+public class HazelcastSqlBinaryOperator extends SqlBinaryOperator {\n+\n+    public HazelcastSqlBinaryOperator(String name, SqlKind kind, int prec, boolean leftAssoc,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NjAwNDM2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445600436", "createdAt": "2020-07-09T13:12:24Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoxMjoyNFrOGvQeSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoxMjoyNFrOGvQeSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwNjE1NA==", "bodyText": "This edge case is not covered with tests. Can we really have lastResult == null?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452206154", "createdAt": "2020-07-09T13:12:24Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/CaseExpression.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Implements evaluation of SQL CASE operator.\n+ */\n+public final class CaseExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private Expression<Boolean>[] conditions;\n+    private Expression<?>[] results;\n+    private QueryDataType resultType;\n+\n+    public CaseExpression() {\n+        // No-op.\n+    }\n+\n+    private CaseExpression(Expression<Boolean>[] conditions, Expression<?>[] results, QueryDataType resultType) {\n+        this.conditions = conditions;\n+        this.results = results;\n+        this.resultType = resultType;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static CaseExpression<?> create(Expression<?>[] expressions, QueryDataType resultType) {\n+        // Split conditions and expressions.\n+        assert expressions != null;\n+        assert expressions.length % 2 == 1;\n+\n+        int conditionCount = expressions.length / 2;\n+\n+        Expression<Boolean>[] conditions = new Expression[conditionCount];\n+        Expression<?>[] results = new Expression[conditionCount + 1];\n+\n+        int idx = 0;\n+\n+        for (int i = 0; i < conditionCount; i++) {\n+            conditions[i] = (Expression<Boolean>) expressions[idx++];\n+            results[i] = expressions[idx++];\n+        }\n+\n+        // Last expression might be null.\n+        results[results.length - 1] = expressions.length == idx + 1 ? expressions[idx] : null;\n+\n+        // Done.\n+        return new CaseExpression<>(conditions, results, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_CASE;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        for (int i = 0; i < conditions.length; i++) {\n+            Expression<Boolean> condition = conditions[i];\n+\n+            Boolean conditionHolds = condition.eval(row, context);\n+            if (TernaryLogic.isTrue(conditionHolds)) {\n+                return (T) results[i].eval(row, context);\n+            }\n+        }\n+\n+        // Return the last result if none conditions were met.\n+        Expression<?> lastResult = results[results.length - 1];\n+\n+        if (lastResult != null) {\n+            return (T) lastResult.eval(row, context);\n+        } else {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NjA3MjI2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445607226", "createdAt": "2020-07-09T13:20:20Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyMDoyMVrOGvQzJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyMDoyMVrOGvQzJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxMTQ5Mw==", "bodyText": "A common comment to all math functions: how do we handle overflow? We are very careful with an overflow for Converter-s, but it seems that we may easily overflow here as well, and this is not handled properly. Or maybe the trick is that the overflow never happens here thanks type widening that happens during planning? If yes - is this the case for all math operators?\nCan we add explicit tests to handle overflow for math operations to prove the correctness?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452211493", "createdAt": "2020-07-09T13:20:21Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/PlusFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Implements evaluation of SQL plus operator.\n+ */\n+public final class PlusFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    public PlusFunction() {\n+        // No-op.\n+    }\n+\n+    private PlusFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        super(operand1, operand2, resultType);\n+    }\n+\n+    public static PlusFunction<?> create(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        return new PlusFunction<>(operand1, operand2, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_PLUS;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        QueryDataTypeFamily family = resultType.getTypeFamily();\n+        if (family.isTemporal()) {\n+            throw new UnsupportedOperationException(\"temporal types are unsupported currently\");\n+        }\n+\n+        return (T) evalNumeric((Number) left, (Number) right, family);\n+    }\n+\n+    private static Object evalNumeric(Number left, Number right, QueryDataTypeFamily family) {\n+        switch (family) {\n+            case TINYINT:\n+                return (byte) (left.byteValue() + right.byteValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NjExODY0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445611864", "createdAt": "2020-07-09T13:25:17Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyNToxN1rOGvRAJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyNToxN1rOGvRAJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNDgyMA==", "bodyText": "It seems that we do not support comparison for ANY type. What is the reason for this? If two objects have the same type and are comparable, then we can compare them, aren't we?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452214820", "createdAt": "2020-07-09T13:25:17Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private ComparisonMode mode;\n+\n+    public ComparisonPredicate() {\n+        // No-op.\n+    }\n+\n+    private ComparisonPredicate(Expression<?> left, Expression<?> right, ComparisonMode mode) {\n+        super(left, right);\n+        this.mode = mode;\n+    }\n+\n+    public static ComparisonPredicate create(Expression<?> left, Expression<?> right, ComparisonMode comparisonMode) {\n+        assert left.getType().equals(right.getType());\n+        return new ComparisonPredicate(left, right, comparisonMode);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_COMPARISON;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"Any SQL expression may return null\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        Comparable leftComparable = (Comparable) left;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NjEyNDE3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445612417", "createdAt": "2020-07-09T13:25:50Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyNTo1MFrOGvRBtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyNTo1MFrOGvRBtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNTIyMA==", "bodyText": "Is it guaranteed that two operands are coerced to the same type by this point?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452215220", "createdAt": "2020-07-09T13:25:50Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private ComparisonMode mode;\n+\n+    public ComparisonPredicate() {\n+        // No-op.\n+    }\n+\n+    private ComparisonPredicate(Expression<?> left, Expression<?> right, ComparisonMode mode) {\n+        super(left, right);\n+        this.mode = mode;\n+    }\n+\n+    public static ComparisonPredicate create(Expression<?> left, Expression<?> right, ComparisonMode comparisonMode) {\n+        assert left.getType().equals(right.getType());\n+        return new ComparisonPredicate(left, right, comparisonMode);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_COMPARISON;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"Any SQL expression may return null\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        Comparable leftComparable = (Comparable) left;\n+        Comparable rightComparable = (Comparable) right;\n+\n+        int order = leftComparable.compareTo(rightComparable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NjE1OTA5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445615909", "createdAt": "2020-07-09T13:29:35Z", "commit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyOTozNVrOGvRLhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMzoyOTozNVrOGvRLhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNzczNQ==", "bodyText": "I am not sure whether this is worth, but - we rely on casts heavily now, therefore the performance is important. In principle, we may avoid calling converter at all if the object is already of expected type:\nif (resultType.getConverter().getNormalizedValueClass() == value.getClass()) {\n    return value;\n}", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452217735", "createdAt": "2020-07-09T13:29:35Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/CastExpression.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+\n+/**\n+ * Implements evaluation of SQL CAST operator.\n+ */\n+public final class CastExpression<T> extends UniExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    public CastExpression() {\n+        // No-op.\n+    }\n+\n+    private CastExpression(Expression<?> operand, QueryDataType resultType) {\n+        super(operand, resultType);\n+    }\n+\n+    public static CastExpression<?> create(Expression<?> operand, QueryDataType resultType) {\n+        return new CastExpression<>(operand, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_CAST;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object value = operand.eval(row, context);\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        Converter fromConverter = operand.getType().getConverter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NjY2NTI1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-445666525", "createdAt": "2020-07-09T14:22:53Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDoyMjo1M1rOGvTf5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDoyMjo1M1rOGvTf5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI1NTcxOA==", "bodyText": "It seems that knowNodeTypes solves some specific problem with the CASE operator. Could you please add JavaDocs explaining the problem?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452255718", "createdAt": "2020-07-09T14:22:53Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjUyMzY2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446252366", "createdAt": "2020-07-10T09:19:07Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxOTowN1rOGvwRwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxOTowN1rOGvwRwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzIzNA==", "bodyText": "This method does nothing in the current PR since we do not support LIMIT/OFFSET.\nI would propose to remove it for now and keep only in the sql branch because from the 4.1 perspective this is a not-tested dead code.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452727234", "createdAt": "2020-07-10T09:19:07Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjUyOTgy", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446252982", "createdAt": "2020-07-10T09:20:00Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyMDowMFrOGvwTnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyMDowMFrOGvwTnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzcwOA==", "bodyText": "DDL is not supported in this PR, so the whole validate method could be removed safely.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452727708", "createdAt": "2020-07-10T09:20:00Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjUzOTk4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446253998", "createdAt": "2020-07-10T09:21:31Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyMTozMVrOGvwWtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyMTozMVrOGvwWtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyODUwMw==", "bodyText": "Can we have an example of before-and-after states here, to better understand the reason of having this rewrite?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452728503", "createdAt": "2020-07-10T09:21:31Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {\n+            return topNode;\n+        }\n+\n+        return super.validate(topNode);\n     }\n \n     @Override\n-    protected void addToSelectList(\n-        List<SqlNode> list,\n-        Set<String> aliases,\n-        List<Map.Entry<String, RelDataType>> fieldList,\n-        SqlNode exp,\n-        SelectScope scope,\n-        boolean includeSystemVars\n-    ) {\n+    protected void addToSelectList(List<SqlNode> list, Set<String> aliases, List<Map.Entry<String, RelDataType>> fieldList,\n+                                   SqlNode exp, SelectScope scope, boolean includeSystemVars) {\n         if (isHiddenColumn(exp, scope)) {\n             return;\n         }\n \n         super.addToSelectList(list, aliases, fieldList, exp, scope, includeSystemVars);\n     }\n \n+    @Override\n+    public RelDataType deriveType(SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType derived = super.deriveType(scope, expression);\n+        assert derived != null;\n+\n+        if (derived.getSqlTypeName() == CHAR) {\n+            // normalize CHAR to VARCHAR\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(VARCHAR, derived.isNullable());\n+            setValidatedNodeType(expression, derived);\n+        }\n+\n+        switch (expression.getKind()) {\n+            case LITERAL:\n+                return deriveLiteralType(derived, expression);\n+\n+            case CAST:\n+                return deriveCastType(derived, scope, expression);\n+\n+            default:\n+                return derived;\n+        }\n+    }\n+\n+    @Override\n+    public void validateLiteral(SqlLiteral literal) {\n+        validateLiteral(literal, getValidatedNodeType(literal));\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidatorScope scope) {\n+        // Enforce type derivation for all calls before validation. Calcite may\n+        // skip it if a call has a fixed type, for instance AND always has\n+        // BOOLEAN type, so operands may end up having no validated type.\n+        deriveType(scope, call);\n+        super.validateCall(call, scope);\n+    }\n+\n+    @Override\n+    protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n+        SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n+\n+        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n+            // rewrite operators to Hazelcast ones starting at every top node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 184}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjU4NTAx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446258501", "createdAt": "2020-07-10T09:28:32Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyODozMlrOGvwkNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyODozMlrOGvwkNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA==", "bodyText": "Could you please clarify the reason of this DECIMAL -> DOUBLE conversion? I tried to disable this branch and several tests failed, such as\nExpected :DOUBLE\nActual   :DECIMAL(38, 38)\n\nBut from this failure, it is not clear why is this a problem in the first place. What would happen if we leave DECIMAL here unchanged?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452731958", "createdAt": "2020-07-10T09:28:32Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {\n+            return topNode;\n+        }\n+\n+        return super.validate(topNode);\n     }\n \n     @Override\n-    protected void addToSelectList(\n-        List<SqlNode> list,\n-        Set<String> aliases,\n-        List<Map.Entry<String, RelDataType>> fieldList,\n-        SqlNode exp,\n-        SelectScope scope,\n-        boolean includeSystemVars\n-    ) {\n+    protected void addToSelectList(List<SqlNode> list, Set<String> aliases, List<Map.Entry<String, RelDataType>> fieldList,\n+                                   SqlNode exp, SelectScope scope, boolean includeSystemVars) {\n         if (isHiddenColumn(exp, scope)) {\n             return;\n         }\n \n         super.addToSelectList(list, aliases, fieldList, exp, scope, includeSystemVars);\n     }\n \n+    @Override\n+    public RelDataType deriveType(SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType derived = super.deriveType(scope, expression);\n+        assert derived != null;\n+\n+        if (derived.getSqlTypeName() == CHAR) {\n+            // normalize CHAR to VARCHAR\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(VARCHAR, derived.isNullable());\n+            setValidatedNodeType(expression, derived);\n+        }\n+\n+        switch (expression.getKind()) {\n+            case LITERAL:\n+                return deriveLiteralType(derived, expression);\n+\n+            case CAST:\n+                return deriveCastType(derived, scope, expression);\n+\n+            default:\n+                return derived;\n+        }\n+    }\n+\n+    @Override\n+    public void validateLiteral(SqlLiteral literal) {\n+        validateLiteral(literal, getValidatedNodeType(literal));\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidatorScope scope) {\n+        // Enforce type derivation for all calls before validation. Calcite may\n+        // skip it if a call has a fixed type, for instance AND always has\n+        // BOOLEAN type, so operands may end up having no validated type.\n+        deriveType(scope, call);\n+        super.validateCall(call, scope);\n+    }\n+\n+    @Override\n+    protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n+        SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n+\n+        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n+            // rewrite operators to Hazelcast ones starting at every top node\n+            rewritten.accept(HazelcastOperatorTableVisitor.INSTANCE);\n+        }\n+\n+        return rewritten;\n+    }\n+\n+    private RelDataType deriveLiteralType(RelDataType derived, SqlNode expression) {\n+        RelDataType known = knownNodeTypes.get(expression);\n+        if (derived == known) {\n+            return derived;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) expression;\n+\n+        if (HazelcastIntegerType.supports(typeName(derived)) && literal.getValue() != null) {\n+            // Assign narrowest type to non-null integer literals.\n+\n+            derived = HazelcastIntegerType.deriveLiteralType(literal);\n+            setKnownAndValidatedNodeType(expression, derived);\n+        } else if (typeName(derived) == DECIMAL) {\n+            // Assign DOUBLE type to any standalone floating point literal: the\n+            // exact type is inferred later from the context in which the literal\n+            // appears.\n+\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(DOUBLE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 209}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjY3NDQx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446267441", "createdAt": "2020-07-10T09:42:43Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0Mjo0NFrOGvxAaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0Mjo0NFrOGvxAaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczOTE3Ng==", "bodyText": "AFAIU we lose some error context here. It could be observed it verify test results when a conversion from a very large numeric literal causes \"numeric overflow\" exception, while conversion from the same literal in single quotes causes \"cannot convert to BIGINT\" exception. I checked Postgres and it is consistent - both values yeilds the same overflow exception,\nI think it should be easy for us to fix this - instead of doing a single canRepresent check, we may first check if types are convertible (if not - throw cannot convert), and only after that perform a separate test for real conversion.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452739176", "createdAt": "2020-07-10T09:42:44Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {\n+            return topNode;\n+        }\n+\n+        return super.validate(topNode);\n     }\n \n     @Override\n-    protected void addToSelectList(\n-        List<SqlNode> list,\n-        Set<String> aliases,\n-        List<Map.Entry<String, RelDataType>> fieldList,\n-        SqlNode exp,\n-        SelectScope scope,\n-        boolean includeSystemVars\n-    ) {\n+    protected void addToSelectList(List<SqlNode> list, Set<String> aliases, List<Map.Entry<String, RelDataType>> fieldList,\n+                                   SqlNode exp, SelectScope scope, boolean includeSystemVars) {\n         if (isHiddenColumn(exp, scope)) {\n             return;\n         }\n \n         super.addToSelectList(list, aliases, fieldList, exp, scope, includeSystemVars);\n     }\n \n+    @Override\n+    public RelDataType deriveType(SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType derived = super.deriveType(scope, expression);\n+        assert derived != null;\n+\n+        if (derived.getSqlTypeName() == CHAR) {\n+            // normalize CHAR to VARCHAR\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(VARCHAR, derived.isNullable());\n+            setValidatedNodeType(expression, derived);\n+        }\n+\n+        switch (expression.getKind()) {\n+            case LITERAL:\n+                return deriveLiteralType(derived, expression);\n+\n+            case CAST:\n+                return deriveCastType(derived, scope, expression);\n+\n+            default:\n+                return derived;\n+        }\n+    }\n+\n+    @Override\n+    public void validateLiteral(SqlLiteral literal) {\n+        validateLiteral(literal, getValidatedNodeType(literal));\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidatorScope scope) {\n+        // Enforce type derivation for all calls before validation. Calcite may\n+        // skip it if a call has a fixed type, for instance AND always has\n+        // BOOLEAN type, so operands may end up having no validated type.\n+        deriveType(scope, call);\n+        super.validateCall(call, scope);\n+    }\n+\n+    @Override\n+    protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n+        SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n+\n+        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n+            // rewrite operators to Hazelcast ones starting at every top node\n+            rewritten.accept(HazelcastOperatorTableVisitor.INSTANCE);\n+        }\n+\n+        return rewritten;\n+    }\n+\n+    private RelDataType deriveLiteralType(RelDataType derived, SqlNode expression) {\n+        RelDataType known = knownNodeTypes.get(expression);\n+        if (derived == known) {\n+            return derived;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) expression;\n+\n+        if (HazelcastIntegerType.supports(typeName(derived)) && literal.getValue() != null) {\n+            // Assign narrowest type to non-null integer literals.\n+\n+            derived = HazelcastIntegerType.deriveLiteralType(literal);\n+            setKnownAndValidatedNodeType(expression, derived);\n+        } else if (typeName(derived) == DECIMAL) {\n+            // Assign DOUBLE type to any standalone floating point literal: the\n+            // exact type is inferred later from the context in which the literal\n+            // appears.\n+\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(DOUBLE);\n+            setKnownAndValidatedNodeType(expression, derived);\n+        }\n+\n+        return derived;\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    private RelDataType deriveCastType(RelDataType derived, SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType known = knownNodeTypes.get(expression);\n+        if (derived == known) {\n+            return derived;\n+        }\n+\n+        SqlCall call = (SqlCall) expression;\n+        SqlNode operand = call.operand(0);\n+        RelDataType from = deriveType(scope, operand);\n+\n+        RelDataType to = deriveType(scope, call.operand(1));\n+        assert !to.isNullable();\n+\n+        // Handle NULL.\n+\n+        if (SqlUtil.isNullLiteral(operand, false)) {\n+            setKnownAndValidatedNodeType(operand, HazelcastTypeFactory.INSTANCE.createSqlType(NULL));\n+            derived = HazelcastTypeFactory.INSTANCE.createTypeWithNullability(to, true);\n+            setKnownAndValidatedNodeType(expression, derived);\n+            return derived;\n+        }\n+\n+        derived = to;\n+\n+        // Assign type for parameters.\n+\n+        if (isParameter(operand)) {\n+            from = HazelcastTypeFactory.INSTANCE.createTypeWithNullability(to, true);\n+        }\n+\n+        // Assign type to numeric literals and validate them.\n+\n+        BigDecimal numeric = isNumeric(from) || isNumeric(to) ? numericValue(operand) : null;\n+\n+        if (numeric != null) {\n+            from = narrowestTypeFor(numeric, typeName(to));\n+        }\n+\n+        if (isLiteral(operand)) {\n+            validateLiteral((SqlLiteral) operand, to);\n+        }\n+\n+        // Infer return type.\n+\n+        if (isInteger(to) && isInteger(from)) {\n+            derived = HazelcastIntegerType.deriveCastType(from, to);\n+        } else if (isInteger(to) && numeric != null) {\n+            long longValue = numeric.longValue();\n+            derived = HazelcastIntegerType.deriveCastType(longValue, to);\n+        }\n+\n+        derived = HazelcastTypeFactory.INSTANCE.createTypeWithNullability(derived, from.isNullable());\n+\n+        setKnownAndValidatedNodeType(operand, from);\n+        setKnownAndValidatedNodeType(expression, derived);\n+\n+        return derived;\n+    }\n+\n+    private void validateLiteral(SqlLiteral literal, RelDataType type) {\n+        SqlTypeName literalTypeName = literal.getTypeName();\n+\n+        if (!canRepresent(literal, type)) {\n+            if (NUMERIC_TYPES.contains(literalTypeName) && isNumeric(type)) {\n+                throw newValidationError(literal, RESOURCE.numberLiteralOutOfRange(literal.toString()));\n+            } else {\n+                throw SqlUtil.newContextException(literal.getParserPosition(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 283}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MzMwMTk4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446330198", "createdAt": "2020-07-10T11:33:33Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTozMzozM1rOGv0Bfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTozMzozM1rOGv0Bfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4ODYwNw==", "bodyText": "Calcite's error message is too vague here. What exactly is wrong with the dynamic parameter in this branch?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452788607", "createdAt": "2020-07-10T11:33:33Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlCaseOperator.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlCaseOperator;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Custom Hazelcast {@link SqlCaseOperator} to override the default return type\n+ * inference strategy for CASE.\n+ *\n+ * @see HazelcastSqlCase\n+ */\n+public final class HazelcastSqlCaseOperator extends SqlOperator {\n+\n+    public HazelcastSqlCaseOperator() {\n+        super(SqlCaseOperator.INSTANCE.getName(), SqlKind.CASE, MDX_PRECEDENCE, true, null, InferTypes.RETURN_TYPE, null);\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidator validator, SqlValidatorScope scope, SqlValidatorScope operandScope) {\n+        SqlCaseOperator.INSTANCE.validateCall(call, validator, scope, operandScope);\n+    }\n+\n+    @Override\n+    public RelDataType deriveType(SqlValidator validator, SqlValidatorScope scope, SqlCall call) {\n+        // SqlCaseOperator is doing the same\n+        return validateOperands(validator, scope, call);\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+        return SqlCaseOperator.INSTANCE.checkOperandTypes(binding, throwOnFailure);\n+    }\n+\n+    @Override\n+    public RelDataType inferReturnType(SqlOperatorBinding binding) {\n+        if (binding instanceof SqlCallBinding) {\n+            SqlCallBinding sqlBinding = (SqlCallBinding) binding;\n+            SqlCase call = (SqlCase) sqlBinding.getCall();\n+            HazelcastSqlValidator validator = (HazelcastSqlValidator) sqlBinding.getValidator();\n+\n+            validator.getTypeCoercion().caseWhenCoercion(sqlBinding);\n+            RelDataType caseType = validator.getKnownNodeType(call);\n+            if (caseType == null) {\n+                throw sqlBinding.newValidationError(RESOURCE.dynamicParamIllegal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MzM2NjE2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446336616", "createdAt": "2020-07-10T11:46:03Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo0NjowM1rOGv0Uzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo0NjowM1rOGv0Uzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MzU1MQ==", "bodyText": "This exception also doesn't help the user much - which exact combination is illegal? We can add our custom error message here easily. Same for the similar exception a below", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452793551", "createdAt": "2020-07-10T11:46:03Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlCaseOperator.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlCaseOperator;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Custom Hazelcast {@link SqlCaseOperator} to override the default return type\n+ * inference strategy for CASE.\n+ *\n+ * @see HazelcastSqlCase\n+ */\n+public final class HazelcastSqlCaseOperator extends SqlOperator {\n+\n+    public HazelcastSqlCaseOperator() {\n+        super(SqlCaseOperator.INSTANCE.getName(), SqlKind.CASE, MDX_PRECEDENCE, true, null, InferTypes.RETURN_TYPE, null);\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidator validator, SqlValidatorScope scope, SqlValidatorScope operandScope) {\n+        SqlCaseOperator.INSTANCE.validateCall(call, validator, scope, operandScope);\n+    }\n+\n+    @Override\n+    public RelDataType deriveType(SqlValidator validator, SqlValidatorScope scope, SqlCall call) {\n+        // SqlCaseOperator is doing the same\n+        return validateOperands(validator, scope, call);\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+        return SqlCaseOperator.INSTANCE.checkOperandTypes(binding, throwOnFailure);\n+    }\n+\n+    @Override\n+    public RelDataType inferReturnType(SqlOperatorBinding binding) {\n+        if (binding instanceof SqlCallBinding) {\n+            SqlCallBinding sqlBinding = (SqlCallBinding) binding;\n+            SqlCase call = (SqlCase) sqlBinding.getCall();\n+            HazelcastSqlValidator validator = (HazelcastSqlValidator) sqlBinding.getValidator();\n+\n+            validator.getTypeCoercion().caseWhenCoercion(sqlBinding);\n+            RelDataType caseType = validator.getKnownNodeType(call);\n+            if (caseType == null) {\n+                throw sqlBinding.newValidationError(RESOURCE.dynamicParamIllegal());\n+            }\n+\n+            for (SqlNode thenOperand : call.getThenOperands()) {\n+                RelDataType thenOperandType = validator.deriveType(sqlBinding.getScope(), thenOperand);\n+                if (!HazelcastTypeSystem.canCast(thenOperandType, caseType)) {\n+                    throw sqlBinding.newValidationError(RESOURCE.illegalMixingOfTypes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAxMzc0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446901374", "createdAt": "2020-07-12T18:48:42Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxODo0ODo0MlrOGwWTVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxODo0ODo0MlrOGwWTVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MDIzMQ==", "bodyText": "Is this \"no-overflow checking\" integrated with expressions somehow? For example, in the PLUS function, we always check for overflow, even for BIGINT(62), where the overflow is impossible.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453350231", "createdAt": "2020-07-12T18:48:42Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastIntegerType.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.BasicSqlType;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+\n+/**\n+ * Represents integer-valued types for Calcite.\n+ * <p>\n+ * Unlike the standard Calcite implementation for TINYINT, SMALLINT, INT and\n+ * BIGINT, this implementation tracks the actual bit width required to represent\n+ * integer values. That bit width information is not directly related to the\n+ * underlying machine representation. The closest concept is SQL precision\n+ * tracking done for DECIMAL type, but the bit width information tracks the\n+ * precision in terms of binary (base-2) digits instead of decimal (base-10)\n+ * digits. For instance, -1 and 1 require a single binary digit, 14 requires 4\n+ * binary digits.\n+ * <p>\n+ * In general, for an N-bit integer type the valid range of bit widths is from 0\n+ * to N: zero bit width corresponds to 0 integer value, bit widths from 1 to\n+ * N - 1 correspond to regular integer values, bit width of N bits has a special\n+ * meaning and indicates a possibility of an overflow.\n+ * <p>\n+ * For instance, for BIGINT type represented as Java {@code long} type:\n+ * the valid bit width range is from 0 to 64, 0L has BIGINT(0) type, -14L has\n+ * BIGINT(4) type, a BIGINT SQL column has BIGINT(63) type, BIGINT(64) indicates\n+ * a potential overflow.\n+ * <p>\n+ * Each arithmetic operation acting on integer types infers its return type\n+ * based on the bit width information: INT(4) + INT(10) -> INT(11),\n+ * INT(4) + INT(31) -> BIGINT(32), INT(10) + BIGINT(63) -> BIGINT(64). In the\n+ * first example the bit width was expanded; in the second example the bit width\n+ * was expanded and the type was promoted to the next wider integer type; in the\n+ * last example the bit width was expanded, but there was no wider integer type\n+ * to promote to and avoid a possible overflow.\n+ * <p>\n+ * The benefits of that bit width approach are: the smallest possible type is\n+ * always selected to represent a result of a certain operation and it's always\n+ * possible to tell from the selected type alone whether overflow checking is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAyMDE2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446902016", "createdAt": "2020-07-12T18:58:30Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxODo1ODozMFrOGwWXKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxODo1ODozMFrOGwWXKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MTIxMA==", "bodyText": "This might be a topic for a separate PR, but still - it seems that maximum possible value is a better candidate than bit width. Consider an example when we add value of the same type N times. Every PLUS operation will add an additional bit, thus, estimating the maximum value to 2^N * MAX_VALUE, while in reality, the max value is only N * MAX_VALUE. This way we may avoid unnecessary expansions.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453351210", "createdAt": "2020-07-12T18:58:30Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastIntegerType.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.BasicSqlType;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+\n+/**\n+ * Represents integer-valued types for Calcite.\n+ * <p>\n+ * Unlike the standard Calcite implementation for TINYINT, SMALLINT, INT and\n+ * BIGINT, this implementation tracks the actual bit width required to represent\n+ * integer values. That bit width information is not directly related to the\n+ * underlying machine representation. The closest concept is SQL precision\n+ * tracking done for DECIMAL type, but the bit width information tracks the\n+ * precision in terms of binary (base-2) digits instead of decimal (base-10)\n+ * digits. For instance, -1 and 1 require a single binary digit, 14 requires 4\n+ * binary digits.\n+ * <p>\n+ * In general, for an N-bit integer type the valid range of bit widths is from 0\n+ * to N: zero bit width corresponds to 0 integer value, bit widths from 1 to\n+ * N - 1 correspond to regular integer values, bit width of N bits has a special\n+ * meaning and indicates a possibility of an overflow.\n+ * <p>\n+ * For instance, for BIGINT type represented as Java {@code long} type:\n+ * the valid bit width range is from 0 to 64, 0L has BIGINT(0) type, -14L has\n+ * BIGINT(4) type, a BIGINT SQL column has BIGINT(63) type, BIGINT(64) indicates\n+ * a potential overflow.\n+ * <p>\n+ * Each arithmetic operation acting on integer types infers its return type\n+ * based on the bit width information: INT(4) + INT(10) -> INT(11),\n+ * INT(4) + INT(31) -> BIGINT(32), INT(10) + BIGINT(63) -> BIGINT(64). In the\n+ * first example the bit width was expanded; in the second example the bit width\n+ * was expanded and the type was promoted to the next wider integer type; in the\n+ * last example the bit width was expanded, but there was no wider integer type\n+ * to promote to and avoid a possible overflow.\n+ * <p>\n+ * The benefits of that bit width approach are: the smallest possible type is\n+ * always selected to represent a result of a certain operation and it's always\n+ * possible to tell from the selected type alone whether overflow checking is\n+ * necessary while executing the operation.\n+ */\n+public final class HazelcastIntegerType extends BasicSqlType {\n+\n+    private static final Map<SqlTypeName, HazelcastIntegerType[]> TYPES = new HashMap<>();\n+    private static final Map<SqlTypeName, HazelcastIntegerType[]> NULLABLE_TYPES = new HashMap<>();\n+\n+    static {\n+        // Preallocate all possible types of all possible bit widths.\n+\n+        TYPES.put(TINYINT, new HazelcastIntegerType[Byte.SIZE + 1]);\n+        TYPES.put(SMALLINT, new HazelcastIntegerType[Short.SIZE + 1]);\n+        TYPES.put(INTEGER, new HazelcastIntegerType[Integer.SIZE + 1]);\n+        TYPES.put(BIGINT, new HazelcastIntegerType[Long.SIZE + 1]);\n+\n+        for (Map.Entry<SqlTypeName, HazelcastIntegerType[]> entry : TYPES.entrySet()) {\n+            SqlTypeName typeName = entry.getKey();\n+            HazelcastIntegerType[] types = entry.getValue();\n+\n+            HazelcastIntegerType[] nullableTypes = new HazelcastIntegerType[types.length];\n+            NULLABLE_TYPES.put(typeName, nullableTypes);\n+\n+            for (int i = 0; i < types.length; ++i) {\n+                types[i] = new HazelcastIntegerType(typeName, false, i);\n+                nullableTypes[i] = new HazelcastIntegerType(typeName, true, i);\n+            }\n+        }\n+    }\n+\n+    private static final HazelcastIntegerType[] TYPES_BY_BIT_WIDTH = new HazelcastIntegerType[Long.SIZE + 1];\n+    private static final HazelcastIntegerType[] NULLABLE_TYPES_BY_BIT_WIDTH = new HazelcastIntegerType[Long.SIZE + 1];\n+\n+    static {\n+        // Build reverse mapping structures to map from a bit width to a\n+        // preferred integer type.\n+\n+        for (int i = 0; i <= Long.SIZE; ++i) {\n+            HazelcastIntegerType type;\n+            HazelcastIntegerType nullableType;\n+            if (i < Byte.SIZE) {\n+                type = TYPES.get(TINYINT)[i];\n+                nullableType = NULLABLE_TYPES.get(TINYINT)[i];\n+            } else if (i < Short.SIZE) {\n+                type = TYPES.get(SMALLINT)[i];\n+                nullableType = NULLABLE_TYPES.get(SMALLINT)[i];\n+            } else if (i < Integer.SIZE) {\n+                type = TYPES.get(INTEGER)[i];\n+                nullableType = NULLABLE_TYPES.get(INTEGER)[i];\n+            } else {\n+                type = TYPES.get(BIGINT)[i];\n+                nullableType = NULLABLE_TYPES.get(BIGINT)[i];\n+            }\n+\n+            TYPES_BY_BIT_WIDTH[i] = type;\n+            NULLABLE_TYPES_BY_BIT_WIDTH[i] = nullableType;\n+        }\n+    }\n+\n+    private final int bitWidth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAyNTY2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446902566", "createdAt": "2020-07-12T19:07:45Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTowNzo0NVrOGwWatA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTowNzo0NVrOGwWatA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjExNg==", "bodyText": "We do we disallow all-null operands? I see that the same behavior is observed in, e.g., PostgreSQL. Is it possible to explain the reason of this decision in the design doc?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352116", "createdAt": "2020-07-12T19:07:45Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastOperandTypes.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataTypeComparability;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.ComparableOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * A collection of operand type checkers. Basically, a mirror of {@link\n+ * OperandTypes} provided by Calcite with various enhancements.\n+ */\n+public final class HazelcastOperandTypes {\n+\n+    /**\n+     * The same as Calcite's {@link OperandTypes#COMPARABLE_ORDERED_COMPARABLE_ORDERED},\n+     * but selects the least restrictive type as a common type. We do character\n+     * coercion provided by {@link SqlOperandTypeChecker.Consistency#COMPARE} and\n+     * used by Calcite on our own.\n+     */\n+    public static final SqlOperandTypeChecker COMPARABLE_ORDERED_COMPARABLE_ORDERED =\n+            new ComparableOperandTypeChecker(2, RelDataTypeComparability.ALL,\n+                    SqlOperandTypeChecker.Consistency.LEAST_RESTRICTIVE);\n+\n+    private HazelcastOperandTypes() {\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing ANY type.\n+     */\n+    public static SqlSingleOperandTypeChecker notAny(SqlOperandTypeChecker base) {\n+        return new NotAny(base);\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing all of the operands to be of NULL type simultaneously.\n+     */\n+    public static SqlOperandTypeChecker notAllNull(SqlOperandTypeChecker base) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAyNjA4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446902608", "createdAt": "2020-07-12T19:08:18Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTowODoxOFrOGwWa6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTowODoxOFrOGwWa6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjE2OQ==", "bodyText": "NULL type should be reflected in the design doc.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352169", "createdAt": "2020-07-12T19:08:18Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "diffHunk": "@@ -67,7 +67,14 @@\n     TIMESTAMP_WITH_TIME_ZONE(OffsetDateTime.class),\n \n     /** OBJECT type, could be represented by any Java class. */\n-    OBJECT(Object.class);\n+    OBJECT(Object.class),\n+\n+    /**\n+     * The type of the generic SQL {@code NULL} literal.\n+     * <p>\n+     * The only valid value of {@code NULL} type is {@code null}.\n+     */\n+    NULL(Void.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAyOTY3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446902967", "createdAt": "2020-07-12T19:13:51Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOToxMzo1MVrOGwWdGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOToxMzo1MVrOGwWdGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjcyOQ==", "bodyText": "This error message is misleading. E.g. it will show \"cannot apply NULL + NULL, possible combination NUMBER + NUMBER, ...\", while in reality NUMBER + NULL is possible. Another problem is that this exception will print info about types that are not supported in the scope of this PR, such as temporal types and intervals.\nWe should provide our own sensible error message here. E.g. this is how PostgreSQL error looks like:\nERROR: operator is not unique: unknown + unknown Hint: Could not choose a best candidate operator. You might need to add explicit type casts. Position: 14", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352729", "createdAt": "2020-07-12T19:13:51Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastOperandTypes.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataTypeComparability;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.ComparableOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * A collection of operand type checkers. Basically, a mirror of {@link\n+ * OperandTypes} provided by Calcite with various enhancements.\n+ */\n+public final class HazelcastOperandTypes {\n+\n+    /**\n+     * The same as Calcite's {@link OperandTypes#COMPARABLE_ORDERED_COMPARABLE_ORDERED},\n+     * but selects the least restrictive type as a common type. We do character\n+     * coercion provided by {@link SqlOperandTypeChecker.Consistency#COMPARE} and\n+     * used by Calcite on our own.\n+     */\n+    public static final SqlOperandTypeChecker COMPARABLE_ORDERED_COMPARABLE_ORDERED =\n+            new ComparableOperandTypeChecker(2, RelDataTypeComparability.ALL,\n+                    SqlOperandTypeChecker.Consistency.LEAST_RESTRICTIVE);\n+\n+    private HazelcastOperandTypes() {\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing ANY type.\n+     */\n+    public static SqlSingleOperandTypeChecker notAny(SqlOperandTypeChecker base) {\n+        return new NotAny(base);\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing all of the operands to be of NULL type simultaneously.\n+     */\n+    public static SqlOperandTypeChecker notAllNull(SqlOperandTypeChecker base) {\n+        return new NotAllNull(base);\n+    }\n+\n+    private static final class NotAny implements SqlSingleOperandTypeChecker {\n+\n+        private final SqlOperandTypeChecker base;\n+\n+        NotAny(SqlOperandTypeChecker base) {\n+            this.base = base;\n+        }\n+\n+        @Override\n+        public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+            if (!base.checkOperandTypes(binding, throwOnFailure)) {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < binding.getOperandCount(); ++i) {\n+                if (!checkSingleOperandType(binding, binding.operand(i), i, throwOnFailure)) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return base.getOperandCountRange();\n+        }\n+\n+        @Override\n+        public String getAllowedSignatures(SqlOperator op, String opName) {\n+            return base.getAllowedSignatures(op, opName);\n+        }\n+\n+        @Override\n+        public Consistency getConsistency() {\n+            return base.getConsistency();\n+        }\n+\n+        @Override\n+        public boolean isOptional(int i) {\n+            return base.isOptional(i);\n+        }\n+\n+        @Override\n+        public boolean checkSingleOperandType(SqlCallBinding binding, SqlNode operand, int index, boolean throwOnFailure) {\n+            if (typeName(binding.getOperandType(index)) == ANY) {\n+                if (throwOnFailure) {\n+                    throw binding.newValidationSignatureError();\n+                }\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+    }\n+\n+    private static final class NotAllNull implements SqlOperandTypeChecker {\n+\n+        private final SqlOperandTypeChecker base;\n+\n+        NotAllNull(SqlOperandTypeChecker base) {\n+            this.base = base;\n+        }\n+\n+        @Override\n+        public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+            boolean seenNonNull = false;\n+            for (int i = 0; i < binding.getOperandCount(); ++i) {\n+                if (typeName(binding.getOperandType(i)) != NULL) {\n+                    seenNonNull = true;\n+                    break;\n+                }\n+            }\n+\n+            if (!seenNonNull) {\n+                if (throwOnFailure) {\n+                    throw binding.newValidationSignatureError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAzMTE0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446903114", "createdAt": "2020-07-12T19:16:24Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOToxNjoyNVrOGwWeFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOToxNjoyNVrOGwWeFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Mjk4Mw==", "bodyText": "The same problem as with \"not all null\" - the error message contains invalid \"supported forms\".", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352983", "createdAt": "2020-07-12T19:16:25Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastOperandTypes.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataTypeComparability;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.ComparableOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * A collection of operand type checkers. Basically, a mirror of {@link\n+ * OperandTypes} provided by Calcite with various enhancements.\n+ */\n+public final class HazelcastOperandTypes {\n+\n+    /**\n+     * The same as Calcite's {@link OperandTypes#COMPARABLE_ORDERED_COMPARABLE_ORDERED},\n+     * but selects the least restrictive type as a common type. We do character\n+     * coercion provided by {@link SqlOperandTypeChecker.Consistency#COMPARE} and\n+     * used by Calcite on our own.\n+     */\n+    public static final SqlOperandTypeChecker COMPARABLE_ORDERED_COMPARABLE_ORDERED =\n+            new ComparableOperandTypeChecker(2, RelDataTypeComparability.ALL,\n+                    SqlOperandTypeChecker.Consistency.LEAST_RESTRICTIVE);\n+\n+    private HazelcastOperandTypes() {\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing ANY type.\n+     */\n+    public static SqlSingleOperandTypeChecker notAny(SqlOperandTypeChecker base) {\n+        return new NotAny(base);\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing all of the operands to be of NULL type simultaneously.\n+     */\n+    public static SqlOperandTypeChecker notAllNull(SqlOperandTypeChecker base) {\n+        return new NotAllNull(base);\n+    }\n+\n+    private static final class NotAny implements SqlSingleOperandTypeChecker {\n+\n+        private final SqlOperandTypeChecker base;\n+\n+        NotAny(SqlOperandTypeChecker base) {\n+            this.base = base;\n+        }\n+\n+        @Override\n+        public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+            if (!base.checkOperandTypes(binding, throwOnFailure)) {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < binding.getOperandCount(); ++i) {\n+                if (!checkSingleOperandType(binding, binding.operand(i), i, throwOnFailure)) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return base.getOperandCountRange();\n+        }\n+\n+        @Override\n+        public String getAllowedSignatures(SqlOperator op, String opName) {\n+            return base.getAllowedSignatures(op, opName);\n+        }\n+\n+        @Override\n+        public Consistency getConsistency() {\n+            return base.getConsistency();\n+        }\n+\n+        @Override\n+        public boolean isOptional(int i) {\n+            return base.isOptional(i);\n+        }\n+\n+        @Override\n+        public boolean checkSingleOperandType(SqlCallBinding binding, SqlNode operand, int index, boolean throwOnFailure) {\n+            if (typeName(binding.getOperandType(index)) == ANY) {\n+                if (throwOnFailure) {\n+                    throw binding.newValidationSignatureError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAzNjQ0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446903644", "createdAt": "2020-07-12T19:26:15Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOToyNjoxNVrOGwWhhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOToyNjoxNVrOGwWhhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Mzg2Mg==", "bodyText": "The branch is never invoked in tests.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453353862", "createdAt": "2020-07-12T19:26:15Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {\n+\n+    private static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    public HazelcastTypeCoercion(HazelcastSqlValidator validator) {\n+        super(TYPE_FACTORY, validator);\n+    }\n+\n+    @Override\n+    public boolean binaryArithmeticCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_ARITHMETIC) && kind != PLUS_PREFIX && kind != MINUS_PREFIX) {\n+            return super.binaryArithmeticCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), true);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, types[i]);\n+            coerced |= operandCoerced;\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_EQUALITY) && !kind.belongsTo(BINARY_COMPARISON) && kind != BETWEEN) {\n+            return super.binaryComparisonCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        RelDataType commonType = types[types.length - 1];\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            RelDataType type = types[i];\n+            type = TYPE_FACTORY.createTypeWithNullability(commonType, type.isNullable());\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, type);\n+            coerced |= operandCoerced;\n+\n+            // If the operand was coerced to integer type, reassign its CAST type\n+            // back to the common type: '0':VARCHAR -> CAST('0' AS INT(31)):INT(0)\n+            // -> CAST('0' AS INT(31)):INT(31).\n+            if (operandCoerced && isInteger(type)) {\n+                updateInferredType(binding.operand(i), type);\n+            }\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean caseWhenCoercion(SqlCallBinding binding) {\n+        // Infer types.\n+\n+        SqlCase call = (SqlCase) binding.getCall();\n+        SqlNodeList thenOperands = call.getThenOperands();\n+\n+        List<SqlNode> operands = new ArrayList<>(thenOperands.size() + 1);\n+        operands.addAll(thenOperands.getList());\n+        operands.add(call.getElseOperand());\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), operands, false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < operands.size() - 1; ++i) {\n+            coerced |= coerceElementType(binding.getScope(), thenOperands, i, types[i]);\n+        }\n+        coerced |= coerceOperandType(binding.getScope(), call, 3, types[operands.size() - 1]);\n+\n+        updateInferredType(call, types[types.length - 1]);\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public RelDataType implicitCast(RelDataType in, SqlTypeFamily expected) {\n+        // enables implicit conversion from CHAR to BOOLEAN\n+        if (CHAR_TYPES.contains(typeName(in)) && expected == SqlTypeFamily.BOOLEAN) {\n+            return TYPE_FACTORY.createSqlType(BOOLEAN, in.isNullable());\n+        }\n+\n+        return super.implicitCast(in, expected);\n+    }\n+\n+    @Override\n+    protected void updateInferredType(SqlNode node, RelDataType type) {\n+        ((HazelcastSqlValidator) validator).setKnownNodeType(node, type);\n+        super.updateInferredType(node, type);\n+    }\n+\n+    @Override\n+    protected boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int index, RelDataType to) {\n+        SqlNode operand = call.getOperandList().get(index);\n+        RelDataType from = validator.deriveType(scope, operand);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail on its validation later.\n+        if (!needToCast(scope, operand, to) && canCast(from, to)) {\n+            updateInferredType(operand, to);\n+            return false;\n+        }\n+\n+        SqlNode cast = makeCast(operand, to);\n+        call.setOperand(index, cast);\n+        // derive the type of the newly created CAST immediately\n+        validator.deriveType(scope, cast);\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    @Override\n+    protected boolean needToCast(SqlValidatorScope scope, SqlNode node, RelDataType to) {\n+        RelDataType from = validator.deriveType(scope, node);\n+\n+        if (typeName(from) == typeName(to)) {\n+            // already of the same type\n+            return false;\n+        }\n+\n+        if (typeName(from) == NULL || SqlUtil.isNullLiteral(node, false)) {\n+            // never cast NULLs, just assign types to them\n+            return false;\n+        }\n+\n+        if (typeName(to) == ANY) {\n+            // all types can be implicitly interpreted as ANY\n+            return false;\n+        }\n+        if (typeName(from) == ANY) {\n+            // casting from ANY is always required\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAzOTUz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446903953", "createdAt": "2020-07-12T19:31:15Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTozMToxNVrOGwWjYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTozMToxNVrOGwWjYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDMzNw==", "bodyText": "But if casting is not possible, still insert the cast to fail on its validation later\n\nDo we have a test for that? I am interested in the exact error that will be thrown in this case", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453354337", "createdAt": "2020-07-12T19:31:15Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {\n+\n+    private static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    public HazelcastTypeCoercion(HazelcastSqlValidator validator) {\n+        super(TYPE_FACTORY, validator);\n+    }\n+\n+    @Override\n+    public boolean binaryArithmeticCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_ARITHMETIC) && kind != PLUS_PREFIX && kind != MINUS_PREFIX) {\n+            return super.binaryArithmeticCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), true);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, types[i]);\n+            coerced |= operandCoerced;\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_EQUALITY) && !kind.belongsTo(BINARY_COMPARISON) && kind != BETWEEN) {\n+            return super.binaryComparisonCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        RelDataType commonType = types[types.length - 1];\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            RelDataType type = types[i];\n+            type = TYPE_FACTORY.createTypeWithNullability(commonType, type.isNullable());\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, type);\n+            coerced |= operandCoerced;\n+\n+            // If the operand was coerced to integer type, reassign its CAST type\n+            // back to the common type: '0':VARCHAR -> CAST('0' AS INT(31)):INT(0)\n+            // -> CAST('0' AS INT(31)):INT(31).\n+            if (operandCoerced && isInteger(type)) {\n+                updateInferredType(binding.operand(i), type);\n+            }\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean caseWhenCoercion(SqlCallBinding binding) {\n+        // Infer types.\n+\n+        SqlCase call = (SqlCase) binding.getCall();\n+        SqlNodeList thenOperands = call.getThenOperands();\n+\n+        List<SqlNode> operands = new ArrayList<>(thenOperands.size() + 1);\n+        operands.addAll(thenOperands.getList());\n+        operands.add(call.getElseOperand());\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), operands, false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < operands.size() - 1; ++i) {\n+            coerced |= coerceElementType(binding.getScope(), thenOperands, i, types[i]);\n+        }\n+        coerced |= coerceOperandType(binding.getScope(), call, 3, types[operands.size() - 1]);\n+\n+        updateInferredType(call, types[types.length - 1]);\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public RelDataType implicitCast(RelDataType in, SqlTypeFamily expected) {\n+        // enables implicit conversion from CHAR to BOOLEAN\n+        if (CHAR_TYPES.contains(typeName(in)) && expected == SqlTypeFamily.BOOLEAN) {\n+            return TYPE_FACTORY.createSqlType(BOOLEAN, in.isNullable());\n+        }\n+\n+        return super.implicitCast(in, expected);\n+    }\n+\n+    @Override\n+    protected void updateInferredType(SqlNode node, RelDataType type) {\n+        ((HazelcastSqlValidator) validator).setKnownNodeType(node, type);\n+        super.updateInferredType(node, type);\n+    }\n+\n+    @Override\n+    protected boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int index, RelDataType to) {\n+        SqlNode operand = call.getOperandList().get(index);\n+        RelDataType from = validator.deriveType(scope, operand);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail on its validation later.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAzOTg0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446903984", "createdAt": "2020-07-12T19:31:47Z", "commit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTozMTo0N1rOGwWjkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTozMTo0N1rOGwWjkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA==", "bodyText": "Why DOUBLE, and not DECIMAL?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453354384", "createdAt": "2020-07-12T19:31:47Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {\n+\n+    private static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    public HazelcastTypeCoercion(HazelcastSqlValidator validator) {\n+        super(TYPE_FACTORY, validator);\n+    }\n+\n+    @Override\n+    public boolean binaryArithmeticCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_ARITHMETIC) && kind != PLUS_PREFIX && kind != MINUS_PREFIX) {\n+            return super.binaryArithmeticCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), true);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, types[i]);\n+            coerced |= operandCoerced;\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_EQUALITY) && !kind.belongsTo(BINARY_COMPARISON) && kind != BETWEEN) {\n+            return super.binaryComparisonCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        RelDataType commonType = types[types.length - 1];\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            RelDataType type = types[i];\n+            type = TYPE_FACTORY.createTypeWithNullability(commonType, type.isNullable());\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, type);\n+            coerced |= operandCoerced;\n+\n+            // If the operand was coerced to integer type, reassign its CAST type\n+            // back to the common type: '0':VARCHAR -> CAST('0' AS INT(31)):INT(0)\n+            // -> CAST('0' AS INT(31)):INT(31).\n+            if (operandCoerced && isInteger(type)) {\n+                updateInferredType(binding.operand(i), type);\n+            }\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean caseWhenCoercion(SqlCallBinding binding) {\n+        // Infer types.\n+\n+        SqlCase call = (SqlCase) binding.getCall();\n+        SqlNodeList thenOperands = call.getThenOperands();\n+\n+        List<SqlNode> operands = new ArrayList<>(thenOperands.size() + 1);\n+        operands.addAll(thenOperands.getList());\n+        operands.add(call.getElseOperand());\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), operands, false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < operands.size() - 1; ++i) {\n+            coerced |= coerceElementType(binding.getScope(), thenOperands, i, types[i]);\n+        }\n+        coerced |= coerceOperandType(binding.getScope(), call, 3, types[operands.size() - 1]);\n+\n+        updateInferredType(call, types[types.length - 1]);\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public RelDataType implicitCast(RelDataType in, SqlTypeFamily expected) {\n+        // enables implicit conversion from CHAR to BOOLEAN\n+        if (CHAR_TYPES.contains(typeName(in)) && expected == SqlTypeFamily.BOOLEAN) {\n+            return TYPE_FACTORY.createSqlType(BOOLEAN, in.isNullable());\n+        }\n+\n+        return super.implicitCast(in, expected);\n+    }\n+\n+    @Override\n+    protected void updateInferredType(SqlNode node, RelDataType type) {\n+        ((HazelcastSqlValidator) validator).setKnownNodeType(node, type);\n+        super.updateInferredType(node, type);\n+    }\n+\n+    @Override\n+    protected boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int index, RelDataType to) {\n+        SqlNode operand = call.getOperandList().get(index);\n+        RelDataType from = validator.deriveType(scope, operand);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail on its validation later.\n+        if (!needToCast(scope, operand, to) && canCast(from, to)) {\n+            updateInferredType(operand, to);\n+            return false;\n+        }\n+\n+        SqlNode cast = makeCast(operand, to);\n+        call.setOperand(index, cast);\n+        // derive the type of the newly created CAST immediately\n+        validator.deriveType(scope, cast);\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    @Override\n+    protected boolean needToCast(SqlValidatorScope scope, SqlNode node, RelDataType to) {\n+        RelDataType from = validator.deriveType(scope, node);\n+\n+        if (typeName(from) == typeName(to)) {\n+            // already of the same type\n+            return false;\n+        }\n+\n+        if (typeName(from) == NULL || SqlUtil.isNullLiteral(node, false)) {\n+            // never cast NULLs, just assign types to them\n+            return false;\n+        }\n+\n+        if (typeName(to) == ANY) {\n+            // all types can be implicitly interpreted as ANY\n+            return false;\n+        }\n+        if (typeName(from) == ANY) {\n+            // casting from ANY is always required\n+            return true;\n+        }\n+\n+        if (isParameter(node)) {\n+            // never cast parameters, just assign types to them\n+            return false;\n+        }\n+\n+        if (isLiteral(node) && !(isTemporal(from) || isTemporal(to) || isChar(from) || isChar(to))) {\n+            // never cast literals, let Calcite decide on temporal and char ones\n+            return false;\n+        }\n+\n+        return super.needToCast(scope, node, to);\n+    }\n+\n+    private boolean coerceElementType(SqlValidatorScope scope, SqlNodeList list, int index, RelDataType to) {\n+        SqlNode element = list.get(index);\n+        RelDataType from = validator.deriveType(scope, element);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail later on its validation.\n+        if (!needToCast(scope, element, to) && canCast(from, to)) {\n+            updateInferredType(element, to);\n+            return false;\n+        }\n+\n+        SqlNode cast = makeCast(element, to);\n+        list.set(index, cast);\n+        // derive the type of the newly created CAST immediately\n+        validator.deriveType(scope, cast);\n+        return true;\n+    }\n+\n+    private static SqlNode makeCast(SqlNode node, RelDataType type) {\n+        return HazelcastSqlOperatorTable.CAST.createCall(SqlParserPos.ZERO, node, SqlTypeUtil.convertTypeToSpec(type));\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:MethodLength\", \"checkstyle:NPathComplexity\",\n+            \"checkstyle:NestedIfDepth\"})\n+    private RelDataType[] inferTypes(SqlValidatorScope scope, List<SqlNode> operands, boolean assumeNumeric) {\n+        // Infer common type from columns and sub-expressions.\n+\n+        RelDataType commonType = null;\n+        boolean seenParameters = false;\n+        boolean seenChar = false;\n+\n+        for (SqlNode operand : operands) {\n+            RelDataType operandType = validator.deriveType(scope, operand);\n+            if (isLiteral(operand)) {\n+                continue;\n+            }\n+\n+            if (isParameter(operand)) {\n+                seenParameters = true;\n+            } else {\n+                commonType = commonType == null ? operandType : withHigherPrecedence(operandType, commonType);\n+                seenChar |= isChar(operandType);\n+            }\n+        }\n+\n+        // Continue common type inference on numeric literals.\n+\n+        for (SqlNode operand : operands) {\n+            RelDataType operandType = validator.deriveType(scope, operand);\n+            if (!isLiteral(operand) || !isNumeric(operandType)) {\n+                continue;\n+            }\n+            SqlLiteral literal = (SqlLiteral) operand;\n+\n+            if (literal.getValue() == null) {\n+                operandType = TYPE_FACTORY.createSqlType(NULL);\n+            } else {\n+                BigDecimal numeric = literal.getValueAs(BigDecimal.class);\n+                operandType = narrowestTypeFor(numeric, commonType == null ? null : typeName(commonType));\n+            }\n+\n+            commonType = commonType == null ? operandType : withHigherPrecedenceForLiterals(operandType, commonType);\n+        }\n+\n+        // Continue common type inference on non-numeric literals.\n+\n+        for (SqlNode operand : operands) {\n+            RelDataType operandType = validator.deriveType(scope, operand);\n+            if (!isLiteral(operand) || isNumeric(operandType)) {\n+                continue;\n+            }\n+            SqlLiteral literal = (SqlLiteral) operand;\n+\n+            if (literal.getValue() == null) {\n+                operandType = TYPE_FACTORY.createSqlType(NULL);\n+            } else if (isChar(operandType) && (commonType != null && isNumeric(commonType) || assumeNumeric)) {\n+                // Infer proper numeric type for char literals.\n+\n+                BigDecimal numeric = numericValue(operand);\n+                assert numeric != null;\n+                operandType = narrowestTypeFor(numeric, commonType == null ? null : typeName(commonType));\n+            }\n+\n+            commonType = commonType == null ? operandType : withHigherPrecedenceForLiterals(operandType, commonType);\n+        }\n+\n+        // seen only parameters\n+        if (commonType == null) {\n+            assert seenParameters;\n+            return null;\n+        }\n+\n+        // can't infer parameter types if seen only NULLs\n+        if (typeName(commonType) == NULL && seenParameters) {\n+            return null;\n+        }\n+\n+        // fallback to DOUBLE from CHAR, if numeric types assumed\n+        if (isChar(commonType) && assumeNumeric) {\n+            commonType = TYPE_FACTORY.createSqlType(DOUBLE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4"}, "originalPosition": 340}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA0Mjkx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446904291", "createdAt": "2020-07-12T19:36:23Z", "commit": {"oid": "b4fc2cb65857e9e3f59c91b56da643807522ca91"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA1NjYx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-446905661", "createdAt": "2020-07-12T19:57:53Z", "commit": {"oid": "b4fc2cb65857e9e3f59c91b56da643807522ca91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTo1Nzo1M1rOGwWtnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxOTo1Nzo1M1rOGwWtnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Njk1Nw==", "bodyText": "INT type is displayed as INTEGER in Calcite exception. I think we'd better rename our type to INTEGER", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453356957", "createdAt": "2020-07-12T19:57:53Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "diffHunk": "@@ -67,7 +67,14 @@\n     TIMESTAMP_WITH_TIME_ZONE(OffsetDateTime.class),\n \n     /** OBJECT type, could be represented by any Java class. */\n-    OBJECT(Object.class);\n+    OBJECT(Object.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4fc2cb65857e9e3f59c91b56da643807522ca91"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92df37338146abc2fc9a502c159b338449448b97", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/92df37338146abc2fc9a502c159b338449448b97", "committedDate": "2020-07-13T09:53:18Z", "message": "verify return types after conversion"}, "afterCommit": {"oid": "80c991bd54ee8a81bb91d53dbd54107c04865257", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/80c991bd54ee8a81bb91d53dbd54107c04865257", "committedDate": "2020-07-13T09:54:23Z", "message": "verify return types after conversion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTIyMDg1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-451122085", "createdAt": "2020-07-19T11:16:31Z", "commit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMToxNjozMVrOGzusZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMToxNjozMVrOGzusZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NTU4OQ==", "bodyText": "Typo: bellow -> below", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r456895589", "createdAt": "2020-07-19T11:16:31Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastRexBuilder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+\n+/**\n+ * Custom Hazelcast expression builder.\n+ * <p>\n+ * Currently, this custom expression builder is used just to workaround quirks\n+ * of the default Calcite expression builder.\n+ */\n+public final class HazelcastRexBuilder extends RexBuilder {\n+\n+    public HazelcastRexBuilder(RelDataTypeFactory typeFactory) {\n+        super(typeFactory);\n+        assert typeFactory instanceof HazelcastTypeFactory;\n+    }\n+\n+    @Override\n+    public RexNode makeLiteral(Object value, RelDataType type, boolean allowCast) {\n+        // XXX: Calcite evaluates casts like CAST(0 AS ANY) statically and\n+        // assigns imprecise types: BIGINT for any integer value and DOUBLE for\n+        // any floating-point value (except BigDecimal). The code bellow fixes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMzcxODUw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-451371850", "createdAt": "2020-07-20T07:50:12Z", "commit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNzo1MDoxMlrOGz94Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNzo1MDoxMlrOGz94Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NDM1OQ==", "bodyText": "Can we reuse here super.equals()?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r457144359", "createdAt": "2020-07-20T07:50:12Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/BiExpressionWithType.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Base class for expressions acting on two operands and having a variable result\n+ * type.\n+ */\n+public abstract class BiExpressionWithType<T> extends BiExpression<T> {\n+\n+    protected QueryDataType resultType;\n+\n+    protected BiExpressionWithType() {\n+        // No-op.\n+    }\n+\n+    protected BiExpressionWithType(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        this.operand1 = operand1;\n+        this.operand2 = operand2;\n+        this.resultType = resultType;\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        super.writeData(out);\n+\n+        out.writeObject(resultType);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        super.readData(in);\n+\n+        resultType = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(operand1, operand2, resultType);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        BiExpressionWithType<?> that = (BiExpressionWithType<?>) o;\n+\n+        return Objects.equals(operand1, that.operand1) && Objects.equals(operand2, that.operand2) && Objects.equals(resultType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMzk0OTEy", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-451394912", "createdAt": "2020-07-20T08:23:41Z", "commit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODoyMzo0MVrOGz_V8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODoyMzo0MVrOGz_V8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE2ODM2OQ==", "bodyText": "Why do we expect here uneven expressions count?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r457168369", "createdAt": "2020-07-20T08:23:41Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/CaseExpression.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Implements evaluation of SQL CASE operator.\n+ */\n+public final class CaseExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private Expression<Boolean>[] conditions;\n+    private Expression<?>[] results;\n+    private QueryDataType resultType;\n+\n+    public CaseExpression() {\n+        // No-op.\n+    }\n+\n+    private CaseExpression(Expression<Boolean>[] conditions, Expression<?>[] results, QueryDataType resultType) {\n+        this.conditions = conditions;\n+        this.results = results;\n+        this.resultType = resultType;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static CaseExpression<?> create(Expression<?>[] expressions, QueryDataType resultType) {\n+        // Split conditions and expressions.\n+        assert expressions != null;\n+        assert expressions.length % 2 == 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNTEzMDQ5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-451513049", "createdAt": "2020-07-20T11:14:59Z", "commit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMToxNDo1OVrOG0Gubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMToxNDo1OVrOG0Gubg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI4OTMyNg==", "bodyText": "More JavaDoc about the precedence argument would be helpful. Are these numbers taken from the spec?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r457289326", "createdAt": "2020-07-20T11:14:59Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -16,13 +16,257 @@\n \n package com.hazelcast.sql.impl.calcite.validate;\n \n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCaseOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCastFunction;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlMonotonicBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastReturnTypes;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlPostfixOperator;\n+import org.apache.calcite.sql.SqlPrefixOperator;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n import org.apache.calcite.sql.util.ReflectiveSqlOperatorTable;\n \n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAllNull;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n /**\n- * An additional functions that are resolved during query parsing/validation.\n+ * Custom functions and operators.\n  */\n public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable {\n \n+    //@formatter:off\n+\n+    public static final SqlFunction CAST = new HazelcastSqlCastFunction();\n+\n+    public static final SqlOperator CASE = new HazelcastSqlCaseOperator();\n+\n+    //#region Predicates.\n+\n+    public static final SqlBinaryOperator AND = new HazelcastSqlBinaryOperator(\n+        \"AND\",\n+        SqlKind.AND,\n+        24,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ddd45d93de22e1b18f017c4a041231cc5b3229"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MTY2NzY5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-454166769", "createdAt": "2020-07-23T14:05:44Z", "commit": {"oid": "61a4f52218d94010087f1955d09fac33d8b70543"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDowNTo0NFrOG2MKLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDowNTo0NFrOG2MKLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw==", "bodyText": "There is one strange thing about type coercion I observe with IN and OR operators. Consider that we have a table t(f INT), The following two queries are presumably equivalent:\nSELECT * FROM t WHERE f=? OR f=?\nSELECT * FROM t WHERE f IN (?,?)\n\nHowever, generated filters are not equivalent:\nOR(=(CAST($0):BIGINT(63), ?0), =(CAST($0):BIGINT(63), ?0))\nOR(=($0, ?0), =($0, ?1))\n\nThat is, we do upcast for OR, but not for IN.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459475503", "createdAt": "2020-07-23T14:05:44Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61a4f52218d94010087f1955d09fac33d8b70543"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MTk5NDY2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-454199466", "createdAt": "2020-07-23T14:39:28Z", "commit": {"oid": "61a4f52218d94010087f1955d09fac33d8b70543"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozOToyOFrOG2Nrww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozOToyOFrOG2Nrww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMDQ4Mw==", "bodyText": "It seems that the comparison of objects is not supported. When I attempt to do f=f for t(f:ANY), the following exception is thrown:\nCannot apply '=' to arguments of type '<ANY> = <ANY>'. Supported form(s): '<COMPARABLE_TYPE> = <COMPARABLE_TYPE>'\n\nThere are two potential problems here:\n\nWhy object comparison is not supported in the first place?\nIf there is a reason to not support it right now, then error message is not intuitive: ANY could be COMPARABLE_TYPE", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459500483", "createdAt": "2020-07-23T14:39:28Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61a4f52218d94010087f1955d09fac33d8b70543"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTQyNzYw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-455142760", "createdAt": "2020-07-24T19:43:15Z", "commit": {"oid": "be03c993b308fb3e328b19f54795d4172ac82d6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0MzoxNVrOG27qRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0MzoxNVrOG27qRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1Mzc2NQ==", "bodyText": "This assertion fails for some types, e.g. for QueryDataType DECIMAL_BIG_INTEGER\nWhen we do bigIntegerColumn=?, then on the left side we have QueryDataType DECIMAL_BIG_INTEGER, but on the right side we have QueryDataType DECIMAL. They are not equal.\nPerhaps the correct assert should check for type family, not type.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r460253765", "createdAt": "2020-07-24T19:43:15Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private ComparisonMode mode;\n+\n+    public ComparisonPredicate() {\n+        // No-op.\n+    }\n+\n+    private ComparisonPredicate(Expression<?> left, Expression<?> right, ComparisonMode mode) {\n+        super(left, right);\n+        this.mode = mode;\n+    }\n+\n+    public static ComparisonPredicate create(Expression<?> left, Expression<?> right, ComparisonMode comparisonMode) {\n+        assert left.getType().equals(right.getType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03c993b308fb3e328b19f54795d4172ac82d6c"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "446d0f284950df93d91306a8e4f6106c6875f327", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/446d0f284950df93d91306a8e4f6106c6875f327", "committedDate": "2020-07-27T09:19:16Z", "message": "minsu end-to-end test"}, "afterCommit": {"oid": "563815a422393a794bca782047009b922bd8f020", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/563815a422393a794bca782047009b922bd8f020", "committedDate": "2020-07-27T09:30:54Z", "message": "minsu end-to-end test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MDQ3NDA4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-459047408", "createdAt": "2020-07-31T09:42:30Z", "commit": {"oid": "1c19573976bfd66fa2aa2616e22787493cacba4c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo0MjozMFrOG6CjVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo0MjozMFrOG6CjVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjQwNg==", "bodyText": "I came across this error message (here and in many other expressions) when doing tests that causes overflow. The problem is that it is not specific - the user will just receive it in runtime, without any understanding of what exactly went wrong.\nWhen implementing new operators I do something like this:\nthrow QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n    \"BIGINT overflow in ABS function (consider adding explicit CAST to DECIMAL)\");\n\nI borrowed this approach from Postgres error messages - they always try to provide better user experience by adding more context to the error message.\nI propose to follow a similar approach in the expressions in this PR.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r463512406", "createdAt": "2020-07-31T09:42:30Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/PlusFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Implements evaluation of SQL plus operator.\n+ */\n+public final class PlusFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    public PlusFunction() {\n+        // No-op.\n+    }\n+\n+    private PlusFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        super(operand1, operand2, resultType);\n+    }\n+\n+    public static PlusFunction<?> create(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        return new PlusFunction<>(operand1, operand2, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_PLUS;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        QueryDataTypeFamily family = resultType.getTypeFamily();\n+        if (family.isTemporal()) {\n+            throw new UnsupportedOperationException(\"temporal types are unsupported currently\");\n+        }\n+\n+        return (T) evalNumeric((Number) left, (Number) right, family);\n+    }\n+\n+    private static Object evalNumeric(Number left, Number right, QueryDataTypeFamily family) {\n+        switch (family) {\n+            case TINYINT:\n+                return (byte) (left.byteValue() + right.byteValue());\n+            case SMALLINT:\n+                return (short) (left.shortValue() + right.shortValue());\n+            case INT:\n+                return left.intValue() + right.intValue();\n+            case BIGINT:\n+                try {\n+                    return Math.addExact(left.longValue(), right.longValue());\n+                } catch (ArithmeticException e) {\n+                    throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"BIGINT overflow\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c19573976bfd66fa2aa2616e22787493cacba4c"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5Nzg4MDk5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-459788099", "createdAt": "2020-08-03T06:57:29Z", "commit": {"oid": "1c19573976bfd66fa2aa2616e22787493cacba4c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1NzoyOVrOG6uLeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1NzoyOVrOG6uLeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzE5Mg==", "bodyText": "The comment relates to this piece of code and other code places where we dump the value. This could be a potential security vulnerability: we add the value to the message, and it could be printed to the application log.\nImagine an application where there are two roles - administrator and HR. An HR submits an invalid query that prints something like \"Cannot convert VARCHAR to DECIMAL: \". Now, by knowing the nature of the application the administrator can infer sensitive information from logs.\nOr imagine that in future we added some sort of row-level security, that allows users to query only rows that satisfy a certain predicate. Again, by carefully constructing the query a user may dump values that he should not have access to.\nNote that some values a harmless, e.g. literals. While others could be sensitive, e.g. column values.\n@kwart What do you think about that? I think we should avoid printing arbitrary internal values to logs.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464227192", "createdAt": "2020-08-03T06:57:29Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converter.java", "diffHunk": "@@ -318,6 +318,20 @@ protected final QueryException cannotConvert(QueryDataTypeFamily source, QueryDa\n         return QueryException.error(SqlErrorCode.DATA_EXCEPTION, message);\n     }\n \n+    protected final QueryException numericOverflow(QueryDataTypeFamily target, Object val) {\n+        return numericOverflow(typeFamily, target, val);\n+    }\n+\n+    protected final QueryException numericOverflow(QueryDataTypeFamily source, QueryDataTypeFamily target, Object val) {\n+        String message = \"Numeric overflow while converting \" + source + \" to \" + target;\n+\n+        if (val != null) {\n+            message += \": \" + val;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c19573976bfd66fa2aa2616e22787493cacba4c"}, "originalPosition": 61}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd2d5d78ed24204bdeea13100415201eb6897e9b", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/dd2d5d78ed24204bdeea13100415201eb6897e9b", "committedDate": "2020-08-05T05:48:00Z", "message": "fix a typo"}, "afterCommit": {"oid": "8bcaecc322c40f6efa45deb4b9a6bffdcdd2f7c3", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8bcaecc322c40f6efa45deb4b9a6bffdcdd2f7c3", "committedDate": "2020-08-05T06:01:26Z", "message": "rebase and fix compilation errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzgyMTg5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461382189", "createdAt": "2020-08-05T06:45:36Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo0NTozNlrOG78XFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo0NTozNlrOG78XFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODExNw==", "bodyText": "catch (QueryException) misses other types of exceptions. It seems we need catch (Exception) here", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465508117", "createdAt": "2020-08-05T06:45:36Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -209,4 +210,33 @@ public QueryOperationHandlerImpl getOperationHandler() {\n     public QueryClientStateRegistry getClientStateRegistry() {\n         return clientStateRegistry;\n     }\n+\n+    private void prepareParameters(Plan plan, List<Object> params) {\n+        assert params != null;\n+        QueryParameterMetadata parameterMetadata = plan.getParameterMetadata();\n+\n+        int parameterCount = parameterMetadata.getParameterCount();\n+        if (parameterCount != params.size()) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"Unexpected parameter count: expected \" + parameterCount + \", got \" + params.size());\n+        }\n+\n+        for (int i = 0; i < params.size(); ++i) {\n+            Object value = params.get(i);\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            Converter valueConverter = Converters.getConverter(value.getClass());\n+            Converter typeConverter = parameterMetadata.getParameterType(i).getConverter();\n+            try {\n+                value = typeConverter.convertToSelf(valueConverter, value);\n+            } catch (QueryException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzg2MDcx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461386071", "createdAt": "2020-08-05T06:52:36Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo1MjozN1rOG78jrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo1MjozN1rOG78jrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxMTM0Mw==", "bodyText": "Can we have a more specific error message here? Strictly speaking, NaN -> Long is not an overflow, but an invalid conversion.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465511343", "createdAt": "2020-08-05T06:52:37Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/FloatConverter.java", "diffHunk": "@@ -38,27 +40,66 @@ private FloatConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        float casted = cast(val);\n+        // here the overflow may happen: (byte) casted = (byte) (int) casted\n+        byte converted = (byte) casted;\n+\n+        // casts from float to int are saturating\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        float casted = cast(val);\n+        // here the overflow may happen: (short) casted = (short) (int) casted\n+        short converted = (short) casted;\n+\n+        // casts from float to int are saturating\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        float casted = cast(val);\n+        // casts from float to int are saturating\n+        int converted = (int) casted;\n+\n+        // casts from float to long are saturating\n+        if (converted != (long) casted || !Float.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        float casted = cast(val);\n+        float truncated = (float) (casted > 0.0 ? Math.floor(casted) : Math.ceil(casted));\n+        // casts from float to long are saturating\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((float) converted != truncated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzk3ODU5", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461397859", "createdAt": "2020-08-05T07:13:25Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoxMzoyNVrOG79INg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoxMzoyNVrOG79INg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyMDY5NA==", "bodyText": "What would happen if we have a literal that just happened to have e or E character, but otherwise is not a number? The exception mentions that the literal \"cannot be converted to DECIMAL\", while this is not really the case - we may have attempted to convert it to DOUBLE. Can we change it to something like ... cannot be converted to numeric type?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465520694", "createdAt": "2020-08-05T07:13:25Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.APPROX_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.EXACT_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {\n+\n+    private SqlNodeUtil() {\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlDynamicParam\n+     * dynamic parameter}, {@code false} otherwise.\n+     */\n+    public static boolean isParameter(SqlNode node) {\n+        return node.getKind() == SqlKind.DYNAMIC_PARAM;\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlLiteral literal},\n+     * {@code false} otherwise.\n+     */\n+    public static boolean isLiteral(SqlNode node) {\n+        return node.getKind() == SqlKind.LITERAL;\n+    }\n+\n+    /**\n+     * Obtains a numeric value of the given node if it's a numeric or string\n+     * {@linkplain SqlLiteral literal}.\n+     * <p>\n+     * If the literal represents an exact value (see {@link\n+     * SqlTypeName#EXACT_TYPES}), the obtained numeric value is {@link BigDecimal}.\n+     * Otherwise, if the literal represents an approximate value (see {@link\n+     * SqlTypeName#APPROX_TYPES}), the obtained numeric value is {@link Double}.\n+     *\n+     * @param node the node to obtain the numeric value of.\n+     * @return the obtained numeric value or {@code null} if the given node is\n+     * not a numeric or string literal.\n+     * @throws CalciteContextException if the given node is a string literal\n+     *                                 that doesn't have a valid numeric\n+     *                                 representation.\n+     */\n+    public static Number numericValue(SqlNode node) {\n+        if (node.getKind() != SqlKind.LITERAL) {\n+            return null;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) node;\n+        SqlTypeName typeName = literal.getTypeName();\n+\n+        if (CHAR_TYPES.contains(typeName)) {\n+            try {\n+                String value = literal.getValueAs(String.class);\n+                if (value == null) {\n+                    return null;\n+                }\n+\n+                if (value.contains(\"e\") || value.contains(\"E\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDAzNjQ0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461403644", "createdAt": "2020-08-05T07:22:52Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoyMjo1MlrOG79ajA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoyMjo1MlrOG79ajA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNTM4OA==", "bodyText": "The test doesn't assert MIN_VALUE-s. For example, Byte.MAX_VALUE yields TINYINT, while Byte.MIN_VALUE yields SMALLINT. Is there a reason for this?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465525388", "createdAt": "2020-08-05T07:22:52Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/LiteralEndToEndTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.NULL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class LiteralEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testValid() {\n+        assertRow(\"0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"-0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"000\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"1\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"-1\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"-01\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"001\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"100\", EXPR0, TINYINT, (byte) 100);\n+        assertRow(Byte.toString(Byte.MAX_VALUE), EXPR0, TINYINT, Byte.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDA0Mzgx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461404381", "createdAt": "2020-08-05T07:24:02Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoyNDowM1rOG79c1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoyNDowM1rOG79c1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNTk3NA==", "bodyText": "Is it possible to specify NaN or infinite values as literal? AFAIK some databases, such as Postgres, can do that", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465525974", "createdAt": "2020-08-05T07:24:03Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/LiteralEndToEndTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.NULL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class LiteralEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testValid() {\n+        assertRow(\"0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"-0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"000\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"1\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"-1\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"-01\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"001\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"100\", EXPR0, TINYINT, (byte) 100);\n+        assertRow(Byte.toString(Byte.MAX_VALUE), EXPR0, TINYINT, Byte.MAX_VALUE);\n+\n+        assertRow(Short.toString((short) (Byte.MAX_VALUE + 1)), EXPR0, SMALLINT, (short) (Byte.MAX_VALUE + 1));\n+        assertRow(Short.toString(Short.MAX_VALUE), EXPR0, SMALLINT, Short.MAX_VALUE);\n+\n+        assertRow(Integer.toString(Short.MAX_VALUE + 1), EXPR0, INTEGER, Short.MAX_VALUE + 1);\n+        assertRow(Integer.toString(Integer.MAX_VALUE), EXPR0, INTEGER, Integer.MAX_VALUE);\n+\n+        assertRow(Long.toString(Integer.MAX_VALUE + 1L), EXPR0, BIGINT, Integer.MAX_VALUE + 1L);\n+        assertRow(Long.toString(Long.MAX_VALUE), EXPR0, BIGINT, Long.MAX_VALUE);\n+\n+        assertRow(\"0.0\", EXPR0, DECIMAL, new BigDecimal(\"0.0\"));\n+        assertRow(\"1.0\", EXPR0, DECIMAL, new BigDecimal(\"1.0\"));\n+        assertRow(\"1.000\", EXPR0, DECIMAL, new BigDecimal(\"1.000\"));\n+        assertRow(\"001.000\", EXPR0, DECIMAL, new BigDecimal(\"1.000\"));\n+        assertRow(\"1.1\", EXPR0, DECIMAL, new BigDecimal(\"1.1\"));\n+        assertRow(\"1.100\", EXPR0, DECIMAL, new BigDecimal(\"1.100\"));\n+        assertRow(\"001.100\", EXPR0, DECIMAL, new BigDecimal(\"1.100\"));\n+        assertRow(\"-0.0\", EXPR0, DECIMAL, new BigDecimal(\"0.0\"));\n+        assertRow(\"-1.0\", EXPR0, DECIMAL, new BigDecimal(\"-1.0\"));\n+        assertRow(\"-001.100\", EXPR0, DECIMAL, new BigDecimal(\"-1.100\"));\n+        assertRow(\".0\", EXPR0, DECIMAL, BigDecimal.valueOf(0.0));\n+        assertRow(\".1\", EXPR0, DECIMAL, BigDecimal.valueOf(0.1));\n+\n+        assertRow(\"0e0\", EXPR0, DOUBLE, 0.0);\n+        assertRow(\"1e0\", EXPR0, DOUBLE, 1.0);\n+        assertRow(\"1e000\", EXPR0, DOUBLE, 1.0);\n+        assertRow(\"001e000\", EXPR0, DOUBLE, 1.0);\n+        assertRow(\"1.1e0\", EXPR0, DOUBLE, 1.1);\n+        assertRow(\"1.100e0\", EXPR0, DOUBLE, 1.1);\n+        assertRow(\"001.100e0\", EXPR0, DOUBLE, 1.1);\n+        assertRow(\"-0.0e0\", EXPR0, DOUBLE, 0.0);\n+        assertRow(\"-1.0e0\", EXPR0, DOUBLE, -1.0);\n+        assertRow(\"-001.100e0\", EXPR0, DOUBLE, -1.1);\n+        assertRow(\".0e0\", EXPR0, DOUBLE, 0.0);\n+        assertRow(\".1e0\", EXPR0, DOUBLE, 0.1);\n+        assertRow(\"1.1e1\", EXPR0, DOUBLE, 11.0);\n+        assertRow(\"1.1e-1\", EXPR0, DOUBLE, 0.11);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDA4MzEz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461408313", "createdAt": "2020-08-05T07:30:04Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzozMDowNFrOG79oqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzozMDowNFrOG79oqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyOTAwMg==", "bodyText": "This test mostly tests parameters with expressions but does not test parameters in isolation. The interesting part here is what would happen when the parameter's value is converted (valid or invalid), and the behavior for SELECT ? ...", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465529002", "createdAt": "2020-08-05T07:30:04Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ParameterEndToEndTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ParameterEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertRow(\"booleanTrue and ?\", EXPR0, BOOLEAN, false, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDI4MzQz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461428343", "createdAt": "2020-08-05T07:59:25Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzo1OToyNVrOG7-ltQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzo1OToyNVrOG7-ltQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ==", "bodyText": "There is one very subtle thing with literal conversions. Consider the following expressions and produced result types. The concrete function is not that important here, because the problem appears to be in the inference mechanics:\nSELECT ABS(1) ... // DECIMAL\nSELECT ABS(`1`) ... // DECIMAL due to inference VARCHAR -> DECIMAL\nSELECT ABS(1E0) ... // DOUBLE\nSELECT ABS(`1E0`) ... // DECIMAL due to inference path VARCHAR -> DECIMAL\n\nThe last result could be surprising to users - somehow an inexact expression is converted to the exact form. I do not say that this is definitely a bug, but ideally we should have a consistent behavior.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465544629", "createdAt": "2020-08-05T07:59:25Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.APPROX_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.EXACT_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {\n+\n+    private SqlNodeUtil() {\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlDynamicParam\n+     * dynamic parameter}, {@code false} otherwise.\n+     */\n+    public static boolean isParameter(SqlNode node) {\n+        return node.getKind() == SqlKind.DYNAMIC_PARAM;\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlLiteral literal},\n+     * {@code false} otherwise.\n+     */\n+    public static boolean isLiteral(SqlNode node) {\n+        return node.getKind() == SqlKind.LITERAL;\n+    }\n+\n+    /**\n+     * Obtains a numeric value of the given node if it's a numeric or string\n+     * {@linkplain SqlLiteral literal}.\n+     * <p>\n+     * If the literal represents an exact value (see {@link\n+     * SqlTypeName#EXACT_TYPES}), the obtained numeric value is {@link BigDecimal}.\n+     * Otherwise, if the literal represents an approximate value (see {@link\n+     * SqlTypeName#APPROX_TYPES}), the obtained numeric value is {@link Double}.\n+     *\n+     * @param node the node to obtain the numeric value of.\n+     * @return the obtained numeric value or {@code null} if the given node is\n+     * not a numeric or string literal.\n+     * @throws CalciteContextException if the given node is a string literal\n+     *                                 that doesn't have a valid numeric\n+     *                                 representation.\n+     */\n+    public static Number numericValue(SqlNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDQ0Nzcy", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-461444772", "createdAt": "2020-08-05T08:22:13Z", "commit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwODoyMjoxM1rOG7_Xuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwODoyMjoxM1rOG7_Xuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NzQzNQ==", "bodyText": "We throw overflow exceptions for NaN/Infinite. However, it seems that conversion to VARCHAR works fine in this case. Consider the following statement\nSELECT ... CAST((CAST doubleCol as VARCHAR) as DOUBLE) ...\n\nWhat would happen if the value of the column is NaN? Will it convert the NaN string back to Double.NaN?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465557435", "createdAt": "2020-08-05T08:22:13Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/DoubleConverter.java", "diffHunk": "@@ -38,27 +40,65 @@ private DoubleConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        double casted = cast(val);\n+        // here the overflow may happen: (byte) casted = (byte) (int) casted\n+        byte converted = (byte) casted;\n+\n+        // casts from double to int are saturating\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        double casted = cast(val);\n+        // here the overflow may happen: (short) casted = (short) (int) casted\n+        short converted = (short) casted;\n+\n+        // casts from double to int are saturating\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        double casted = cast(val);\n+        int converted = (int) casted;\n+\n+        // casts from double to long are saturating\n+        if (converted != (long) casted || !Double.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        double casted = cast(val);\n+        double truncated = casted > 0.0 ? Math.floor(casted) : Math.ceil(casted);\n+        // casts from double to long are saturating\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((double) converted != truncated) {\n+            throw numericOverflow(QueryDataTypeFamily.BIGINT, val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNDU5ODkz", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-462459893", "createdAt": "2020-08-06T12:14:08Z", "commit": {"oid": "3d4560a657e7723584fa0dfb6e4b7d2c498b1cfc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMjoxNDowOFrOG8w3DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMjoxNDowOFrOG8w3DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM2ODI2OA==", "bodyText": "I would propose to add the type to which we tried to convert. E.g.:\nFailed to convert parameter at position 1 to VARCHAR: ...", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466368268", "createdAt": "2020-08-06T12:14:08Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -209,4 +210,33 @@ public QueryOperationHandlerImpl getOperationHandler() {\n     public QueryClientStateRegistry getClientStateRegistry() {\n         return clientStateRegistry;\n     }\n+\n+    private void prepareParameters(Plan plan, List<Object> params) {\n+        assert params != null;\n+        QueryParameterMetadata parameterMetadata = plan.getParameterMetadata();\n+\n+        int parameterCount = parameterMetadata.getParameterCount();\n+        if (parameterCount != params.size()) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"Unexpected parameter count: expected \" + parameterCount + \", got \" + params.size());\n+        }\n+\n+        for (int i = 0; i < params.size(); ++i) {\n+            Object value = params.get(i);\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            Converter valueConverter = Converters.getConverter(value.getClass());\n+            Converter typeConverter = parameterMetadata.getParameterType(i).getConverter();\n+            try {\n+                value = typeConverter.convertToSelf(valueConverter, value);\n+            } catch (RuntimeException e) {\n+                throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d4560a657e7723584fa0dfb6e4b7d2c498b1cfc"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzE0NDgx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464314481", "createdAt": "2020-08-10T15:05:59Z", "commit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTowNjowMFrOG-SmwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTo0MjoyNlrOG-UgWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2OTcyOA==", "bodyText": "The order of TIME and DATE is different in columns and rows.\nWe can use - instead of I on the diagonal where no conversion takes place (like VARCHAR to VARCHAR)\nOn line 132 above: also implicit conversion can fail", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r467969728", "createdAt": "2020-08-10T15:06:00Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/01-type-system.md", "diffHunk": "@@ -127,22 +134,23 @@ converted to the target type.\n \n *Table 4: Type conversions (I - implicit, E - explicit)*\n \n-| From/To | VARCHAR | BOOLEAN | TINYINT | SMALLINT | INT | BIGINT | DECIMAL | REAL | DOUBLE | DATE | TIME | TIMESTAMP | TIMESTAMP W/ TZ | OBJECT |\n-|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n-| **VARCHAR** | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` |\n-| **BOOLEAN** | `E` | `I` |  |  |  |  |  |  |  |  |  |  |  | `I` |\n-| **TINYINT** | `E` |  | `I` | `I` | `I` | `I` | `I` | `I` |`I`  |  |  |  |  | `I` |\n-| **SMALLINT** | `E` |  | `E` | `I` | `I` | `I` | `I` | `I` | `I` |  |  |  |  | `I` |\n-| **INT** | `E` |  | `E` | `E` | `I` | `I` | `I` | `I` | `I` |  |  |  |  | `I` |\n-| **BIGINT** | `E` |  | `E` | `E` | `E` | `I` | `I` | `I` | `I` |  |  |  |  | `I` |\n-| **DECIMAL** | `E` |  | `E` | `E` | `E` | `E` | `I` | `I` | `I` |  |  |  |  | `I` |\n-| **REAL** | `E` |  | `E` | `E` | `E` | `E` | `E` | `I` | `I` |  |  |  |  | `I` |\n-| **DOUBLE** | `E` |  | `E` | `E` | `E` | `E` | `E` | `E` | `I` |  |  |  |  | `I` |\n-| **TIME** | `E` |  |  |  |  |  |  |  |  |  | `I` | `I` | `I` | `I` |\n-| **DATE** | `E` |  |  |  |  |  |  |  |  | `I` |  | `I` | `I` | `I` |\n-| **TIMESTAMP** | `E` |  |  |  |  |  |  |  |  | `E` | `E` | `I` | `I` | `I` |\n-| **TIMESTAMP W/ TZ** | `E` |  |  |  |  |  |  |  |  | `E` | `E` | `E`  | `I` | `I` |\n-| **OBJECT** | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `I` |\n+| From/To | NULL | VARCHAR | BOOLEAN | TINYINT | SMALLINT | INTEGER | BIGINT | DECIMAL | REAL | DOUBLE | DATE | TIME | TIMESTAMP | TIMESTAMP W/ TZ | OBJECT |\n+|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n+| **NULL** | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` |\n+| **VARCHAR** |  | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` | `I` |\n+| **BOOLEAN** |  | `E` | `I` |  |  |  |  |  |  |  |  |  |  |  | `I` |\n+| **TINYINT** |  | `E` |  | `I` | `I` | `I` | `I` | `I` | `I` |`I`  |  |  |  |  | `I` |\n+| **SMALLINT** |  | `E` |  | `E` | `I` | `I` | `I` | `I` | `I` | `I` |  |  |  |  | `I` |\n+| **INTEGER** |  | `E` |  | `E` | `E` | `I` | `I` | `I` | `I` | `I` |  |  |  |  | `I` |\n+| **BIGINT** |  | `E` |  | `E` | `E` | `E` | `I` | `I` | `I` | `I` |  |  |  |  | `I` |\n+| **DECIMAL** |  | `E` |  | `E` | `E` | `E` | `E` | `I` | `I` | `I` |  |  |  |  | `I` |\n+| **REAL** |  | `E` |  | `E` | `E` | `E` | `E` | `E` | `I` | `I` |  |  |  |  | `I` |\n+| **DOUBLE** |  | `E` |  | `E` | `E` | `E` | `E` | `E` | `E` | `I` |  |  |  |  | `I` |\n+| **TIME** |  | `E` |  |  |  |  |  |  |  |  |  | `I` | `I` | `I` | `I` |\n+| **DATE** |  | `E` |  |  |  |  |  |  |  |  | `I` |  | `I` | `I` | `I` |\n+| **TIMESTAMP** |  | `E` |  |  |  |  |  |  |  |  | `E` | `E` | `I` | `I` | `I` |\n+| **TIMESTAMP W/ TZ** |  | `E` |  |  |  |  |  |  |  |  | `E` | `E` | `E`  | `I` | `I` |\n+| **OBJECT** |  | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `E` | `I` |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwMDg1Nw==", "bodyText": "If I understand this comment correctly, bitWidthOf(N) = bitWidthOf(-N). But it doesn't hold here, bitWidthOf(128) = 8 and bitWidthOf(-128) = 7. Is this correct?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468000857", "createdAt": "2020-08-10T15:42:26Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastIntegerTypeTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.hazelcast.test.HazelcastTestSupport.assertThrows;\n+import static org.apache.calcite.sql.parser.SqlParserPos.ZERO;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class HazelcastIntegerTypeTest {\n+\n+    @Test\n+    public void testIntegerTypeOfTypeName() {\n+        assertType(TINYINT, Byte.SIZE - 1, false, HazelcastIntegerType.of(TINYINT));\n+        assertType(SMALLINT, Short.SIZE - 1, false, HazelcastIntegerType.of(SMALLINT));\n+        assertType(INTEGER, Integer.SIZE - 1, false, HazelcastIntegerType.of(INTEGER));\n+        assertType(BIGINT, Long.SIZE - 1, false, HazelcastIntegerType.of(BIGINT));\n+    }\n+\n+    @Test\n+    public void testNullableIntegerTypeOfTypeName() {\n+        assertType(TINYINT, Byte.SIZE - 1, false, HazelcastIntegerType.of(TINYINT, false));\n+        assertType(SMALLINT, Short.SIZE - 1, false, HazelcastIntegerType.of(SMALLINT, false));\n+        assertType(INTEGER, Integer.SIZE - 1, false, HazelcastIntegerType.of(INTEGER, false));\n+        assertType(BIGINT, Long.SIZE - 1, false, HazelcastIntegerType.of(BIGINT, false));\n+\n+        assertType(TINYINT, Byte.SIZE - 1, true, HazelcastIntegerType.of(TINYINT, true));\n+        assertType(SMALLINT, Short.SIZE - 1, true, HazelcastIntegerType.of(SMALLINT, true));\n+        assertType(INTEGER, Integer.SIZE - 1, true, HazelcastIntegerType.of(INTEGER, true));\n+        assertType(BIGINT, Long.SIZE - 1, true, HazelcastIntegerType.of(BIGINT, true));\n+    }\n+\n+    @Test\n+    public void testNullableIntegerTypeOfType() {\n+        RelDataType intType = HazelcastIntegerType.of(INTEGER);\n+        RelDataType nullableIntType = HazelcastIntegerType.of(INTEGER, true);\n+\n+        assertSame(intType, HazelcastIntegerType.of(intType, false));\n+        assertSame(nullableIntType, HazelcastIntegerType.of(intType, true));\n+\n+        assertSame(intType, HazelcastIntegerType.of(nullableIntType, false));\n+        assertSame(nullableIntType, HazelcastIntegerType.of(nullableIntType, true));\n+    }\n+\n+    @Test\n+    public void testNullableIntegerTypeOfBitWidth() {\n+        for (int i = 0; i < Long.SIZE + 10; ++i) {\n+            RelDataType type = HazelcastIntegerType.of(i, false);\n+            RelDataType nullableType = HazelcastIntegerType.of(i, true);\n+\n+            if (i < Byte.SIZE) {\n+                assertType(TINYINT, i, false, type);\n+                assertType(TINYINT, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else if (i < Short.SIZE) {\n+                assertType(SMALLINT, i, false, type);\n+                assertType(SMALLINT, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else if (i < Integer.SIZE) {\n+                assertType(INTEGER, i, false, type);\n+                assertType(INTEGER, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else if (i < Long.SIZE) {\n+                assertType(BIGINT, i, false, type);\n+                assertType(BIGINT, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else {\n+                assertType(BIGINT, Long.SIZE, false, type);\n+                assertType(BIGINT, Long.SIZE, true, nullableType);\n+\n+                assertTrue(HazelcastIntegerType.canOverflow(type));\n+                assertTrue(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(Long.SIZE - 1, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(Long.SIZE - 1, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSupports() {\n+        for (SqlTypeName typeName : SqlTypeName.values()) {\n+            assertEquals(typeName == TINYINT || typeName == SMALLINT || typeName == INTEGER || typeName == BIGINT,\n+                    HazelcastIntegerType.supports(typeName));\n+        }\n+    }\n+\n+    @Test\n+    public void testBitWidthOfLong() {\n+        assertEquals(0, HazelcastIntegerType.bitWidthOf(0));\n+        assertEquals(1, HazelcastIntegerType.bitWidthOf(1));\n+        assertEquals(1, HazelcastIntegerType.bitWidthOf(-1));\n+        assertEquals(2, HazelcastIntegerType.bitWidthOf(2));\n+        assertEquals(2, HazelcastIntegerType.bitWidthOf(-2));\n+        assertEquals(10, HazelcastIntegerType.bitWidthOf(555));\n+        assertEquals(10, HazelcastIntegerType.bitWidthOf(-555));\n+\n+        assertEquals(Long.SIZE - 1, HazelcastIntegerType.bitWidthOf(Long.MAX_VALUE));\n+        assertEquals(Long.SIZE - 1, HazelcastIntegerType.bitWidthOf(Long.MIN_VALUE));\n+\n+        assertEquals(Integer.SIZE - 1, HazelcastIntegerType.bitWidthOf(Integer.MAX_VALUE));\n+        assertEquals(Integer.SIZE - 1, HazelcastIntegerType.bitWidthOf(Integer.MIN_VALUE));\n+\n+        assertEquals(Short.SIZE - 1, HazelcastIntegerType.bitWidthOf(Short.MAX_VALUE));\n+        assertEquals(Short.SIZE - 1, HazelcastIntegerType.bitWidthOf(Short.MIN_VALUE));\n+\n+        assertEquals(Byte.SIZE - 1, HazelcastIntegerType.bitWidthOf(Byte.MAX_VALUE));\n+        assertEquals(Byte.SIZE - 1, HazelcastIntegerType.bitWidthOf(Byte.MIN_VALUE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Mzk3NzU1", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464397755", "createdAt": "2020-08-10T16:41:45Z", "commit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo0MTo0NVrOG-WvFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjo0OToyM1rOG-XAJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzNzM5Nw==", "bodyText": "What about adding this field to the Record in ExpressionEndToEndTestBase:\npublic Object booleanTrueObject = Boolean.TRUE;\nand then add the following line here:\nassertRow(\"cast(booleanTrueObject as boolean)\", EXPR0, BOOLEAN, true);\nAlso for other types. It will check the conversion from OBJECT type.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468037397", "createdAt": "2020-08-10T16:41:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastEndToEndTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.OBJECT;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertRow(\"cast(booleanTrue as boolean)\", EXPR0, BOOLEAN, true);\n+\n+        assertParsingError(\"cast(byte1 as boolean)\", \"Cast function cannot convert value of type TINYINT to type BOOLEAN\");\n+        assertParsingError(\"cast(short1 as boolean)\", \"Cast function cannot convert value of type SMALLINT to type BOOLEAN\");\n+        assertParsingError(\"cast(int1 as boolean)\", \"Cast function cannot convert value of type INTEGER to type BOOLEAN\");\n+        assertParsingError(\"cast(long1 as boolean)\", \"Cast function cannot convert value of type BIGINT to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(float1 as boolean)\", \"Cast function cannot convert value of type REAL to type BOOLEAN\");\n+        assertParsingError(\"cast(double1 as boolean)\", \"Cast function cannot convert value of type DOUBLE to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(decimal1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+        assertParsingError(\"cast(bigInteger1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+\n+        assertDataError(\"cast(string1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+        assertRow(\"cast(stringFalse as boolean)\", EXPR0, BOOLEAN, false);\n+        assertDataError(\"cast(char1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+\n+        assertDataError(\"cast(object as boolean)\", \"Cannot convert OBJECT to BOOLEAN\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MDExOA==", "bodyText": "Why don't we test temporal types here?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468040118", "createdAt": "2020-08-10T16:46:24Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastEndToEndTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.OBJECT;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastEndToEndTest extends ExpressionEndToEndTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MTc2Nw==", "bodyText": "With every other source type we include the value that failed to convert in the error message, we should do that same with OBJECT.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468041767", "createdAt": "2020-08-10T16:49:23Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastEndToEndTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.OBJECT;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertRow(\"cast(booleanTrue as boolean)\", EXPR0, BOOLEAN, true);\n+\n+        assertParsingError(\"cast(byte1 as boolean)\", \"Cast function cannot convert value of type TINYINT to type BOOLEAN\");\n+        assertParsingError(\"cast(short1 as boolean)\", \"Cast function cannot convert value of type SMALLINT to type BOOLEAN\");\n+        assertParsingError(\"cast(int1 as boolean)\", \"Cast function cannot convert value of type INTEGER to type BOOLEAN\");\n+        assertParsingError(\"cast(long1 as boolean)\", \"Cast function cannot convert value of type BIGINT to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(float1 as boolean)\", \"Cast function cannot convert value of type REAL to type BOOLEAN\");\n+        assertParsingError(\"cast(double1 as boolean)\", \"Cast function cannot convert value of type DOUBLE to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(decimal1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+        assertParsingError(\"cast(bigInteger1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+\n+        assertDataError(\"cast(string1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+        assertRow(\"cast(stringFalse as boolean)\", EXPR0, BOOLEAN, false);\n+        assertDataError(\"cast(char1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+\n+        assertDataError(\"cast(object as boolean)\", \"Cannot convert OBJECT to BOOLEAN\");\n+    }\n+\n+    @Test\n+    public void testTinyint() {\n+        assertParsingError(\"cast(booleanTrue as tinyint)\", \"Cast function cannot convert value of type BOOLEAN to type TINYINT\");\n+\n+        assertRow(\"cast(byte1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"cast(byteMax as tinyint)\", EXPR0, TINYINT, Byte.MAX_VALUE);\n+        assertRow(\"cast(short1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(shortMax as tinyint)\", \"Numeric overflow while converting SMALLINT to TINYINT: 32767\");\n+        assertRow(\"cast(int1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(intMax as tinyint)\", \"Numeric overflow while converting INT to TINYINT: 2147483647\");\n+        assertRow(\"cast(long1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(longMax as tinyint)\", \"Numeric overflow while converting BIGINT to TINYINT: 9223372036854775807\");\n+\n+        assertRow(\"cast(float1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(floatMax as tinyint)\", \"Numeric overflow while converting REAL to TINYINT: 3.4028235E38\");\n+        assertRow(\"cast(double1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(doubleMax as tinyint)\",\n+                \"Numeric overflow while converting DOUBLE to TINYINT: 1.7976931348623157E308\");\n+\n+        assertRow(\"cast(decimal1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(decimalBig as tinyint)\",\n+                \"Numeric overflow while converting DECIMAL to TINYINT: 92233720368547758070\");\n+        assertRow(\"cast(bigInteger1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(bigIntegerBig as tinyint)\",\n+                \"Numeric overflow while converting DECIMAL to TINYINT: 92233720368547758070\");\n+\n+        assertRow(\"cast(string1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(stringBig as tinyint)\", \"Cannot convert VARCHAR to TINYINT: 92233720368547758070\");\n+        assertDataError(\"cast(stringFoo as tinyint)\", \"Cannot convert VARCHAR to TINYINT: foo\");\n+        assertRow(\"cast(char1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(charF as tinyint)\", \"Cannot convert VARCHAR to TINYINT: f\");\n+\n+        assertDataError(\"cast(object as tinyint)\", \"Cannot convert OBJECT to TINYINT\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDIwODE2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464420816", "createdAt": "2020-08-10T17:13:25Z", "commit": {"oid": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODoxMDoxOVrOG-tApg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODoxMDoxOVrOG-tApg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQwMjM0Mg==", "bodyText": "We can add this test:\n    @Test\n    public void testMixedTypes() {\n        SqlService sql = createEndToEndRecords();\n        assertQueryThrows(sql, \"select __key from records where case boolean1 when true then int1 else boolean1 end\",\n                \"Illegal mixing of types in CASE or COALESCE statement\");\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468402342", "createdAt": "2020-08-11T08:10:19Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/CaseExpressionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BOOLEAN;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CaseExpressionTest extends ExpressionTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4f1a091791e4047d14c23e9372c3da25561b37"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0ODUyOTY0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464852964", "createdAt": "2020-08-11T08:26:14Z", "commit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODoyNjoxNVrOG-tlDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODoyNjoxNVrOG-tlDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMTY2Mg==", "bodyText": "This error message is not precise, better would be \"must be a boolean expression\". You can use a boolean literal, but is that a condition?\nHowever, it comes from calcite code, so if it's not easy to replace it, maybe it's not worth the trouble:\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateWhereOrOn(SqlValidatorImpl.java:4200)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateWhereClause(SqlValidatorImpl.java:4184)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:3513)\n\tat org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:60)\n\tat org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:84)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1110)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1084)\n\tat org.apache.calcite.sql.SqlSelect.validate(SqlSelect.java:232)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1059)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:766)\n\tat com.hazelcast.sql.impl.calcite.parse.QueryParser.parse(QueryParser.java:55)", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468411662", "createdAt": "2020-08-11T08:26:15Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/CaseExpressionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BOOLEAN;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CaseExpressionTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where case boolean1 when true then false when false then true end\"),\n+                keyRange(0, 500));\n+        assertRows(query(sql, \"select __key from records where case not boolean1 when true then false when false then true end\"),\n+                keyRange(500, 1000));\n+        assertRows(query(sql,\n+                \"select __key, case when __key < 500 then double1 when __key < 1000 then int1 else decimal1 end from records\"),\n+                keyRange(0, 1000, 5000, 6000), k -> {\n+                    if (k < 500) {\n+                        return 2000.1 + k;\n+                    } else if (k < 1000) {\n+                        return 1000.0 + k;\n+                    } else {\n+                        return k == 5000 ? 9001.0 : null;\n+                    }\n+                });\n+        assertQueryThrows(sql, \"select * from records where case boolean1 when true then string1 end\",\n+                \"where clause must be a condition\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0ODU0ODg0", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464854884", "createdAt": "2020-08-11T08:28:43Z", "commit": {"oid": "09c52aa98d7b273a7cdc992ea5e122e4c9041294"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODoyODo0M1rOG-trEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODoyODo0M1rOG-trEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMzIwMA==", "bodyText": "Why do we expect here <BOOLEAN> * <BOOLEAN> instead of VARCHAR?", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468413200", "createdAt": "2020-08-11T08:28:43Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/MultiplyEndToEndTest.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.impl.expression.ExpressionEndToEndTestBase;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MultiplyEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertParsingError(\"booleanTrue * booleanTrue\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <BOOLEAN>'\");\n+\n+        assertParsingError(\"booleanTrue * byte1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <TINYINT>'\");\n+        assertParsingError(\"booleanTrue * short1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <SMALLINT>'\");\n+        assertParsingError(\"booleanTrue * int1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <INTEGER>'\");\n+        assertParsingError(\"booleanTrue * long1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <BIGINT>'\");\n+\n+        assertParsingError(\"booleanTrue * float1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <REAL>'\");\n+        assertParsingError(\"booleanTrue * double1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <DOUBLE>'\");\n+\n+        assertParsingError(\"booleanTrue * decimal1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <DECIMAL(38, 38)>'\");\n+        assertParsingError(\"booleanTrue * bigInteger1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <DECIMAL(38, 38)>'\");\n+\n+        assertParsingError(\"booleanTrue * string1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <BOOLEAN>'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c52aa98d7b273a7cdc992ea5e122e4c9041294"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0OTA0OTE4", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464904918", "createdAt": "2020-08-11T09:36:26Z", "commit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTozNjoyNlrOG-wGaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTozNjo0M1rOG-wHEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1Mjk2OA==", "bodyText": "This is not correct, Inf / 5 results in infinite too, but it's not division by zero. The user might be looking for a zero in the data and find none. The Inf can be already present in the user data, even though we don't support such literal for now.\nSame issue is for floats below.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468452968", "createdAt": "2020-08-11T09:36:26Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/ExpressionMath.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.math.MathContext;\n+import java.math.RoundingMode;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.MAX_DECIMAL_PRECISION;\n+\n+/**\n+ * Utility methods for math functions.\n+ */\n+public final class ExpressionMath {\n+\n+    /**\n+     * Math context used by expressions while doing math on BigDecimal values.\n+     * <p>\n+     * The context uses {@link RoundingMode#HALF_UP HALF_UP} rounding mode, with\n+     * which most users should be familiar from school, and limits the precision\n+     * to {@link QueryDataType#MAX_DECIMAL_PRECISION}.\n+     */\n+    public static final MathContext DECIMAL_MATH_CONTEXT = new MathContext(MAX_DECIMAL_PRECISION, RoundingMode.HALF_UP);\n+\n+    private ExpressionMath() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * resulted in overflow.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if overflow or division by zero is detected.\n+     */\n+    public static long divideExact(long left, long right) {\n+        if (left == Long.MIN_VALUE && right == -1) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"BIGINT overflow in '/' operator (consider adding explicit CAST to DECIMAL)\");\n+        }\n+        try {\n+            return left / right;\n+        } catch (ArithmeticException e) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");\n+        }\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * by zero is detected.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if division by zero is detected.\n+     */\n+    public static double divideExact(double left, double right) {\n+        double result = left / right;\n+        if (Double.isInfinite(result)) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1MzEzNg==", "bodyText": "We can return NaN if both operands are 0, is that ok?\nSame issue is for floats below.", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468453136", "createdAt": "2020-08-11T09:36:43Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/ExpressionMath.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.math.MathContext;\n+import java.math.RoundingMode;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.MAX_DECIMAL_PRECISION;\n+\n+/**\n+ * Utility methods for math functions.\n+ */\n+public final class ExpressionMath {\n+\n+    /**\n+     * Math context used by expressions while doing math on BigDecimal values.\n+     * <p>\n+     * The context uses {@link RoundingMode#HALF_UP HALF_UP} rounding mode, with\n+     * which most users should be familiar from school, and limits the precision\n+     * to {@link QueryDataType#MAX_DECIMAL_PRECISION}.\n+     */\n+    public static final MathContext DECIMAL_MATH_CONTEXT = new MathContext(MAX_DECIMAL_PRECISION, RoundingMode.HALF_UP);\n+\n+    private ExpressionMath() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * resulted in overflow.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if overflow or division by zero is detected.\n+     */\n+    public static long divideExact(long left, long right) {\n+        if (left == Long.MIN_VALUE && right == -1) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"BIGINT overflow in '/' operator (consider adding explicit CAST to DECIMAL)\");\n+        }\n+        try {\n+            return left / right;\n+        } catch (ArithmeticException e) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");\n+        }\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * by zero is detected.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if division by zero is detected.\n+     */\n+    public static double divideExact(double left, double right) {\n+        double result = left / right;\n+        if (Double.isInfinite(result)) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");\n+        }\n+        return result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0OTQ4MDA2", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464948006", "createdAt": "2020-08-11T10:40:30Z", "commit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0OTM5MjQx", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-464939241", "createdAt": "2020-08-11T10:26:30Z", "commit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoyNjozMFrOG-xv9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoyNjozMFrOG-xv9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3OTk5MA==", "bodyText": "Might be useful to test a conversion with precision loss:\nassertEquals(1, converter.asTinyint(BigDecimal.valueOf(1.1)));", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468479990", "createdAt": "2020-08-11T10:26:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java", "diffHunk": "@@ -263,13 +278,18 @@ public void testBigDecimalConverter() {\n         checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, REAL, DOUBLE, OBJECT);\n \n         BigDecimal val = BigDecimal.valueOf(11, 1);\n+        BigDecimal bigValue = BigDecimal.valueOf(Long.MAX_VALUE).add(new BigDecimal(\"1.1\"));\n \n         assertEquals(\"1.1\", converter.asVarchar(val));\n \n         assertEquals(1, converter.asTinyint(val));\n+        checkDataException(() -> converter.asTinyint(bigValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDA1MTkw", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-465005190", "createdAt": "2020-08-11T12:13:41Z", "commit": {"oid": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDE5NjE3", "url": "https://github.com/hazelcast/hazelcast/pull/17183#pullrequestreview-465019617", "createdAt": "2020-08-11T12:34:10Z", "commit": {"oid": "084c08a2d61de582664c629d7412d31dac006e86"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4619167e052d3bb9e9440163f38217c4bb2491fd", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4619167e052d3bb9e9440163f38217c4bb2491fd", "committedDate": "2020-08-11T12:43:36Z", "message": "Add basic SQL expressions support\n\nThis commit adds support for the following SQL types:\n\n- Integer types: `TINYINT`, `SMALLINT`, `(INT)EGER` and `BIGINT`.\n  The implementation always tries to select the narrowest integer type\n  possible to represent integer literals and results of operators\n  returning integer values. At the same time, the implementation\n  performs the widening of operator result types to avoid arithmetic\n  overflows. This all achieved by providing a custom Calcite type:\n  `HazelcastIntegerType`.\n\n- Floating-point types: `REAL` (Java's `float`), `DOUBLE` and `DECIMAL`.\n  The implementation never assigns `DECIMAL` type to literals,\n  parameters and operator result types if there are no `DECIMAL` columns\n  or explicit casts to `DECIMAL` involved in the expression.\n\n- String types: `VARCHAR` and `CHAR`. Where possible, string types are\n  normalized to `VARCHAR`, but, for instance, string literals still\n  have `CHAR` type as required by Calcite. Such `CHAR` usages are purely\n  internal and not accessible by users: `CAST(foo AS CHAR)` is invalid.\n\n- `BOOLEAN` type. The usual SQL ternary boolean logic type.\n\n- `NULL` type. The implementation follows the standard Calcite approach\n  on assigning more specific types than just `NULL` to operands of\n  expressions. For instance, consider the following expression:\n  `1 + NULL`, the `NULL` literal would receive nullable `TINYINT` type.\n  But in some cases it's impossible to assign a more specific type, so\n  the raw `NULL` type may appear: `SELECT NULL FROM table`, the `NULL`\n  literal doesn't have any specific type in this example.\n\n- `OBJECT` type currently mapped to `ANY` Calcite type, that mapping\n   might change in the future. The only reason for such mapping is that\n   `ANY` type transparently passes through all validation, type inference\n   and coercion stages without producing obscure errors, so more concise\n   errors can be reported for operators that don't support `OBJECT` as\n   an input.\n\nThe following expressions are supported for the types listed above:\n\n- Arithmetics: binary and unary `+`, binary and unary `-`, `*`, `/`.\n\n- Comparison: `=`, `!=`, `<`, `>`, `<=`, `>=`.\n\n- Logic: `AND`, `OR`, `NOT`.\n\n- `IS` predicates: `IS [NOT] TRUE`, `IS [NOT] FALSE`, `IS [NOT] NULL`.\n\n- `CAST` and `CASE`.\n\nAll expressions, including columns, literals and parameters, are\nstatically typed: their types are assigned once during query plan\ncreation and never change. This allows to avoid unnecessary type\nconversion and overflow checks during query execution. Necessary\nimplicit type conversions are still performed according to the type\nconversion rules defined in the type system design document. Type\nprecedence defined in the document is also respected while selecting\nan appropriate overload provided by a certain operator.\n\nSome initial support for temporal types is added as well, but currently\nthere are no operators and functions supporting temporal operands."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32cdd5924813aae87a5b9e3c1d45564c15bc12ee", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/32cdd5924813aae87a5b9e3c1d45564c15bc12ee", "committedDate": "2020-08-11T12:43:36Z", "message": "remove unused methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf2db28c53ffd79947625f5eef20e27b27eb199a", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bf2db28c53ffd79947625f5eef20e27b27eb199a", "committedDate": "2020-08-11T12:43:36Z", "message": "Grammar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0154e73ed51124bc4bbb9dcc489fe3fa2572b640", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0154e73ed51124bc4bbb9dcc489fe3fa2572b640", "committedDate": "2020-08-11T12:43:37Z", "message": "add explicit case for CHAR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ba198ab0e0150adbca98ed24210b1ed145cc636", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0ba198ab0e0150adbca98ed24210b1ed145cc636", "committedDate": "2020-08-11T12:43:37Z", "message": "simplify asserts\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "826a52c3a017e21254e8a59bda5228fb5063f278", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/826a52c3a017e21254e8a59bda5228fb5063f278", "committedDate": "2020-08-11T12:43:37Z", "message": "simplify CASE rewriting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cdd96adf606b599e3e19611b2ca02e81598f754", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2cdd96adf606b599e3e19611b2ca02e81598f754", "committedDate": "2020-08-11T12:43:37Z", "message": "use IdentityHashMap instead of HashMap for node type tracking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "committedDate": "2020-08-11T12:43:37Z", "message": "simplify javadoc wording\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5765c88ab53240721dbfa3cbc5d48234c1d218f", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f5765c88ab53240721dbfa3cbc5d48234c1d218f", "committedDate": "2020-08-11T12:43:37Z", "message": "check for edge case values in ConvertersTest for double and float"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a05587b170f16b1ae09d654027efab551bf35d3", "author": {"user": {"login": "taburet", "name": "Sergey Sitnikov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0a05587b170f16b1ae09d654027efab551bf35d3", "committedDate": "2020-08-11T12:43:37Z", "message": "make overflow error messages more concise in converters"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3533, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}