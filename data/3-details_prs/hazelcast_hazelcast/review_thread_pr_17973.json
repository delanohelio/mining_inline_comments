{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMDc0MzM5", "number": 17973, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNzowNzoyMFrOFVh-8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNzozODo0OFrOFVikPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MTIxMjAyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/ProxyManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNzowNzoyMFrOIeCVvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMDowOTozM1rOIe6g5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM2NjUyNg==", "bodyText": "I think we don't need to catch InterruptedException , just let it be thrown.", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r568366526", "createdAt": "2021-02-02T07:07:20Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/ProxyManager.java", "diffHunk": "@@ -462,6 +456,35 @@ void set(Object o) {\n                 notifyAll();\n             }\n         }\n+\n+        @Override\n+        public boolean block() throws InterruptedException {\n+            if (Thread.currentThread().isInterrupted()\n+                    || isReleasable()) {\n+                return true;\n+            }\n+\n+            boolean interrupted = false;\n+            synchronized (this) {\n+                while (proxy == null) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyNDg5NA==", "bodyText": "removed catch block", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r568524894", "createdAt": "2021-02-02T11:22:26Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/ProxyManager.java", "diffHunk": "@@ -462,6 +456,35 @@ void set(Object o) {\n                 notifyAll();\n             }\n         }\n+\n+        @Override\n+        public boolean block() throws InterruptedException {\n+            if (Thread.currentThread().isInterrupted()\n+                    || isReleasable()) {\n+                return true;\n+            }\n+\n+            boolean interrupted = false;\n+            synchronized (this) {\n+                while (proxy == null) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM2NjUyNg=="}, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI4Njg4NQ==", "bodyText": "As discussed on slack, removing the catch block would change code execution path, so it was restored.", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r569286885", "createdAt": "2021-02-03T10:09:33Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/ProxyManager.java", "diffHunk": "@@ -462,6 +456,35 @@ void set(Object o) {\n                 notifyAll();\n             }\n         }\n+\n+        @Override\n+        public boolean block() throws InterruptedException {\n+            if (Thread.currentThread().isInterrupted()\n+                    || isReleasable()) {\n+                return true;\n+            }\n+\n+            boolean interrupted = false;\n+            synchronized (this) {\n+                while (proxy == null) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM2NjUyNg=="}, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MTIzNTc5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/AbstractInvocationFuture.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNzoxNTo1OVrOIeCjRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToyMjozOFrOIeMA3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM2OTk4OA==", "bodyText": "Can we remove the timed parameter? Seems like we need to parkNanos when timeoutNanos > 0, otherwise just park().\nalso minor typo: managedParking?", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r568369988", "createdAt": "2021-02-02T07:15:59Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/AbstractInvocationFuture.java", "diffHunk": "@@ -653,6 +655,50 @@ public final V get(final long timeout, final TimeUnit unit)\n         throw newTimeoutException(timeout, unit);\n     }\n \n+    // Use when the caller thread is a ForkJoinWorkerThread\n+    class ManagedBlocker implements ForkJoinPool.ManagedBlocker {\n+        private boolean timed;\n+        private long timeoutNanos;\n+\n+        ManagedBlocker(boolean timed, long timeoutNanos) {\n+            this.timed = timed;\n+            this.timeoutNanos = timeoutNanos;\n+        }\n+\n+        @Override\n+        public boolean isReleasable() {\n+            return Thread.currentThread().isInterrupted()\n+                    || isDone();\n+        }\n+\n+        @Override\n+        public boolean block() throws InterruptedException {\n+            if (isReleasable()) {\n+                return true;\n+            } else if (!timed) {\n+                park();\n+            } else if (timeoutNanos > 0) {\n+                parkNanos(timeoutNanos);\n+            }\n+            return isReleasable();\n+        }\n+    }\n+\n+    private void manageParking(boolean timed, long timeoutNanos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyNTAyMQ==", "bodyText": "removed timed parameter", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r568525021", "createdAt": "2021-02-02T11:22:38Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/AbstractInvocationFuture.java", "diffHunk": "@@ -653,6 +655,50 @@ public final V get(final long timeout, final TimeUnit unit)\n         throw newTimeoutException(timeout, unit);\n     }\n \n+    // Use when the caller thread is a ForkJoinWorkerThread\n+    class ManagedBlocker implements ForkJoinPool.ManagedBlocker {\n+        private boolean timed;\n+        private long timeoutNanos;\n+\n+        ManagedBlocker(boolean timed, long timeoutNanos) {\n+            this.timed = timed;\n+            this.timeoutNanos = timeoutNanos;\n+        }\n+\n+        @Override\n+        public boolean isReleasable() {\n+            return Thread.currentThread().isInterrupted()\n+                    || isDone();\n+        }\n+\n+        @Override\n+        public boolean block() throws InterruptedException {\n+            if (isReleasable()) {\n+                return true;\n+            } else if (!timed) {\n+                park();\n+            } else if (timeoutNanos > 0) {\n+                parkNanos(timeoutNanos);\n+            }\n+            return isReleasable();\n+        }\n+    }\n+\n+    private void manageParking(boolean timed, long timeoutNanos) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM2OTk4OA=="}, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MTMwNzQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/impl/spi/ClientHazelcastRunningInForkJoinPoolTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNzozODo0OFrOIeDMLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToyMjo0OFrOIeMBMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM4MDQ2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        tasks.add(ForkJoinPool.commonPool().submit(new ACallable()));\n          \n          \n            \n                        tasks.add(ForkJoinPool.commonPool().submit(() -> clientMap.get(1)));", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r568380461", "createdAt": "2021-02-02T07:38:48Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/spi/ClientHazelcastRunningInForkJoinPoolTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi;\n+\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.config.MapStoreConfig;\n+import com.hazelcast.core.EntryAdapter;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.map.MapStoreAdapter;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientHazelcastRunningInForkJoinPoolTest extends HazelcastTestSupport {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    private HazelcastInstance client;\n+    private HazelcastInstance server;\n+    private IMap serverMap;\n+    private IMap clientMap;\n+    private String mapName = \"loading-takes-ages\";\n+    private String innocentMap = \"innocent\";\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new MapStoreAdapter() {\n+            @Override\n+            public Object load(Object key) {\n+                sleepSeconds(1000);\n+                return super.load(key);\n+            }\n+        });\n+\n+        MapConfig mapConfig = new MapConfig(\n+                mapName);\n+        mapConfig.setMapStoreConfig(mapStoreConfig);\n+\n+        Config config = getConfig().addMapConfig(mapConfig);\n+\n+        server = hazelcastFactory.newHazelcastInstance(config);\n+        client = hazelcastFactory.newHazelcastClient();\n+\n+        serverMap = server.getMap(innocentMap);\n+        clientMap = client.getMap(mapName);\n+    }\n+\n+    @Test\n+    public void slow_data_loading_does_not_block_entry_listener_addition() {\n+        // 1. Let's simulate 1000 parallel tasks\n+        // contend on loading 1 item from a database.\n+        Collection<Future> tasks = new ArrayList<>();\n+        for (int i = 0; i < 1000; i++) {\n+            tasks.add(ForkJoinPool.commonPool().submit(new ACallable()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyNTEwNw==", "bodyText": "updated test", "url": "https://github.com/hazelcast/hazelcast/pull/17973#discussion_r568525107", "createdAt": "2021-02-02T11:22:48Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/spi/ClientHazelcastRunningInForkJoinPoolTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi;\n+\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.config.MapStoreConfig;\n+import com.hazelcast.core.EntryAdapter;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.map.MapStoreAdapter;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientHazelcastRunningInForkJoinPoolTest extends HazelcastTestSupport {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    private HazelcastInstance client;\n+    private HazelcastInstance server;\n+    private IMap serverMap;\n+    private IMap clientMap;\n+    private String mapName = \"loading-takes-ages\";\n+    private String innocentMap = \"innocent\";\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new MapStoreAdapter() {\n+            @Override\n+            public Object load(Object key) {\n+                sleepSeconds(1000);\n+                return super.load(key);\n+            }\n+        });\n+\n+        MapConfig mapConfig = new MapConfig(\n+                mapName);\n+        mapConfig.setMapStoreConfig(mapStoreConfig);\n+\n+        Config config = getConfig().addMapConfig(mapConfig);\n+\n+        server = hazelcastFactory.newHazelcastInstance(config);\n+        client = hazelcastFactory.newHazelcastClient();\n+\n+        serverMap = server.getMap(innocentMap);\n+        clientMap = client.getMap(mapName);\n+    }\n+\n+    @Test\n+    public void slow_data_loading_does_not_block_entry_listener_addition() {\n+        // 1. Let's simulate 1000 parallel tasks\n+        // contend on loading 1 item from a database.\n+        Collection<Future> tasks = new ArrayList<>();\n+        for (int i = 0; i < 1000; i++) {\n+            tasks.add(ForkJoinPool.commonPool().submit(new ACallable()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODM4MDQ2MQ=="}, "originalCommit": {"oid": "4e078e0e85b82dcab3fed384d45c1b92448a5a9c"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 20, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}