{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MTg2NzE3", "number": 17545, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOTozNTo1MlrOEmeZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDowMDo1NVrOEmfSUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Nzc5Mjc0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/mapstore/MetadataAwareMapDataStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOTozNTo1MlrOHWhJjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOTozNTo1MlrOHWhJjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MzgzNg==", "bodyText": "Do you need to unwrap the value here as well?", "url": "https://github.com/hazelcast/hazelcast/pull/17545#discussion_r493373836", "createdAt": "2020-09-23T09:35:52Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/mapstore/MetadataAwareMapDataStore.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.mapstore;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.EntryLoader;\n+import com.hazelcast.map.impl.mapstore.writebehind.TxnReservedCapacityCounter;\n+import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+\n+/**\n+ * Should be created one per record-store due to the {@code lastLoadedTtl} field.\n+ */\n+public class MetadataAwareMapDataStore<K, V> implements MapDataStore<K, V> {\n+\n+    private final MapDataStore<K, V> delegate;\n+\n+    private long lastLoadedTtl = UNSET;\n+\n+    public MetadataAwareMapDataStore(MapDataStore<K, V> delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public V add(K key, V value, long expirationTime, long now, UUID transactionId) {\n+        return delegate.add(key, value, expirationTime, now, transactionId);\n+    }\n+\n+    @Override\n+    public V addBackup(K key, V value, long expirationTime, long now, UUID transactionId) {\n+        return delegate.addBackup(key, value, expirationTime, now, transactionId);\n+    }\n+\n+    @Override\n+    public void addForcibly(DelayedEntry<Data, Object> delayedEntry) {\n+        delegate.addForcibly(delayedEntry);\n+    }\n+\n+    @Override\n+    public void addTransient(K key, long now) {\n+        delegate.addTransient(key, now);\n+    }\n+\n+    @Override\n+    public void remove(K key, long now, UUID transactionId) {\n+        delegate.remove(key, now, transactionId);\n+    }\n+\n+    @Override\n+    public void removeBackup(K key, long now, UUID transactionId) {\n+        delegate.removeBackup(key, now, transactionId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        delegate.reset();\n+    }\n+\n+    @Override\n+    public V load(K key) {\n+        V loadedValue = delegate.load(key);\n+        if (loadedValue != null) {\n+            EntryLoader.MetadataAwareValue<V> metadataAwareValue = toMetadataAware(loadedValue);\n+            long remainingTtl = toRemainingTtl(metadataAwareValue);\n+            loadedValue = remainingTtl <= 0 ? null : metadataAwareValue.getValue();\n+            lastLoadedTtl = remainingTtl > 0 ? remainingTtl : UNSET;\n+        } else {\n+            lastLoadedTtl = UNSET;\n+        }\n+        return loadedValue;\n+    }\n+\n+    @Override\n+    public void loadAll(Collection givenKeys,\n+                        BiConsumer<Map.Entry, Long> loadedEntryWithTtlConsumer) {\n+        Map map = delegate.loadAll(givenKeys);\n+\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry) iterator.next();\n+            EntryLoader.MetadataAwareValue<V> metadataAwareValue = toMetadataAware(entry.getValue());\n+            long remainingTtl = toRemainingTtl(metadataAwareValue);\n+            if (remainingTtl > 0) {\n+                AbstractMap.SimpleImmutableEntry newEntry = new AbstractMap.SimpleImmutableEntry(entry.getKey(),\n+                        metadataAwareValue.getValue());\n+                loadedEntryWithTtlConsumer.accept(newEntry, remainingTtl);\n+            }\n+        }\n+    }\n+\n+    public long toRemainingTtl(EntryLoader.MetadataAwareValue<V> metadataAwareValue) {\n+        return metadataAwareValue.getExpirationTime() - System.currentTimeMillis();\n+    }\n+\n+    public EntryLoader.MetadataAwareValue<V> toMetadataAware(Object loadedValue) {\n+        return (EntryLoader.MetadataAwareValue<V>) loadedValue;\n+    }\n+\n+    @Override\n+    public long getLastLoadedTtl() {\n+        return lastLoadedTtl;\n+    }\n+\n+    @Override\n+    public Map loadAll(Collection keys) {\n+        Map map = delegate.loadAll(keys);\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry) iterator.next();\n+            long remainingTtl = toRemainingTtl(toMetadataAware(entry.getValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc991f18380d668123030a3ca867aa6bad7c89e"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzkzOTM3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDowMDo1NVrOHWio9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNjoyNjoxN1rOHX2i5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM5ODI2MQ==", "bodyText": "I understand that now, because of concurrency, we need create per-record store wrappers. Although it does move some code out of the record store, I'm thinking is it worth it. I can imagine lots of wrappers are created with high partition counts and it's just to keep the last loaded TTL value and some additional code.\nAlthough it complicates the record store, can we try keeping the code in the record store instead and avoid the map store wrapper?", "url": "https://github.com/hazelcast/hazelcast/pull/17545#discussion_r493398261", "createdAt": "2020-09-23T10:00:55Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -370,28 +372,19 @@ public String getLockOwnerInfo(Data key) {\n \n     @Override\n     public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress) {\n-        Object value = mapDataStore.load(key);\n-        if (value == null) {\n+        Object oldValue = mapDataStore.load(key);\n+        if (oldValue == null) {\n             return null;\n         }\n \n-        long ttl = UNSET;\n-        if (mapDataStore.isWithExpirationTime()) {\n-            MetadataAwareValue loaderEntry = (MetadataAwareValue) value;\n-            long proposedTtl = expirationTimeToTtl(loaderEntry.getExpirationTime());\n-            if (proposedTtl <= 0) {\n-                return null;\n-            }\n-            value = loaderEntry.getValue();\n-            ttl = proposedTtl;\n-        }\n-        Record record = createRecord(key, value, ttl, UNSET, getNow());\n-        markRecordStoreExpirable(ttl, UNSET);\n+        long lastLoadedTtl = mapDataStore.getLastLoadedTtl();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc991f18380d668123030a3ca867aa6bad7c89e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3Mjk2NQ==", "bodyText": "makes sense, i removed wrapper.", "url": "https://github.com/hazelcast/hazelcast/pull/17545#discussion_r494772965", "createdAt": "2020-09-25T06:26:17Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -370,28 +372,19 @@ public String getLockOwnerInfo(Data key) {\n \n     @Override\n     public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress) {\n-        Object value = mapDataStore.load(key);\n-        if (value == null) {\n+        Object oldValue = mapDataStore.load(key);\n+        if (oldValue == null) {\n             return null;\n         }\n \n-        long ttl = UNSET;\n-        if (mapDataStore.isWithExpirationTime()) {\n-            MetadataAwareValue loaderEntry = (MetadataAwareValue) value;\n-            long proposedTtl = expirationTimeToTtl(loaderEntry.getExpirationTime());\n-            if (proposedTtl <= 0) {\n-                return null;\n-            }\n-            value = loaderEntry.getValue();\n-            ttl = proposedTtl;\n-        }\n-        Record record = createRecord(key, value, ttl, UNSET, getNow());\n-        markRecordStoreExpirable(ttl, UNSET);\n+        long lastLoadedTtl = mapDataStore.getLastLoadedTtl();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM5ODI2MQ=="}, "originalCommit": {"oid": "dcc991f18380d668123030a3ca867aa6bad7c89e"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 223, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}