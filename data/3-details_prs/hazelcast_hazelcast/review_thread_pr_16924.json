{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MzAzMzI4", "number": 16924, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzoxOTo0MlrOD1oYTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOToxMDoyNFrOD1rMJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTYyNzAwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzoxOTo0MlrOGLKB1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzoxOTo0MlrOGLKB1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1MTgzMA==", "bodyText": "rogue \\ inserted here", "url": "https://github.com/hazelcast/hazelcast/pull/16924#discussion_r414351830", "createdAt": "2020-04-24T07:19:42Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "diffHunk": "@@ -39,33 +40,54 @@\n      * Returns a {@link ServerConnectionManager} that is able to handle\n      * connections for the given qualifier.\n      *\n-     * It is important to realize that the returned manager could also\n+     * It is important to realize that the return\\ed manager could also", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9352e653a2254c5594fc4fd2dd83fa03611ba460"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTYzMDE5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzoyMDozNlrOGLKDnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNzoyMDozNlrOGLKDnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1MjI4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * for the given an {@link EndpointQualifier}. It for MEMBER there will always be an\n          \n          \n            \n                 * for the given {@link EndpointQualifier}. For {@code MEMBER} there will always be a", "url": "https://github.com/hazelcast/hazelcast/pull/16924#discussion_r414352284", "createdAt": "2020-04-24T07:20:36Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "diffHunk": "@@ -39,33 +40,54 @@\n      * Returns a {@link ServerConnectionManager} that is able to handle\n      * connections for the given qualifier.\n      *\n-     * It is important to realize that the returned manager could also\n+     * It is important to realize that the return\\ed manager could also\n      * manage other connections; so if you ask for a member connection manager\n      * it could be that you get a connection manager that also handles client\n      * connections. So if you would ask for {@link ServerConnectionManager#getConnections()}\n      * it could contain a mixture of client and member connections.\n      *\n      * @param qualifier the EndpointQualifier used to select the right connection manager.\n      * @return the relevant {@link ServerConnectionManager} that processes connections\n-     * for the given an {@link EndpointQualifier}\n+     * for the given an {@link EndpointQualifier}. It for MEMBER there will always be an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9352e653a2254c5594fc4fd2dd83fa03611ba460"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjAyMzg2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/TcpServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODo1NTo1MVrOGLNn3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMDo1MzowM1rOGLSDQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxMDcxNg==", "bodyText": "minor: why specify a merge function instead of using Collectors.toMap(keyMapper, valueMapper)? Collisions are not expected here.", "url": "https://github.com/hazelcast/hazelcast/pull/16924#discussion_r414410716", "createdAt": "2020-04-24T08:55:51Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/TcpServer.java", "diffHunk": "@@ -233,22 +217,18 @@ public synchronized void shutdown() {\n             return emptyMap();\n         }\n \n-        Map<EndpointQualifier, NetworkStats> stats = null;\n-        for (Map.Entry<EndpointQualifier, TcpServerConnectionManager> entry : connectionManagers.entrySet()) {\n-            if (stats == null) {\n-                stats = new HashMap<>();\n-            }\n-            stats.put(entry.getKey(), entry.getValue().getNetworkStats());\n-        }\n-        return stats == null ? emptyMap() : stats;\n+        return connectionManagers.entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().getNetworkStats(), (a, b) -> b));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9352e653a2254c5594fc4fd2dd83fa03611ba460"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4MzI2Nw==", "bodyText": "Intellij code rewrite function :) I'll have a look.", "url": "https://github.com/hazelcast/hazelcast/pull/16924#discussion_r414483267", "createdAt": "2020-04-24T10:53:03Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/TcpServer.java", "diffHunk": "@@ -233,22 +217,18 @@ public synchronized void shutdown() {\n             return emptyMap();\n         }\n \n-        Map<EndpointQualifier, NetworkStats> stats = null;\n-        for (Map.Entry<EndpointQualifier, TcpServerConnectionManager> entry : connectionManagers.entrySet()) {\n-            if (stats == null) {\n-                stats = new HashMap<>();\n-            }\n-            stats.put(entry.getKey(), entry.getValue().getNetworkStats());\n-        }\n-        return stats == null ? emptyMap() : stats;\n+        return connectionManagers.entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().getNetworkStats(), (a, b) -> b));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxMDcxNg=="}, "originalCommit": {"oid": "9352e653a2254c5594fc4fd2dd83fa03611ba460"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjA0MTQwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/TcpServerConnectionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODo1OTozNVrOGLNx0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODo1OTozNVrOGLNx0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxMzI2Ng==", "bodyText": "minor: EndpointManager -> ConnectionManager", "url": "https://github.com/hazelcast/hazelcast/pull/16924#discussion_r414413266", "createdAt": "2020-04-24T08:59:35Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/TcpServerConnectionManager.java", "diffHunk": "@@ -258,13 +264,13 @@ public int getKey() {\n \n     public synchronized void reset(boolean cleanListeners) {\n         acceptedChannels.forEach(IOUtil::closeResource);\n-        connectionsMap.values().forEach(conn -> close(conn, \"EndpointManager is stopping\"));\n-        activeConnections.forEach(conn -> close(conn, \"EndpointManager is stopping\"));\n+        mappedConnections.values().forEach(conn -> close(conn, \"EndpointManager is stopping\"));\n+        connections.forEach(conn -> close(conn, \"EndpointManager is stopping\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9352e653a2254c5594fc4fd2dd83fa03611ba460"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjA4NzQzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOToxMDoyNVrOGLOM1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOToxMDoyNVrOGLOM1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQyMDE4MQ==", "bodyText": "a @Nonnull annotation in this method could help clarify API. It seems there were some methods expecting it might return null but that was not the case.", "url": "https://github.com/hazelcast/hazelcast/pull/16924#discussion_r414420181", "createdAt": "2020-04-24T09:10:25Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "diffHunk": "@@ -39,33 +40,54 @@\n      * Returns a {@link ServerConnectionManager} that is able to handle\n      * connections for the given qualifier.\n      *\n-     * It is important to realize that the returned manager could also\n+     * It is important to realize that the return\\ed manager could also\n      * manage other connections; so if you ask for a member connection manager\n      * it could be that you get a connection manager that also handles client\n      * connections. So if you would ask for {@link ServerConnectionManager#getConnections()}\n      * it could contain a mixture of client and member connections.\n      *\n      * @param qualifier the EndpointQualifier used to select the right connection manager.\n      * @return the relevant {@link ServerConnectionManager} that processes connections\n-     * for the given an {@link EndpointQualifier}\n+     * for the given an {@link EndpointQualifier}. It for MEMBER there will always be an\n+     * ConnectionManager, but for the other ones null could be returned.\n      */\n     ServerConnectionManager getConnectionManager(EndpointQualifier qualifier);\n \n     /**\n-     * Returns all connections that have been successfully established.\n+     * Returns all connections.\n      *\n-     * @return active connections\n+     * This can be a relatively expensive operations the returned collection might be created\n+     * on every invocation. So if you are just interested in count, have a look at\n+     * {@link #connectionCount(Predicate)} method.\n+     *\n+     * @return the connections.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9352e653a2254c5594fc4fd2dd83fa03611ba460"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 685, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}