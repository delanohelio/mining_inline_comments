{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMTUyNzky", "number": 17909, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMTo0NzowNlrOE_lOdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjozMzoyMFrOE_mQlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MTA1NjU0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMTo0NzowNlrOH9XOPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNjowNDozMVrOH9iQpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEwNTY2MA==", "bodyText": "I think if we take this unified putInternal() way, we should consider introducing a parameter type for it. It's a bit hard to follow which boolean means what in the PR. I mean something like\nprivate static class PutControl {\n  private static final PutControl PUT_IF_ABSENT = PutControl.of().putIfAbsent().putIfExists().putIfEqual()...;\n\n  boolean putIfAbsent;\n  boolean putIfExists;\n  ...\n}\n\nThen, we can call from putIfAbsent() something like putInternal(key, value, ttl, maxIdle, getNow(), PutControl.PUT_IF_ABSENT)\nWDYT?\nOn the other hand, I'm not sure that merging multiple methods into a single one loaded with branches is better for readability/understandability/performance. What gain do we expect here? Can't we just extract parts of this method into primitive building blocks and use those blocks directly in the callers?", "url": "https://github.com/hazelcast/hazelcast/pull/17909#discussion_r534105660", "createdAt": "2020-12-02T11:47:06Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -746,66 +738,158 @@ private void addEventToQueryCache(Data dataKey, Record record) {\n \n     @Override\n     public boolean setTtl(Data key, long ttl, boolean backup) {\n-        long now = getNow();\n-        Record record = getRecordOrNull(key, now, false);\n-        Object existingValue = record == null ? loadValueOf(key) : record.getValue();\n-        if (existingValue == null) {\n-            return false;\n-        }\n-        if (record == null) {\n-            createRecord(key, existingValue, ttl, UNSET, now);\n-            mutationObserver.onPutRecord(key, null, existingValue, false);\n-        } else {\n-            updateRecord(key, record, existingValue, existingValue, now, true, ttl,\n-                    UNSET, true, null, backup);\n-        }\n-        markRecordStoreExpirable(ttl, UNSET);\n-        return true;\n+        Object oldValue = putInternal(key, null, ttl, UNSET, getNow(),\n+                true, true, false, true, false,\n+                false, null, true, true,\n+                null, null, true, backup);\n+        return oldValue != null;\n     }\n \n     @Override\n     public Object set(Data dataKey, Object value, long ttl, long maxIdle) {\n-        return putInternal(dataKey, value, ttl, maxIdle, null, false, true);\n+        return putInternal(dataKey, value, ttl, maxIdle, getNow(),\n+                false, true, false, false, false,\n+                false, null, false, true,\n+                null, null, true, false);\n     }\n \n     @Override\n     public Object setTxn(Data dataKey, Object value, long ttl, long maxIdle, UUID transactionId) {\n-        return putInternal(dataKey, value, ttl, maxIdle, transactionId, false, true);\n+        return putInternal(dataKey, value, ttl, maxIdle, getNow(),\n+                false, true, false, false, false,\n+                false, null, false, true,\n+                transactionId, null, true, false);\n     }\n \n     @Override\n     public Object put(Data key, Object value, long ttl, long maxIdle) {\n-        return putInternal(key, value, ttl, maxIdle, null, true, true);\n+        return putInternal(key, value, ttl, maxIdle, getNow(),\n+                true, true, false, false, false,\n+                false, null, false, true,\n+                null, null, true, false);\n     }\n \n-    protected Object putInternal(Data key, Object newValue, long ttl,\n-                                 long maxIdle, @Nullable UUID transactionId,\n-                                 boolean loadFromStore, boolean countAsAccess) {\n-        checkIfLoaded();\n-\n-        long now = getNow();\n-        markRecordStoreExpirable(ttl, maxIdle);\n-\n-        Record record = getRecordOrNull(key, now, false);\n-        Object oldValue = record == null\n-                ? (loadFromStore ? loadValueOf(key) : null) : record.getValue();\n-        newValue = mapServiceContext.interceptPut(interceptorRegistry, oldValue, newValue);\n-        onStore(record);\n+    /**\n+     * Core put method for all variants of puts/updates.\n+     * @return old value if this is an update operations, otherwise returns null\n+     */\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\",\n+            \"checkstyle:parameternumber\", \"checkstyle:cyclomaticcomplexity\"})\n+    private Object putInternal(Data key, Object newValue, long ttl,\n+                               long maxIdle, long now, boolean load, boolean store,\n+                               boolean putIfAbsent, boolean putIfExists, boolean putIfEqual,\n+                               boolean putFromLoad, Object expectedValue, boolean useOldValueIfNoNewValue,\n+                               boolean checkIfLoaded, @Nullable UUID transactionId,\n+                               Address callerAddress, boolean countAsAccess, boolean backup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fecde9dbb797c303d6fca39a9e8b5567678697"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2Njk1NA==", "bodyText": "Merging will help here to see logical problems, fixing bugs or making improvements in one place for all variants of puts. For readability/understandability, i added short comments. For performance, i believe branching has very minimal effect, since we have still a lot of branching, but with this 2-3 new branches... it needs verifications of course. To see possible improvements  easily i'll keep the method as dumb as possible for now, so not planning to add PutControl.", "url": "https://github.com/hazelcast/hazelcast/pull/17909#discussion_r534266954", "createdAt": "2020-12-02T15:40:27Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -746,66 +738,158 @@ private void addEventToQueryCache(Data dataKey, Record record) {\n \n     @Override\n     public boolean setTtl(Data key, long ttl, boolean backup) {\n-        long now = getNow();\n-        Record record = getRecordOrNull(key, now, false);\n-        Object existingValue = record == null ? loadValueOf(key) : record.getValue();\n-        if (existingValue == null) {\n-            return false;\n-        }\n-        if (record == null) {\n-            createRecord(key, existingValue, ttl, UNSET, now);\n-            mutationObserver.onPutRecord(key, null, existingValue, false);\n-        } else {\n-            updateRecord(key, record, existingValue, existingValue, now, true, ttl,\n-                    UNSET, true, null, backup);\n-        }\n-        markRecordStoreExpirable(ttl, UNSET);\n-        return true;\n+        Object oldValue = putInternal(key, null, ttl, UNSET, getNow(),\n+                true, true, false, true, false,\n+                false, null, true, true,\n+                null, null, true, backup);\n+        return oldValue != null;\n     }\n \n     @Override\n     public Object set(Data dataKey, Object value, long ttl, long maxIdle) {\n-        return putInternal(dataKey, value, ttl, maxIdle, null, false, true);\n+        return putInternal(dataKey, value, ttl, maxIdle, getNow(),\n+                false, true, false, false, false,\n+                false, null, false, true,\n+                null, null, true, false);\n     }\n \n     @Override\n     public Object setTxn(Data dataKey, Object value, long ttl, long maxIdle, UUID transactionId) {\n-        return putInternal(dataKey, value, ttl, maxIdle, transactionId, false, true);\n+        return putInternal(dataKey, value, ttl, maxIdle, getNow(),\n+                false, true, false, false, false,\n+                false, null, false, true,\n+                transactionId, null, true, false);\n     }\n \n     @Override\n     public Object put(Data key, Object value, long ttl, long maxIdle) {\n-        return putInternal(key, value, ttl, maxIdle, null, true, true);\n+        return putInternal(key, value, ttl, maxIdle, getNow(),\n+                true, true, false, false, false,\n+                false, null, false, true,\n+                null, null, true, false);\n     }\n \n-    protected Object putInternal(Data key, Object newValue, long ttl,\n-                                 long maxIdle, @Nullable UUID transactionId,\n-                                 boolean loadFromStore, boolean countAsAccess) {\n-        checkIfLoaded();\n-\n-        long now = getNow();\n-        markRecordStoreExpirable(ttl, maxIdle);\n-\n-        Record record = getRecordOrNull(key, now, false);\n-        Object oldValue = record == null\n-                ? (loadFromStore ? loadValueOf(key) : null) : record.getValue();\n-        newValue = mapServiceContext.interceptPut(interceptorRegistry, oldValue, newValue);\n-        onStore(record);\n+    /**\n+     * Core put method for all variants of puts/updates.\n+     * @return old value if this is an update operations, otherwise returns null\n+     */\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\",\n+            \"checkstyle:parameternumber\", \"checkstyle:cyclomaticcomplexity\"})\n+    private Object putInternal(Data key, Object newValue, long ttl,\n+                               long maxIdle, long now, boolean load, boolean store,\n+                               boolean putIfAbsent, boolean putIfExists, boolean putIfEqual,\n+                               boolean putFromLoad, Object expectedValue, boolean useOldValueIfNoNewValue,\n+                               boolean checkIfLoaded, @Nullable UUID transactionId,\n+                               Address callerAddress, boolean countAsAccess, boolean backup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEwNTY2MA=="}, "originalCommit": {"oid": "38fecde9dbb797c303d6fca39a9e8b5567678697"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4NjUwMQ==", "bodyText": "I agree that the performance loss is insignificant here. I commented that as well because the branches break the previously straight control flow similarly to how they break the \"reading flow\" (for me). Anyways, I'm not blocking you on this, we will see in the end if this unification helps or distracts.\nWith the PutControl idea, I didn't mean any change to putInternal() itself. It would be only changing if (putIfAbsent) {...} to if (ctrl.putIfAbsent) {...}. It would be useful only to the non-IDE readers though, as the IDEs - at least IntelliJ - label the variables, so I'm ok with not implementing this as well.", "url": "https://github.com/hazelcast/hazelcast/pull/17909#discussion_r534286501", "createdAt": "2020-12-02T16:04:31Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -746,66 +738,158 @@ private void addEventToQueryCache(Data dataKey, Record record) {\n \n     @Override\n     public boolean setTtl(Data key, long ttl, boolean backup) {\n-        long now = getNow();\n-        Record record = getRecordOrNull(key, now, false);\n-        Object existingValue = record == null ? loadValueOf(key) : record.getValue();\n-        if (existingValue == null) {\n-            return false;\n-        }\n-        if (record == null) {\n-            createRecord(key, existingValue, ttl, UNSET, now);\n-            mutationObserver.onPutRecord(key, null, existingValue, false);\n-        } else {\n-            updateRecord(key, record, existingValue, existingValue, now, true, ttl,\n-                    UNSET, true, null, backup);\n-        }\n-        markRecordStoreExpirable(ttl, UNSET);\n-        return true;\n+        Object oldValue = putInternal(key, null, ttl, UNSET, getNow(),\n+                true, true, false, true, false,\n+                false, null, true, true,\n+                null, null, true, backup);\n+        return oldValue != null;\n     }\n \n     @Override\n     public Object set(Data dataKey, Object value, long ttl, long maxIdle) {\n-        return putInternal(dataKey, value, ttl, maxIdle, null, false, true);\n+        return putInternal(dataKey, value, ttl, maxIdle, getNow(),\n+                false, true, false, false, false,\n+                false, null, false, true,\n+                null, null, true, false);\n     }\n \n     @Override\n     public Object setTxn(Data dataKey, Object value, long ttl, long maxIdle, UUID transactionId) {\n-        return putInternal(dataKey, value, ttl, maxIdle, transactionId, false, true);\n+        return putInternal(dataKey, value, ttl, maxIdle, getNow(),\n+                false, true, false, false, false,\n+                false, null, false, true,\n+                transactionId, null, true, false);\n     }\n \n     @Override\n     public Object put(Data key, Object value, long ttl, long maxIdle) {\n-        return putInternal(key, value, ttl, maxIdle, null, true, true);\n+        return putInternal(key, value, ttl, maxIdle, getNow(),\n+                true, true, false, false, false,\n+                false, null, false, true,\n+                null, null, true, false);\n     }\n \n-    protected Object putInternal(Data key, Object newValue, long ttl,\n-                                 long maxIdle, @Nullable UUID transactionId,\n-                                 boolean loadFromStore, boolean countAsAccess) {\n-        checkIfLoaded();\n-\n-        long now = getNow();\n-        markRecordStoreExpirable(ttl, maxIdle);\n-\n-        Record record = getRecordOrNull(key, now, false);\n-        Object oldValue = record == null\n-                ? (loadFromStore ? loadValueOf(key) : null) : record.getValue();\n-        newValue = mapServiceContext.interceptPut(interceptorRegistry, oldValue, newValue);\n-        onStore(record);\n+    /**\n+     * Core put method for all variants of puts/updates.\n+     * @return old value if this is an update operations, otherwise returns null\n+     */\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\",\n+            \"checkstyle:parameternumber\", \"checkstyle:cyclomaticcomplexity\"})\n+    private Object putInternal(Data key, Object newValue, long ttl,\n+                               long maxIdle, long now, boolean load, boolean store,\n+                               boolean putIfAbsent, boolean putIfExists, boolean putIfEqual,\n+                               boolean putFromLoad, Object expectedValue, boolean useOldValueIfNoNewValue,\n+                               boolean checkIfLoaded, @Nullable UUID transactionId,\n+                               Address callerAddress, boolean countAsAccess, boolean backup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEwNTY2MA=="}, "originalCommit": {"oid": "38fecde9dbb797c303d6fca39a9e8b5567678697"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MTIyNTgwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjozMzoyMFrOH9Y03A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTo0MDozM1rOH9hEmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMTkzMg==", "bodyText": "Can't we use record here instead of getRecord()?", "url": "https://github.com/hazelcast/hazelcast/pull/17909#discussion_r534131932", "createdAt": "2020-12-02T12:33:20Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -410,13 +404,11 @@ public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress)\n             value = loaderEntry.getValue();\n             ttl = proposedTtl;\n         }\n-        Record record = createRecord(key, value, ttl, UNSET, getNow());\n-        markRecordStoreExpirable(ttl, UNSET);\n-        storage.put(key, record);\n-        mutationObserver.onLoadRecord(key, record, backup);\n-        if (!backup) {\n+        Record record = putNewRecord(key, null, value, ttl, UNSET, getNow(),\n+                null, LOADED, false, backup);\n+        if (!backup && mapEventPublisher.hasEventListener(name)) {\n             mapEventPublisher.publishEvent(callerAddress, name, EntryEventType.LOADED,\n-                    key, null, value, null);\n+                    key, null, getRecord(key).getValue(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fecde9dbb797c303d6fca39a9e8b5567678697"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2NzAzMw==", "bodyText": "fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17909#discussion_r534267033", "createdAt": "2020-12-02T15:40:33Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -410,13 +404,11 @@ public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress)\n             value = loaderEntry.getValue();\n             ttl = proposedTtl;\n         }\n-        Record record = createRecord(key, value, ttl, UNSET, getNow());\n-        markRecordStoreExpirable(ttl, UNSET);\n-        storage.put(key, record);\n-        mutationObserver.onLoadRecord(key, record, backup);\n-        if (!backup) {\n+        Record record = putNewRecord(key, null, value, ttl, UNSET, getNow(),\n+                null, LOADED, false, backup);\n+        if (!backup && mapEventPublisher.hasEventListener(name)) {\n             mapEventPublisher.publishEvent(callerAddress, name, EntryEventType.LOADED,\n-                    key, null, value, null);\n+                    key, null, getRecord(key).getValue(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMTkzMg=="}, "originalCommit": {"oid": "38fecde9dbb797c303d6fca39a9e8b5567678697"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4980, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}