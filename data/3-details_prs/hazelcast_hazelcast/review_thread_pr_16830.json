{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2Mjk4MTY2", "number": 16830, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTo1MDowNlrODtdVdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo1NTozNlrODthNpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTkzMTQyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryResultProducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTo1MDowNlrOF-5FTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDowNDoyMVrOF-5n9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5MTI3Ng==", "bodyText": "Subsequent calls must return the same instance\n\nLooks like QueryResultProducer is itself an iterator.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401491276", "createdAt": "2020-04-01T09:50:06Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryResultProducer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Generic interface which produces iterator over results which are then delivered to users.\n+ * Returned iterator must provide rows which were not returned yet.\n+ */\n+public interface QueryResultProducer {\n+    /**\n+     * Get iterator over results. Subsequent calls must return the same instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwMDE1MQ==", "bodyText": "Yes. There are no strong indications for an inheritance, so the composition is used instead because it simplifies testing.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401500151", "createdAt": "2020-04-01T10:04:21Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryResultProducer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Generic interface which produces iterator over results which are then delivered to users.\n+ * Returned iterator must provide rows which were not returned yet.\n+ */\n+public interface QueryResultProducer {\n+    /**\n+     * Get iterator over results. Subsequent calls must return the same instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5MTI3Ng=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTk3ODg3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDowMjoyNFrOF-5jOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1Njo0N1rOF-9OzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA==", "bodyText": "Are push/pop public only for testing purposes?", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401498938", "createdAt": "2020-04-01T10:02:24Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwMDU0NQ==", "bodyText": "Yes, otherwise it is impossible to introduce new plan nodes and execs for testing.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401500545", "createdAt": "2020-04-01T10:05:05Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxNDQyMg==", "bodyText": "Probably they deserve \"only for testing\" comment.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401514422", "createdAt": "2020-04-01T10:29:10Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxNTE3Nw==", "bodyText": "They are exposed as public for testing, but they are also used by the real implementation (e.g. see root node processing).", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401515177", "createdAt": "2020-04-01T10:30:40Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxNjcxNw==", "bodyText": "\"public only for testing\" comment? :)", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401516717", "createdAt": "2020-04-01T10:33:16Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1OTI0NA==", "bodyText": "Got it. Added JavaDoc.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401559244", "createdAt": "2020-04-01T11:56:47Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDE3NDIzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDo1ODo1OFrOF-7c8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMzowOTo1NlrOF-_0gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ==", "bodyText": "That implies next can be called without preceding hasNext call, is that possible?", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401530099", "createdAt": "2020-04-01T10:58:58Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.root;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Blocking array-based result consumer which delivers the results to API caller.\n+ */\n+public class BlockingRootResultConsumer implements RootResultConsumer {\n+    /** Mutex for concurrency support. */\n+    private final Object mux = new Object();\n+\n+    /** Iterator over produced rows. */\n+    private final InternalIterator iterator = new InternalIterator();\n+\n+    /** Query context to schedule root execution when the next batch is needed. */\n+    private volatile QueryFragmentContext context;\n+\n+    /** The batch that is currently being consumed. */\n+    private List<Row> currentBatch;\n+\n+    /** When \"true\" no more batches are expected. */\n+    private boolean done;\n+\n+    /** Error which occurred during query execution. */\n+    private HazelcastSqlException doneError;\n+\n+    @Override\n+    public void setup(QueryFragmentContext context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public boolean consume(List<Row> batch, boolean last) {\n+        assert !batch.isEmpty();\n+\n+        synchronized (mux) {\n+            assert !done;\n+\n+            if (currentBatch == null) {\n+                currentBatch = batch;\n+\n+                if (last) {\n+                    done = true;\n+                }\n+\n+                mux.notifyAll();\n+\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onError(HazelcastSqlException error) {\n+        synchronized (mux) {\n+            if (!done) {\n+                done = true;\n+                doneError = error;\n+\n+                mux.notifyAll();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Poll the next batch from the upstream, waiting if needed.\n+     *\n+     * @return The batch or {@code null} if end of stream is reached.\n+     */\n+    private List<Row> awaitNextBatch() {\n+        synchronized (mux) {\n+            while (true) {\n+                // Consume the batch if it is available.\n+                if (currentBatch != null) {\n+                    List<Row> res = currentBatch;\n+\n+                    currentBatch = null;\n+\n+                    return res;\n+                }\n+\n+                // Handle end of the stream.\n+                if (done) {\n+                    if (doneError != null) {\n+                        throw doneError;\n+                    }\n+\n+                    return null;\n+                }\n+\n+                // Otherwise wait.\n+                try {\n+                    mux.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+\n+                    throw HazelcastSqlException.error(\"Thread was interrupted while waiting for more results.\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Request the next batch from the executor.\n+     */\n+    private void requestNextBatch() {\n+        synchronized (mux) {\n+            if (done) {\n+                return;\n+            }\n+        }\n+\n+        // We may reach this place only if some rows are already produced, and this is possible only after the setup,\n+        // so the context should be initialized.\n+        assert context != null;\n+\n+        context.schedule();\n+    }\n+\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Iterator over results.\n+     */\n+    private class InternalIterator implements Iterator<Row> {\n+\n+        private List<Row> batch;\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+            setNextBatchIfNeeded();\n+\n+            assert batch != null || done;\n+\n+            return batch != null;\n+        }\n+\n+        @Override\n+        public Row next() {\n+            setNextBatchIfNeeded();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1OTYyMQ==", "bodyText": "Yes, it is possible. The Iterator interface doesn't require users to call hasNext first.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401559621", "createdAt": "2020-04-01T11:57:38Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.root;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Blocking array-based result consumer which delivers the results to API caller.\n+ */\n+public class BlockingRootResultConsumer implements RootResultConsumer {\n+    /** Mutex for concurrency support. */\n+    private final Object mux = new Object();\n+\n+    /** Iterator over produced rows. */\n+    private final InternalIterator iterator = new InternalIterator();\n+\n+    /** Query context to schedule root execution when the next batch is needed. */\n+    private volatile QueryFragmentContext context;\n+\n+    /** The batch that is currently being consumed. */\n+    private List<Row> currentBatch;\n+\n+    /** When \"true\" no more batches are expected. */\n+    private boolean done;\n+\n+    /** Error which occurred during query execution. */\n+    private HazelcastSqlException doneError;\n+\n+    @Override\n+    public void setup(QueryFragmentContext context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public boolean consume(List<Row> batch, boolean last) {\n+        assert !batch.isEmpty();\n+\n+        synchronized (mux) {\n+            assert !done;\n+\n+            if (currentBatch == null) {\n+                currentBatch = batch;\n+\n+                if (last) {\n+                    done = true;\n+                }\n+\n+                mux.notifyAll();\n+\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onError(HazelcastSqlException error) {\n+        synchronized (mux) {\n+            if (!done) {\n+                done = true;\n+                doneError = error;\n+\n+                mux.notifyAll();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Poll the next batch from the upstream, waiting if needed.\n+     *\n+     * @return The batch or {@code null} if end of stream is reached.\n+     */\n+    private List<Row> awaitNextBatch() {\n+        synchronized (mux) {\n+            while (true) {\n+                // Consume the batch if it is available.\n+                if (currentBatch != null) {\n+                    List<Row> res = currentBatch;\n+\n+                    currentBatch = null;\n+\n+                    return res;\n+                }\n+\n+                // Handle end of the stream.\n+                if (done) {\n+                    if (doneError != null) {\n+                        throw doneError;\n+                    }\n+\n+                    return null;\n+                }\n+\n+                // Otherwise wait.\n+                try {\n+                    mux.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+\n+                    throw HazelcastSqlException.error(\"Thread was interrupted while waiting for more results.\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Request the next batch from the executor.\n+     */\n+    private void requestNextBatch() {\n+        synchronized (mux) {\n+            if (done) {\n+                return;\n+            }\n+        }\n+\n+        // We may reach this place only if some rows are already produced, and this is possible only after the setup,\n+        // so the context should be initialized.\n+        assert context != null;\n+\n+        context.schedule();\n+    }\n+\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Iterator over results.\n+     */\n+    private class InternalIterator implements Iterator<Row> {\n+\n+        private List<Row> batch;\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+            setNextBatchIfNeeded();\n+\n+            assert batch != null || done;\n+\n+            return batch != null;\n+        }\n+\n+        @Override\n+        public Row next() {\n+            setNextBatchIfNeeded();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4MjA3MA==", "bodyText": "I'd replace it with the\nif (!hasNext()) {\n    throw new NoSuchElementException();\n}", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401582070", "createdAt": "2020-04-01T12:38:45Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.root;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Blocking array-based result consumer which delivers the results to API caller.\n+ */\n+public class BlockingRootResultConsumer implements RootResultConsumer {\n+    /** Mutex for concurrency support. */\n+    private final Object mux = new Object();\n+\n+    /** Iterator over produced rows. */\n+    private final InternalIterator iterator = new InternalIterator();\n+\n+    /** Query context to schedule root execution when the next batch is needed. */\n+    private volatile QueryFragmentContext context;\n+\n+    /** The batch that is currently being consumed. */\n+    private List<Row> currentBatch;\n+\n+    /** When \"true\" no more batches are expected. */\n+    private boolean done;\n+\n+    /** Error which occurred during query execution. */\n+    private HazelcastSqlException doneError;\n+\n+    @Override\n+    public void setup(QueryFragmentContext context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public boolean consume(List<Row> batch, boolean last) {\n+        assert !batch.isEmpty();\n+\n+        synchronized (mux) {\n+            assert !done;\n+\n+            if (currentBatch == null) {\n+                currentBatch = batch;\n+\n+                if (last) {\n+                    done = true;\n+                }\n+\n+                mux.notifyAll();\n+\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onError(HazelcastSqlException error) {\n+        synchronized (mux) {\n+            if (!done) {\n+                done = true;\n+                doneError = error;\n+\n+                mux.notifyAll();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Poll the next batch from the upstream, waiting if needed.\n+     *\n+     * @return The batch or {@code null} if end of stream is reached.\n+     */\n+    private List<Row> awaitNextBatch() {\n+        synchronized (mux) {\n+            while (true) {\n+                // Consume the batch if it is available.\n+                if (currentBatch != null) {\n+                    List<Row> res = currentBatch;\n+\n+                    currentBatch = null;\n+\n+                    return res;\n+                }\n+\n+                // Handle end of the stream.\n+                if (done) {\n+                    if (doneError != null) {\n+                        throw doneError;\n+                    }\n+\n+                    return null;\n+                }\n+\n+                // Otherwise wait.\n+                try {\n+                    mux.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+\n+                    throw HazelcastSqlException.error(\"Thread was interrupted while waiting for more results.\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Request the next batch from the executor.\n+     */\n+    private void requestNextBatch() {\n+        synchronized (mux) {\n+            if (done) {\n+                return;\n+            }\n+        }\n+\n+        // We may reach this place only if some rows are already produced, and this is possible only after the setup,\n+        // so the context should be initialized.\n+        assert context != null;\n+\n+        context.schedule();\n+    }\n+\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Iterator over results.\n+     */\n+    private class InternalIterator implements Iterator<Row> {\n+\n+        private List<Row> batch;\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+            setNextBatchIfNeeded();\n+\n+            assert batch != null || done;\n+\n+            return batch != null;\n+        }\n+\n+        @Override\n+        public Row next() {\n+            setNextBatchIfNeeded();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwMTY2NQ==", "bodyText": "Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401601665", "createdAt": "2020-04-01T13:09:56Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.root;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Blocking array-based result consumer which delivers the results to API caller.\n+ */\n+public class BlockingRootResultConsumer implements RootResultConsumer {\n+    /** Mutex for concurrency support. */\n+    private final Object mux = new Object();\n+\n+    /** Iterator over produced rows. */\n+    private final InternalIterator iterator = new InternalIterator();\n+\n+    /** Query context to schedule root execution when the next batch is needed. */\n+    private volatile QueryFragmentContext context;\n+\n+    /** The batch that is currently being consumed. */\n+    private List<Row> currentBatch;\n+\n+    /** When \"true\" no more batches are expected. */\n+    private boolean done;\n+\n+    /** Error which occurred during query execution. */\n+    private HazelcastSqlException doneError;\n+\n+    @Override\n+    public void setup(QueryFragmentContext context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public boolean consume(List<Row> batch, boolean last) {\n+        assert !batch.isEmpty();\n+\n+        synchronized (mux) {\n+            assert !done;\n+\n+            if (currentBatch == null) {\n+                currentBatch = batch;\n+\n+                if (last) {\n+                    done = true;\n+                }\n+\n+                mux.notifyAll();\n+\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onError(HazelcastSqlException error) {\n+        synchronized (mux) {\n+            if (!done) {\n+                done = true;\n+                doneError = error;\n+\n+                mux.notifyAll();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Poll the next batch from the upstream, waiting if needed.\n+     *\n+     * @return The batch or {@code null} if end of stream is reached.\n+     */\n+    private List<Row> awaitNextBatch() {\n+        synchronized (mux) {\n+            while (true) {\n+                // Consume the batch if it is available.\n+                if (currentBatch != null) {\n+                    List<Row> res = currentBatch;\n+\n+                    currentBatch = null;\n+\n+                    return res;\n+                }\n+\n+                // Handle end of the stream.\n+                if (done) {\n+                    if (doneError != null) {\n+                        throw doneError;\n+                    }\n+\n+                    return null;\n+                }\n+\n+                // Otherwise wait.\n+                try {\n+                    mux.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+\n+                    throw HazelcastSqlException.error(\"Thread was interrupted while waiting for more results.\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Request the next batch from the executor.\n+     */\n+    private void requestNextBatch() {\n+        synchronized (mux) {\n+            if (done) {\n+                return;\n+            }\n+        }\n+\n+        // We may reach this place only if some rows are already produced, and this is possible only after the setup,\n+        // so the context should be initialized.\n+        assert context != null;\n+\n+        context.schedule();\n+    }\n+\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Iterator over results.\n+     */\n+    private class InternalIterator implements Iterator<Row> {\n+\n+        private List<Row> batch;\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+            setNextBatchIfNeeded();\n+\n+            assert batch != null || done;\n+\n+            return batch != null;\n+        }\n+\n+        @Override\n+        public Row next() {\n+            setNextBatchIfNeeded();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ=="}, "originalCommit": {"oid": "b646dc26aaf9e41e53f50679392df59eb91be510"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDU2Njc5OnYy", "diffSide": "LEFT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/mailbox/OutboundHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo1NTozNlrOF-_Q4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMzoyNToyM1rOF_AeUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU5MjU0Nw==", "bodyText": "It seems the old version is grammatically correct? :-)", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401592547", "createdAt": "2020-04-01T12:55:36Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/mailbox/OutboundHandler.java", "diffHunk": "@@ -23,7 +23,7 @@\n     /**\n      * Handle flow control response from the remote inbound handler.\n      *\n-     * @param remainingMemory Amount of memory which is available on the remote end.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b81fd1281e6aec85638b3a37b8e41adfd5d36ef1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxMjM2OA==", "bodyText": "Fixed. Bad merge, I guess )", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401612368", "createdAt": "2020-04-01T13:25:23Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/mailbox/OutboundHandler.java", "diffHunk": "@@ -23,7 +23,7 @@\n     /**\n      * Handle flow control response from the remote inbound handler.\n      *\n-     * @param remainingMemory Amount of memory which is available on the remote end.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU5MjU0Nw=="}, "originalCommit": {"oid": "b81fd1281e6aec85638b3a37b8e41adfd5d36ef1"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 620, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}