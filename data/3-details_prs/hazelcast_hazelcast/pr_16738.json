{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NTY5NDc2", "number": 16738, "title": "SQL: Type system (#15241)", "bodyText": "Closes #15241", "createdAt": "2020-03-11T09:18:08Z", "url": "https://github.com/hazelcast/hazelcast/pull/16738", "merged": true, "mergeCommit": {"oid": "417bab6e0226eee4e9564a6f47856f897b3c11fb"}, "closed": true, "closedAt": "2020-03-17T07:48:31Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMjg0jAH2gAyMzg2NTY5NDc2OjI0YWQ3MjMxYzZhNzE3NGUyZTU2NjQ3NWJjYzU5MTIwZTQ1YTUxZTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOdzd0gFqTM3NTc5ODg0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/24ad7231c6a7174e2e566475bcc59120e45a51e6", "committedDate": "2020-03-11T09:15:42Z", "message": "SQL type system."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNDQ3NzEz", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-373447713", "createdAt": "2020-03-12T10:45:16Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDo0NToxNlrOF1ZfQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDo0NToxNlrOF1ZfQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzNjQ0OA==", "bodyText": "Not a big deal, but in the standard it's named as TIMESTAMP WITH TIME ZONE, with a space between TIME and ZONE. Looks like other products are following that style as well.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391536448", "createdAt": "2020-03-12T10:45:16Z", "author": {"login": "taburet"}, "path": "docs/design/sql/01-type-system.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# SQL Type System\n+\n+## Overview\n+Hazelcast SQL type system defines how objects of different types interact with each other. Type system\n+is defined by the list of supported types, type mapping and type conversion rules.\n+\n+Type is described by name, precedence, precision and scale.\n+- Name is textual representation of type name\n+- Precedence is an integer number which defines context-dependent type resolution rules for expressions\n+- Precision is the total count of significant digits in the whole number, applicable to **numeric types**\n+\n+Type family is a collection of types with the same name, but different precisions. All types\n+within a family have the same name and precedence. For example, `INT(11)` and `INT(12)` are two types\n+from the same `INT` family.\n+\n+Scale is not used in Hazelcast SQL. It is applicable only for DECIMAL, REAL and DOUBLE types, and instead\n+of defining it as a separate value, we just treat these types as types with infinite scale.\n+\n+## Supported types\n+Types supported by the Hazelcast SQL engine is listed in the Table 1. Precision is the smallest precision in the type family.\n+\n+`OBJECT` is Hazelcast-specific type representing an object which doesn't match any other type.\n+\n+*Table 1: Hazelcast SQL Data Types*\n+\n+| SQL Type | Precedence | Precision |\n+|---|---|---|\n+| `VARCHAR` | 100 |  |\n+| `BIT` | 200 | 1 |\n+| `TINYINT` | 300 | 4 |\n+| `SMALLINT` | 400 | 7 |\n+| `INT` | 500 | 11 |\n+| `BIGINT` | 600 | 20 |\n+| `DECIMAL` | 700 | Unlimited |\n+| `REAL` | 800 | Unlimited |\n+| `DOUBLE` | 900 | Unlimited |\n+| `TIME` | 1000 |  |\n+| `DATE` | 1100 |  |\n+| `TIMESTAMP` | 1200 |  |\n+| `TIMESTAMP WITH TIMEZONE` | 1300 |  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNDU4MTU1", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-373458155", "createdAt": "2020-03-12T11:01:11Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTowMToxMVrOF1aAgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTowMToxMVrOF1aAgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU0NDk2Mw==", "bodyText": "The missing part is LATE type description: it's not documented here and it's not documented in the code. It's not clear how it interacts with other types, in which situations it may pop up and what is the purpose of it. Do we need it after all? If we are going with the static schema approach, we should know all the types.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391544963", "createdAt": "2020-03-12T11:01:11Z", "author": {"login": "taburet"}, "path": "docs/design/sql/01-type-system.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# SQL Type System", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNDYyMTMz", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-373462133", "createdAt": "2020-03-12T11:07:20Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTowNzoyMFrOF1aNMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTowNzoyMFrOF1aNMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU0ODIwOA==", "bodyText": "Minor: the usual naming pattern is <Module>DataSerializerHook, SqlDataSerializerHook?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391548208", "createdAt": "2020-03-12T11:07:20Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QuerySerializationHook.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.internal.serialization.DataSerializerHook;\n+import com.hazelcast.internal.serialization.impl.ArrayDataSerializableFactory;\n+import com.hazelcast.internal.serialization.impl.FactoryIdHelper;\n+import com.hazelcast.internal.util.ConstructorFunction;\n+import com.hazelcast.nio.serialization.DataSerializableFactory;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import static com.hazelcast.internal.serialization.impl.FactoryIdHelper.SQL_DS_FACTORY;\n+import static com.hazelcast.internal.serialization.impl.FactoryIdHelper.SQL_DS_FACTORY_ID;\n+\n+/**\n+ * Serialization hook for SQL classes.\n+ */\n+public class QuerySerializationHook implements DataSerializerHook {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNDY1MTE4", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-373465118", "createdAt": "2020-03-12T11:12:11Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMToxMjoxMVrOF1aWlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMToxMjoxMVrOF1aWlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MDYxNQ==", "bodyText": "(De)serialization is not covered in tests.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391550615", "createdAt": "2020-03-12T11:12:11Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataType.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QuerySerializationHook;\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.BooleanConverter;\n+import com.hazelcast.sql.impl.type.converter.ByteConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.DoubleConverter;\n+import com.hazelcast.sql.impl.type.converter.FloatConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.IntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.LateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LongConverter;\n+import com.hazelcast.sql.impl.type.converter.ObjectConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.ShortConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Data type represents a type of concrete expression which is based on some basic data type.\n+ */\n+public class QueryDataType implements IdentifiedDataSerializable {\n+    public static final int PRECISION_BIT = 1;\n+    public static final int PRECISION_TINYINT = 4;\n+    public static final int PRECISION_SMALLINT = 7;\n+    public static final int PRECISION_INT = 11;\n+    public static final int PRECISION_BIGINT = 20;\n+    public static final int PRECISION_UNLIMITED = -1;\n+\n+    public static final QueryDataType LATE = new QueryDataType(LateConverter.INSTANCE);\n+\n+    public static final QueryDataType VARCHAR = new QueryDataType(StringConverter.INSTANCE);\n+    public static final QueryDataType VARCHAR_CHARACTER = new QueryDataType(CharacterConverter.INSTANCE);\n+\n+    public static final QueryDataType BIT = new QueryDataType(BooleanConverter.INSTANCE, PRECISION_BIT);\n+    public static final QueryDataType TINYINT = new QueryDataType(ByteConverter.INSTANCE, PRECISION_TINYINT);\n+    public static final QueryDataType SMALLINT = new QueryDataType(ShortConverter.INSTANCE, PRECISION_SMALLINT);\n+    public static final QueryDataType INT = new QueryDataType(IntegerConverter.INSTANCE, PRECISION_INT);\n+    public static final QueryDataType BIGINT = new QueryDataType(LongConverter.INSTANCE, PRECISION_BIGINT);\n+    public static final QueryDataType DECIMAL = new QueryDataType(BigDecimalConverter.INSTANCE);\n+    public static final QueryDataType DECIMAL_BIG_INTEGER = new QueryDataType(BigIntegerConverter.INSTANCE);\n+    public static final QueryDataType REAL = new QueryDataType(FloatConverter.INSTANCE);\n+    public static final QueryDataType DOUBLE = new QueryDataType(DoubleConverter.INSTANCE);\n+\n+    public static final QueryDataType TIME = new QueryDataType(LocalTimeConverter.INSTANCE);\n+    public static final QueryDataType DATE = new QueryDataType(LocalDateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP = new QueryDataType(LocalDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_DATE = new QueryDataType(DateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_CALENDAR = new QueryDataType(CalendarConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_INSTANT = new QueryDataType(InstantConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME = new QueryDataType(OffsetDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_ZONED_DATE_TIME = new QueryDataType(ZonedDateTimeConverter.INSTANCE);\n+\n+    public static final QueryDataType OBJECT = new QueryDataType(ObjectConverter.INSTANCE);\n+\n+    /** Converter. */\n+    private Converter converter;\n+\n+    /** Precision. */\n+    private int precision;\n+\n+    public QueryDataType() {\n+        // No-op.\n+    }\n+\n+    QueryDataType(Converter converter) {\n+        this(converter, PRECISION_UNLIMITED);\n+    }\n+\n+    QueryDataType(Converter converter, int precision) {\n+        this.converter = converter;\n+        this.precision = precision;\n+    }\n+\n+    public QueryDataTypeFamily getTypeFamily() {\n+        return converter.getTypeFamily();\n+    }\n+\n+    public Converter getConverter() {\n+        return converter;\n+    }\n+\n+    public int getPrecision() {\n+        return precision;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return QuerySerializationHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return QuerySerializationHook.QUERY_DATA_TYPE;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeInt(converter.getId());\n+        out.writeInt(precision);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        converter = Converters.getConverter(in.readInt());\n+        precision = in.readInt();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a96bbf03ef9119da2c28de1a62be71596b9c501", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6a96bbf03ef9119da2c28de1a62be71596b9c501", "committedDate": "2020-03-12T11:34:22Z", "message": "Fixed review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNDgxMzQ1", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-373481345", "createdAt": "2020-03-12T11:39:44Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTozOTo0NFrOF1bIOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTozOTo0NFrOF1bIOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzMyMw==", "bodyText": "If the javadoc is merely duplicating the field name, what is the purpose in having it?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391563323", "createdAt": "2020-03-12T11:39:44Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataType.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QuerySerializationHook;\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.BooleanConverter;\n+import com.hazelcast.sql.impl.type.converter.ByteConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.DoubleConverter;\n+import com.hazelcast.sql.impl.type.converter.FloatConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.IntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.LateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LongConverter;\n+import com.hazelcast.sql.impl.type.converter.ObjectConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.ShortConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Data type represents a type of concrete expression which is based on some basic data type.\n+ */\n+public class QueryDataType implements IdentifiedDataSerializable {\n+    public static final int PRECISION_BIT = 1;\n+    public static final int PRECISION_TINYINT = 4;\n+    public static final int PRECISION_SMALLINT = 7;\n+    public static final int PRECISION_INT = 11;\n+    public static final int PRECISION_BIGINT = 20;\n+    public static final int PRECISION_UNLIMITED = -1;\n+\n+    public static final QueryDataType LATE = new QueryDataType(LateConverter.INSTANCE);\n+\n+    public static final QueryDataType VARCHAR = new QueryDataType(StringConverter.INSTANCE);\n+    public static final QueryDataType VARCHAR_CHARACTER = new QueryDataType(CharacterConverter.INSTANCE);\n+\n+    public static final QueryDataType BIT = new QueryDataType(BooleanConverter.INSTANCE, PRECISION_BIT);\n+    public static final QueryDataType TINYINT = new QueryDataType(ByteConverter.INSTANCE, PRECISION_TINYINT);\n+    public static final QueryDataType SMALLINT = new QueryDataType(ShortConverter.INSTANCE, PRECISION_SMALLINT);\n+    public static final QueryDataType INT = new QueryDataType(IntegerConverter.INSTANCE, PRECISION_INT);\n+    public static final QueryDataType BIGINT = new QueryDataType(LongConverter.INSTANCE, PRECISION_BIGINT);\n+    public static final QueryDataType DECIMAL = new QueryDataType(BigDecimalConverter.INSTANCE);\n+    public static final QueryDataType DECIMAL_BIG_INTEGER = new QueryDataType(BigIntegerConverter.INSTANCE);\n+    public static final QueryDataType REAL = new QueryDataType(FloatConverter.INSTANCE);\n+    public static final QueryDataType DOUBLE = new QueryDataType(DoubleConverter.INSTANCE);\n+\n+    public static final QueryDataType TIME = new QueryDataType(LocalTimeConverter.INSTANCE);\n+    public static final QueryDataType DATE = new QueryDataType(LocalDateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP = new QueryDataType(LocalDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_DATE = new QueryDataType(DateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_CALENDAR = new QueryDataType(CalendarConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_INSTANT = new QueryDataType(InstantConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME = new QueryDataType(OffsetDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_ZONED_DATE_TIME = new QueryDataType(ZonedDateTimeConverter.INSTANCE);\n+\n+    public static final QueryDataType OBJECT = new QueryDataType(ObjectConverter.INSTANCE);\n+\n+    /** Converter. */\n+    private Converter converter;\n+\n+    /** Precision. */\n+    private int precision;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "committedDate": "2020-03-12T11:44:00Z", "message": "Removed useless JavaDocs."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTU1NDIz", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-373555423", "createdAt": "2020-03-12T13:30:54Z", "commit": {"oid": "b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzozMDo1NVrOF1eqHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzozMDo1NVrOF1eqHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyMTE0OA==", "bodyText": "Looks like we need some documentation here or/and in the design document: \"bigger\" and \"precedence is an integer number which defines context-dependent type resolution rules\" don't sound that self-explanatory.\nIsn't the meaning of \"precedence\"/\"bigger\" kind of inverted/confusing here? The type with the higher precedence value and higher precision is considered \"bigger\". Usually the lower precedence value means higher priority and when comparing things higher priority means bigger. Probably \"widest\" is a better name for this method. It's especially confusing seeing LATE (which is a special name for unknown/object, AFAIU) having the lowest precedence value among all types which implies it's the most specific/restrictive type, so every other type is bigger/wider than the unknown type.\nAnd also types having PRECISION_UNLIMITED are really confusing, PRECISION_UNLIMITED is actually the lowest precision possible according to bigger, probably a better name is something like PRECISION_NONE/UNSPECIFIED/UNAPPLICABLE.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391621148", "createdAt": "2020-03-12T13:30:55Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataTypeUtils.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+/**\n+ * Utility methods for SQL data types.\n+ */\n+public final class QueryDataTypeUtils {\n+    /** 12 (hdr) + 12 (fields) + 12 (arr) + 4 (arr len) + 16 (eight chars) */\n+    public static final int TYPE_LEN_VARCHAR = 12 + 4 + 8 + 12 + 4 + 16;\n+\n+    /** 12 (hdr) + 28 (fields + padding) + 12 (int hdr) + 28 (int fields) + (12 arr hdr) + 4 (arr len) + 8 (eight digits). */\n+    public static final int TYPE_LEN_DECIMAL = 12 + 28 + 12 + 28 + 12 + 4 + 8;\n+\n+    /** 12 (hdr) + 12 (fields + padding). */\n+    public static final int TYPE_LEN_TIME = 12 + 12;\n+\n+    /** 12 (hdr) + 12 (fields + padding). */\n+    public static final int TYPE_LEN_DATE = 12 + 12;\n+\n+    /** 12 (hdr) + 20 (fields + padding) + date + time. */\n+    public static final int TYPE_LEN_TIMESTAMP = 12 + 20 + TYPE_LEN_TIME + TYPE_LEN_DATE;\n+\n+    /** 12 (hdr) + 20 (fields + padding) + timestamp + 12 (offset hdr) + 12 (offset fields). */\n+    public static final int TYPE_LEN_TIMESTAMP_WITH_OFFSET = 12 + 20 + TYPE_LEN_TIMESTAMP + 12 + 12;\n+\n+    /** 12 (hdr) + 36 (arbitrary content). */\n+    public static final int TYPE_LEN_OBJECT = 12 + 36;\n+\n+    private static final QueryDataType[] INTEGER_TYPES = new QueryDataType[QueryDataType.PRECISION_BIGINT + 1];\n+\n+    static {\n+        for (int i = 1; i <= QueryDataType.PRECISION_BIGINT; i++) {\n+            QueryDataType type;\n+\n+            if (i == QueryDataType.PRECISION_BIT) {\n+                type = QueryDataType.BIT;\n+            } else if (i < QueryDataType.PRECISION_TINYINT) {\n+                type = new QueryDataType(QueryDataType.TINYINT.getConverter(), i);\n+            } else if (i == QueryDataType.PRECISION_TINYINT) {\n+                type = QueryDataType.TINYINT;\n+            } else if (i < QueryDataType.PRECISION_SMALLINT) {\n+                type = new QueryDataType(QueryDataType.SMALLINT.getConverter(), i);\n+            } else if (i == QueryDataType.PRECISION_SMALLINT) {\n+                type = QueryDataType.SMALLINT;\n+            } else if (i < QueryDataType.PRECISION_INT) {\n+                type = new QueryDataType(QueryDataType.INT.getConverter(), i);\n+            } else if (i == QueryDataType.PRECISION_INT) {\n+                type = QueryDataType.INT;\n+            } else if (i < QueryDataType.PRECISION_BIGINT) {\n+                type = new QueryDataType(QueryDataType.BIGINT.getConverter(), i);\n+            } else {\n+                type = QueryDataType.BIGINT;\n+            }\n+\n+            INTEGER_TYPES[i] = type;\n+        }\n+    }\n+\n+    private QueryDataTypeUtils() {\n+        // No-op.\n+    }\n+\n+    public static QueryDataType resolveType(Object obj) {\n+        if (obj == null) {\n+            return QueryDataType.LATE;\n+        }\n+\n+        Class<?> clazz = obj.getClass();\n+\n+        return resolveTypeForClass(clazz);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\", \"checkstyle:MethodLength\"})\n+    public static QueryDataType resolveTypeForClass(Class<?> clazz) {\n+        Converter converter = Converters.getConverter(clazz);\n+\n+        QueryDataTypeFamily typeFamily = converter.getTypeFamily();\n+\n+        switch (typeFamily) {\n+            case VARCHAR:\n+                if (converter == StringConverter.INSTANCE) {\n+                    return QueryDataType.VARCHAR;\n+                } else {\n+                    assert converter == CharacterConverter.INSTANCE;\n+\n+                    return QueryDataType.VARCHAR_CHARACTER;\n+                }\n+\n+            case BIT:\n+                return QueryDataType.BIT;\n+\n+            case TINYINT:\n+                return QueryDataType.TINYINT;\n+\n+            case SMALLINT:\n+                return QueryDataType.SMALLINT;\n+\n+            case INT:\n+                return QueryDataType.INT;\n+\n+            case BIGINT:\n+                return QueryDataType.BIGINT;\n+\n+            case DECIMAL:\n+                if (converter == BigDecimalConverter.INSTANCE) {\n+                    return QueryDataType.DECIMAL;\n+                } else {\n+                    assert converter == BigIntegerConverter.INSTANCE;\n+\n+                    return QueryDataType.DECIMAL_BIG_INTEGER;\n+                }\n+\n+            case REAL:\n+                return QueryDataType.REAL;\n+\n+            case DOUBLE:\n+                return QueryDataType.DOUBLE;\n+\n+            case DATE:\n+                return QueryDataType.DATE;\n+\n+            case TIME:\n+                return QueryDataType.TIME;\n+\n+            case TIMESTAMP:\n+                return QueryDataType.TIMESTAMP;\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                if (converter == DateConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_DATE;\n+                } else if (converter == CalendarConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_CALENDAR;\n+                } else if (converter == InstantConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_INSTANT;\n+                } else if (converter == OffsetDateTimeConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME;\n+                } else {\n+                    assert converter == ZonedDateTimeConverter.INSTANCE;\n+\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_ZONED_DATE_TIME;\n+                }\n+\n+            case OBJECT:\n+                return QueryDataType.OBJECT;\n+\n+            default:\n+                assert typeFamily == QueryDataTypeFamily.LATE;\n+\n+                throw new IllegalArgumentException(\"Unexpected class: \" + clazz);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\", \"checkstyle:MethodLength\"})\n+    public static QueryDataType resolveTypeForTypeFamily(QueryDataTypeFamily typeFamily) {\n+        switch (typeFamily) {\n+            case VARCHAR:\n+                return QueryDataType.VARCHAR;\n+\n+            case BIT:\n+                return QueryDataType.BIT;\n+\n+            case TINYINT:\n+                return QueryDataType.TINYINT;\n+\n+            case SMALLINT:\n+                return QueryDataType.SMALLINT;\n+\n+            case INT:\n+                return QueryDataType.INT;\n+\n+            case BIGINT:\n+                return QueryDataType.BIGINT;\n+\n+            case DECIMAL:\n+                return QueryDataType.DECIMAL;\n+\n+            case REAL:\n+                return QueryDataType.REAL;\n+\n+            case DOUBLE:\n+                return QueryDataType.DOUBLE;\n+\n+            case DATE:\n+                return QueryDataType.DATE;\n+\n+            case TIME:\n+                return QueryDataType.TIME;\n+\n+            case TIMESTAMP:\n+                return QueryDataType.TIMESTAMP;\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                return QueryDataType.TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME;\n+\n+            case OBJECT:\n+                return QueryDataType.OBJECT;\n+\n+            default:\n+                assert typeFamily == QueryDataTypeFamily.LATE;\n+\n+                throw new IllegalArgumentException(\"Unexpected type family: \" + typeFamily);\n+        }\n+    }\n+\n+    /**\n+     * Get integer type for the given precision.\n+     *\n+     * @param precision Precision.\n+     * @return Type.\n+     */\n+    public static QueryDataType integerType(int precision) {\n+        if (precision == 0) {\n+            throw new IllegalArgumentException(\"Precision cannot be zero.\");\n+        }\n+\n+        if (precision == QueryDataType.PRECISION_UNLIMITED) {\n+            return QueryDataType.DECIMAL;\n+        } else if (precision <= QueryDataType.PRECISION_BIGINT) {\n+            return INTEGER_TYPES[precision];\n+        } else {\n+            return QueryDataType.DECIMAL;\n+        }\n+    }\n+\n+    public static QueryDataType bigger(QueryDataType first, QueryDataType second) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce"}, "originalPosition": 252}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af90816527413e2d6663ceba6b5687708459c7cf", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/af90816527413e2d6663ceba6b5687708459c7cf", "committedDate": "2020-03-12T14:32:36Z", "message": "Clarification on precedence."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MTc3Mzg2", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374177386", "createdAt": "2020-03-13T10:03:54Z", "commit": {"oid": "af90816527413e2d6663ceba6b5687708459c7cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDowMzo1NFrOF196aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDowMzo1NFrOF196aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzMzIyNw==", "bodyText": "checkPrecedence?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392133227", "createdAt": "2020-03-13T10:03:54Z", "author": {"login": "taburet"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/QueryDataTypeTest.java", "diffHunk": "@@ -239,10 +239,10 @@ private void checkResolvedTypeForTypeFamily(QueryDataType expectedType, QueryDat\n     }\n \n     private void checkBigger(QueryDataType bigger, QueryDataType smaller) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af90816527413e2d6663ceba6b5687708459c7cf"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjEyMDI4", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374212028", "createdAt": "2020-03-13T10:59:47Z", "commit": {"oid": "af90816527413e2d6663ceba6b5687708459c7cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDo1OTo0N1rOF1_kxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDo1OTo0N1rOF1_kxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MDQ1NQ==", "bodyText": "... for {@link Object} type.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392160455", "createdAt": "2020-03-13T10:59:47Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/ObjectConverter.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link Integer} type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af90816527413e2d6663ceba6b5687708459c7cf"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52853076caf0544f7f19bb0ee38902af052a8255", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/52853076caf0544f7f19bb0ee38902af052a8255", "committedDate": "2020-03-13T11:41:22Z", "message": "Fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjgxNjkx", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374281691", "createdAt": "2020-03-13T13:04:27Z", "commit": {"oid": "52853076caf0544f7f19bb0ee38902af052a8255"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzowNDoyOFrOF2C1_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzowNDoyOFrOF2C1_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIxNDAxNA==", "bodyText": "Looks like it might be null as well.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392214014", "createdAt": "2020-03-13T13:04:28Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/BooleanConverter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link java.lang.Boolean} type.\n+ */\n+public final class BooleanConverter extends Converter {\n+\n+    public static final BooleanConverter INSTANCE = new BooleanConverter();\n+\n+    protected static final String TRUE = \"true\";\n+    protected static final String FALSE = \"false\";\n+\n+    private BooleanConverter() {\n+        super(ID_BOOLEAN, QueryDataTypeFamily.BIT);\n+    }\n+\n+    @Override\n+    public Class<?> getValueClass() {\n+        return Boolean.class;\n+    }\n+\n+    @Override\n+    public boolean asBit(Object val) {\n+        return ((Boolean) val);\n+    }\n+\n+    @Override\n+    public String asVarchar(Object val) {\n+        boolean val0 = (Boolean) val;\n+\n+        return val0 ? TRUE : FALSE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52853076caf0544f7f19bb0ee38902af052a8255"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzI5OTc2", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374329976", "createdAt": "2020-03-13T14:10:53Z", "commit": {"oid": "52853076caf0544f7f19bb0ee38902af052a8255"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDoxMDo1M1rOF2FHQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDoxMDo1M1rOF2FHQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1MTIwMw==", "bodyText": "The design document specifies that BIT should be convertible to VARCHAR, BIT, TINYINT, SMALLINT, INT, BINGINT, DECIMAL, REAL  and DOUBLE. But the converter supports only conversions to VARCHAR and BIT. Could you please check other converters as well.\nAlso, it's not clear how converters in general distinguish between implicit and explicit conversion: AFAIU, currently if a converter supports some kind of a conversion it would be applied no matter is it implicit or explicit. For instance, ... WHERE LENGTH(intColumn) = 1 is considered valid in the current code base while the design document treats INT to VARCHAR conversion as explicit. Looks like we need to convey that implicit-explicit information somehow from the converters or by some other means. Another set of methods? Like canConvertImplicitly/Explicitly and probably implicit/explicitAs*.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392251203", "createdAt": "2020-03-13T14:10:53Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/BooleanConverter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link java.lang.Boolean} type.\n+ */\n+public final class BooleanConverter extends Converter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52853076caf0544f7f19bb0ee38902af052a8255"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b7f32db0896793357a09edc4d882005a69ae530", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2b7f32db0896793357a09edc4d882005a69ae530", "committedDate": "2020-03-13T17:29:02Z", "message": "Fixed type compatibility matrix for BIT."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8dbfa537ad955200f980c576ccf9945913006c2c", "committedDate": "2020-03-16T06:27:50Z", "message": "Merge branch 'master' into issues/15241"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0OTgwNjI1", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374980625", "createdAt": "2020-03-16T07:57:38Z", "commit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzo1NzozOFrOF2o75A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzo1NzozOFrOF2o75A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzODExNg==", "bodyText": "short", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392838116", "createdAt": "2020-03-16T07:57:38Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/ShortConverter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Converter for {@link java.lang.Float} type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0OTgwODc2", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374980876", "createdAt": "2020-03-16T07:58:07Z", "commit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzo1ODowOFrOF2o8rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzo1ODowOFrOF2o8rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzODMxNw==", "bodyText": "It's not necessarily a literal.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392838317", "createdAt": "2020-03-16T07:58:08Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractStringConverter.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeParseException;\n+\n+/**\n+ * Common converter for string-based classes.\n+ */\n+public abstract class AbstractStringConverter extends Converter {\n+    protected AbstractStringConverter(int id) {\n+        super(id, QueryDataTypeFamily.VARCHAR);\n+    }\n+\n+    @Override\n+    public final boolean asBit(Object val) {\n+        String val0 = cast(val);\n+\n+        if (val0.equalsIgnoreCase(BooleanConverter.TRUE)) {\n+            return true;\n+        } else if (val0.equalsIgnoreCase(BooleanConverter.FALSE)) {\n+            return false;\n+        }\n+\n+        throw HazelcastSqlException.error(SqlErrorCode.DATA_EXCEPTION, \"String literal cannot be converter to BIT: \" + val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0OTg2NjY1", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-374986665", "createdAt": "2020-03-16T08:09:29Z", "commit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODowOToyOVrOF2pOiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODowOToyOVrOF2pOiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0Mjg4OQ==", "bodyText": "Why some converters are trying to convert the passed value to their own type while others are not doing that? For instance, IntegerConverter and many others are not trying to convert.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392842889", "createdAt": "2020-03-16T08:09:29Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractDecimalConverter.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+public abstract class AbstractDecimalConverter extends Converter {\n+    protected AbstractDecimalConverter(int id) {\n+        super(id, QueryDataTypeFamily.DECIMAL);\n+    }\n+\n+    @Override\n+    public final Object asObject(Object val) {\n+        return asDecimal(val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdf9f084335595402a030e0a8e243f1cc4773a0d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cdf9f084335595402a030e0a8e243f1cc4773a0d", "committedDate": "2020-03-16T08:51:00Z", "message": "Fix review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MDA0Njcx", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-375004671", "createdAt": "2020-03-16T08:40:45Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo0MDo0NVrOF2qHKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMDo1ODoxMlrOF2u9AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NzM4Ng==", "bodyText": "\"are listed\" ?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392857386", "createdAt": "2020-03-16T08:40:45Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/sql/01-type-system.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# SQL Type System\n+\n+## Overview\n+Hazelcast SQL type system defines how objects of different types interact with each other. Type system\n+is defined by the list of supported types, type mapping and type conversion rules.\n+\n+Type is described by name, precedence, precision and scale.\n+- Name is textual representation of type name\n+- Precedence is an integer number which defines context-dependent type resolution rules for expressions\n+- Precision is the total count of significant digits in the whole number, applicable to **numeric types**\n+\n+Type family is a collection of types with the same name, but different precisions. All types\n+within a family have the same name and precedence. For example, `INT(11)` and `INT(12)` are two types\n+from the same `INT` family.\n+\n+Scale is not used in Hazelcast SQL. It is applicable only for DECIMAL, REAL and DOUBLE types, and instead\n+of defining it as a separate value, we just treat these types as types with infinite scale.\n+\n+## Supported types\n+Types supported by the Hazelcast SQL engine is listed in the Table 1. Precision is the smallest precision in the type family.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MzU0MQ==", "bodyText": "Should it be final?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392883541", "createdAt": "2020-03-16T09:30:37Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/HazelcastSqlException.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.core.HazelcastException;\n+\n+/**\n+ * Exception occurred during SQL query execution.\n+ */\n+public final class HazelcastSqlException extends HazelcastException {\n+    /** Code of the exception. */\n+    private int code;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MzkyMg==", "bodyText": "type: and-> an ?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392883922", "createdAt": "2020-03-16T09:31:19Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/HazelcastSqlException.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.core.HazelcastException;\n+\n+/**\n+ * Exception occurred during SQL query execution.\n+ */\n+public final class HazelcastSqlException extends HazelcastException {\n+    /** Code of the exception. */\n+    private int code;\n+\n+    private HazelcastSqlException(int code, String message, Throwable cause) {\n+        super(message, cause);\n+\n+        this.code = code;\n+    }\n+\n+    /**\n+     * Constructs a generic error.\n+     *\n+     * @param message Error message.\n+     * @return Exception object.\n+     */\n+    public static HazelcastSqlException error(String message) {\n+        return error(message, null);\n+    }\n+\n+    /**\n+     * Constructs a generic error with the cause.\n+     *\n+     * @param message Error message.\n+     * @return Exception object.\n+     */\n+    public static HazelcastSqlException error(String message, Throwable cause) {\n+        return error(SqlErrorCode.GENERIC, message, cause);\n+    }\n+\n+    /**\n+     * Constructs an error with specific code.\n+     *\n+     * @param code Error code.\n+     * @param message Error message.\n+     * @return Exception object.\n+     */\n+    public static HazelcastSqlException error(int code, String message) {\n+        return error(code, message, null);\n+    }\n+\n+    /**\n+     * Constructs and error with specific code and cause.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4NTM4Mg==", "bodyText": "Why not to use enum?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392885382", "createdAt": "2020-03-16T09:33:58Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlErrorCode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+/**\n+ * Error codes used in Hazelcast SQL.\n+ */\n+public final class SqlErrorCode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5MjI2Mw==", "bodyText": "Minor: in the comment we say 12 (fields) which consists of 4 + 8 in the code. Should we document this further?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392892263", "createdAt": "2020-03-16T09:45:53Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataTypeUtils.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+/**\n+ * Utility methods for SQL data types.\n+ */\n+public final class QueryDataTypeUtils {\n+    /** 12 (hdr) + 12 (fields) + 12 (arr) + 4 (arr len) + 16 (eight chars) */\n+    public static final int TYPE_LEN_VARCHAR = 12 + 4 + 8 + 12 + 4 + 16;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyODcxOQ==", "bodyText": "Shall we add assert val0 != null as in the CharacterConverter?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392928719", "createdAt": "2020-03-16T10:43:41Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/BooleanConverter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link java.lang.Boolean} type.\n+ */\n+public final class BooleanConverter extends Converter {\n+    /** Singleton instance. */\n+    public static final BooleanConverter INSTANCE = new BooleanConverter();\n+\n+    protected static final String TRUE = \"true\";\n+    protected static final String FALSE = \"false\";\n+\n+    private BooleanConverter() {\n+        super(ID_BOOLEAN, QueryDataTypeFamily.BIT);\n+    }\n+\n+    @Override\n+    public Class<?> getValueClass() {\n+        return Boolean.class;\n+    }\n+\n+    @Override\n+    public boolean asBit(Object val) {\n+        return ((Boolean) val);\n+    }\n+\n+    @Override\n+    public String asVarchar(Object val) {\n+        boolean val0 = (Boolean) val;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNDA4NA==", "bodyText": "Shall we add id and typeFamily here?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392934084", "createdAt": "2020-03-16T10:53:10Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+\n+/**\n+ * Interface to convert an item from one type to another.\n+ */\n+@SuppressWarnings(\"checkstyle:MethodCount\")\n+public abstract class Converter {\n+    protected static final int ID_LATE = 0;\n+    protected static final int ID_BOOLEAN = 1;\n+    protected static final int ID_BYTE = 2;\n+    protected static final int ID_SHORT = 3;\n+    protected static final int ID_INTEGER = 4;\n+    protected static final int ID_LONG = 5;\n+    protected static final int ID_BIG_INTEGER = 6;\n+    protected static final int ID_BIG_DECIMAL = 7;\n+    protected static final int ID_FLOAT = 8;\n+    protected static final int ID_DOUBLE = 9;\n+    protected static final int ID_CHARACTER = 10;\n+    protected static final int ID_STRING = 11;\n+    protected static final int ID_DATE = 12;\n+    protected static final int ID_CALENDAR = 13;\n+    protected static final int ID_LOCAL_DATE = 14;\n+    protected static final int ID_LOCAL_TIME = 15;\n+    protected static final int ID_LOCAL_DATE_TIME = 16;\n+    protected static final int ID_INSTANT = 17;\n+    protected static final int ID_OFFSET_DATE_TIME = 18;\n+    protected static final int ID_ZONED_DATE_TIME = 19;\n+    protected static final int ID_OBJECT = 20;\n+\n+    private final int id;\n+    private final QueryDataTypeFamily typeFamily;\n+\n+    private final boolean convertToBit;\n+    private final boolean convertToTinyint;\n+    private final boolean convertToSmallint;\n+    private final boolean convertToInt;\n+    private final boolean convertToBigint;\n+    private final boolean convertToDecimal;\n+    private final boolean convertToReal;\n+    private final boolean convertToDouble;\n+    private final boolean convertToVarchar;\n+    private final boolean convertToDate;\n+    private final boolean convertToTime;\n+    private final boolean convertToTimestamp;\n+    private final boolean convertToTimestampWithTimezone;\n+    private final boolean convertToObject;\n+\n+    protected Converter(int id, QueryDataTypeFamily typeFamily) {\n+        this.id = id;\n+        this.typeFamily = typeFamily;\n+\n+        try {\n+            Class<? extends Converter> clazz = getClass();\n+\n+            convertToBit = canConvert(clazz.getMethod(\"asBit\", Object.class));\n+            convertToTinyint = canConvert(clazz.getMethod(\"asTinyint\", Object.class));\n+            convertToSmallint = canConvert(clazz.getMethod(\"asSmallint\", Object.class));\n+            convertToInt = canConvert(clazz.getMethod(\"asInt\", Object.class));\n+            convertToBigint = canConvert(clazz.getMethod(\"asBigint\", Object.class));\n+            convertToDecimal = canConvert(clazz.getMethod(\"asDecimal\", Object.class));\n+            convertToReal = canConvert(clazz.getMethod(\"asReal\", Object.class));\n+            convertToDouble = canConvert(clazz.getMethod(\"asDouble\", Object.class));\n+            convertToVarchar = canConvert(clazz.getMethod(\"asVarchar\", Object.class));\n+            convertToDate = canConvert(clazz.getMethod(\"asDate\", Object.class));\n+            convertToTime = canConvert(clazz.getMethod(\"asTime\", Object.class));\n+            convertToTimestamp = canConvert(clazz.getMethod(\"asTimestamp\", Object.class));\n+            convertToTimestampWithTimezone = canConvert(clazz.getMethod(\"asTimestampWithTimezone\", Object.class));\n+            convertToObject = canConvert(clazz.getMethod(\"asObject\", Object.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new HazelcastException(\"Failed to initialize converter: \" + getClass().getName(), e);\n+        }\n+    }\n+\n+    public final int getId() {\n+        return id;\n+    }\n+\n+    public final QueryDataTypeFamily getTypeFamily() {\n+        return typeFamily;\n+    }\n+\n+    public abstract Class<?> getValueClass();\n+\n+    @NotConvertible\n+    public boolean asBit(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.BIT);\n+    }\n+\n+    @NotConvertible\n+    public byte asTinyint(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TINYINT);\n+    }\n+\n+    @NotConvertible\n+    public short asSmallint(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.SMALLINT);\n+    }\n+\n+    @NotConvertible\n+    public int asInt(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.INT);\n+    }\n+\n+    @NotConvertible\n+    public long asBigint(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.BIGINT);\n+    }\n+\n+    @NotConvertible\n+    public BigDecimal asDecimal(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.DECIMAL);\n+    }\n+\n+    @NotConvertible\n+    public float asReal(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.REAL);\n+    }\n+\n+    @NotConvertible\n+    public double asDouble(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.DOUBLE);\n+    }\n+\n+    @NotConvertible\n+    public String asVarchar(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.VARCHAR);\n+    }\n+\n+    @NotConvertible\n+    public LocalDate asDate(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.DATE);\n+    }\n+\n+    @NotConvertible\n+    public LocalTime asTime(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TIME);\n+    }\n+\n+    @NotConvertible\n+    public LocalDateTime asTimestamp(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TIMESTAMP);\n+    }\n+\n+    @NotConvertible\n+    public OffsetDateTime asTimestampWithTimezone(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TIMESTAMP_WITH_TIMEZONE);\n+    }\n+\n+    public Object asObject(Object val) {\n+        return val;\n+    }\n+\n+    public final boolean canConvertToBit() {\n+        return convertToBit;\n+    }\n+\n+    public final boolean canConvertToTinyint() {\n+        return convertToTinyint;\n+    }\n+\n+    public final boolean canConvertToSmallint() {\n+        return convertToSmallint;\n+    }\n+\n+    public final boolean canConvertToInt() {\n+        return convertToInt;\n+    }\n+\n+    public final boolean canConvertToBigint() {\n+        return convertToBigint;\n+    }\n+\n+    public final boolean canConvertToDecimal() {\n+        return convertToDecimal;\n+    }\n+\n+    public final boolean canConvertToReal() {\n+        return convertToReal;\n+    }\n+\n+    public final boolean canConvertToDouble() {\n+        return convertToDouble;\n+    }\n+\n+    public final boolean canConvertToVarchar() {\n+        return convertToVarchar;\n+    }\n+\n+    public final boolean canConvertToDate() {\n+        return convertToDate;\n+    }\n+\n+    public final boolean canConvertToTime() {\n+        return convertToTime;\n+    }\n+\n+    public final boolean canConvertToTimestamp() {\n+        return convertToTimestamp;\n+    }\n+\n+    public final boolean canConvertToTimestampWithTimezone() {\n+        return convertToTimestampWithTimezone;\n+    }\n+\n+    public final boolean canConvertToObject() {\n+        return convertToObject;\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\"})\n+    public final boolean canConvertTo(QueryDataTypeFamily typeFamily) {\n+        switch (typeFamily) {\n+            case BIT:\n+                return canConvertToBit();\n+\n+            case TINYINT:\n+                return canConvertToTinyint();\n+\n+            case SMALLINT:\n+                return canConvertToSmallint();\n+\n+            case INT:\n+                return canConvertToInt();\n+\n+            case BIGINT:\n+                return canConvertToBigint();\n+\n+            case DECIMAL:\n+                return canConvertToDecimal();\n+\n+            case REAL:\n+                return canConvertToReal();\n+\n+            case DOUBLE:\n+                return canConvertToDouble();\n+\n+            case VARCHAR:\n+                return canConvertToVarchar();\n+\n+            case DATE:\n+                return canConvertToDate();\n+\n+            case TIME:\n+                return canConvertToTime();\n+\n+            case TIMESTAMP:\n+                return canConvertToTimestamp();\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                return canConvertToTimestampWithTimezone();\n+\n+            case OBJECT:\n+                return canConvertToObject();\n+\n+            default:\n+                return getTypeFamily() == typeFamily;\n+        }\n+    }\n+\n+    public abstract Object convertToSelf(Converter converter, Object val);\n+\n+    protected final HazelcastSqlException cannotConvert(QueryDataTypeFamily target) {\n+        return cannotConvert(target, null);\n+    }\n+\n+    protected final HazelcastSqlException cannotConvert(QueryDataTypeFamily target, Object val) {\n+        return cannotConvert(typeFamily, target, val);\n+    }\n+\n+    protected final HazelcastSqlException cannotConvert(QueryDataTypeFamily source, QueryDataTypeFamily target, Object val) {\n+        String message = \"Cannot convert \" + source + \" to \" + target;\n+\n+        if (val != null) {\n+            message += \": \" + val;\n+        }\n+\n+        return HazelcastSqlException.error(SqlErrorCode.DATA_EXCEPTION, message);\n+    }\n+\n+    private static boolean canConvert(Method method) {\n+        return method.getAnnotation(NotConvertible.class) == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNTk3Mw==", "bodyText": "Initialize res with the size of converters?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392935973", "createdAt": "2020-03-16T10:56:46Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converters.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.sql.HazelcastSqlException;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * Utility methods for converters.\n+ */\n+@SuppressWarnings(\"checkstyle:ExecutableStatementCount\")\n+public final class Converters {\n+    /** Synthetic maximum number of converters to prevent an accidental bug which will generate too big array. */\n+    private static final int MAX_CONVERTER_COUNT = 100;\n+\n+    private static final Converter[] CONVERTERS;\n+    private static final Map<Class<?>, Converter> CLASS_TO_CONVERTER;\n+\n+    static {\n+        List<Converter> converters = getConverters();\n+\n+        CONVERTERS = createConvertersArray(converters);\n+        CLASS_TO_CONVERTER = createConvertersMap(converters);\n+    }\n+\n+    private Converters() {\n+        // No-op.\n+    }\n+\n+    public static Converter getConverter(int converterId) {\n+        if (converterId < CONVERTERS.length) {\n+            return CONVERTERS[converterId];\n+        }\n+\n+        throw HazelcastSqlException.error(\"Converter with ID \" + converterId + \" doesn't exist\");\n+    }\n+\n+    /**\n+     * Get converter for the given class.\n+     *\n+     * @param clazz Class.\n+     * @return Converter or exception if no matching converters found.\n+     */\n+    public static Converter getConverter(Class<?> clazz) {\n+        Converter res = CLASS_TO_CONVERTER.get(clazz);\n+\n+        if (res == null) {\n+            if (Calendar.class.isAssignableFrom(clazz)) {\n+                res = CalendarConverter.INSTANCE;\n+            } else {\n+                res = ObjectConverter.INSTANCE;\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * @return List of all supported converters.\n+     */\n+    private static List<Converter> getConverters() {\n+        List<Converter> converters = new ArrayList<>();\n+\n+        // Late binding support.\n+        converters.add(LateConverter.INSTANCE);\n+\n+        // Boolean converter.\n+        converters.add(BooleanConverter.INSTANCE);\n+\n+        // Converters for exact numeric types.\n+        converters.add(ByteConverter.INSTANCE);\n+        converters.add(ShortConverter.INSTANCE);\n+        converters.add(IntegerConverter.INSTANCE);\n+        converters.add(LongConverter.INSTANCE);\n+        converters.add(BigIntegerConverter.INSTANCE);\n+        converters.add(BigDecimalConverter.INSTANCE);\n+\n+        // Converters for inexact numeric types.\n+        converters.add(FloatConverter.INSTANCE);\n+        converters.add(DoubleConverter.INSTANCE);\n+\n+        // String converters.\n+        converters.add(CharacterConverter.INSTANCE);\n+        converters.add(StringConverter.INSTANCE);\n+\n+        // Converters for temporal data types.\n+        converters.add(DateConverter.INSTANCE);\n+        converters.add(CalendarConverter.INSTANCE);\n+\n+        converters.add(LocalDateConverter.INSTANCE);\n+        converters.add(LocalTimeConverter.INSTANCE);\n+        converters.add(LocalDateTimeConverter.INSTANCE);\n+        converters.add(InstantConverter.INSTANCE);\n+        converters.add(OffsetDateTimeConverter.INSTANCE);\n+        converters.add(ZonedDateTimeConverter.INSTANCE);\n+\n+        // Object converter.\n+        converters.add(ObjectConverter.INSTANCE);\n+\n+        return converters;\n+    }\n+\n+    private static Map<Class<?>, Converter> createConvertersMap(List<Converter> converters) {\n+        Map<Class<?>, Converter> res = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjcwNA==", "bodyText": "The same here.", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392936704", "createdAt": "2020-03-16T10:58:12Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converters.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.sql.HazelcastSqlException;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * Utility methods for converters.\n+ */\n+@SuppressWarnings(\"checkstyle:ExecutableStatementCount\")\n+public final class Converters {\n+    /** Synthetic maximum number of converters to prevent an accidental bug which will generate too big array. */\n+    private static final int MAX_CONVERTER_COUNT = 100;\n+\n+    private static final Converter[] CONVERTERS;\n+    private static final Map<Class<?>, Converter> CLASS_TO_CONVERTER;\n+\n+    static {\n+        List<Converter> converters = getConverters();\n+\n+        CONVERTERS = createConvertersArray(converters);\n+        CLASS_TO_CONVERTER = createConvertersMap(converters);\n+    }\n+\n+    private Converters() {\n+        // No-op.\n+    }\n+\n+    public static Converter getConverter(int converterId) {\n+        if (converterId < CONVERTERS.length) {\n+            return CONVERTERS[converterId];\n+        }\n+\n+        throw HazelcastSqlException.error(\"Converter with ID \" + converterId + \" doesn't exist\");\n+    }\n+\n+    /**\n+     * Get converter for the given class.\n+     *\n+     * @param clazz Class.\n+     * @return Converter or exception if no matching converters found.\n+     */\n+    public static Converter getConverter(Class<?> clazz) {\n+        Converter res = CLASS_TO_CONVERTER.get(clazz);\n+\n+        if (res == null) {\n+            if (Calendar.class.isAssignableFrom(clazz)) {\n+                res = CalendarConverter.INSTANCE;\n+            } else {\n+                res = ObjectConverter.INSTANCE;\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * @return List of all supported converters.\n+     */\n+    private static List<Converter> getConverters() {\n+        List<Converter> converters = new ArrayList<>();\n+\n+        // Late binding support.\n+        converters.add(LateConverter.INSTANCE);\n+\n+        // Boolean converter.\n+        converters.add(BooleanConverter.INSTANCE);\n+\n+        // Converters for exact numeric types.\n+        converters.add(ByteConverter.INSTANCE);\n+        converters.add(ShortConverter.INSTANCE);\n+        converters.add(IntegerConverter.INSTANCE);\n+        converters.add(LongConverter.INSTANCE);\n+        converters.add(BigIntegerConverter.INSTANCE);\n+        converters.add(BigDecimalConverter.INSTANCE);\n+\n+        // Converters for inexact numeric types.\n+        converters.add(FloatConverter.INSTANCE);\n+        converters.add(DoubleConverter.INSTANCE);\n+\n+        // String converters.\n+        converters.add(CharacterConverter.INSTANCE);\n+        converters.add(StringConverter.INSTANCE);\n+\n+        // Converters for temporal data types.\n+        converters.add(DateConverter.INSTANCE);\n+        converters.add(CalendarConverter.INSTANCE);\n+\n+        converters.add(LocalDateConverter.INSTANCE);\n+        converters.add(LocalTimeConverter.INSTANCE);\n+        converters.add(LocalDateTimeConverter.INSTANCE);\n+        converters.add(InstantConverter.INSTANCE);\n+        converters.add(OffsetDateTimeConverter.INSTANCE);\n+        converters.add(ZonedDateTimeConverter.INSTANCE);\n+\n+        // Object converter.\n+        converters.add(ObjectConverter.INSTANCE);\n+\n+        return converters;\n+    }\n+\n+    private static Map<Class<?>, Converter> createConvertersMap(List<Converter> converters) {\n+        Map<Class<?>, Converter> res = new HashMap<>();\n+\n+        for (Converter converter : converters) {\n+            Class<?> valueClass = converter.getValueClass();\n+\n+            if (valueClass != null) {\n+                Converter prevConverter = res.put(valueClass, converter);\n+\n+                if (prevConverter != null) {\n+                    throw new HazelcastException(\"Duplicate converter for class [class=\" + valueClass\n+                         + \", converter1=\" + prevConverter.getValueClass().getName()\n+                         + \", converter2=\" + valueClass.getName()\n+                         + ']');\n+                }\n+\n+                Class<?> primitiveValueClass = getPrimitiveClass(valueClass);\n+\n+                if (primitiveValueClass != null) {\n+                    res.put(primitiveValueClass, converter);\n+                }\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    private static Converter[] createConvertersArray(List<Converter> converters) {\n+        TreeMap<Integer, Converter> map = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MTc5MTE4", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-375179118", "createdAt": "2020-03-16T12:44:26Z", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjo0NDoyNlrOF2ykug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjo0NDoyNlrOF2ykug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NjAyNg==", "bodyText": "Minor: make it final?", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392996026", "createdAt": "2020-03-16T12:44:26Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java", "diffHunk": "@@ -0,0 +1,1074 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.BIT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.DATE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.DECIMAL;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.DOUBLE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.INT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.LATE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.OBJECT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.REAL;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.SMALLINT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TIME;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TIMESTAMP;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TIMESTAMP_WITH_TIMEZONE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TINYINT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.VARCHAR;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.values;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings(\"SimplifiableJUnitAssertion\")\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ConvertersTest {\n+    @Test\n+    public void testGetById() {\n+        checkGetById(LateConverter.INSTANCE);\n+\n+        checkGetById(StringConverter.INSTANCE);\n+        checkGetById(CharacterConverter.INSTANCE);\n+\n+        checkGetById(BooleanConverter.INSTANCE);\n+        checkGetById(ByteConverter.INSTANCE);\n+        checkGetById(ShortConverter.INSTANCE);\n+        checkGetById(IntegerConverter.INSTANCE);\n+        checkGetById(LongConverter.INSTANCE);\n+        checkGetById(BigDecimalConverter.INSTANCE);\n+        checkGetById(BigIntegerConverter.INSTANCE);\n+        checkGetById(FloatConverter.INSTANCE);\n+        checkGetById(DoubleConverter.INSTANCE);\n+\n+        checkGetById(LocalTimeConverter.INSTANCE);\n+        checkGetById(LocalDateConverter.INSTANCE);\n+        checkGetById(LocalDateTimeConverter.INSTANCE);\n+        checkGetById(DateConverter.INSTANCE);\n+        checkGetById(CalendarConverter.INSTANCE);\n+        checkGetById(InstantConverter.INSTANCE);\n+        checkGetById(OffsetDateTimeConverter.INSTANCE);\n+        checkGetById(ZonedDateTimeConverter.INSTANCE);\n+\n+        checkGetById(ObjectConverter.INSTANCE);\n+    }\n+\n+    @Test\n+    public void testGetByClass() {\n+        checkGetByClass(StringConverter.INSTANCE, String.class);\n+        checkGetByClass(CharacterConverter.INSTANCE, char.class, Character.class);\n+\n+        checkGetByClass(BooleanConverter.INSTANCE, boolean.class, Boolean.class);\n+        checkGetByClass(ByteConverter.INSTANCE, byte.class, Byte.class);\n+        checkGetByClass(ShortConverter.INSTANCE, short.class, Short.class);\n+        checkGetByClass(IntegerConverter.INSTANCE, int.class, Integer.class);\n+        checkGetByClass(LongConverter.INSTANCE, long.class, Long.class);\n+        checkGetByClass(BigDecimalConverter.INSTANCE, BigDecimal.class);\n+        checkGetByClass(BigIntegerConverter.INSTANCE, BigInteger.class);\n+        checkGetByClass(FloatConverter.INSTANCE, float.class, Float.class);\n+        checkGetByClass(DoubleConverter.INSTANCE, double.class, Double.class);\n+\n+        checkGetByClass(LocalTimeConverter.INSTANCE, LocalTime.class);\n+        checkGetByClass(LocalDateConverter.INSTANCE, LocalDate.class);\n+        checkGetByClass(LocalDateTimeConverter.INSTANCE, LocalDateTime.class);\n+        checkGetByClass(DateConverter.INSTANCE, Date.class);\n+        checkGetByClass(CalendarConverter.INSTANCE, Calendar.class, GregorianCalendar.class);\n+        checkGetByClass(InstantConverter.INSTANCE, Instant.class);\n+        checkGetByClass(OffsetDateTimeConverter.INSTANCE, OffsetDateTime.class);\n+        checkGetByClass(ZonedDateTimeConverter.INSTANCE, ZonedDateTime.class);\n+\n+        checkGetByClass(ObjectConverter.INSTANCE, Object.class, CustomClass.class);\n+    }\n+\n+    @Test\n+    public void testBooleanConverter() {\n+        BooleanConverter converter = BooleanConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BOOLEAN, BIT, Boolean.class);\n+        checkConverterConversions(converter, VARCHAR, OBJECT);\n+\n+        assertEquals(\"true\", converter.asVarchar(true));\n+        assertEquals(\"false\", converter.asVarchar(false));\n+\n+        assertEquals(true, converter.asObject(true));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testByteConverter() {\n+        ByteConverter converter = ByteConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BYTE, TINYINT, Byte.class);\n+        checkConverterConversions(converter, VARCHAR, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar((byte) 1));\n+\n+        assertEquals(1, converter.asTinyint((byte) 1));\n+        assertEquals(1, converter.asSmallint((byte) 1));\n+        assertEquals(1, converter.asInt((byte) 1));\n+        assertEquals(1L, converter.asBigint((byte) 1));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal((byte) 1));\n+\n+        assertEquals(1.0f, converter.asReal((byte) 1), 0);\n+        assertEquals(1.0d, converter.asDouble((byte) 1), 0);\n+\n+        assertEquals((byte) 1, converter.asObject((byte) 1));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testShortConverter() {\n+        ShortConverter converter = ShortConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_SHORT, SMALLINT, Short.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar((short) 1));\n+\n+        assertEquals(1, converter.asTinyint((short) 1));\n+        assertEquals(1, converter.asSmallint((short) 1));\n+        assertEquals(1, converter.asInt((short) 1));\n+        assertEquals(1L, converter.asBigint((short) 1));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal((short) 1));\n+\n+        assertEquals(1.0f, converter.asReal((short) 1), 0);\n+        assertEquals(1.0d, converter.asDouble((short) 1), 0);\n+\n+        assertEquals((short) 1, converter.asObject((short) 1));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testIntConverter() {\n+        IntegerConverter converter = IntegerConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_INTEGER, INT, Integer.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, BIGINT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar(1));\n+\n+        assertEquals(1, converter.asTinyint(1));\n+        assertEquals(1, converter.asSmallint(1));\n+        assertEquals(1, converter.asInt(1));\n+        assertEquals(1L, converter.asBigint(1));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal(1));\n+\n+        assertEquals(1.0f, converter.asReal(1), 0);\n+        assertEquals(1.0d, converter.asDouble(1), 0);\n+\n+        assertEquals(1, converter.asObject(1));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLongConverter() {\n+        LongConverter converter = LongConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LONG, BIGINT, Long.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar(1L));\n+\n+        assertEquals(1, converter.asTinyint(1L));\n+        assertEquals(1, converter.asSmallint(1L));\n+        assertEquals(1, converter.asInt(1L));\n+        assertEquals(1L, converter.asBigint(1L));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal(1L));\n+\n+        assertEquals(1.0f, converter.asReal(1L), 0);\n+        assertEquals(1.0d, converter.asDouble(1L), 0);\n+\n+        assertEquals(1L, converter.asObject(1L));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testBigIntegerConverter() {\n+        BigIntegerConverter converter = BigIntegerConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BIG_INTEGER, DECIMAL, BigInteger.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar(BigInteger.ONE));\n+\n+        assertEquals(1, converter.asTinyint(BigInteger.ONE));\n+        assertEquals(1, converter.asSmallint(BigInteger.ONE));\n+        assertEquals(1, converter.asInt(BigInteger.ONE));\n+        assertEquals(1L, converter.asBigint(BigInteger.ONE));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal(BigInteger.ONE));\n+\n+        assertEquals(1.0f, converter.asReal(BigInteger.ONE), 0);\n+        assertEquals(1.0d, converter.asDouble(BigInteger.ONE), 0);\n+\n+        assertEquals(BigDecimal.ONE, converter.asObject(BigInteger.ONE));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testBigDecimalConverter() {\n+        BigDecimalConverter converter = BigDecimalConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BIG_DECIMAL, DECIMAL, BigDecimal.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, REAL, DOUBLE, OBJECT);\n+\n+        BigDecimal val = BigDecimal.valueOf(11, 1);\n+\n+        assertEquals(\"1.1\", converter.asVarchar(val));\n+\n+        assertEquals(1, converter.asTinyint(val));\n+        assertEquals(1, converter.asSmallint(val));\n+        assertEquals(1, converter.asInt(val));\n+        assertEquals(1L, converter.asBigint(val));\n+        assertEquals(val, converter.asDecimal(val));\n+\n+        assertEquals(1.1f, converter.asReal(val), 0);\n+        assertEquals(1.1d, converter.asDouble(val), 0);\n+\n+        assertEquals(val, converter.asObject(val));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testFloatConverter() {\n+        FloatConverter converter = FloatConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_FLOAT, REAL, Float.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, DOUBLE, OBJECT);\n+\n+        float val = 1.1f;\n+\n+        assertEquals(\"1.1\", converter.asVarchar(val));\n+\n+        assertEquals(1, converter.asTinyint(val));\n+        assertEquals(1, converter.asSmallint(val));\n+        assertEquals(1, converter.asInt(val));\n+        assertEquals(1L, converter.asBigint(val));\n+        assertEquals(BigDecimal.valueOf(val), converter.asDecimal(val));\n+\n+        assertEquals(1.1f, converter.asReal(val), 0);\n+        assertEquals(1.1f, converter.asDouble(val), 0);\n+\n+        assertEquals(1.1f, converter.asObject(val));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testDoubleConverter() {\n+        DoubleConverter converter = DoubleConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_DOUBLE, DOUBLE, Double.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, OBJECT);\n+\n+        double val = 1.1d;\n+\n+        assertEquals(\"1.1\", converter.asVarchar(val));\n+\n+        assertEquals(1, converter.asTinyint(val));\n+        assertEquals(1, converter.asSmallint(val));\n+        assertEquals(1, converter.asInt(val));\n+        assertEquals(1L, converter.asBigint(val));\n+        assertEquals(BigDecimal.valueOf(val), converter.asDecimal(val));\n+\n+        assertEquals(1.1f, converter.asReal(val), 0);\n+        assertEquals(1.1d, converter.asDouble(val), 0);\n+\n+        assertEquals(1.1d, converter.asObject(val));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLocalTimeConverter() {\n+        LocalTimeConverter converter = LocalTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LOCAL_TIME, TIME, LocalTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        String timeString = \"11:22:33.444\";\n+        LocalTime time = LocalTime.parse(timeString);\n+        LocalDate date = LocalDate.now();\n+        LocalDateTime dateTime = LocalDateTime.of(date, time);\n+        OffsetDateTime globalDateTime = OffsetDateTime.ofInstant(dateTime.toInstant(ZoneOffset.UTC), ZoneId.systemDefault());\n+\n+        assertEquals(timeString, converter.asVarchar(time));\n+        assertEquals(time, converter.asTime(time));\n+        assertEquals(dateTime, converter.asTimestamp(time));\n+        assertEquals(globalDateTime, converter.asTimestampWithTimezone(time));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLocalDateConverter() {\n+        LocalDateConverter converter = LocalDateConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LOCAL_DATE, DATE, LocalDate.class);\n+        checkConverterConversions(converter, VARCHAR, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        String dateString = \"2020-02-02\";\n+        LocalDate date = LocalDate.parse(dateString);\n+        LocalDateTime dateTime = date.atStartOfDay();\n+        OffsetDateTime globalDateTime = OffsetDateTime.ofInstant(dateTime.toInstant(ZoneOffset.UTC), ZoneId.systemDefault());\n+\n+        assertEquals(dateString, converter.asVarchar(date));\n+        assertEquals(date, converter.asDate(date));\n+        assertEquals(dateTime, converter.asTimestamp(date));\n+        assertEquals(globalDateTime, converter.asTimestampWithTimezone(date));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLocalDateTimeConverter() {\n+        LocalDateTimeConverter converter = LocalDateTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LOCAL_DATE_TIME, TIMESTAMP, LocalDateTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        String dateTimeString = \"2020-02-02T11:22:33.444\";\n+        LocalDateTime dateTime = LocalDateTime.parse(dateTimeString);\n+        OffsetDateTime globalDateTime = OffsetDateTime.ofInstant(dateTime.toInstant(ZoneOffset.UTC), ZoneId.systemDefault());\n+\n+        assertEquals(dateTimeString, converter.asVarchar(dateTime));\n+        assertEquals(dateTime.toLocalDate(), converter.asDate(dateTime));\n+        assertEquals(dateTime.toLocalTime(), converter.asTime(dateTime));\n+        assertEquals(dateTime, converter.asTimestamp(dateTime));\n+        assertEquals(globalDateTime, converter.asTimestampWithTimezone(dateTime));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testDateConverter() {\n+        DateConverter converter = DateConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_DATE, TIMESTAMP_WITH_TIMEZONE, Date.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        Date val = new Date();\n+\n+        checkTimestampWithTimezone(converter, val, OffsetDateTime.ofInstant(val.toInstant(), ZoneOffset.UTC));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testCalendarConverter() {\n+        CalendarConverter converter = CalendarConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_CALENDAR, TIMESTAMP_WITH_TIMEZONE, Calendar.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        Calendar val = Calendar.getInstance();\n+\n+        checkTimestampWithTimezone(converter, val, OffsetDateTime.ofInstant(val.toInstant(), ZoneOffset.UTC));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testInstantConverter() {\n+        InstantConverter converter = InstantConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_INSTANT, TIMESTAMP_WITH_TIMEZONE, Instant.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        Instant val = Instant.now();\n+\n+        checkTimestampWithTimezone(converter, val, OffsetDateTime.ofInstant(val, ZoneOffset.UTC));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testOffsetDateTimeConverter() {\n+        OffsetDateTimeConverter converter = OffsetDateTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_OFFSET_DATE_TIME, TIMESTAMP_WITH_TIMEZONE, OffsetDateTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        OffsetDateTime val = OffsetDateTime.now();\n+\n+        checkTimestampWithTimezone(converter, val, val);\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testZonedDateTimeConverter() {\n+        ZonedDateTimeConverter converter = ZonedDateTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_ZONED_DATE_TIME, TIMESTAMP_WITH_TIMEZONE, ZonedDateTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        ZonedDateTime val = ZonedDateTime.now();\n+\n+        checkTimestampWithTimezone(converter, val, val.toOffsetDateTime());\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testStringConverter() {\n+        StringConverter c = StringConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_STRING, VARCHAR, String.class);\n+        checkConverterConversions(c,\n+            BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        // Boolean\n+        assertEquals(false, c.asBit(\"false\"));\n+        assertEquals(false, c.asBit(\"False\"));\n+        assertEquals(true, c.asBit(\"true\"));\n+        assertEquals(true, c.asBit(\"True\"));\n+        checkDataException(() -> c.asBit(\"0\"));\n+        checkDataException(() -> c.asBit(\"1\"));\n+\n+        // Numeric\n+        String invalid = \"invalid\";\n+\n+        assertEquals((byte) 1, c.asTinyint(\"1\"));\n+        checkDataException(() -> c.asTinyint(invalid));\n+\n+        assertEquals((short) 1, c.asSmallint(\"1\"));\n+        checkDataException(() -> c.asSmallint(invalid));\n+\n+        assertEquals(1, c.asInt(\"1\"));\n+        checkDataException(() -> c.asInt(invalid));\n+\n+        assertEquals(1L, c.asBigint(\"1\"));\n+        checkDataException(() -> c.asBigint(invalid));\n+\n+        assertEquals(new BigDecimal(\"1.1\"), c.asDecimal(\"1.1\"));\n+        checkDataException(() -> c.asDecimal(invalid));\n+\n+        assertEquals(1.1f, c.asReal(\"1.1\"), 0);\n+        checkDataException(() -> c.asReal(invalid));\n+\n+        assertEquals(1.1d, c.asDouble(\"1.1\"), 0);\n+        checkDataException(() -> c.asDouble(invalid));\n+\n+        // Temporal\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(\"11:22\"));\n+        assertEquals(LocalTime.parse(\"11:22:33\"), c.asTime(\"11:22:33\"));\n+        assertEquals(LocalTime.parse(\"11:22:33.444\"), c.asTime(\"11:22:33.444\"));\n+        assertEquals(LocalTime.parse(\"11:22:33.444444444\"), c.asTime(\"11:22:33.444444444\"));\n+        checkDataException(() -> c.asTime(\"33:22\"));\n+        checkDataException(() -> c.asTime(\"11:66\"));\n+        checkDataException(() -> c.asTime(\"11:22:66\"));\n+        checkDataException(() -> c.asTime(\"11:22:33.4444444444\"));\n+        checkDataException(() -> c.asTime(invalid));\n+\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(\"2020-01-01\"));\n+        checkDataException(() -> c.asDate(\"2020-13-01\"));\n+        checkDataException(() -> c.asDate(\"2020-01-35\"));\n+        checkDataException(() -> c.asDate(invalid));\n+\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22\"), c.asTimestamp(\"2020-01-01T11:22\"));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33\"), c.asTimestamp(\"2020-01-01T11:22:33\"));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444\"), c.asTimestamp(\"2020-01-01T11:22:33.444\"));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\"), c.asTimestamp(\"2020-01-01T11:22:33.444444444\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-13-01T11:22\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-35T11:22\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T33:22\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T11:66\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T11:22:66\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T11:22:33.4444444444\"));\n+        checkDataException(() -> c.asTimestamp(invalid));\n+\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444Z\"),\n+            c.asTimestampWithTimezone(\"2020-01-01T11:22:33.444444444Z\"));\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\"),\n+            c.asTimestampWithTimezone(\"2020-01-01T11:22:33.444444444+01:00\"));\n+        checkDataException(() -> c.asTimestampWithTimezone(invalid));\n+\n+        // Object\n+        assertEquals(\"val\", c.asObject(\"val\"));\n+\n+        checkConverterSelf(c);\n+    }\n+\n+    @Test\n+    public void testCharacterConverter() {\n+        CharacterConverter c = CharacterConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_CHARACTER, VARCHAR, Character.class);\n+        checkConverterConversions(c,\n+            BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        char invalid = 'c';\n+\n+        assertEquals((byte) 1, c.asTinyint('1'));\n+        checkDataException(() -> c.asTinyint(invalid));\n+\n+        assertEquals((short) 1, c.asSmallint('1'));\n+        checkDataException(() -> c.asSmallint(invalid));\n+\n+        assertEquals(1, c.asInt('1'));\n+        checkDataException(() -> c.asInt(invalid));\n+\n+        assertEquals(1L, c.asBigint('1'));\n+        checkDataException(() -> c.asBigint(invalid));\n+\n+        assertEquals(new BigDecimal(\"1\"), c.asDecimal('1'));\n+        checkDataException(() -> c.asDecimal(invalid));\n+\n+        assertEquals(1f, c.asReal('1'), 0);\n+        checkDataException(() -> c.asReal(invalid));\n+\n+        assertEquals(1d, c.asDouble('1'), 0);\n+        checkDataException(() -> c.asDouble(invalid));\n+\n+        assertEquals(\"c\", c.asObject('c'));\n+\n+        checkConverterSelf(c);\n+    }\n+\n+    @Test\n+    public void testObjectConverter() {\n+        ObjectConverter c = ObjectConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_OBJECT, OBJECT, Object.class);\n+        checkConverterConversions(c,\n+            BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, VARCHAR);\n+\n+        checkObjectConverter(c);\n+\n+        checkConverterSelf(c);\n+    }\n+\n+    @Test\n+    public void testLateConverter() {\n+        LateConverter c = LateConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_LATE, LATE, null);\n+        checkConverterConversions(c, BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP,\n+            TIMESTAMP_WITH_TIMEZONE, VARCHAR, OBJECT);\n+\n+        checkObjectConverter(c);\n+\n+        MockConverter mockConverter = new MockConverter();\n+        c.convertToSelf(mockConverter, new Object());\n+        assertTrue(mockConverter.isInvokedSelf());\n+    }\n+\n+    private void checkDataException(Runnable runnable) {\n+        try {\n+            runnable.run();\n+\n+            fail(\"Must fail\");\n+        } catch (HazelcastSqlException e) {\n+            assertEquals(SqlErrorCode.DATA_EXCEPTION, e.getCode());\n+        }\n+    }\n+\n+    private void checkTimestampWithTimezone(Converter converter, Object value, OffsetDateTime timestampWithTimezone) {\n+        LocalDateTime timestamp = timestampWithTimezone.atZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime();\n+        LocalDate date = timestamp.toLocalDate();\n+        LocalTime time = timestamp.toLocalTime();\n+\n+        assertEquals(timestampWithTimezone.toString(), converter.asVarchar(value));\n+        assertEquals(date, converter.asDate(value));\n+        assertEquals(time, converter.asTime(value));\n+        assertEquals(timestamp, converter.asTimestamp(value));\n+        assertEquals(timestampWithTimezone, converter.asTimestampWithTimezone(value));\n+        assertEquals(timestampWithTimezone, converter.asObject(value));\n+    }\n+\n+    private void checkObjectConverter(Converter c) {\n+        // Boolean\n+        assertEquals(true, c.asBit(true));\n+        assertEquals(true, c.asBit(\"true\"));\n+        assertEquals(false, c.asBit(false));\n+        assertEquals(false, c.asBit(\"false\"));\n+        checkDataException(() -> c.asBit(\"1\"));\n+        checkDataException(() -> c.asBit(1));\n+        checkDataException(() -> c.asBit(new Object()));\n+\n+        // Numeric\n+        String invalid = \"invalid\";\n+\n+        assertEquals((byte) 1, c.asTinyint(1));\n+        assertEquals((byte) 1, c.asTinyint(\"1\"));\n+        checkDataException(() -> c.asTinyint(invalid));\n+\n+        assertEquals((short) 1, c.asSmallint(1));\n+        assertEquals((short) 1, c.asSmallint(\"1\"));\n+        checkDataException(() -> c.asSmallint(invalid));\n+\n+        assertEquals(1, c.asInt(1));\n+        assertEquals(1, c.asInt(\"1\"));\n+        checkDataException(() -> c.asInt(invalid));\n+\n+        assertEquals(1L, c.asBigint(1));\n+        assertEquals(1L, c.asBigint(\"1\"));\n+        checkDataException(() -> c.asBigint(invalid));\n+\n+        assertEquals(new BigDecimal(\"1.1\"), c.asDecimal(new BigDecimal(\"1.1\")));\n+        assertEquals(new BigDecimal(\"1.1\"), c.asDecimal(\"1.1\"));\n+        checkDataException(() -> c.asDecimal(invalid));\n+\n+        assertEquals(1.1f, c.asReal(1.1f), 0);\n+        assertEquals(1.1f, c.asReal(\"1.1\"), 0);\n+        checkDataException(() -> c.asReal(invalid));\n+\n+        assertEquals(1.1d, c.asDouble(1.1d), 0);\n+        assertEquals(1.1d, c.asDouble(\"1.1\"), 0);\n+        checkDataException(() -> c.asDouble(invalid));\n+\n+        // Temporal\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(LocalTime.parse(\"11:22\")));\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(LocalDateTime.parse(\"2020-01-01T11:22\")));\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(\"11:22\"));\n+        checkDataException(() -> c.asTime(invalid));\n+\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(LocalDate.parse(\"2020-01-01\")));\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(LocalDateTime.parse(\"2020-01-01T11:22:33\")));\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(\"2020-01-01\"));\n+        checkDataException(() -> c.asDate(invalid));\n+\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\"),\n+            c.asTimestamp(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\")));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\"), c.asTimestamp(\"2020-01-01T11:22:33.444444444\"));\n+        checkDataException(() -> c.asTimestamp(invalid));\n+\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\"),\n+            c.asTimestampWithTimezone(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\")));\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\"),\n+            c.asTimestampWithTimezone(\"2020-01-01T11:22:33.444444444+01:00\"));\n+        checkDataException(() -> c.asTimestampWithTimezone(invalid));\n+\n+        // Strings.\n+        assertEquals(\"c\", c.asVarchar('c'));\n+        assertEquals(\"val\", c.asVarchar(\"val\"));\n+        assertEquals(\"2020-01-01T11:22:33.444444444\", c.asVarchar(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\")));\n+        assertEquals(new CustomClass(1).toString(), c.asVarchar(new CustomClass(1)));\n+\n+        // Object\n+        assertEquals(\"val\", c.asObject(\"val\"));\n+        assertEquals(1, c.asObject(1));\n+        assertEquals(new CustomClass(1), c.asObject(new CustomClass(1)));\n+    }\n+\n+    private void checkGetById(Converter converter) {\n+        Converter other = Converters.getConverter(converter.getId());\n+\n+        assertSame(converter, other);\n+    }\n+\n+    private void checkGetByClass(Converter expectedConverter, Class<?>... classes) {\n+        for (Class<?> clazz : classes) {\n+            Converter other = Converters.getConverter(clazz);\n+\n+            assertSame(expectedConverter, other);\n+        }\n+    }\n+\n+    private void checkConverter(\n+        Converter converter,\n+        int expectedId,\n+        QueryDataTypeFamily expectedTypeFamily,\n+        Class<?> expectedValueClass\n+    ) {\n+        assertEquals(expectedId, converter.getId());\n+        assertEquals(expectedTypeFamily, converter.getTypeFamily());\n+        assertEquals(expectedValueClass, converter.getValueClass());\n+    }\n+\n+    private void checkConverterConversions(Converter converter, QueryDataTypeFamily... expectedSupportedConversions) {\n+        Set<QueryDataTypeFamily> expectedSupportedConversions0 = new HashSet<>();\n+\n+        expectedSupportedConversions0.add(converter.getTypeFamily());\n+        expectedSupportedConversions0.addAll(Arrays.asList(expectedSupportedConversions));\n+\n+        for (QueryDataTypeFamily typeFamily : values()) {\n+            checkConverterConversion(converter, typeFamily, expectedSupportedConversions0.contains(typeFamily));\n+        }\n+    }\n+\n+    private void checkConverterConversion(Converter converter, QueryDataTypeFamily typeFamily, boolean expected) {\n+        assertEquals(typeFamily + \": \" + expected, expected, converter.canConvertTo(typeFamily));\n+\n+        switch (typeFamily) {\n+            case VARCHAR:\n+                assertEquals(expected, converter.canConvertToVarchar());\n+\n+                break;\n+\n+            case BIT:\n+                assertEquals(expected, converter.canConvertToBit());\n+\n+                break;\n+\n+            case TINYINT:\n+                assertEquals(expected, converter.canConvertToTinyint());\n+\n+                break;\n+\n+            case SMALLINT:\n+                assertEquals(expected, converter.canConvertToSmallint());\n+\n+                break;\n+\n+            case INT:\n+                assertEquals(expected, converter.canConvertToInt());\n+\n+                break;\n+\n+            case BIGINT:\n+                assertEquals(expected, converter.canConvertToBigint());\n+\n+                break;\n+\n+            case DECIMAL:\n+                assertEquals(expected, converter.canConvertToDecimal());\n+\n+                break;\n+\n+            case REAL:\n+                assertEquals(expected, converter.canConvertToReal());\n+\n+                break;\n+\n+            case DOUBLE:\n+                assertEquals(expected, converter.canConvertToDouble());\n+\n+                break;\n+\n+            case TIME:\n+                assertEquals(expected, converter.canConvertToTime());\n+\n+                break;\n+\n+            case DATE:\n+                assertEquals(expected, converter.canConvertToDate());\n+\n+                break;\n+\n+            case TIMESTAMP:\n+                assertEquals(expected, converter.canConvertToTimestamp());\n+\n+                break;\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                assertEquals(expected, converter.canConvertToTimestampWithTimezone());\n+\n+                break;\n+\n+            case OBJECT:\n+                assertEquals(expected, converter.canConvertToObject());\n+\n+                break;\n+        }\n+\n+        if (!expected) {\n+            checkCannotConvert(converter, typeFamily);\n+        }\n+    }\n+\n+    private void checkCannotConvert(Converter converter, QueryDataTypeFamily typeFamily) {\n+        try {\n+            Object val = new Object();\n+\n+            switch (typeFamily) {\n+                case VARCHAR:\n+                    converter.asVarchar(val);\n+\n+                    break;\n+\n+                case BIT:\n+                    converter.asBit(val);\n+\n+                    break;\n+\n+                case TINYINT:\n+                    converter.asTinyint(val);\n+\n+                    break;\n+\n+                case SMALLINT:\n+                    converter.asSmallint(val);\n+\n+                    break;\n+\n+                case INT:\n+                    converter.asInt(val);\n+\n+                    break;\n+\n+                case BIGINT:\n+                    converter.asBigint(val);\n+\n+                    break;\n+\n+                case DECIMAL:\n+                    converter.asDecimal(val);\n+\n+                    break;\n+\n+                case REAL:\n+                    converter.asReal(val);\n+\n+                    break;\n+\n+                case DOUBLE:\n+                    converter.asDouble(val);\n+\n+                    break;\n+\n+                case TIME:\n+                    converter.asTime(val);\n+\n+                    break;\n+\n+                case DATE:\n+                    converter.asDate(val);\n+\n+                    break;\n+\n+                case TIMESTAMP:\n+                    converter.asTimestamp(val);\n+\n+                    break;\n+\n+                case TIMESTAMP_WITH_TIMEZONE:\n+                    converter.asTimestampWithTimezone(val);\n+\n+                    break;\n+\n+                case OBJECT:\n+                    converter.asObject(val);\n+\n+                    break;\n+\n+                default:\n+                    return;\n+            }\n+\n+            fail(\"Must fail: \" + typeFamily);\n+        } catch (HazelcastSqlException e) {\n+            assertEquals(SqlErrorCode.DATA_EXCEPTION, e.getCode());\n+        }\n+    }\n+\n+    private void checkConverterSelf(Converter converter) {\n+        MockConverter mockConverter = new MockConverter();\n+\n+        converter.convertToSelf(mockConverter, new Object());\n+\n+        assertEquals(converter.getTypeFamily(), mockConverter.getInvoked());\n+    }\n+\n+    private static final class CustomClass {\n+        private int val;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6"}, "originalPosition": 915}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76c5c7fa0493c5888169dd7b04cbf3d597133f8f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/76c5c7fa0493c5888169dd7b04cbf3d597133f8f", "committedDate": "2020-03-16T13:00:02Z", "message": "Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDE2MzI1", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-375416325", "createdAt": "2020-03-16T17:05:21Z", "commit": {"oid": "76c5c7fa0493c5888169dd7b04cbf3d597133f8f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Nzk4ODQ2", "url": "https://github.com/hazelcast/hazelcast/pull/16738#pullrequestreview-375798846", "createdAt": "2020-03-17T07:44:29Z", "commit": {"oid": "76c5c7fa0493c5888169dd7b04cbf3d597133f8f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3867, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}