{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MDU0NDgy", "number": 17174, "title": "SQL client support (#17173)", "bodyText": "This PR introduces client-side support for SQL. The design is explained in the issue #17173 (comment)\nEnt PR: https://github.com/hazelcast/hazelcast-enterprise/pull/3666\nProtocol PR: hazelcast/hazelcast-client-protocol#329\nCloses #17173", "createdAt": "2020-07-03T13:18:45Z", "url": "https://github.com/hazelcast/hazelcast/pull/17174", "merged": true, "mergeCommit": {"oid": "ff942b5781d52d7991996c7c5d30f6f38a9626a9"}, "closed": true, "closedAt": "2020-07-23T19:00:12Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 62, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxTQzJgH2gAyNDQ0MDU0NDgyOjRmZGY4MDZhOGM0MmQ0MWEyMzE5NjQzMTQ2ODU1YTMyNGM1ZGZjM2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3w5cLAH2gAyNDQ0MDU0NDgyOjJmNWRjZTViNTBjYWRlMzE2MDAxODZhZGRhYjYxNDhlNjhiYzUzMzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4fdf806a8c42d41a2319643146855a324c5dfc3c", "committedDate": "2020-07-03T13:14:55Z", "message": "SQL client support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyODA5ODQy", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442809842", "createdAt": "2020-07-06T06:44:28Z", "commit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo0NDoyOFrOGtKqMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo0NDoyOFrOGtKqMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMzc0Ng==", "bodyText": "We can't change public API.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450013746", "createdAt": "2020-07-06T06:44:28Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/client/LoadBalancer.java", "diffHunk": "@@ -43,9 +43,10 @@\n     void init(Cluster cluster, ClientConfig config);\n \n     /**\n-     * Returns the next member to route to.\n+     * Returns the next data member to route to.\n      *\n-     * @return Returns the next member or null if no member is available\n+     * @param dataMember {@code true} if only data members should be considered\n+     * @return Returns the next data member or null if no member is available\n      */\n-    Member next();\n+    Member next(boolean dataMember);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8156be67c7ba2308c3093a693f159b9bed599a8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f8156be67c7ba2308c3093a693f159b9bed599a8", "committedDate": "2020-07-06T07:30:14Z", "message": "Fixed public API changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyODE3Nzc3", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442817777", "createdAt": "2020-07-06T07:00:12Z", "commit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNzowMjoxOVrOGtLHEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoyMDoyMVrOGtNb1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTEzNg==", "bodyText": "Why is this in initializeManagementCenterTaskFactories method? We can maybe create initializeSqlTaskFactories.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450021136", "createdAt": "2020-07-06T07:02:19Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/DefaultMessageTaskFactoryProvider.java", "diffHunk": "@@ -1779,6 +1785,15 @@ private void initializeManagementCenterTaskFactories() {\n                 (cm, con) -> new HotRestartTriggerBackupMessageTask(cm, node, con));\n         factories.put(MCInterruptHotRestartBackupCodec.REQUEST_MESSAGE_TYPE,\n                 (cm, con) -> new HotRestartInterruptBackupMessageTask(cm, node, con));\n+\n+// region ----------- REGISTRATION FOR SQL\n+        factories.put(SqlExecuteCodec.REQUEST_MESSAGE_TYPE,\n+            (cm, con) -> new SqlExecuteMessageTask(cm, node, con));\n+        factories.put(SqlFetchCodec.REQUEST_MESSAGE_TYPE,\n+            (cm, con) -> new SqlFetchMessageTask(cm, node, con));\n+        factories.put(SqlCloseCodec.REQUEST_MESSAGE_TYPE,\n+            (cm, con) -> new SqlCloseMessageTask(cm, node, con));\n+//endregion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNTI3MQ==", "bodyText": "Not really part of this PR, but since we only use set and get, we can replace this with a volatile field.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450025271", "createdAt": "2020-07-06T07:12:19Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/client/util/AbstractLoadBalancer.java", "diffHunk": "@@ -32,8 +34,9 @@\n  */\n public abstract class AbstractLoadBalancer implements LoadBalancer, InitialMembershipListener {\n \n-    private final AtomicReference<Member[]> membersRef = new AtomicReference<Member[]>(new Member[0]);\n+    private static final Member[] EMPTY_MEMBERS = new Member[0];\n \n+    private final AtomicReference<Members> membersRef = new AtomicReference<>(new Members(EMPTY_MEMBERS, EMPTY_MEMBERS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzOTUxNw==", "bodyText": "null should be returned if no member is available, not if we're lazy to find one.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450039517", "createdAt": "2020-07-06T07:42:13Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/client/util/StaticLB.java", "diffHunk": "@@ -38,7 +38,7 @@ public void init(Cluster cluster, ClientConfig config) {\n     }\n \n     @Override\n-    public Member next() {\n-        return member;\n+    public Member next(boolean dataMember) {\n+        return dataMember && member.isLiteMember() ? null : member;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NDU0Ng==", "bodyText": "We could declare the return type as Set<UUID>. We actually only call contains on the returned value, a Set indicates that it's designed for that.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450044546", "createdAt": "2020-07-06T07:51:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/NodeServiceProviderImpl.java", "diffHunk": "@@ -63,6 +64,17 @@ public UUID getLocalMemberId() {\n         return res;\n     }\n \n+    @Override\n+    public Collection<UUID> getClientMembersIds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8156be67c7ba2308c3093a693f159b9bed599a8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NTM0NQ==", "bodyText": "We probably should say just \"Client cannot be reached\", a client is not a member.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450045345", "createdAt": "2020-07-06T07:53:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryException.java", "diffHunk": "@@ -62,15 +63,19 @@ public static QueryException error(int code, String message, Throwable cause, UU\n     }\n \n     public static QueryException memberConnection(UUID memberId) {\n-        return error(SqlErrorCode.MEMBER_CONNECTION, \"Connection to the member is broken: \" + memberId);\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Member cannot be reached: \" + memberId);\n     }\n \n-    public static QueryException memberLeave(UUID memberId) {\n-        return error(SqlErrorCode.MEMBER_LEAVE, \"Participating member has left the topology: \" + memberId);\n+    public static QueryException memberConnection(Address address) {\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Member cannot be reached: \" + address);\n     }\n \n-    public static QueryException memberLeave(Collection<UUID> memberIds) {\n-        return error(SqlErrorCode.MEMBER_LEAVE, \"Participating members have left the topology: \" + memberIds);\n+    public static QueryException memberConnection(Collection<UUID> memberIds) {\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Members cannot be reached: \" + memberIds);\n+    }\n+\n+    public static QueryException clientMemberConnection(UUID clientId) {\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Client member cannot be reached: \" + clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8156be67c7ba2308c3093a693f159b9bed599a8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1MTEzMA==", "bodyText": "Suggested by intellij\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return rows != null ? rows.equals(page.rows) : page.rows == null;\n          \n          \n            \n                    return Objects.equals(rows, page.rows);", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450051130", "createdAt": "2020-07-06T08:05:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlPage.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+\n+import java.util.List;\n+\n+public class SqlPage {\n+\n+    private final List<Data> rows;\n+    private final boolean last;\n+\n+    public SqlPage(List<Data> rows, boolean last) {\n+        this.rows = rows;\n+        this.last = last;\n+    }\n+\n+    public List<Data> getRows() {\n+        return rows;\n+    }\n+\n+    public boolean isLast() {\n+        return last;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        SqlPage page = (SqlPage) o;\n+\n+        if (last != page.last) {\n+            return false;\n+        }\n+\n+        return rows != null ? rows.equals(page.rows) : page.rows == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8156be67c7ba2308c3093a693f159b9bed599a8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1OTIyMw==", "bodyText": "This is a fallback code that's used when the load balancer returned null, even though it should return null only if there's no member available. But it's also a fallback when the load balancer doesn't implement the nextDataMember method, and in this case we should find the first data member.\nWhat if the first member returned by the iterator isn't a data member? A user upgrading to 4.2 that has a custom LB can get random \"Client must be connected to at least one data member to execute SQL queries\" errors.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450059223", "createdAt": "2020-07-06T08:20:21Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -767,8 +779,25 @@ public ClientConnection getRandomConnection() {\n             }\n         }\n \n-        Iterator<TcpClientConnection> iterator = activeConnections.values().iterator();\n-        return iterator.hasNext() ? iterator.next() : null;\n+        Iterator<Map.Entry<UUID, TcpClientConnection>> iterator = activeConnections.entrySet().iterator();\n+\n+        Map.Entry<UUID, TcpClientConnection> connectionEntry = iterator.hasNext() ? iterator.next() : null;\n+\n+        if (connectionEntry != null) {\n+            if (dataMember) {\n+                UUID memberId = connectionEntry.getKey();\n+\n+                Member member = client.getClientClusterService().getMember(memberId);\n+\n+                if (member == null || member.isLiteMember()) {\n+                    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8156be67c7ba2308c3093a693f159b9bed599a8"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f650b0b2268ad9a0695a09f19271faeaba9df0e6", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f650b0b2268ad9a0695a09f19271faeaba9df0e6", "committedDate": "2020-07-06T08:25:22Z", "message": "Typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe85d5c72092b58e986b9ed512cd7ff034fcf121", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fe85d5c72092b58e986b9ed512cd7ff034fcf121", "committedDate": "2020-07-06T08:45:57Z", "message": "Proper method placement in DefaultMessageTaskFactoryProvider.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1c0d6732b4f34edd97f25e3d6c12e26d6cff20c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a1c0d6732b4f34edd97f25e3d6c12e26d6cff20c", "committedDate": "2020-07-06T08:46:07Z", "message": "Merge remote-tracking branch 'devozerov/issues/17173' into issues/17173"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4f2316ad26d9fee60a302104d98fa23561e4d90", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d4f2316ad26d9fee60a302104d98fa23561e4d90", "committedDate": "2020-07-06T09:00:52Z", "message": "Reworked random connection handling."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/55633b28d49ce6102ad8d37e2ad752704d869b4f", "committedDate": "2020-07-06T09:05:12Z", "message": "Minors."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTM1Njc3", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442935677", "createdAt": "2020-07-06T09:54:41Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTo1NDo0MVrOGtQtEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTo1NDo0MVrOGtQtEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMjc4Ng==", "bodyText": "Should be Set<UUID> also here", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450112786", "createdAt": "2020-07-06T09:54:41Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -153,6 +160,12 @@ private void checkMemberState() {\n             }\n         }\n \n+        private void checkClientState() {\n+            Collection<UUID> activeClientIds = nodeServiceProvider.getClientIds();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTUyMTA2", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442952106", "createdAt": "2020-07-06T10:19:12Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDoxOToxMlrOGtRf7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDoxOToxMlrOGtRf7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyNTgwNw==", "bodyText": "It would be much easier to understand if we represent the empty list with an actually empty list rather than null.\nI have checked the SqlExecuteMessageTask code. It would simplify the code there also.\nInstead of\n if (parameters.parameters != null && !parameters.parameters.isEmpty()) {\n                for (Data param : parameters.parameters) {\n                    query.addParameter(serializationService.toObject(param));\n                }\n            }\n\nthe following will suffice\n                for (Data param : parameters.parameters) {\n                    query.addParameter(serializationService.toObject(param));\n                }", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450125807", "createdAt": "2020-07-06T10:19:12Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.ClientMessageDecoder;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private static final ClientMessageDecoder<SqlExecuteResponse> EXECUTE_DECODER = clientMessage -> {\n+        SqlExecuteCodec.ResponseParameters response = SqlExecuteCodec.decodeResponse(clientMessage);\n+\n+        return new SqlExecuteResponse(response.queryId, response.rowMetadata, response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<SqlFetchResponse> FETCH_DECODER = clientMessage -> {\n+        SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(clientMessage);\n+\n+        return new SqlFetchResponse(response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<Void> CLOSE_DECODER = clientMessage -> {\n+        SqlCloseCodec.decodeResponse(clientMessage);\n+\n+        return null;\n+    };\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+            List<Data> params0;\n+\n+            if (!params.isEmpty()) {\n+                params0 = new ArrayList<>(params.size());\n+\n+                for (Object param : params) {\n+                    params0.add(serializeParameter(param));\n+                }\n+            } else {\n+                params0 = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTU3MjAy", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442957202", "createdAt": "2020-07-06T10:27:25Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDoyNzoyNVrOGtRv-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDoyNzoyNVrOGtRv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyOTkxMw==", "bodyText": "You don't need the ClientDelegatingFuture since you are doing a sync call. It is mostly needed when we need to pass a future to the user(or other part of the system)\nWhy not just do the following instead?\nClientMessage clientMessage = fut.get();\nreturn decoder.decodeClientMessage(clientMessage);\n\nEven further, there is no need for static decoder functions because they are all sync calls.\nI would suggest making the return type ClientMessage.  For the fetch method:\n            ClientMessage responseMessage = invoke(message, connection);\n            SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(responseMessage);\n            SqlFetchResponse res = new SqlFetchResponse(response.rowPage, response.error);\n            handleResponseError(res.getError());\n\nStatic decoder functions and delegating future are used for async cases. There is no need to complicate the code with them when not needed.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450129913", "createdAt": "2020-07-06T10:27:25Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.ClientMessageDecoder;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private static final ClientMessageDecoder<SqlExecuteResponse> EXECUTE_DECODER = clientMessage -> {\n+        SqlExecuteCodec.ResponseParameters response = SqlExecuteCodec.decodeResponse(clientMessage);\n+\n+        return new SqlExecuteResponse(response.queryId, response.rowMetadata, response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<SqlFetchResponse> FETCH_DECODER = clientMessage -> {\n+        SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(clientMessage);\n+\n+        return new SqlFetchResponse(response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<Void> CLOSE_DECODER = clientMessage -> {\n+        SqlCloseCodec.decodeResponse(clientMessage);\n+\n+        return null;\n+    };\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+            List<Data> params0;\n+\n+            if (!params.isEmpty()) {\n+                params0 = new ArrayList<>(params.size());\n+\n+                for (Object param : params) {\n+                    params0.add(serializeParameter(param));\n+                }\n+            } else {\n+                params0 = null;\n+            }\n+\n+            ClientMessage message = SqlExecuteCodec.encodeRequest(\n+                query.getSql(),\n+                params0,\n+                query.getTimeoutMillis(),\n+                query.getCursorBufferSize()\n+            );\n+\n+            SqlExecuteResponse response = invoke(message, connection, EXECUTE_DECODER);\n+\n+            handleResponseError(response.getError());\n+\n+            return new SqlClientResult(\n+                this,\n+                connection,\n+                response.getQueryId(),\n+                response.getRowMetadata(),\n+                response.getPage(),\n+                query.getCursorBufferSize()\n+            );\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    /**\n+     * Fetch the next page of the given query.\n+     *\n+     * @param connection Connection.\n+     * @param queryId Query ID.\n+     * @return Pair: fetched rows + last page flag.\n+     */\n+    public SqlPage fetch(Connection connection, QueryId queryId, int cursorBufferSize) {\n+        try {\n+            ClientMessage message = SqlFetchCodec.encodeRequest(queryId, cursorBufferSize);\n+\n+            SqlFetchResponse res = invoke(message, connection, FETCH_DECODER);\n+\n+            handleResponseError(res.getError());\n+\n+            return res.getPage();\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    /**\n+     * Close remote query cursor.\n+     *\n+     * @param connection Connection.\n+     * @param queryId Query ID.\n+     */\n+    void close(Connection connection, QueryId queryId) {\n+        try {\n+            ClientMessage request = SqlCloseCodec.encodeRequest(queryId);\n+\n+            invoke(request, connection, CLOSE_DECODER);\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    private Data serializeParameter(Object parameter) {\n+        try {\n+            return getSerializationService().toData(parameter);\n+        } catch (Exception e) {\n+            throw rethrow(\n+                QueryException.error(\"Failed to serialize query parameter \" + parameter + \": \" + e.getMessage())\n+            );\n+        }\n+    }\n+\n+    Row deserializeRow(Data data) {\n+        try {\n+            return getSerializationService().toObject(data);\n+        } catch (Exception e) {\n+            throw rethrow(\n+                QueryException.error(\"Failed to deserialize query result row: \" + e.getMessage())\n+            );\n+        }\n+    }\n+\n+    private UUID getClientId() {\n+        return client.getLocalEndpoint().getUuid();\n+    }\n+\n+    private InternalSerializationService getSerializationService() {\n+        return client.getSerializationService();\n+    }\n+\n+    private <T> T invoke(ClientMessage request, Connection connection, ClientMessageDecoder<T> decoder) throws Exception {\n+        ClientInvocation invocation = new ClientInvocation(client, request, null, connection);\n+\n+        ClientInvocationFuture fut = invocation.invoke();\n+\n+        return new ClientDelegatingFuture<T>(fut, getSerializationService(), decoder, false).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTYyMTIw", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442962120", "createdAt": "2020-07-06T10:35:35Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDozNTozNlrOGtR_LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDozNTozNlrOGtR_LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA==", "bodyText": "So a un\u0131socket client that is connected to a lite member can not run a query?\nThis is not suited to our unisocket client behavior. Our unisocket clients should be able to operate same regardless of the member type they are connected to.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450133804", "createdAt": "2020-07-06T10:35:36Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.ClientMessageDecoder;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private static final ClientMessageDecoder<SqlExecuteResponse> EXECUTE_DECODER = clientMessage -> {\n+        SqlExecuteCodec.ResponseParameters response = SqlExecuteCodec.decodeResponse(clientMessage);\n+\n+        return new SqlExecuteResponse(response.queryId, response.rowMetadata, response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<SqlFetchResponse> FETCH_DECODER = clientMessage -> {\n+        SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(clientMessage);\n+\n+        return new SqlFetchResponse(response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<Void> CLOSE_DECODER = clientMessage -> {\n+        SqlCloseCodec.decodeResponse(clientMessage);\n+\n+        return null;\n+    };\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTc5MTI1", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-442979125", "createdAt": "2020-07-06T11:04:31Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTowNDozMlrOGtSzpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTowNDozMlrOGtSzpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ==", "bodyText": "Both serialization service and client protocol have built-in UUID support. If the only purpose of these High and Low part splits is to support them, I think you can just use UUID instead.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450147239", "createdAt": "2020-07-06T11:04:32Z", "author": {"login": "asimarslan"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java", "diffHunk": "@@ -35,20 +35,20 @@\n     private long memberIdLow;\n \n     /** Local ID: most significant bits. */\n-    private long localHigh;\n+    private long localIdHigh;\n \n     /** Local ID: least significant bits. */\n-    private long localLow;\n+    private long localIdLow;\n \n     public QueryId() {\n         // No-op.\n     }\n \n-    QueryId(long memberIdHigh, long memberIdLow, long localHigh, long localLow) {\n+    public QueryId(long memberIdHigh, long memberIdLow, long localIdHigh, long localIdLow) {\n         this.memberIdHigh = memberIdHigh;\n         this.memberIdLow = memberIdLow;\n-        this.localHigh = localHigh;\n-        this.localLow = localLow;\n+        this.localIdHigh = localIdHigh;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDEwMjMx", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-443010231", "createdAt": "2020-07-06T11:58:02Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTo1ODowMlrOGtUR3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTo1ODowMlrOGtUR3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE3MTM1OQ==", "bodyText": "This does not seem correct. We are not using Data for builtin IdentifiedDataSerializable objects on our protocol as much as possible. It is hard to define what is Data in the protocol. More importantly, they don't support evolution, it is very likely to make a mistake.\nI see that Row is an interface. Which Row implementations can we return to the client?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450171359", "createdAt": "2020-07-06T11:58:02Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+    /** Registered client cursors. */\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<Data> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<Data> page,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        while (iterator.hasNext()) {\n+            SqlRow row = iterator.next();\n+            Row rowInternal = ((SqlRowImpl) row).getDelegate();\n+            Data rowData = serializationService.toData(rowInternal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDI0MTgx", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-443024181", "createdAt": "2020-07-06T12:19:43Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMjoxOTo0M1rOGtU6WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMjoxOTo0M1rOGtU6WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA==", "bodyText": "I could not find the cleanup code for the case where a client lefts the cluster without closing the query.\nYou can use ClientEndpoint.addDestroyAction(UUID registrationId, Callable<Boolean> removeAction); for this.\nA client enndpoint is removed and all desrtoy actions are called when the assocaiated connection is disconnected. Since the queries are desinged to be sticky it looks like a good fit.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450181720", "createdAt": "2020-07-06T12:19:43Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+    /** Registered client cursors. */\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDI2MzAx", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-443026301", "createdAt": "2020-07-06T12:23:00Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMjoyMzowMFrOGtVAyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMjoyMzowMFrOGtVAyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MzM2OA==", "bodyText": "Is permission left null on purpose? I think, SQL permissions are important.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450183368", "createdAt": "2020-07-06T12:23:00Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlExecuteMessageTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.impl.SqlInternalService;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlServiceImpl;\n+\n+import java.security.Permission;\n+\n+/**\n+ * SQL query execute task.\n+ */\n+public class SqlExecuteMessageTask extends AbstractCallableMessageTask<SqlExecuteCodec.RequestParameters> {\n+    public SqlExecuteMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Object call() throws Exception {\n+        try {\n+            SqlQuery query = new SqlQuery(parameters.sql);\n+\n+            if (parameters.parameters != null && !parameters.parameters.isEmpty()) {\n+                for (Data param : parameters.parameters) {\n+                    query.addParameter(serializationService.toObject(param));\n+                }\n+            }\n+\n+            query.setTimeoutMillis(parameters.timeoutMillis);\n+            query.setCursorBufferSize(parameters.cursorBufferSize);\n+\n+            SqlServiceImpl sqlService = nodeEngine.getSqlService();\n+\n+            SqlResultImpl cursor = (SqlResultImpl) sqlService.query(query);\n+\n+            SqlPage page = sqlService.getInternalService().getClientStateRegistry().registerAndFetch(\n+                endpoint.getUuid(),\n+                cursor,\n+                parameters.cursorBufferSize,\n+                serializationService\n+            );\n+\n+            return new SqlExecuteResponse(\n+                cursor.getQueryId(),\n+                cursor.getRowMetadata(),\n+                page,\n+                null\n+            );\n+        } catch (Exception e) {\n+            SqlError error = SqlClientUtils.exceptionToClientError(e, nodeEngine.getLocalMember().getUuid());\n+\n+            return new SqlExecuteResponse(null, null, null, error);\n+        }\n+    }\n+\n+    @Override\n+    protected SqlExecuteCodec.RequestParameters decodeClientMessage(ClientMessage clientMessage) {\n+        return SqlExecuteCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        SqlExecuteResponse response0 = (SqlExecuteResponse) response;\n+\n+        return SqlExecuteCodec.encodeResponse(\n+            response0.getQueryId(),\n+            response0.getRowMetadata(),\n+            response0.getPage(),\n+            response0.getError()\n+        );\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return SqlInternalService.SERVICE_NAME;\n+    }\n+\n+    @Override\n+    public String getDistributedObjectName() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getMethodName() {\n+        return \"execute\";\n+    }\n+\n+    @Override\n+    public Object[] getParameters() {\n+        return new Object[] {\n+            parameters.sql,\n+            parameters.parameters,\n+            parameters.timeoutMillis,\n+            parameters.cursorBufferSize\n+        } ;\n+    }\n+\n+    @Override\n+    public Permission getRequiredPermission() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDI3MDk0", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-443027094", "createdAt": "2020-07-06T12:24:10Z", "commit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMjoyNDoxMFrOGtVDBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMjoyNDoxMFrOGtVDBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4Mzk0Mg==", "bodyText": "for the method name, we usually use the user API method name. So should it be query?  And note that related tests are on the enterprise repo. Make sure that you have SecurityInterceptor and permission tests for the new use case.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450183942", "createdAt": "2020-07-06T12:24:10Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlExecuteMessageTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.impl.SqlInternalService;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlServiceImpl;\n+\n+import java.security.Permission;\n+\n+/**\n+ * SQL query execute task.\n+ */\n+public class SqlExecuteMessageTask extends AbstractCallableMessageTask<SqlExecuteCodec.RequestParameters> {\n+    public SqlExecuteMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Object call() throws Exception {\n+        try {\n+            SqlQuery query = new SqlQuery(parameters.sql);\n+\n+            if (parameters.parameters != null && !parameters.parameters.isEmpty()) {\n+                for (Data param : parameters.parameters) {\n+                    query.addParameter(serializationService.toObject(param));\n+                }\n+            }\n+\n+            query.setTimeoutMillis(parameters.timeoutMillis);\n+            query.setCursorBufferSize(parameters.cursorBufferSize);\n+\n+            SqlServiceImpl sqlService = nodeEngine.getSqlService();\n+\n+            SqlResultImpl cursor = (SqlResultImpl) sqlService.query(query);\n+\n+            SqlPage page = sqlService.getInternalService().getClientStateRegistry().registerAndFetch(\n+                endpoint.getUuid(),\n+                cursor,\n+                parameters.cursorBufferSize,\n+                serializationService\n+            );\n+\n+            return new SqlExecuteResponse(\n+                cursor.getQueryId(),\n+                cursor.getRowMetadata(),\n+                page,\n+                null\n+            );\n+        } catch (Exception e) {\n+            SqlError error = SqlClientUtils.exceptionToClientError(e, nodeEngine.getLocalMember().getUuid());\n+\n+            return new SqlExecuteResponse(null, null, null, error);\n+        }\n+    }\n+\n+    @Override\n+    protected SqlExecuteCodec.RequestParameters decodeClientMessage(ClientMessage clientMessage) {\n+        return SqlExecuteCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        SqlExecuteResponse response0 = (SqlExecuteResponse) response;\n+\n+        return SqlExecuteCodec.encodeResponse(\n+            response0.getQueryId(),\n+            response0.getRowMetadata(),\n+            response0.getPage(),\n+            response0.getError()\n+        );\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return SqlInternalService.SERVICE_NAME;\n+    }\n+\n+    @Override\n+    public String getDistributedObjectName() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getMethodName() {\n+        return \"execute\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d0414080aef15b7526eb961cc1505f5614f28b9", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1d0414080aef15b7526eb961cc1505f5614f28b9", "committedDate": "2020-07-07T06:53:31Z", "message": "1) Added more tests for server-side cursor cleanup\n2) Reworked protocol page representation from List<Data> to List<List<Data>\n3) Made query parameters non-nullable in the protocol\n4) Several other minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57f99ce30c1fa43c5fa602b15394b503b972a753", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/57f99ce30c1fa43c5fa602b15394b503b972a753", "committedDate": "2020-07-07T06:57:59Z", "message": "Removed delegating future."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "185dc6749498837536ad3e03909d83cf51a98a1b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/185dc6749498837536ad3e03909d83cf51a98a1b", "committedDate": "2020-07-07T07:04:00Z", "message": "Removed decoders."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b7f8b720ed2b9a4263ae3f104d46db5699c85678", "committedDate": "2020-07-07T08:09:41Z", "message": "Added security support."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzODU5NjU0", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-443859654", "createdAt": "2020-07-07T12:53:42Z", "commit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjo1Mzo0MlrOGt9JGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxMjo0MFrOGt94RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0MDg1Ng==", "bodyText": "Typo: double type?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450840856", "createdAt": "2020-07-07T12:53:42Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/codec/builtin/CustomTypeFactory.java", "diffHunk": "@@ -197,4 +200,14 @@ public static EndpointQualifier createEndpointQualifier(int type, String identif\n         }\n         return EndpointQualifier.resolve(protocolType, identifier);\n     }\n+\n+    public static SqlColumnMetadata createSqlColumnMetadata(String name, int type) {\n+        SqlColumnType sqlColumnType = SqlColumnType.getById(type);\n+\n+        if (sqlColumnType == null) {\n+            throw new HazelcastException(\"Unexpected SQL column type type = [\" + type + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MjkzMw==", "bodyText": "Not sure that I got why do we need to convert the result to Data if we are already on the client?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450852933", "createdAt": "2020-07-07T13:12:40Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<SqlPageRow> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private static boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<SqlPageRow> page,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        while (iterator.hasNext()) {\n+            SqlRow row = iterator.next();\n+            SqlPageRow convertedRow = convertRow(row, serializationService);\n+\n+            page.add(convertedRow);\n+\n+            if (page.size() == cursorBufferSize) {\n+                break;\n+            }\n+        }\n+\n+        return !iterator.hasNext();\n+    }\n+\n+    private static SqlPageRow convertRow(SqlRow row, InternalSerializationService serializationService) {\n+        int columnCount = row.getMetadata().getColumnCount();\n+\n+        List<Data> values = new ArrayList<>(columnCount);\n+\n+        for (int i = 0; i < columnCount; i++) {\n+            values.add(serializationService.toData(row.getObject(i)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzODc5NzM5", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-443879739", "createdAt": "2020-07-07T13:17:36Z", "commit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxNzozNlrOGt-EzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzozNDo1MlrOGt-0Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NjE0MQ==", "bodyText": "If an exception is thrown from service.close(connection, queryId) then we still mark the iterator as closed while it is not?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450856141", "createdAt": "2020-07-07T13:17:36Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientResult.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlRowMetadata;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Client-side cursor.\n+ */\n+public class SqlClientResult implements SqlResult {\n+\n+    private final SqlClientService service;\n+    private final Connection connection;\n+    private final QueryId queryId;\n+    private final SqlRowMetadata rowMetadata;\n+    private final ClientIterator iterator = new ClientIterator();\n+\n+    private int cursorBufferSize;\n+    private boolean closed;\n+    private boolean iteratorAccessed;\n+\n+    public SqlClientResult(\n+        SqlClientService service,\n+        Connection connection,\n+        QueryId queryId,\n+        SqlRowMetadata rowMetadata,\n+        SqlPage page,\n+        int cursorBufferSize\n+    ) {\n+        this.service = service;\n+        this.connection = connection;\n+        this.queryId = queryId;\n+        this.rowMetadata = rowMetadata;\n+        this.cursorBufferSize = cursorBufferSize;\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlRowMetadata getRowMetadata() {\n+        return rowMetadata;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Iterator<SqlRow> iterator() {\n+        if (!iteratorAccessed) {\n+            iteratorAccessed = true;\n+\n+            return iterator;\n+        } else {\n+            throw new IllegalStateException(\"Iterator could be requested only once\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (!closed) {\n+                if (iterator.last) {\n+                    // The last page accessed, so the remote cursor is already closed. No-op.\n+                    return;\n+                }\n+\n+                service.close(connection, queryId);\n+            }\n+        } finally {\n+            closed = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NjU0NA==", "bodyText": "What is the meaning for the cursorBufferSize=0?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450856544", "createdAt": "2020-07-07T13:18:16Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientResult.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlRowMetadata;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Client-side cursor.\n+ */\n+public class SqlClientResult implements SqlResult {\n+\n+    private final SqlClientService service;\n+    private final Connection connection;\n+    private final QueryId queryId;\n+    private final SqlRowMetadata rowMetadata;\n+    private final ClientIterator iterator = new ClientIterator();\n+\n+    private int cursorBufferSize;\n+    private boolean closed;\n+    private boolean iteratorAccessed;\n+\n+    public SqlClientResult(\n+        SqlClientService service,\n+        Connection connection,\n+        QueryId queryId,\n+        SqlRowMetadata rowMetadata,\n+        SqlPage page,\n+        int cursorBufferSize\n+    ) {\n+        this.service = service;\n+        this.connection = connection;\n+        this.queryId = queryId;\n+        this.rowMetadata = rowMetadata;\n+        this.cursorBufferSize = cursorBufferSize;\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlRowMetadata getRowMetadata() {\n+        return rowMetadata;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Iterator<SqlRow> iterator() {\n+        if (!iteratorAccessed) {\n+            iteratorAccessed = true;\n+\n+            return iterator;\n+        } else {\n+            throw new IllegalStateException(\"Iterator could be requested only once\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (!closed) {\n+                if (iterator.last) {\n+                    // The last page accessed, so the remote cursor is already closed. No-op.\n+                    return;\n+                }\n+\n+                service.close(connection, queryId);\n+            }\n+        } finally {\n+            closed = true;\n+        }\n+    }\n+\n+    public int getCursorBufferSize() {\n+        return cursorBufferSize;\n+    }\n+\n+    public void setCursorBufferSize(int cursorBufferSize) {\n+        assert cursorBufferSize >= 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzkyMg==", "bodyText": "Shall we add if(closed) check here as well?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450857922", "createdAt": "2020-07-07T13:20:24Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientResult.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlRowMetadata;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Client-side cursor.\n+ */\n+public class SqlClientResult implements SqlResult {\n+\n+    private final SqlClientService service;\n+    private final Connection connection;\n+    private final QueryId queryId;\n+    private final SqlRowMetadata rowMetadata;\n+    private final ClientIterator iterator = new ClientIterator();\n+\n+    private int cursorBufferSize;\n+    private boolean closed;\n+    private boolean iteratorAccessed;\n+\n+    public SqlClientResult(\n+        SqlClientService service,\n+        Connection connection,\n+        QueryId queryId,\n+        SqlRowMetadata rowMetadata,\n+        SqlPage page,\n+        int cursorBufferSize\n+    ) {\n+        this.service = service;\n+        this.connection = connection;\n+        this.queryId = queryId;\n+        this.rowMetadata = rowMetadata;\n+        this.cursorBufferSize = cursorBufferSize;\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlRowMetadata getRowMetadata() {\n+        return rowMetadata;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Iterator<SqlRow> iterator() {\n+        if (!iteratorAccessed) {\n+            iteratorAccessed = true;\n+\n+            return iterator;\n+        } else {\n+            throw new IllegalStateException(\"Iterator could be requested only once\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (!closed) {\n+                if (iterator.last) {\n+                    // The last page accessed, so the remote cursor is already closed. No-op.\n+                    return;\n+                }\n+\n+                service.close(connection, queryId);\n+            }\n+        } finally {\n+            closed = true;\n+        }\n+    }\n+\n+    public int getCursorBufferSize() {\n+        return cursorBufferSize;\n+    }\n+\n+    public void setCursorBufferSize(int cursorBufferSize) {\n+        assert cursorBufferSize >= 0;\n+\n+        this.cursorBufferSize = cursorBufferSize;\n+    }\n+\n+    private void fetchNextPage(ClientIterator iterator) {\n+        SqlPage page = service.fetch(connection, queryId, cursorBufferSize);\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    private List<Row> convertPageRows(List<SqlPageRow> serializedRows) {\n+        List<Row> rows = new ArrayList<>(serializedRows.size());\n+\n+        for (SqlPageRow serializedRow : serializedRows) {\n+            List<Data> serializedValues = serializedRow.getValues();\n+            Object[] values = new Object[serializedValues.size()];\n+\n+            for (int i = 0; i < serializedValues.size(); i++) {\n+                values[i] = service.deserializeRowValue(serializedValues.get(i));\n+            }\n+\n+            rows.add(new HeapRow(values));\n+        }\n+\n+        return rows;\n+    }\n+\n+    /**\n+     * Implementation of lazy iterator, which fetches results as needed.\n+     */\n+    private class ClientIterator implements Iterator<SqlRow> {\n+\n+        private List<Row> currentRows;\n+        private int currentPosition;\n+        private boolean last;\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (closed) {\n+                throw service.rethrow(QueryException.cancelledByUser());\n+            }\n+\n+            while (currentPosition == currentRows.size()) {\n+                // Reached end of the page. Try fetching the next one if possible.\n+                if (!last) {\n+                    fetchNextPage(this);\n+                } else {\n+                    // No more pages expected, so return false.\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public SqlRow next() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2NTUyOQ==", "bodyText": "Javadoc would be useful.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450865529", "createdAt": "2020-07-07T13:31:00Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlPage.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import java.util.List;\n+import java.util.Objects;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2ODMyNg==", "bodyText": "Why do we return the last member in this case?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450868326", "createdAt": "2020-07-07T13:34:52Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/client/txn/ClientTxnUniSocketTest.java", "diffHunk": "@@ -65,6 +65,23 @@ public Member next() {\n                 }\n                 return members[0];\n             }\n+\n+            @Override\n+            public Member nextDataMember() {\n+                Member[] members = getDataMembers();\n+                if (members == null || members.length == 0) {\n+                    return null;\n+                }\n+                if (members.length == 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b258543a7c9921c5e7c043c1035f7ec470c9edeb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b258543a7c9921c5e7c043c1035f7ec470c9edeb", "committedDate": "2020-07-08T07:08:57Z", "message": "JavaDocs for SqlPage."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5bfad4117617a4e3bd5142bcf0e1f9c2c630424", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a5bfad4117617a4e3bd5142bcf0e1f9c2c630424", "committedDate": "2020-07-08T07:12:14Z", "message": "Removed unused methods from SqlClientResult."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "committedDate": "2020-07-08T07:18:26Z", "message": "Minors."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTA3NzMy", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-444507732", "createdAt": "2020-07-08T08:08:37Z", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODowODozN1rOGuc3vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODowODozN1rOGuc3vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MDcwMQ==", "bodyText": "There is no need for SqlExecuteResponse object anymore here.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451360701", "createdAt": "2020-07-08T08:08:37Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+\n+import javax.annotation.Nonnull;\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+\n+            List<Data> params0 = new ArrayList<>(params.size());\n+\n+            for (Object param : params) {\n+                params0.add(serializeParameter(param));\n+            }\n+\n+            ClientMessage requestMessage = SqlExecuteCodec.encodeRequest(\n+                query.getSql(),\n+                params0,\n+                query.getTimeoutMillis(),\n+                query.getCursorBufferSize()\n+            );\n+\n+            ClientMessage responseMessage = invoke(requestMessage, connection);\n+\n+            SqlExecuteCodec.ResponseParameters responseParameters = SqlExecuteCodec.decodeResponse(responseMessage);\n+\n+            SqlExecuteResponse response = new SqlExecuteResponse(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTA4MjI1", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-444508225", "createdAt": "2020-07-08T08:09:19Z", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODowOToxOVrOGuc5NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODowOToxOVrOGuc5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MTA3Ng==", "bodyText": "There is no need for SqlFetchResponse  object anymore here.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451361076", "createdAt": "2020-07-08T08:09:19Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+\n+import javax.annotation.Nonnull;\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+\n+            List<Data> params0 = new ArrayList<>(params.size());\n+\n+            for (Object param : params) {\n+                params0.add(serializeParameter(param));\n+            }\n+\n+            ClientMessage requestMessage = SqlExecuteCodec.encodeRequest(\n+                query.getSql(),\n+                params0,\n+                query.getTimeoutMillis(),\n+                query.getCursorBufferSize()\n+            );\n+\n+            ClientMessage responseMessage = invoke(requestMessage, connection);\n+\n+            SqlExecuteCodec.ResponseParameters responseParameters = SqlExecuteCodec.decodeResponse(responseMessage);\n+\n+            SqlExecuteResponse response = new SqlExecuteResponse(\n+                    responseParameters.queryId,\n+                    responseParameters.rowMetadata,\n+                    responseParameters.rowPage,\n+                    responseParameters.error\n+            );\n+\n+            handleResponseError(response.getError());\n+\n+            return new SqlClientResult(\n+                this,\n+                connection,\n+                response.getQueryId(),\n+                response.getRowMetadata(),\n+                response.getPage(),\n+                query.getCursorBufferSize()\n+            );\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    /**\n+     * Fetch the next page of the given query.\n+     *\n+     * @param connection Connection.\n+     * @param queryId Query ID.\n+     * @return Pair: fetched rows + last page flag.\n+     */\n+    public SqlPage fetch(Connection connection, QueryId queryId, int cursorBufferSize) {\n+        try {\n+            ClientMessage requestMessage = SqlFetchCodec.encodeRequest(queryId, cursorBufferSize);\n+            ClientMessage responseMessage = invoke(requestMessage, connection);\n+            SqlFetchCodec.ResponseParameters responseParameters = SqlFetchCodec.decodeResponse(responseMessage);\n+            SqlFetchResponse response = new SqlFetchResponse(responseParameters.rowPage, responseParameters.error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTQ1NDU1", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-444545455", "createdAt": "2020-07-08T08:56:59Z", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1Njo1OVrOGuerMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1Njo1OVrOGuerMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MDI1OQ==", "bodyText": "Would it be possible to use List<Data> instead of SqlPageRow here. And also in the protocol ?\nIt would eliminate the need for creating a new type in the protocol, as well as creating extra objects here.\nIn the protocol, we may also eliminate SqlPage in the protocol and put the last boolean as one of the response params.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451390259", "createdAt": "2020-07-08T08:56:59Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.state;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.client.SqlPage;\n+import com.hazelcast.sql.impl.client.SqlPageRow;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<SqlPageRow> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private static boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<SqlPageRow> page,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTQ5MDI0", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-444549024", "createdAt": "2020-07-08T09:01:14Z", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTowMToxNFrOGue1ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTowMToxNFrOGue1ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MjkwNg==", "bodyText": "You can eliminate the need for creating SqlFetchResponse class by returning page or error directly.\nencodeResponse method could act accordingle by checking if response is instanceOf Exception or not.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451392906", "createdAt": "2020-07-08T09:01:14Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlFetchMessageTask.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.security.permission.SqlPermission;\n+import com.hazelcast.sql.impl.SqlInternalService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+\n+/**\n+ * SQL query fetch task.\n+ */\n+public class SqlFetchMessageTask extends AbstractCallableMessageTask<SqlFetchCodec.RequestParameters> {\n+    public SqlFetchMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Object call() throws Exception {\n+        UUID localMemberId = nodeEngine.getLocalMember().getUuid();\n+        SqlInternalService service = nodeEngine.getSqlService().getInternalService();\n+\n+        SqlPage page = null;\n+        SqlError error = null;\n+\n+        try {\n+            page = service.getClientStateRegistry().fetch(\n+                endpoint.getUuid(),\n+                parameters.queryId,\n+                parameters.cursorBufferSize,\n+                serializationService\n+            );\n+        } catch (Exception e) {\n+            error = SqlClientUtils.exceptionToClientError(e, localMemberId);\n+        }\n+\n+        return new SqlFetchResponse(page, error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTU4OTE2", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-444558916", "createdAt": "2020-07-08T09:14:24Z", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToxNDoyNFrOGufSZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToxNDoyNFrOGufSZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMDI5Mg==", "bodyText": "@devozerov This part is confusing to me. Can you document when can a client be null? To me, it looked like it can not, or maybe I am missing something.", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451400292", "createdAt": "2020-07-08T09:14:24Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.state;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.client.SqlPage;\n+import com.hazelcast.sql.impl.client.SqlPageRow;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<SqlPageRow> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private static boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<SqlPageRow> page,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        while (iterator.hasNext()) {\n+            SqlRow row = iterator.next();\n+            SqlPageRow convertedRow = convertRow(row, serializationService);\n+\n+            page.add(convertedRow);\n+\n+            if (page.size() == cursorBufferSize) {\n+                break;\n+            }\n+        }\n+\n+        return !iterator.hasNext();\n+    }\n+\n+    private static SqlPageRow convertRow(SqlRow row, InternalSerializationService serializationService) {\n+        int columnCount = row.getMetadata().getColumnCount();\n+\n+        List<Data> values = new ArrayList<>(columnCount);\n+\n+        for (int i = 0; i < columnCount; i++) {\n+            values.add(serializationService.toData(row.getObject(i)));\n+        }\n+\n+        return new SqlPageRow(values);\n+    }\n+\n+    public void close(UUID clientId, QueryId queryId) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor != null) {\n+            clientCursor.getSqlResult().close();\n+\n+            deleteClientCursor(clientCursor);\n+        }\n+    }\n+\n+    public void reset() {\n+        clientCursors.clear();\n+    }\n+\n+    public void update(Set<UUID> activeClientIds) {\n+        List<QueryClientState> victims = new ArrayList<>();\n+\n+        for (QueryClientState clientCursor : clientCursors.values()) {\n+            if (!activeClientIds.contains(clientCursor.getClientId())) {\n+                victims.add(clientCursor);\n+            }\n+        }\n+\n+        for (QueryClientState victim : victims) {\n+            QueryException error = QueryException.clientMemberConnection(victim.getClientId());\n+\n+            victim.getSqlResult().closeOnError(error);\n+\n+            deleteClientCursor(victim);\n+        }\n+    }\n+\n+    private QueryClientState getClientCursor(UUID clientId, QueryId queryId) {\n+        QueryClientState cursor = clientCursors.get(queryId);\n+\n+        if (cursor == null || (clientId != null && !cursor.getClientId().equals(clientId))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODgwNzY1", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-444880765", "createdAt": "2020-07-08T15:27:21Z", "commit": {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cecc200ec59e63dbcf3b0c61a52d151bd4773346", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cecc200ec59e63dbcf3b0c61a52d151bd4773346", "committedDate": "2020-07-09T06:05:00Z", "message": "1) Fixed if-statement in the QueryClientStateRegistry\n2) Changed query ID to String in the protocol\n3) Removed unnecessary allocations in SqlClientService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406e59f944d8dbd814788ac38a18eb806fe74b8c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/406e59f944d8dbd814788ac38a18eb806fe74b8c", "committedDate": "2020-07-09T06:17:04Z", "message": "Execute SQL tasks in the query executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03810a4af80ae36600b3cf4686bbd5f9062538fa", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/03810a4af80ae36600b3cf4686bbd5f9062538fa", "committedDate": "2020-07-09T06:48:12Z", "message": "Removed SqlPage from the protocol level."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49eef72128852d8d8943382a0858061cc5d19fd6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/49eef72128852d8d8943382a0858061cc5d19fd6", "committedDate": "2020-07-09T06:49:14Z", "message": "Merge branch 'master' into issues/17173\n\n# Conflicts:\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/ClientCompatibilityNullTest_2_0_1.java\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/ClientCompatibilityTest_2_0_1.java\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/MemberCompatibilityNullTest_2_0_1.java\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/MemberCompatibilityTest_2_0_1.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dc4fac9bb52b09dd09eb4866760dd033ec97d81", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0dc4fac9bb52b09dd09eb4866760dd033ec97d81", "committedDate": "2020-07-09T06:56:07Z", "message": "Merge with master."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDI5NDQw", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-445429440", "createdAt": "2020-07-09T09:09:04Z", "commit": {"oid": "0dc4fac9bb52b09dd09eb4866760dd033ec97d81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTowOTowNFrOGvIe_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTowOTowNFrOGvIe_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA3NTI2MQ==", "bodyText": "Javadoc of UUID.toString() specifies that the result is always 36 chars, so we could just split there. But UUID.fromString doesn't assume that, so I don't know. The below code is safe in this regard and doesn't deal with regexes.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String[] parts = input.split(\"_\");\n          \n          \n            \n            \n          \n          \n            \n                    if (parts.length != 2) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Query ID is malformed: \" + input);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        UUID memberId = UUID.fromString(parts[0]);\n          \n          \n            \n                        UUID localId = UUID.fromString(parts[1]);\n          \n          \n            \n                    int underscorePos = input.indexOf(\"_\");\n          \n          \n            \n            \n          \n          \n            \n                    if (underscorePos < 0) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Query ID is malformed: \" + input);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        UUID memberId = UUID.fromString(input.substring(0, underscorePos));\n          \n          \n            \n                        UUID localId = UUID.fromString(input.substring(underscorePos + 1);", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r452075261", "createdAt": "2020-07-09T09:09:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java", "diffHunk": "@@ -58,22 +58,72 @@ public QueryId() {\n      * @return Query ID.\n      */\n     public static QueryId create(UUID memberId) {\n-        UUID qryId = UuidUtil.newUnsecureUUID();\n+        UUID localId = UuidUtil.newUnsecureUUID();\n \n         return new QueryId(\n             memberId.getMostSignificantBits(),\n             memberId.getLeastSignificantBits(),\n-            qryId.getMostSignificantBits(),\n-            qryId.getLeastSignificantBits()\n+            localId.getMostSignificantBits(),\n+            localId.getLeastSignificantBits()\n         );\n     }\n \n+    public static QueryId parse(String input) {\n+        assert input != null;\n+\n+        String[] parts = input.split(\"_\");\n+\n+        if (parts.length != 2) {\n+            throw new IllegalArgumentException(\"Query ID is malformed: \" + input);\n+        }\n+\n+        try {\n+            UUID memberId = UUID.fromString(parts[0]);\n+            UUID localId = UUID.fromString(parts[1]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc4fac9bb52b09dd09eb4866760dd033ec97d81"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7570e47f972cd88104a45880fa4e8e60c62ec9af", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7570e47f972cd88104a45880fa4e8e60c62ec9af", "committedDate": "2020-07-09T09:45:14Z", "message": "Update hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "842a479df5e6e856490ccc15e8dff6ba3970488b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/842a479df5e6e856490ccc15e8dff6ba3970488b", "committedDate": "2020-07-09T13:32:19Z", "message": "Fix compilation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "030f982da27dfa9b3d1d4db3d37f0e63e5b4b90d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/030f982da27dfa9b3d1d4db3d37f0e63e5b4b90d", "committedDate": "2020-07-14T11:49:01Z", "message": "Merge branch 'master' into issues/17173"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "244d974d117be1ba270a3164a9293d841db29fc6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/244d974d117be1ba270a3164a9293d841db29fc6", "committedDate": "2020-07-14T12:36:17Z", "message": "Improved compatibility support."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dbba16d216aaee28471e7ca8f4f3933d08e08f2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1dbba16d216aaee28471e7ca8f4f3933d08e08f2", "committedDate": "2020-07-14T14:04:16Z", "message": "Fixes discussed with Asim."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5638d1f5209e63c20fa42cb0816a7b990b25fae5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5638d1f5209e63c20fa42cb0816a7b990b25fae5", "committedDate": "2020-07-15T13:17:49Z", "message": "Merge branch 'master' into issues/17173"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22c58a650cd0be04f31c240d11c2d4d918d68422", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/22c58a650cd0be04f31c240d11c2d4d918d68422", "committedDate": "2020-07-15T13:29:14Z", "message": "WIP on document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baa16db36108a7ed24a49a547ac4e032941fe2b1", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/baa16db36108a7ed24a49a547ac4e032941fe2b1", "committedDate": "2020-07-15T14:50:13Z", "message": "Design doc."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NTg0OTQy", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-449584942", "createdAt": "2020-07-16T07:34:50Z", "commit": {"oid": "baa16db36108a7ed24a49a547ac4e032941fe2b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe7f8ff368bcae77ea7d8277b19010d8369e46fc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fe7f8ff368bcae77ea7d8277b19010d8369e46fc", "committedDate": "2020-07-17T06:50:20Z", "message": "Added missing element to YAML config."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4361ff7d1f8f82daeadc845f8cd74afdeff187d0", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4361ff7d1f8f82daeadc845f8cd74afdeff187d0", "committedDate": "2020-07-17T06:51:16Z", "message": "Merge branch 'master' into issues/17173"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f6d668cf0d5e544929b7d653b53db4dd9d3ce6f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9f6d668cf0d5e544929b7d653b53db4dd9d3ce6f", "committedDate": "2020-07-17T11:18:01Z", "message": "Fix class compliance checks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8bde71f71caab6b2b5040d06a25109a645efbdb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f8bde71f71caab6b2b5040d06a25109a645efbdb", "committedDate": "2020-07-21T18:03:59Z", "message": "Merge branch 'master' into issues/17173"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6151619cc1efacf6ca8db743384ad241481c68f2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6151619cc1efacf6ca8db743384ad241481c68f2", "committedDate": "2020-07-21T18:16:10Z", "message": "Removed SqlRowMetadata from the protocol."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b34d32137b9fbe04f936a5d7ef22c5bb85161a60", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b34d32137b9fbe04f936a5d7ef22c5bb85161a60", "committedDate": "2020-07-23T10:22:08Z", "message": "Merge branch 'master' into issues/17173"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06295b4bc1bff291f926f8921a3f9515bcbdc14f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/06295b4bc1bff291f926f8921a3f9515bcbdc14f", "committedDate": "2020-07-23T10:53:15Z", "message": "Removed SqlRow from the protocol."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fecbe0761967b35a0b93bb13b0fa234f889d551d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fecbe0761967b35a0b93bb13b0fa234f889d551d", "committedDate": "2020-07-23T11:22:51Z", "message": "Use Collection<Collection<Data>> instead of List<List<Data>> for Java protocol definitions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fda547ad5fcb4aea6ec70028934cbd9cc053a25", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3fda547ad5fcb4aea6ec70028934cbd9cc053a25", "committedDate": "2020-07-23T11:35:55Z", "message": "Returned back QueryId to the protocol."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MTI4MDUz", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-454128053", "createdAt": "2020-07-23T13:26:31Z", "commit": {"oid": "3fda547ad5fcb4aea6ec70028934cbd9cc053a25"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyNjozMVrOG2KbWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyNjozMVrOG2KbWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0NzEyOQ==", "bodyText": "Can you update this doc?", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r459447129", "createdAt": "2020-07-23T13:26:31Z", "author": {"login": "asimarslan"}, "path": "docs/design/sql/05-client-support.md", "diffHunk": "@@ -0,0 +1,164 @@\n+05-client-support.md\n+\n+# SQL Client Support\n+\n+## Overview\n+\n+This document describes the design of the client protocol and the corresponding server-side implementation.    \n+\n+The rest of this document is organized as follows. In section 1 we describe the requirements to the implementation. In \n+section 2 we describe the protocol design and implementation concerns. In section 3 we summarize the limitations of the current\n+implementation.\n+\n+## 1 Requirements\n+\n+### 1.1 Pagination\n+\n+The result set might be large enough so that it doesn't fit to client's memory. \n+\n+Therefore, data should be returned to the client in pages.\n+\n+### 1.2 Message Routing\n+\n+The Hazelcast Mustang engine is a distributed SQL query engine. When a query is submitted for execution, the engine splits\n+it into several fragments. The fragments are executed on cluster members. \n+\n+Members executing one or more fragments of the given query are called **participants**. The participant that started execution \n+of the query is called **initiator**. Participants exchange data with each other. On the final execution stage participants send\n+data to the initiator to build the final result set. Only the initiator can return the final result set. \n+\n+Therefore, the implementation should be able to route all requests related to the given query to the query initiator. \n+\n+### 1.3 Lite Members\n+\n+At the moment lite members cannot start queries. I.e. a lite member can never be a query initiator. Note that this limitation\n+is different from other Hazelcast subsystems. Normally, if the operation cannot be executed on the lite member, it is handed \n+over to the normal member transparently. This is not the case for the SQL purely due to time constraints: we do no have enough\n+time to implement it in 4.1. This limitation will be removed in future versions.\n+\n+Therefore, the client should never route query execute requests to the lite members in the 4.1 release. \n+\n+### 1.4 Resource Cleanup\n+\n+When a query is started on the initiator, certain amount of system resources are allocated. The resources are released either\n+when all rows are consumed by the user, or when the explicit `close` command is invoked by the user.\n+\n+Therefore, the implementation must support a distinct `close` command. Also, the implementation must release the resources when\n+the client disconnects.\n+\n+## 2 Protocol\n+\n+The protocol contains three commands: `execute`, `fetch`, and `close`.\n+\n+### 2.1 Common Entities\n+\n+The protocol contains the following common entities that are used across different commands:\n+- **Query ID** - an opaque query identifier of type `String` that is used to locate the server-side cursor on the member", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fda547ad5fcb4aea6ec70028934cbd9cc053a25"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64ecbfc46da530d3fbac8836a95623f283723b58", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/64ecbfc46da530d3fbac8836a95623f283723b58", "committedDate": "2020-07-23T13:33:03Z", "message": "Fixed the design doc reflect that QueryId is no longer a string."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd6e1cf9562c1187abae7dc7b65f9c696b1f9a16", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/dd6e1cf9562c1187abae7dc7b65f9c696b1f9a16", "committedDate": "2020-07-23T13:38:03Z", "message": "Design doc: \"queryId : String\" -> \"queryId : SqlQueryId\""}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MTYwNjQz", "url": "https://github.com/hazelcast/hazelcast/pull/17174#pullrequestreview-454160643", "createdAt": "2020-07-23T13:59:16Z", "commit": {"oid": "dd6e1cf9562c1187abae7dc7b65f9c696b1f9a16"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f5dce5b50cade31600186addab6148e68bc5333", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2f5dce5b50cade31600186addab6148e68bc5333", "committedDate": "2020-07-23T15:10:06Z", "message": "Merge branch 'master' into issues/17173"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3529, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}