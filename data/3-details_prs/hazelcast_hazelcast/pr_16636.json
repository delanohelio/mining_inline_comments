{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNDY1MzQ0", "number": 16636, "title": "Added support for ConcurrentMap.computeIfPresent #11958", "bodyText": "The new computeIfPresent() implementation keeps a clone of the old/existing value and uses that for replace/delete operations. This takes care of the user modifying existing value in-place.\nFixes: #11958", "createdAt": "2020-02-11T04:13:18Z", "url": "https://github.com/hazelcast/hazelcast/pull/16636", "merged": true, "mergeCommit": {"oid": "87baf078bab8002c88a97d467a89b3f93772a458"}, "closed": true, "closedAt": "2020-03-24T11:32:48Z", "author": {"login": "webashutosh"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDJwM7gH2gAyMzczNDY1MzQ0OmMzMWY0MWM3ZWVkYjJmYmE5N2Q5YWU0Y2I2MzQ3YTUxNDEyYTM0NTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQxN4jgFqTM4MDIyMDM0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457", "author": {"user": {"login": "webashutosh", "name": "Ashutosh Agrawal"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c31f41c7eedb2fba97d9ae4cb6347a51412a3457", "committedDate": "2020-02-11T04:09:39Z", "message": "Added support for ConcurrentMap.computeIfPresent #11958"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDEwNjg1", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-356410685", "createdAt": "2020-02-11T04:15:33Z", "commit": {"oid": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNDoxNTozM1rOFn9IBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNDoxNTozM1rOFn9IBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDI2Mw==", "bodyText": "Removing this part of the documentation as Hz is already compiled with Java 8, and we have a plan to support Java 8 methods (#14913).\nHappy to revert this change in case I should keep this until we actually address #14913", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377440263", "createdAt": "2020-02-11T04:15:33Z", "author": {"login": "webashutosh"}, "path": "hazelcast/src/main/java/com/hazelcast/map/IMap.java", "diffHunk": "@@ -70,28 +70,6 @@\n  * {@code entrySet}, return an <b>immutable</b> collection clone of the values.\n  * The collection is <b>NOT</b> backed by the map, so changes to the map are\n  * <b>NOT</b> reflected in the collection.</li>\n- * <li>Since Hazelcast is compiled with Java 1.6, we can't override default\n- * methods introduced in later Java versions, nor can we add documentation\n- * to them. Methods, including but not limited to {@code computeIfPresent},\n- * may behave incorrectly if the value passed to the update function is\n- * modified in-place and returned as a result of the invocation.\n- * You should create a new value instance and return it as a result.\n- * <p>\n- * For example, following code fragment will behave incorrectly and will\n- * enter an infinite loop:\n- * <pre>\n- * map.computeIfPresent(\"key\", (key, value) -&gt; {\n- *     value.setSomeAttribute(\"newAttributeValue\");\n- *     return value;\n- * });\n- * </pre>\n- * It should be replaced with:\n- * <pre>\n- * map.computeIfPresent(\"key\", (key, value) -&gt; {\n- *     return new ObjectWithSomeAttribute(\"newAttributeValue\");\n- * });\n- * </pre>\n- * </li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDExMDUz", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-356411053", "createdAt": "2020-02-11T04:17:52Z", "commit": {"oid": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNDoxNzo1M1rOFn9JKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNDoxNzo1M1rOFn9JKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ==", "bodyText": "I could not think of a way to combine the get() + replace() operation into a single remote call. Mainly because I don't know how to send the BiFunction code/body across the wire (the function may've used classes/utilities that are only present on the client JVM)", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377440555", "createdAt": "2020-02-11T04:17:53Z", "author": {"login": "webashutosh"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxyImpl.java", "diffHunk": "@@ -1025,4 +1026,27 @@ private static void checkNotPagingPredicate(Predicate predicate, String method)\n             throw new IllegalArgumentException(\"PagingPredicate not supported in \" + method + \" method\");\n         }\n     }\n+\n+    @Override\n+    public V computeIfPresent(K key,\n+                               BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);\n+\n+        while (true) {\n+            Data oldValueData = toData(getInternal(key));\n+            if (oldValueData == null) {\n+                return null;\n+            }\n+\n+            V oldValueClone = toObject(oldValueData);\n+            V newValue = remappingFunction.apply(key, oldValueClone);\n+            if (newValue != null) {\n+                if (replaceInternal(key, oldValueData, toData(newValue))) {\n+                    return newValue;\n+                }\n+            } else if (removeInternal(key, oldValueData)) {\n+                return null;\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c783f1955bfc87861f783a6a3c168f8cc6831c16", "author": {"user": {"login": "webashutosh", "name": "Ashutosh Agrawal"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c783f1955bfc87861f783a6a3c168f8cc6831c16", "committedDate": "2020-02-29T05:27:24Z", "message": "Added support for ConcurrentMap.computeIfPresent #11958 #14913"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "author": {"user": {"login": "webashutosh", "name": "Ashutosh Agrawal"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bc5711f30f81e60eb98fbfc7e481ef78256a0108", "committedDate": "2020-02-29T05:38:51Z", "message": "Removed unnecessary exception handling #11958 #14913"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Nzc5NTgw", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-366779580", "createdAt": "2020-02-29T05:46:09Z", "commit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNTo0NjoxMFrOFwH02Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNTo0NjoxMFrOFwH02Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNDE4NQ==", "bodyText": "These tests cover execution from both the client and the server (we need to execute the same set of tests for both). So I didn't write a separate test class for the client.", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r386004185", "createdAt": "2020-02-29T05:46:10Z", "author": {"login": "webashutosh"}, "path": "hazelcast/src/test/java/com/hazelcast/map/ComputeConditionallyTests.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.nio.serialization.HazelcastSerializationException;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import testsubjects.ClientOnlyStaticSerializableBiFunction;\n+import testsubjects.NonStaticFunctionFactory;\n+import testsubjects.StaticNonSerializableBiFunction;\n+import testsubjects.StaticSerializableBiFunction;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ComputeConditionallyTests extends HazelcastTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2OTIyNjgz", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-366922683", "createdAt": "2020-03-02T02:36:49Z", "commit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMjozNjo0OVrOFwSNkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMjozNjo0OVrOFwSNkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3NDM1NA==", "bodyText": "From here down, its all test classes I wrote in non-hazelcast base package.\nThese are to make sure that the solution works for static/non-static and serializable/non-serializable bi-functions", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r386174354", "createdAt": "2020-03-02T02:36:49Z", "author": {"login": "webashutosh"}, "path": "hazelcast/src/test/java/testsubjects/ClientOnlyStaticSerializableBiFunction.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODAzMDc3", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-368803077", "createdAt": "2020-03-04T14:05:30Z", "commit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDowNTozMFrOFxuf9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozODoxNlrOFxvxpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NjM4OQ==", "bodyText": "Maybe it's an overkill having a separate class for this, you can move this to ComputeConditionallyTests.\nAlso, can you move the package testsubjects under com.hazelcast.test. And what does testsubjects stand for?", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387686389", "createdAt": "2020-03-04T14:05:30Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/testsubjects/NonStaticFunctionFactory.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package testsubjects;\n+\n+import java.util.function.BiFunction;\n+\n+public class NonStaticFunctionFactory {\n+\n+    private NonStaticFunctionFactory() {\n+    }\n+\n+    public static BiFunction<String, String, String> getAnonymousNonSerializableBiFunction(final String returnValue) {\n+        return new BiFunction<String, String, String>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4ODE2Ng==", "bodyText": "You can use com.hazelcast.internal.util.RootCauseMatcher instead. See here for an example.", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387688166", "createdAt": "2020-03-04T14:08:32Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/map/ComputeConditionallyTests.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.nio.serialization.HazelcastSerializationException;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import testsubjects.ClientOnlyStaticSerializableBiFunction;\n+import testsubjects.NonStaticFunctionFactory;\n+import testsubjects.StaticNonSerializableBiFunction;\n+import testsubjects.StaticSerializableBiFunction;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ComputeConditionallyTests extends HazelcastTestSupport {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    private HazelcastInstance server;\n+    private HazelcastInstance client;\n+\n+    @Before\n+    public void setup() {\n+        ClassLoader customClassLoader = new ClassLoader(Thread.currentThread().getContextClassLoader().getParent()) {\n+        };\n+        Config config = getConfig();\n+        config.setClassLoader(customClassLoader);\n+        config.getUserCodeDeploymentConfig().setEnabled(true);\n+        server = hazelcastFactory.newHazelcastInstance(config);\n+\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.getUserCodeDeploymentConfig().setEnabled(true);\n+        clientConfig.getUserCodeDeploymentConfig().addClass(StaticSerializableBiFunction.class);\n+        clientConfig.getUserCodeDeploymentConfig().addClass(StaticNonSerializableBiFunction.class);\n+        client = hazelcastFactory.newHazelcastClient(clientConfig);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testComputeIfPresentWithLambdaReMappingFunction() {\n+        final String outer_state = \"outer_state\";\n+        BiFunction biFunction = (key, oldValue) -> \"new_value_from_lambda_and_\" + outer_state;\n+        testComputeIfPresentForFunction(biFunction, \"new_value_from_lambda_and_outer_state\");\n+    }\n+\n+\n+    @Test\n+    public void testComputeIfPresentWithAnonymousReMappingFunction() {\n+        BiFunction<String, String, String> biFunction = NonStaticFunctionFactory\n+                .getAnonymousNonSerializableBiFunction(\"new_value\");\n+        testComputeIfPresentForFunction(biFunction, \"new_value\");\n+    }\n+\n+    @Test\n+    public void testComputeIfPresentWithStaticSerializableRemappingFunction() {\n+        StaticSerializableBiFunction biFunction = new StaticSerializableBiFunction(\"new_value\");\n+        testComputeIfPresentForFunction(biFunction, \"new_value\");\n+    }\n+\n+    @Test\n+    public void testComputeIfPresentWithStaticNonSerializableRemappingFunction() {\n+        StaticNonSerializableBiFunction biFunction = new StaticNonSerializableBiFunction(\"new_value\");\n+        testComputeIfPresentForFunction(biFunction, \"new_value\");\n+    }\n+\n+    @Test(expected = ClassNotFoundException.class)\n+    public void testComputeIfPresentWithRemappingFunctionPresentOnClientJVMOnly() throws Throwable {\n+        ClientOnlyStaticSerializableBiFunction biFunction = new ClientOnlyStaticSerializableBiFunction(\"new_value\");\n+        try {\n+            testComputeIfPresentForFunction(biFunction, \"new_value\");\n+        } catch (HazelcastSerializationException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA==", "bodyText": "You can move these kind of methods in SerializationUtil. Specifically, there is already a similar method there - SerializationUtil#checkSerializable.\nA bigger issue is that this does not cover some serialisation techniques that HZ supports, such as IdentifiedDataSerializable, DataSerializable and others. For instance (although it's not that common), the user can define a function like this:\npublic class IDSBiFunction implements BiFunction<String, String, String>, IdentifiedDataSerializable {\n    private String returnValue;\n    public IDSBiFunction() {\n    }\n\n    public IDSBiFunction(String returnValue) {\n        this.returnValue = returnValue;\n    }\n\n    @Override\n    public String apply(String key, String oldValue) {\n        return returnValue;\n    }\n\n    @Override\n    public int getFactoryId() {\n        return 1;\n    }\n\n    @Override\n    public int getClassId() {\n        return 0;\n    }\n\n    @Override\n    public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeUTF(returnValue);\n    }\n\n    @Override\n    public void readData(ObjectDataInput in) throws IOException {\n        returnValue = in.readUTF();\n    }\n}\nIf this class is registered with a factory, such as: config.getSerializationConfig().addDataSerializableFactory(1, typeId -> new IDSBiFunction());, it will be possible to serialize and deserialize the class.\nUnfortunately, checking for all possible serialization strategies is probably not going to be easy to do in a utility method. I was initially thinking that we should simply try to serialise the function here but that might incur an unnecessary overhead for most users trying to submit non-serializable functions. So maybe for a best-effort approach we can additionally check if the class inherits DataSerializable or Portable.  If the class doesn't implement these but is serializable, we can always add more checks in the future.\n@cangencer @taburet WDYT?", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387690210", "createdAt": "2020-03-04T14:12:00Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ClassMetadataUtil.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import java.io.Serializable;\n+\n+public final class ClassMetadataUtil {\n+\n+    private ClassMetadataUtil() {\n+    }\n+\n+    public static boolean isClassStaticAndSerializable(Class clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzMwMA==", "bodyText": "It would be great if you could make this class implement IdentifiedDataSerializable since currently this class uses java serialisation which is not efficient and does not allow class evolution. It does get complicated here, though. Once you add the interface, you'll have to implement some additional methods, like:\n@Override\n    public int getFactoryId() {\n        return MapDataSerializerHook.F_ID;\n    }\n\n    @Override\n    public int getClassId() {\n        return MapDataSerializerHook.BI_FUNCTION_EXECUTING_EP;\n    }\n\n    @Override\n    public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeObject(biFunction);\n    }\n\n    @Override\n    public void readData(ObjectDataInput in) throws IOException {\n        biFunction = in.readObject();\n    }\n\nThis will also require adding a new row in MapDataSerializerHook but also a new client message and you'll need to modify the client protocol. I suggest you look at the EntryRemovingProcessor class and how it's instantiated and used from other parts of the code.", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387707300", "createdAt": "2020-03-04T14:38:16Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/BiFunctionExecutingEntryProcessor.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl;\n+\n+import com.hazelcast.map.EntryProcessor;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+public class BiFunctionExecutingEntryProcessor<K, V> implements EntryProcessor<K, V, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d", "author": {"user": {"login": "webashutosh", "name": "Ashutosh Agrawal"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a4ca6a9cc86274a8b33db2a859124c7a2de5f16d", "committedDate": "2020-03-06T13:37:18Z", "message": "Addressed review comments #11958 #14913"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1OTczNjI4", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-375973628", "createdAt": "2020-03-17T12:07:42Z", "commit": {"oid": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjowNzo0MlrOF3ZXUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjoxNjoxMFrOF3ZnxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMTU3MA==", "bodyText": "IMHO Looks good now. You're going to have to add one more check. We have a feature calling \"rolling upgrade\" where a cluster can be consisted out of members with 1 minor version difference. This means, if this feature is released in 4.1, the cluster may contain members with version 4.0 which will not be able to deserialise the new entry processor. So, the check should be added:\nVersion clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n\n        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)\n                && clusterVersion.isGreaterOrEqual(Versions.V4_1)) {", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393631570", "createdAt": "2020-03-17T12:07:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxyImpl.java", "diffHunk": "@@ -1025,4 +1028,41 @@ private static void checkNotPagingPredicate(Predicate predicate, String method)\n             throw new IllegalArgumentException(\"PagingPredicate not supported in \" + method + \" method\");\n         }\n     }\n+\n+    @Override\n+    public V computeIfPresent(K key,\n+                              BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);\n+        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);\n+\n+        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNTc4MA==", "bodyText": "This is where it gets tricky again. The client is not aware of the version of the cluster it is connected to. So it might happen that the function is serializable and static and is sent to the cluster but the cluster members fail to deserialise it. Unfortunately, this would mean there is no other option for the user but to not have a serializable function when calling from the client or to upgrade the member versions.\nI don't have a good idea how to tackle this. As a poor-man's solution (but, still better than an infinite loop which we have now), we can avoid this optimisation on the client and simply use computeIfPresentLocally in all cases. WDYT? cc @sancar", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393635780", "createdAt": "2020-03-17T12:16:10Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientMapProxy.java", "diffHunk": "@@ -1984,4 +1988,39 @@ protected void onDestroy() {\n             super.onDestroy();\n         }\n     }\n+\n+    @Override\n+    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);\n+        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);\n+\n+        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b5eedd2ece3ec0d9a3a2f9a3826f55c9daaf044", "author": {"user": {"login": "webashutosh", "name": "Ashutosh Agrawal"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2b5eedd2ece3ec0d9a3a2f9a3826f55c9daaf044", "committedDate": "2020-03-21T17:39:54Z", "message": "Addressed review comments #11958 #14913"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96621632ebbae3111c353524bea837ea29a9cb2f", "author": {"user": {"login": "webashutosh", "name": "Ashutosh Agrawal"}}, "url": "https://github.com/hazelcast/hazelcast/commit/96621632ebbae3111c353524bea837ea29a9cb2f", "committedDate": "2020-03-21T17:56:54Z", "message": "Addressed review comments #11958 #14913"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MTUxMDcy", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-379151072", "createdAt": "2020-03-23T06:05:15Z", "commit": {"oid": "96621632ebbae3111c353524bea837ea29a9cb2f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMjIwMzQy", "url": "https://github.com/hazelcast/hazelcast/pull/16636#pullrequestreview-380220342", "createdAt": "2020-03-24T11:29:23Z", "commit": {"oid": "96621632ebbae3111c353524bea837ea29a9cb2f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3969, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}