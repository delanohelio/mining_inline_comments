{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDkzOTQ2", "number": 17037, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxMTo1N1rOECJYcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxNToxNlrOEdMbzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg2MzIxOnYy", "diffSide": "RIGHT", "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxMTo1N1rOGebIAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjozMDoxN1rOGfsjNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NDg4Mw==", "bodyText": "How was this \"one minute\" decided? Based on what?", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r434554883", "createdAt": "2020-06-03T13:11:57Z", "author": {"login": "Holmistr"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.\n+ *\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityEvent {\n+\n+    /**\n+     * Returns the id of the related CP group.\n+     *\n+     * @return CP group id\n+     */\n+    CPGroupId getGroupId();\n+\n+    /**\n+     * Returns the current members of the CP group.\n+     *\n+     * @return group members\n+     */\n+    Collection<CPMember> getGroupMembers();\n+\n+    /**\n+     * Returns the unavailable members of the CP group.\n+     *\n+     * @return unavailable members\n+     */\n+    Collection<CPMember> getUnavailableMembers();\n+\n+    /**\n+     * Returns the majority member count of the CP group.\n+     * Simply it's {@code (memberCount/2) + 1}\n+     *\n+     * @return majority\n+     */\n+    int getMajority();\n+\n+    /**\n+     * Returns whether this group has the majority of its members available or not.\n+     *\n+     * @return true if the group still has the majority, false otherwise\n+     */\n+    boolean isMajorityAvailable();\n+\n+    /**\n+     * Returns whether this is the METADATA CP group or not.\n+     *\n+     * @return true if the group is METADATA group, false otherwise\n+     */\n+    boolean isMetadataGroup();\n+}\n+```\n+\n+## Technical Design\n+\n+CP group operations are performed by METADATA group. Because of this, events for group availability changes are published \n+by METADATA members.\n+\n+In general, availability decreases when a CP member becomes unreachable because of process crash, network partition, \n+out of memory etc. Tracking CP group availability is not as strict as CP membership changes. It relies on Hazelcast's \n+unreliable membership failure detectors. Once a member is declared as unavailable by the Hazelcast's failure detector, \n+that member is removed from the cluster. When a Hazelcast member is removed from the cluster, all METADATA group members \n+iterate over CP groups to find out the ones having a member with the same address as the removed member. If a group is \n+affected by the member's removal, then a new `CPGroupAvailabilityEvent` is published for that group. That group can be \n+METADATA group itself too.\n+\n+Since all available METADATA members produce the same `CPGroupAvailabilityEvent` for a specific member removal, \n+it's possible to receive multiple instances of the same event. To avoid this issue, a deduplication filter is applied \n+before invoking `CPGroupAvailabilityListener`. Events with the exact same signature in a _one minute_ period will be \n+discarded, only the first instance of them will be passed to the listeners. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2OTU2Mw==", "bodyText": "I think one min is long enough window to receive events from all members.\n\nIf this value is too high, then we can skip some real new events. For instance, when persistence is enabled, a member can come and go a in a few minutes.\nIf it's too low, then we can show fire multiple events for a single event when a late event comes.\n\nIf it was 5mins, then you would ask why it is 5min. If I make it configurable, then I would need a default value. And how would user decide on a good value?", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r434569563", "createdAt": "2020-06-03T13:33:56Z", "author": {"login": "mdogan"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.\n+ *\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityEvent {\n+\n+    /**\n+     * Returns the id of the related CP group.\n+     *\n+     * @return CP group id\n+     */\n+    CPGroupId getGroupId();\n+\n+    /**\n+     * Returns the current members of the CP group.\n+     *\n+     * @return group members\n+     */\n+    Collection<CPMember> getGroupMembers();\n+\n+    /**\n+     * Returns the unavailable members of the CP group.\n+     *\n+     * @return unavailable members\n+     */\n+    Collection<CPMember> getUnavailableMembers();\n+\n+    /**\n+     * Returns the majority member count of the CP group.\n+     * Simply it's {@code (memberCount/2) + 1}\n+     *\n+     * @return majority\n+     */\n+    int getMajority();\n+\n+    /**\n+     * Returns whether this group has the majority of its members available or not.\n+     *\n+     * @return true if the group still has the majority, false otherwise\n+     */\n+    boolean isMajorityAvailable();\n+\n+    /**\n+     * Returns whether this is the METADATA CP group or not.\n+     *\n+     * @return true if the group is METADATA group, false otherwise\n+     */\n+    boolean isMetadataGroup();\n+}\n+```\n+\n+## Technical Design\n+\n+CP group operations are performed by METADATA group. Because of this, events for group availability changes are published \n+by METADATA members.\n+\n+In general, availability decreases when a CP member becomes unreachable because of process crash, network partition, \n+out of memory etc. Tracking CP group availability is not as strict as CP membership changes. It relies on Hazelcast's \n+unreliable membership failure detectors. Once a member is declared as unavailable by the Hazelcast's failure detector, \n+that member is removed from the cluster. When a Hazelcast member is removed from the cluster, all METADATA group members \n+iterate over CP groups to find out the ones having a member with the same address as the removed member. If a group is \n+affected by the member's removal, then a new `CPGroupAvailabilityEvent` is published for that group. That group can be \n+METADATA group itself too.\n+\n+Since all available METADATA members produce the same `CPGroupAvailabilityEvent` for a specific member removal, \n+it's possible to receive multiple instances of the same event. To avoid this issue, a deduplication filter is applied \n+before invoking `CPGroupAvailabilityListener`. Events with the exact same signature in a _one minute_ period will be \n+discarded, only the first instance of them will be passed to the listeners. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NDg4Mw=="}, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4ODk1MQ==", "bodyText": "Ok, sounds reasonable. I'm fine with the decision then as I understand the problems.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r435888951", "createdAt": "2020-06-05T12:30:17Z", "author": {"login": "Holmistr"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.\n+ *\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityEvent {\n+\n+    /**\n+     * Returns the id of the related CP group.\n+     *\n+     * @return CP group id\n+     */\n+    CPGroupId getGroupId();\n+\n+    /**\n+     * Returns the current members of the CP group.\n+     *\n+     * @return group members\n+     */\n+    Collection<CPMember> getGroupMembers();\n+\n+    /**\n+     * Returns the unavailable members of the CP group.\n+     *\n+     * @return unavailable members\n+     */\n+    Collection<CPMember> getUnavailableMembers();\n+\n+    /**\n+     * Returns the majority member count of the CP group.\n+     * Simply it's {@code (memberCount/2) + 1}\n+     *\n+     * @return majority\n+     */\n+    int getMajority();\n+\n+    /**\n+     * Returns whether this group has the majority of its members available or not.\n+     *\n+     * @return true if the group still has the majority, false otherwise\n+     */\n+    boolean isMajorityAvailable();\n+\n+    /**\n+     * Returns whether this is the METADATA CP group or not.\n+     *\n+     * @return true if the group is METADATA group, false otherwise\n+     */\n+    boolean isMetadataGroup();\n+}\n+```\n+\n+## Technical Design\n+\n+CP group operations are performed by METADATA group. Because of this, events for group availability changes are published \n+by METADATA members.\n+\n+In general, availability decreases when a CP member becomes unreachable because of process crash, network partition, \n+out of memory etc. Tracking CP group availability is not as strict as CP membership changes. It relies on Hazelcast's \n+unreliable membership failure detectors. Once a member is declared as unavailable by the Hazelcast's failure detector, \n+that member is removed from the cluster. When a Hazelcast member is removed from the cluster, all METADATA group members \n+iterate over CP groups to find out the ones having a member with the same address as the removed member. If a group is \n+affected by the member's removal, then a new `CPGroupAvailabilityEvent` is published for that group. That group can be \n+METADATA group itself too.\n+\n+Since all available METADATA members produce the same `CPGroupAvailabilityEvent` for a specific member removal, \n+it's possible to receive multiple instances of the same event. To avoid this issue, a deduplication filter is applied \n+before invoking `CPGroupAvailabilityListener`. Events with the exact same signature in a _one minute_ period will be \n+discarded, only the first instance of them will be passed to the listeners. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NDg4Mw=="}, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg5NTAyOnYy", "diffSide": "RIGHT", "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMDowOFrOGebcrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1MTowMlrOGftNKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDE3NA==", "bodyText": "I'm wondering whether we could (or it makes sense) fire an event whenever the CP group majority is back again. Kind of like \"split brain healed\" kind of thing.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r434560174", "createdAt": "2020-06-03T13:20:08Z", "author": {"login": "Holmistr"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NTA4OQ==", "bodyText": "I thought about it too. But it's not very straightforward. Because in this case, we are monitoring the CP group from outside, I mean outside of the Raft consensus. That's why we track unavailability of a member based on Hazelcast's failure detector. If a member is removed from cluster, it's clear that availability is decreased. But a member joining to cluster does not mean it's still part of the CP group and can interact in consensus. It might be a different member started on the same address, it might have lost the CP data. We cannot observe that from outside of the group.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r434575089", "createdAt": "2020-06-03T13:41:06Z", "author": {"login": "mdogan"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDE3NA=="}, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NTcyMg==", "bodyText": "If it's requested too, later we can add them. It needs more work.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r434575722", "createdAt": "2020-06-03T13:42:00Z", "author": {"login": "mdogan"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDE3NA=="}, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTY4OA==", "bodyText": "Ok, agreed. Since it's not so trivial, let's not invest more time in it unless requested.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r435899688", "createdAt": "2020-06-05T12:51:02Z", "author": {"login": "Holmistr"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,145 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPGroupAvailabilityEvent is published when a CP group's\n+ * availability is decreased or it has lost the majority completely.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDE3NA=="}, "originalCommit": {"oid": "a34118a356048688e49aeab0f921c279315e1563"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTIxODgwOnYy", "diffSide": "RIGHT", "path": "docs/design/cpsubsystem/01-membership-listener.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxNzo1M1rOGuAvcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxNzo1M1rOGuAvcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5OTgyNg==", "bodyText": "Typo: especially if CP members crash?", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r450899826", "createdAt": "2020-07-07T14:17:53Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/cpsubsystem/01-membership-listener.md", "diffHunk": "@@ -0,0 +1,130 @@\n+# CP Subsystem Membership Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4ea9b0d4021018456c6d45d7a0bf09cc6dc075c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTIyMTA0OnYy", "diffSide": "RIGHT", "path": "docs/design/cpsubsystem/01-membership-listener.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxODoyM1rOGuAw7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxODoyM1rOGuAw7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMDIwNQ==", "bodyText": "Minor: is to add?", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r450900205", "createdAt": "2020-07-07T14:18:23Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/cpsubsystem/01-membership-listener.md", "diffHunk": "@@ -0,0 +1,130 @@\n+# CP Subsystem Membership Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to listen events for CP member additions and removals.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4ea9b0d4021018456c6d45d7a0bf09cc6dc075c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTIyNDA4OnYy", "diffSide": "RIGHT", "path": "docs/design/cpsubsystem/01-membership-listener.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxOTowN1rOGuAy4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxOTowN1rOGuAy4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMDcwNg==", "bodyText": "Minor: are performed by?", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r450900706", "createdAt": "2020-07-07T14:19:07Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/cpsubsystem/01-membership-listener.md", "diffHunk": "@@ -0,0 +1,130 @@\n+# CP Subsystem Membership Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to listen events for CP member additions and removals.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPMembershipListener to listen CP membership changes.\n+     *\n+     * @param listener membership listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addMembershipListener(CPMembershipListener listener);\n+\n+    /**\n+     * Removes membership listener registration. Previously registered listener\n+     * will not receive further events.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeMembershipListener(UUID id);\n+```                        \n+\n+A new `CPMembershipListener` interface and a new `CPMembershipEvent` interface will be added to the CP Subsystem \n+module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPMembershipListener is notified when a CP member is added to\n+ * or removed from the CP Subsystem.\n+ *\n+ * @since 4.1\n+ */\n+public interface CPMembershipListener extends EventListener {\n+\n+    /**\n+     * Called when a new CP member is added to the CP Subsystem.\n+     *\n+     * @param event membership event\n+     */\n+    void memberAdded(CPMembershipEvent event);\n+\n+    /**\n+     * Called when a CP member is removed from the CP Subsystem.\n+     *\n+     * @param event membership event\n+     */\n+    void memberRemoved(CPMembershipEvent event);\n+}\n+```       \n+\n+```java \n+/**\n+ * CPMembershipEvent is published when a CP member is added to\n+ * or removed from the CP Subsystem.\n+ *\n+ * @since 4.1\n+ */\n+public interface CPMembershipEvent {\n+\n+    /**\n+     * Membership event type.\n+     */\n+    enum EventType { ADDED, REMOVED }\n+\n+    /**\n+     * Returns the CPMember that is added to\n+     * or removed from CP Subsystem.\n+     *\n+     * @return the CP member\n+     */\n+    CPMember getMember();\n+\n+    /**\n+     * Returns the type of membership change.\n+     *\n+     * @return membership event type\n+     */\n+    EventType getType();\n+}\n+```        \n+\n+`CPMembershipListener` can be registered in declarative configuration too, similar to regular `MembershipListener`.\n+\n+```xml\n+<hazelcast>\n+    ...\n+\n+    <listeners>\n+        <listener>com.hazelcast.examples.CPMembershipListener</listener>\n+    </listeners>\n+\n+    ...\n+</hazelcast>\n+```          \n+\n+```yaml\n+hazelcast:\n+  ...\n+\n+  listeners:\n+    - com.hazelcast.examples.CPMembershipListener\n+\n+  ...\n+```\n+\n+## Technical Design\n+\n+CP membership changes performed by METADATA group using Raft consensus mechanism. Because of this, events for membership ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4ea9b0d4021018456c6d45d7a0bf09cc6dc075c"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTIzMzI2OnYy", "diffSide": "RIGHT", "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMTowN1rOGuA40Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMTowN1rOGuA40Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMjIyNQ==", "bodyText": "Which method will be called when CP group restores availability?", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r450902225", "createdAt": "2020-07-07T14:21:07Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/cpsubsystem/02-group-availability-listener.md", "diffHunk": "@@ -0,0 +1,169 @@\n+# CP Subsystem Group Availability Listener\n+\n+|\u2139\ufe0f Since: 4.1| \n+|-------------|\n+\n+## Background\n+\n+CP Subsystem requires manual user intervention in some cases, especially CP members crash or become unreachable. \n+But there's no programmatic way of monitoring CP members. Users should track Hazelcast logs or look at Management Center \n+to see any problems in CP membership healthiness. \n+\n+Our goal in this work to add a new listener to the CP Subsystem to get notified when availability of a CP group decreases. \n+This also covers majority loss of a CP group.\n+\n+\n+## API Design\n+\n+Two new methods will be added to the CPSubsystem interface, to register and deregister listeners.\n+\n+```java\n+    /**\n+     * Registers a new CPGroupAvailabilityListener to listen CP group availability changes.\n+     *\n+     * @param listener group availability listener\n+     * @return id of the listener registration\n+     * @since 4.1\n+     */\n+    UUID addGroupAvailabilityListener(CPGroupAvailabilityListener listener);\n+\n+    /**\n+     * Removes CPGroupAvailabilityListener registration.\n+     *\n+     * @param id of the registration\n+     * @return true if listener registration is removed, false otherwise\n+     * @since 4.1\n+     */\n+    boolean removeGroupAvailabilityListener(UUID id);\n+```                        \n+\n+A new `CPGroupAvailabilityListener` interface and a new `CPGroupAvailabilityEvent` interface will be added to the \n+CP Subsystem module under `com.hazelcast.cp.event` package.\n+\n+```java\n+/**\n+ * CPGroupAvailabilityListener is notified when availability\n+ * of a CP group decreases or it loses the majority completely.\n+ * @since 4.1\n+ */\n+public interface CPGroupAvailabilityListener extends EventListener {\n+\n+    /**\n+     * Called when a CP group's availability decreases,\n+     * but still has the majority of members available.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void availabilityDecreased(CPGroupAvailabilityEvent event);\n+\n+    /**\n+     * Called when a CP group has lost its majority.\n+     *\n+     * @param event CP group availability event\n+     */\n+    void majorityLost(CPGroupAvailabilityEvent event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4ea9b0d4021018456c6d45d7a0bf09cc6dc075c"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ3ODg2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/RaftService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxNToxNlrOHINjag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjozNjowOFrOHIOSmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjcxNA==", "bodyText": "If we throw an exception here, the availability event might be missing.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r478372714", "createdAt": "2020-08-27T12:15:16Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/RaftService.java", "diffHunk": "@@ -1336,6 +1380,59 @@ public void applyUnsafeModeState(int partitionId, UnsafeModePartitionState state\n         unsafeModeStates[partitionId].apply(state);\n     }\n \n+    public UUID registerMembershipListener(CPMembershipListener listener) {\n+        return nodeEngine.getEventService().registerListener(SERVICE_NAME, EVENT_TOPIC_MEMBERSHIP, listener).getId();\n+    }\n+\n+    public boolean removeMembershipListener(UUID id) {\n+        return nodeEngine.getEventService().deregisterListener(SERVICE_NAME, EVENT_TOPIC_MEMBERSHIP, id);\n+    }\n+\n+    public UUID registerAvailabilityListener(CPGroupAvailabilityListener listener) {\n+        return nodeEngine.getEventService().registerListener(SERVICE_NAME, EVENT_TOPIC_AVAILABILITY, listener).getId();\n+    }\n+\n+    public boolean removeAvailabilityListener(UUID id) {\n+        return nodeEngine.getEventService().deregisterListener(SERVICE_NAME, EVENT_TOPIC_AVAILABILITY, id);\n+    }\n+\n+    @Override\n+    public void dispatchEvent(Object e, EventListener l) {\n+        long now = Clock.currentTimeMillis();\n+        recentAvailabilityEvents.values().removeIf(expirationTime -> expirationTime < now);\n+\n+        if (e instanceof CPMembershipEvent) {\n+            CPMembershipEvent event = (CPMembershipEvent) e;\n+            CPMembershipListener listener = (CPMembershipListener) l;\n+            switch (event.getType()) {\n+                case ADDED:\n+                    listener.memberAdded(event);\n+                    break;\n+                case REMOVED:\n+                    listener.memberRemoved(event);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unhandled event: \" + event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425569efd1a4fd63ad5e2bb3e88e5e92662ca602"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM4NDc5Mw==", "bodyText": "At this point we already know event object is instance of CPMembershipEvent. This default case should be unreachable under normal conditions, it's just for the case we add a new CPMembershipEvent type.", "url": "https://github.com/hazelcast/hazelcast/pull/17037#discussion_r478384793", "createdAt": "2020-08-27T12:36:08Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/RaftService.java", "diffHunk": "@@ -1336,6 +1380,59 @@ public void applyUnsafeModeState(int partitionId, UnsafeModePartitionState state\n         unsafeModeStates[partitionId].apply(state);\n     }\n \n+    public UUID registerMembershipListener(CPMembershipListener listener) {\n+        return nodeEngine.getEventService().registerListener(SERVICE_NAME, EVENT_TOPIC_MEMBERSHIP, listener).getId();\n+    }\n+\n+    public boolean removeMembershipListener(UUID id) {\n+        return nodeEngine.getEventService().deregisterListener(SERVICE_NAME, EVENT_TOPIC_MEMBERSHIP, id);\n+    }\n+\n+    public UUID registerAvailabilityListener(CPGroupAvailabilityListener listener) {\n+        return nodeEngine.getEventService().registerListener(SERVICE_NAME, EVENT_TOPIC_AVAILABILITY, listener).getId();\n+    }\n+\n+    public boolean removeAvailabilityListener(UUID id) {\n+        return nodeEngine.getEventService().deregisterListener(SERVICE_NAME, EVENT_TOPIC_AVAILABILITY, id);\n+    }\n+\n+    @Override\n+    public void dispatchEvent(Object e, EventListener l) {\n+        long now = Clock.currentTimeMillis();\n+        recentAvailabilityEvents.values().removeIf(expirationTime -> expirationTime < now);\n+\n+        if (e instanceof CPMembershipEvent) {\n+            CPMembershipEvent event = (CPMembershipEvent) e;\n+            CPMembershipListener listener = (CPMembershipListener) l;\n+            switch (event.getType()) {\n+                case ADDED:\n+                    listener.memberAdded(event);\n+                    break;\n+                case REMOVED:\n+                    listener.memberRemoved(event);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unhandled event: \" + event);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjcxNA=="}, "originalCommit": {"oid": "425569efd1a4fd63ad5e2bb3e88e5e92662ca602"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 558, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}