{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MjYxNzMw", "number": 17121, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDo1NTo1MVrOEH6u4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDo1NTo1MVrOEH6u4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NzM3NzYyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDo1NTo1MVrOGnj_2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDo1NTo1MVrOGnj_2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNzQzMw==", "bodyText": "use throw ExceptionUtil.rethrow(ex); instead here. If ex is already a runtime exception, it will be thrown as is, otherwise it will be wrapped in a HazelcastException.", "url": "https://github.com/hazelcast/hazelcast/pull/17121#discussion_r444137433", "createdAt": "2020-06-23T10:55:51Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -162,53 +164,62 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        this.eventJournalConfig = nodeEngine.getConfig().findCacheEventJournalConfig(cacheConfig.getName());\n-        this.evictionConfig = cacheConfig.getEvictionConfig();\n-        if (evictionConfig == null) {\n-            throw new IllegalStateException(\"Eviction config cannot be null!\");\n-        }\n-        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-        if (cacheConfig.isStatisticsEnabled()) {\n-            statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n-        }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            injectDependencies(cacheWriter);\n-        }\n-        if (cacheConfig.getExpiryPolicyFactory() != null) {\n-            Factory<ExpiryPolicy> expiryPolicyFactory = cacheConfig.getExpiryPolicyFactory();\n-            injectDependencies(expiryPolicyFactory);\n-            defaultExpiryPolicy = expiryPolicyFactory.create();\n-            injectDependencies(defaultExpiryPolicy);\n-        } else {\n-            throw new IllegalStateException(\"Expiry policy factory cannot be null!\");\n-        }\n-\n-        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-        this.records = createRecordCacheMap();\n-        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaximumSizePolicy());\n-        this.evictionPolicyEvaluator = createEvictionPolicyEvaluator(evictionConfig);\n-        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n-        registerResourceIfItIsClosable(cacheWriter);\n-        registerResourceIfItIsClosable(cacheLoader);\n-        registerResourceIfItIsClosable(defaultExpiryPolicy);\n-        init();\n+        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n+        try {\n+            this.eventJournalConfig = nodeEngine.getConfig().findCacheEventJournalConfig(cacheConfig.getName());\n+            this.evictionConfig = cacheConfig.getEvictionConfig();\n+            if (evictionConfig == null) {\n+                throw new IllegalStateException(\"Eviction config cannot be null!\");\n+            }\n+            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+            if (cacheConfig.isStatisticsEnabled()) {\n+                statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n+            }\n+            if (cacheConfig.getCacheLoaderFactory() != null) {\n+                Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n+                injectDependencies(cacheLoaderFactory);\n+                cacheLoader = cacheLoaderFactory.create();\n+                injectDependencies(cacheLoader);\n+            }\n+            if (cacheConfig.getCacheWriterFactory() != null) {\n+                Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n+                injectDependencies(cacheWriterFactory);\n+                cacheWriter = cacheWriterFactory.create();\n+                injectDependencies(cacheWriter);\n+            }\n+            if (cacheConfig.getExpiryPolicyFactory() != null) {\n+                Factory<ExpiryPolicy> expiryPolicyFactory = cacheConfig.getExpiryPolicyFactory();\n+                injectDependencies(expiryPolicyFactory);\n+                defaultExpiryPolicy = expiryPolicyFactory.create();\n+                injectDependencies(defaultExpiryPolicy);\n+            } else {\n+                throw new IllegalStateException(\"Expiry policy factory cannot be null!\");\n+            }\n+\n+            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+            this.records = createRecordCacheMap();\n+            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaximumSizePolicy());\n+            this.evictionPolicyEvaluator = createEvictionPolicyEvaluator(evictionConfig);\n+            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n+\n+            injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n+            registerResourceIfItIsClosable(cacheWriter);\n+            registerResourceIfItIsClosable(cacheLoader);\n+            registerResourceIfItIsClosable(defaultExpiryPolicy);\n+            init();\n+        } finally {\n+            try {\n+                tenantContext.close();\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08482d9750781fdd63799c79fd391b4c9c1336e0"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 612, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}