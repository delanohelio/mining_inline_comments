{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDczMTI4", "number": 17184, "title": "Tenant control moved to TenantControlService, fix cache replication with unavailable applications / classes", "bodyText": "Fixes #10875\nOld PR (for 3.12) #17129", "createdAt": "2020-07-07T00:46:29Z", "url": "https://github.com/hazelcast/hazelcast/pull/17184", "merged": true, "mergeCommit": {"oid": "02b2b4556dbfd4551d4a8be403a7af2bf066b5a9"}, "closed": true, "closedAt": "2020-12-11T06:36:17Z", "author": {"login": "lprimak"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABczJwCTAFqTQ0NTM0ODI1Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdlB4dAAFqTU0OTgyOTUwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzQ4MjUz", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-445348253", "createdAt": "2020-07-09T07:17:50Z", "commit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoxNzo1MFrOGvEpdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoxNzo1MFrOGvEpdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ==", "bodyText": "Calling allien code while holding a lock is a source or problems.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452012405", "createdAt": "2020-07-09T07:17:50Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed\n+ *\n+ * @author lprimak\n+ * @param <T> object type\n+ */\n+public class TenantContextual<T> {\n+    private T contextual;\n+    private volatile boolean initialized;\n+    private final Supplier<T> initFunction;\n+    private final Supplier<Boolean> existsFunction;\n+    private final TenantControl tenantControl;\n+    private final Lock lock = new ReentrantLock();\n+\n+    public TenantContextual(Supplier<T> initFunction, Supplier<Boolean> existsFunction, TenantControl tenantControl) {\n+        this.initFunction = initFunction;\n+        this.existsFunction = existsFunction;\n+        this.tenantControl = tenantControl;\n+    }\n+\n+    /**\n+     *\n+     * @return underlying object, initialize within Tenant Control when necessary\n+     */\n+    public T get() {\n+        boolean localInitialized = this.initialized;\n+        if (!localInitialized) {\n+            try {\n+                lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzQ4NzM3", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-445348737", "createdAt": "2020-07-09T07:18:35Z", "commit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoxODozNVrOGvEq8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoxODozNVrOGvEq8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjc4Ng==", "bodyText": "Every problem in software engineering can be solved by adding an extra layer of indirection; apart from having too many layers of indirection. I have the feeling that we are adding an unwanted layer of indirection here.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452012786", "createdAt": "2020-07-09T07:18:35Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed\n+ *\n+ * @author lprimak\n+ * @param <T> object type\n+ */\n+public class TenantContextual<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzQ5MTc1", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-445349175", "createdAt": "2020-07-09T07:19:16Z", "commit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoxOToxNlrOGvEsPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoxOToxNlrOGvEsPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMzExNw==", "bodyText": "A lock always needs to be acquired outside the try block.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452013117", "createdAt": "2020-07-09T07:19:16Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed\n+ *\n+ * @author lprimak\n+ * @param <T> object type\n+ */\n+public class TenantContextual<T> {\n+    private T contextual;\n+    private volatile boolean initialized;\n+    private final Supplier<T> initFunction;\n+    private final Supplier<Boolean> existsFunction;\n+    private final TenantControl tenantControl;\n+    private final Lock lock = new ReentrantLock();\n+\n+    public TenantContextual(Supplier<T> initFunction, Supplier<Boolean> existsFunction, TenantControl tenantControl) {\n+        this.initFunction = initFunction;\n+        this.existsFunction = existsFunction;\n+        this.tenantControl = tenantControl;\n+    }\n+\n+    /**\n+     *\n+     * @return underlying object, initialize within Tenant Control when necessary\n+     */\n+    public T get() {\n+        boolean localInitialized = this.initialized;\n+        if (!localInitialized) {\n+            try {\n+                lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzUyNTY2", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-445352566", "createdAt": "2020-07-09T07:24:44Z", "commit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoyNDo0NFrOGvE29g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoyNDo0NFrOGvE29g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNTg2Mg==", "bodyText": "This will break any implementation of TenantControl. In theory it is allowed because it is @Beta, but something that needs to be considered since there is already a release with this interface.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452015862", "createdAt": "2020-07-09T07:24:44Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -33,8 +31,7 @@\n  * @author lprimak\n  */\n @Beta\n-public interface TenantControl extends Serializable {\n-\n+public interface TenantControl extends DataSerializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzUyNzkz", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-445352793", "createdAt": "2020-07-09T07:25:04Z", "commit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoyNTowNFrOGvE3tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzoyNTowNFrOGvE3tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNjA1NQ==", "bodyText": "Breaking beta interface..", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452016055", "createdAt": "2020-07-09T07:25:04Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/DestroyEventContext.java", "diffHunk": "@@ -16,27 +16,21 @@\n \n package com.hazelcast.spi.tenantcontrol;\n \n+import com.hazelcast.core.HazelcastInstance;\n import com.hazelcast.spi.annotation.Beta;\n \n /**\n  * Hook to decouple Hazelcast object from the tenant\n- * @param <T> context type\n  */\n @Beta\n-public interface DestroyEventContext<T> {\n+public interface DestroyEventContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9262896bfe67873d293133e6630c6aaaeab8b1ff"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMDkxNTE3", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-460091517", "createdAt": "2020-08-03T14:49:45Z", "commit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0OTo0NVrOG68msg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwOToxNDozOVrOG95gsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzUzOA==", "bodyText": "minor: method instead of class", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r464463538", "createdAt": "2020-08-03T14:49:45Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/Operation.java", "diffHunk": "@@ -772,6 +785,48 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n     protected void readInternal(ObjectDataInput in) throws IOException {\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n+    public void setTenantControlIfNotAlready() {\n+        if (tenantControl == TenantControl.NOOP_TENANT_CONTROL) {\n+            tenantControl = nodeEngine.getTenantControlFactory().saveCurrentTenant();\n+            if (tenantControl == null) {\n+                getLogger().warning(String.format(\"TenantControl factory return null: %s - %s)\",\n+                        this.toString(), nodeEngine.getTenantControlFactory().toString()));\n+                tenantControl = TenantControl.NOOP_TENANT_CONTROL;\n+            } else {\n+                setFlag(true, BITMASK_TENANT_CONTROL_SET);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * checks if operation is ready to execute,\n+     * if not, it will be pushed to the back of the queue\n+     * Tenant's isAvailable() class is responsible for waiting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Njc2NQ==", "bodyText": "This method body should be only executed when cluster version is >= 4.1, otherwise it might introduce trouble with rolling upgrades. So something like:\nif (nodeEngine.getClusterService().getClusterVersion().isGreaterOrEqual(Versions.V4_1)) {\n  ... // do stuff\n}\n\nedit (note to self): reconsider, maybe old members just ignore the flag they don't know how to deal with", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r464466765", "createdAt": "2020-08-03T14:54:58Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/Operation.java", "diffHunk": "@@ -772,6 +785,48 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n     protected void readInternal(ObjectDataInput in) throws IOException {\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n+    public void setTenantControlIfNotAlready() {\n+        if (tenantControl == TenantControl.NOOP_TENANT_CONTROL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MDU5NA==", "bodyText": "This method name might be confusing (eg it reminds me of BlockingOperation#shouldWait). Maybe rename to isTenantAvailable?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r464480594", "createdAt": "2020-08-03T15:16:26Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/Operation.java", "diffHunk": "@@ -772,6 +785,48 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n     protected void readInternal(ObjectDataInput in) throws IOException {\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n+    public void setTenantControlIfNotAlready() {\n+        if (tenantControl == TenantControl.NOOP_TENANT_CONTROL) {\n+            tenantControl = nodeEngine.getTenantControlFactory().saveCurrentTenant();\n+            if (tenantControl == null) {\n+                getLogger().warning(String.format(\"TenantControl factory return null: %s - %s)\",\n+                        this.toString(), nodeEngine.getTenantControlFactory().toString()));\n+                tenantControl = TenantControl.NOOP_TENANT_CONTROL;\n+            } else {\n+                setFlag(true, BITMASK_TENANT_CONTROL_SET);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * checks if operation is ready to execute,\n+     * if not, it will be pushed to the back of the queue\n+     * Tenant's isAvailable() class is responsible for waiting\n+     * so there is no tight loop\n+     *\n+     * @return true if ready\n+     */\n+    public boolean isOperationReady() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NjI2MQ==", "bodyText": "must be guarded for rolling upgrades:\nif (out.getVersion().isGreaterOrEqual(Versions.V4_1)) {\n  ... write\n}\n\nAlso, for this to work, this class must implement Versioned interface.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467066261", "createdAt": "2020-08-07T14:12:28Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/operations/PostJoinProxyOperation.java", "diffHunk": "@@ -86,6 +87,7 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n                 out.writeUTF(proxy.getServiceName());\n                 out.writeUTF(proxy.getObjectName());\n                 UUIDSerializationUtil.writeUUID(out, proxy.getSource());\n+                out.writeObject(proxy.getTenantControl());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NjM5Nw==", "bodyText": "Same as above for rolling upgrades", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467066397", "createdAt": "2020-08-07T14:12:41Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/operations/PostJoinProxyOperation.java", "diffHunk": "@@ -97,7 +99,7 @@ protected void readInternal(ObjectDataInput in) throws IOException {\n         if (len > 0) {\n             proxies = new ArrayList<>(len);\n             for (int i = 0; i < len; i++) {\n-                ProxyInfo proxy = new ProxyInfo(in.readUTF(), in.readUTF(), UUIDSerializationUtil.readUUID(in));\n+                ProxyInfo proxy = new ProxyInfo(in.readUTF(), in.readUTF(), UUIDSerializationUtil.readUUID(in), in.readObject());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4NjI0NQ==", "bodyText": "The effects of this method's return value on ICache implementation should not be part of this javadoc. Instead we need something helpful for TenantControlFactory implementors (like you ;-)).", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467086245", "createdAt": "2020-08-07T14:44:38Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControlFactory.java", "diffHunk": "@@ -47,11 +45,14 @@\n      * Further operations from other threads will use the returned context\n      * for this particular Hazelcast object to re-establish the invocation context\n      *\n-     * @param event hook to destroy any Hazelcast object when the tenant is destroyed,\n-     * This is used, for example, to delete all associated caches from the application when\n-     * it gets undeployed, so there are no ClassCastExceptions afterwards\n-     *\n      * @return new TenantControl instance with the saved state of the current tenant\n      */\n-    TenantControl saveCurrentTenant(DestroyEventContext event);\n+    TenantControl saveCurrentTenant();\n+\n+    /**\n+     * If not, CacheConfigs are always sent over the wire as PreJoin ops", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNTg5Mw==", "bodyText": "rename method to distributedObjectCreated (to match the term \"distributed object\" for hazelcast-managed objects). Same for objectDestroyed below. (see also similar DistributedObjectListener interface)\nAdditionally, Optionals as wrappers create litter and my personal opinion is that they don't look great as method arguments. I think @Nullable DestroyEventContext destroyEventContext would be better here, but let's see what other reviewers think about this.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467105893", "createdAt": "2020-08-07T15:18:14Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +42,18 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards\n+     */\n+    void objectCreated(Optional<DestroyEventContext> destroyEventContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwOTY3NA==", "bodyText": "Optionals as method arguments? let's see what other reviewers think.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467109674", "createdAt": "2020-08-07T15:24:54Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/ProxyRegistry.java", "diffHunk": "@@ -194,9 +197,11 @@ public DistributedObjectFuture getOrCreateProxyFuture(String name, UUID source,\n      * @param local        {@code true} if the proxy should be only created on the local member,\n      *                     otherwise fires {@code DistributedObjectEvent} to trigger cluster-wide\n      *                     proxy creation.\n+     * @param tenantControl optional, if it was transferred via PostOp\n      * @return The DistributedObject instance if it is created by this method, null otherwise.\n      */\n-    public DistributedObjectFuture createProxy(String name, UUID source, boolean initialize, boolean local) {\n+    public DistributedObjectFuture createProxy(String name, UUID source, boolean initialize, boolean local,\n+            Optional<TenantControl> tenantControl) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ==", "bodyText": "in this section, the returned value from process conflates the counter to be incremented with the need to retry the task. This is confusing. Maybe keep the counter logic encapsulated in process methods and indicate need to retry with a boolean return type from process? Or someone else may have a better idea", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467555499", "createdAt": "2020-08-09T08:43:15Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -132,20 +132,27 @@ public final void executeRun() {\n \n     private void process(Object task) {\n         try {\n+            SwCounter counter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NjQ4MA==", "bodyText": "call may result in an Operation being offloaded for execution in another thread (see OFFLOAD_ORDINAL case below and Offload#start javadoc). Probably we need to just mention the TenantControl relationship in the javadoc of Offload#start, as it is the offloaded operation implementor's responsibility to offload to another thread.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467556480", "createdAt": "2020-08-09T08:52:51Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/OperationRunnerImpl.java", "diffHunk": "@@ -204,23 +204,29 @@ public void run(Operation op) {\n             checkNodeState(op);\n \n             if (timeout(op)) {\n-                return;\n+                return false;\n             }\n \n             ensureNoPartitionProblems(op);\n \n             ensureNoSplitBrain(op);\n \n-            op.beforeRun();\n-\n-            call(op);\n+            if (op.isOperationReady()) {\n+                op.pushThreadContext();\n+                op.beforeRun();\n+                call(op);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1ODU3Ng==", "bodyText": "rolling upgrades: make this class implement Versioned and guard for cluster version being greater or equal than current one\n(also in readData below)", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467558576", "createdAt": "2020-08-09T09:14:39Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/DistributedObjectEventPacket.java", "diffHunk": "@@ -60,12 +64,17 @@ public UUID getSource() {\n         return source;\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n     @Override\n     public void writeData(ObjectDataOutput out) throws IOException {\n         out.writeBoolean(eventType == EventType.CREATED);\n         out.writeUTF(serviceName);\n         out.writeUTF(name);\n         UUIDSerializationUtil.writeUUID(out, source);\n+        out.writeObject(tenantControl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0OTE2MTQ0", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-484916144", "createdAt": "2020-09-09T11:34:29Z", "commit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMTozNDoyOVrOHPDD2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo1NjoyOFrOHRVjdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MDgyNA==", "bodyText": "\"cannot be null\" is a new sentence I guess?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r485540824", "createdAt": "2020-09-09T11:34:29Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards\n+     * cannot be null. This is a functional interface, no-op lambda can be used", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5MTE4NA==", "bodyText": "Is the purpose of this interface to be implemented by user classes? Is it necessary to add this interface and introduce more complication in class loading? If so, then the interface should be placed in a public package.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r485691184", "createdAt": "2020-09-09T15:12:27Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/nio/ClassLoaderUtil.java", "diffHunk": "@@ -39,6 +39,13 @@\n  */\n @SuppressWarnings({\"checkstyle:magicnumber\", \"checkstyle:npathcomplexity\"})\n public final class ClassLoaderUtil {\n+    /**\n+     * Marker interface.\n+     * do not cache constructors if an instance of this interface,\n+     * Used by systems with complicated class loader schemes\n+     * that may interfere with caching\n+     */\n+    public interface BypassClassCaching { };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3MjY1OQ==", "bodyText": "since this field is not part of the serialized form of this operation, it should be transient", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487672659", "createdAt": "2020-09-14T06:14:17Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/operation/CacheReplicationOperation.java", "diffHunk": "@@ -64,6 +62,7 @@\n     private final List<CacheConfig> configs = new ArrayList<CacheConfig>();\n     private final Map<String, Map<Data, CacheRecord>> data = new HashMap<String, Map<Data, CacheRecord>>();\n     private CacheNearCacheStateHolder nearCacheStateHolder;\n+    private boolean classesAlwaysAvailable = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3MzcxNg==", "bodyText": "This needs to be guarded for rolling upgrade (add implements Versioned to class and check out.getVersion() / in.getVersion() in the corresponding read implementation)", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487673716", "createdAt": "2020-09-14T06:17:23Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/operation/CacheReplicationOperation.java", "diffHunk": "@@ -157,7 +146,11 @@ protected void writeInternal(ObjectDataOutput out)\n         int confSize = configs.size();\n         out.writeInt(confSize);\n         for (CacheConfig config : configs) {\n-            out.writeObject(config);\n+            if (!classesAlwaysAvailable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3ODQ4OQ==", "bodyText": "This class is not specific to cache implementation, I would move it to com.hazelcast.spi.impl.tenantcontrol. Since it is in impl package, no reason to annotate with @PrivateApi. I see the usefulness of this class, assuming it is used for once-off configuration initialization and not in the hot path.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487678489", "createdAt": "2020-09-14T06:29:57Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.annotation.PrivateApi;\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxNTQ0Ng==", "bodyText": "This breaks RU compatibility. CacheDestroyEventContext class and this line need to be restored", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487815446", "createdAt": "2020-09-14T10:38:36Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CacheDataSerializerHook.java", "diffHunk": "@@ -236,7 +234,6 @@ public DataSerializableFactory createFactory() {\n         constructors[SET_EXPIRY_POLICY] = arg -> new CacheSetExpiryPolicyOperation();\n         constructors[SET_EXPIRY_POLICY_BACKUP] = arg -> new CacheSetExpiryPolicyBackupOperation();\n         constructors[EXPIRE_BATCH_BACKUP] = arg -> new CacheExpireBatchBackupOperation();\n-        constructors[CACHE_DESTROY_EVENT_CONTEXT] = arg -> new CacheDestroyEventContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzA1Nw==", "bodyText": "why is the second argument always false? It should match OperationThread#priority.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487913057", "createdAt": "2020-09-14T13:29:51Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -132,20 +132,33 @@ public final void executeRun() {\n \n     private void process(Object task) {\n         try {\n+            SwCounter counter;\n+            // process() will return it's appropriate counter to be incremented\n+            // if process() returns null instead, which means that task's tenant\n+            // is not available, the task will be put in the back of the queue\n+            // this, however, conflates the meaning of SwCounter return value\n+            // design choice needed to be made, otherwise there would be a lot of\n+            // code duplication. Wishing Java had tuples (although they bring their own problems)\n             if (task.getClass() == Packet.class) {\n-                process((Packet) task);\n+                counter = process((Packet) task);\n             } else if (task instanceof Operation) {\n-                process((Operation) task);\n+                counter = process((Operation) task);\n             } else if (task instanceof PartitionSpecificRunnable) {\n-                process((PartitionSpecificRunnable) task);\n+                counter = process((PartitionSpecificRunnable) task);\n             } else if (task instanceof Runnable) {\n-                process((Runnable) task);\n+                counter = process((Runnable) task);\n             } else if (task instanceof TaskBatch) {\n-                process((TaskBatch) task);\n+                counter = process((TaskBatch) task);\n             } else {\n                 throw new IllegalStateException(\"Unhandled task:\" + task);\n             }\n-            completedTotalCount.inc();\n+            if (counter != null) {\n+                counter.inc();\n+                completedTotalCount.inc();\n+            } else {\n+                // retry later if not ready\n+                queue.add(task, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDcwMQ==", "bodyText": "add javadoc explaining possible return values", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487940701", "createdAt": "2020-09-14T13:56:11Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/OperationRunner.java", "diffHunk": "@@ -49,11 +49,11 @@ public OperationRunner(int partitionId) {\n \n     public abstract long executedOperationsCount();\n \n-    public abstract void run(Packet packet) throws Exception;\n+    public abstract boolean run(Packet packet) throws Exception;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDk4Mw==", "bodyText": "javadoc: same as above", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487940983", "createdAt": "2020-09-14T13:56:28Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/OperationRunner.java", "diffHunk": "@@ -49,11 +49,11 @@ public OperationRunner(int partitionId) {\n \n     public abstract long executedOperationsCount();\n \n-    public abstract void run(Packet packet) throws Exception;\n+    public abstract boolean run(Packet packet) throws Exception;\n \n     public abstract void run(Runnable task);\n \n-    public abstract void run(Operation task);\n+    public abstract boolean run(Operation task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "164021d0811c0fa2115991237705d4f9d9ec7bf6"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjUyMzky", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-497252392", "createdAt": "2020-09-28T07:31:25Z", "commit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNzozMToyNlrOHYxn4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTo1ODowMVrOHY2s6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MDg5Nw==", "bodyText": "I see you've basically removed all previous logic and switched to the new one. Now, what should happen if there's a cluster comprised out of 4.1 members (having the new logic) but operating at a cluster version of 4.0? Since the old logic was removed but the new logic isn't in effect till the cluster version is 4.1, neither will actually be used and in this case it seems like tenant control is completely ignored.\nPossibly, we need to keep the old logic running till the cluster version is 4.1.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495740897", "createdAt": "2020-09-28T07:31:26Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/tenantcontrol/CacheDestroyEventContext.java", "diffHunk": "@@ -42,21 +42,6 @@ public CacheDestroyEventContext(String cacheName) {\n         this.cacheName = cacheName;\n     }\n \n-    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ==", "bodyText": "It's rather awkward that tenant control is scattered in different subsystems. Some of it is in distributed proxies, some of it is in the operation subsystem, some of it is in the record stores. Perhaps the most surprising part is that it is part of the proxies, which should be simple lightweight facades over the operations sent to members.\nAs far as I can see, it's mostly because you would like to hook into the lifecycle and destroy mechanism. I see two issues with this:\n\nfirst, the proxy lifecycle is not synchronized with the partition operations. That means, you might destroy a proxy on one thread while there's a partition operation currently running and using a tenant control\nsecondly, as initially mentioned, it's rather awkward to see tenant control in the proxy and the operation subsystem. Proxies are also part of hazelcast clients and as far as I could tell, it's not really needed for clients to interact with tenant control, as they might not have any cache classes in the classpath and basically the tenant control is part of the operation subsystem.\n\nAs such, I suggest that you keep the tenant control as part of the cache service or the cache record store and move the tenant control cleanup to com.hazelcast.cache.impl.AbstractCacheService#deleteCache, which is what a member will run once a cache (and proxy) is destroyed.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495753855", "createdAt": "2020-09-28T07:56:41Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -164,64 +162,72 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n-        try {\n-            this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n-            this.evictionConfig = cacheConfig.getEvictionConfig();\n-            if (evictionConfig == null) {\n-                throw new IllegalStateException(\"Eviction config cannot be null!\");\n-            }\n-            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-            initializeStatisticsAndFactories(cacheNameWithPrefix);\n-\n-            EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n-            evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n-            this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n-            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-            this.records = createRecordCacheMap();\n-            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n-            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-            registerResourceIfItIsClosable(cacheWriter);\n-            registerResourceIfItIsClosable(cacheLoader);\n-            registerResourceIfItIsClosable(defaultExpiryPolicy);\n-            init();\n-        } finally {\n-            try {\n-                tenantContext.close();\n-            } catch (IOException ex) {\n-                ExceptionUtil.rethrow(ex);\n-            }\n-        }\n-    }\n+        this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n+        this.evictionConfig = cacheConfig.getEvictionConfig();\n+        if (evictionConfig == null) {\n+            throw new IllegalStateException(\"Eviction config cannot be null!\");\n+        }\n+        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+\n+        EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n+        evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n+        this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n+        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+        this.records = createRecordCacheMap();\n+        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n+        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n \n-    private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {\n         if (cacheConfig.isStatisticsEnabled()) {\n             statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n         }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            cacheLoaderFactory = injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            cacheLoader = injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            cacheWriterFactory = injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            cacheWriter = injectDependencies(cacheWriter);\n-        }\n+        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n+        TenantControl tenantControl = nodeEngine.getProxyService()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1NzY0NQ==", "bodyText": "Can you avoid creating TenantContextual wrappers in case there are no factories and no expiry policy? Thing is, we're targetting high partition counts (e.g. 50k) and with this code, every record store of every cache will have three TenantContextual objects wrapped in LatencyTrackingCacheLoader, wrapped in more TenantContextual.\nSo if I'm calculating this correct, each ICache with no cache loader, cache writer or expiry policy will have hundreds of thousands of objects instantiated. Instead, you can have NOOP implementations to avoid null checks.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495757645", "createdAt": "2020-09-28T08:03:41Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -164,64 +162,72 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n-        try {\n-            this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n-            this.evictionConfig = cacheConfig.getEvictionConfig();\n-            if (evictionConfig == null) {\n-                throw new IllegalStateException(\"Eviction config cannot be null!\");\n-            }\n-            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-            initializeStatisticsAndFactories(cacheNameWithPrefix);\n-\n-            EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n-            evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n-            this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n-            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-            this.records = createRecordCacheMap();\n-            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n-            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-            registerResourceIfItIsClosable(cacheWriter);\n-            registerResourceIfItIsClosable(cacheLoader);\n-            registerResourceIfItIsClosable(defaultExpiryPolicy);\n-            init();\n-        } finally {\n-            try {\n-                tenantContext.close();\n-            } catch (IOException ex) {\n-                ExceptionUtil.rethrow(ex);\n-            }\n-        }\n-    }\n+        this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n+        this.evictionConfig = cacheConfig.getEvictionConfig();\n+        if (evictionConfig == null) {\n+            throw new IllegalStateException(\"Eviction config cannot be null!\");\n+        }\n+        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+\n+        EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n+        evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n+        this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n+        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+        this.records = createRecordCacheMap();\n+        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n+        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n \n-    private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {\n         if (cacheConfig.isStatisticsEnabled()) {\n             statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n         }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            cacheLoaderFactory = injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            cacheLoader = injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            cacheWriterFactory = injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            cacheWriter = injectDependencies(cacheWriter);\n-        }\n+        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n+        TenantControl tenantControl = nodeEngine.getProxyService()\n+                .getTenantControl(ICacheService.SERVICE_NAME, cacheNameWithPrefix);\n+        cacheLoader = new TenantContextual<>(this::initCacheLoader,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NjAzMg==", "bodyText": "You can also add Nonnull annotation here then, also add Nonnull or Nullable for other methods, parameters and return values.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495796032", "createdAt": "2020-09-28T09:10:47Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards.\n+     * Cannot be null. This is a functional interface, so no-op lambda can be used instead.\n+     */\n+    void distributedObjectCreated(DestroyEventContext destroyEventContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NjM5NA==", "bodyText": "Minor - \"Particular TenantControl implementation will control the details of how\" can probably be rephrased as it sounds strange.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495796394", "createdAt": "2020-09-28T09:11:22Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5OTE0Nw==", "bodyText": "Minor: {@code null} and {@link ClassCastException}", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495799147", "createdAt": "2020-09-28T09:16:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMDc3NA==", "bodyText": "Minor: maybe we can change the method names distributedObjectCreated and distributedObjectDestroyed. I understand they should be called when the object is created and destroyed but this tells more about when they will be called rather than what the implementation should do. In some other case, maybe we might call these methods when the object hasn't yet been created or destroyed.\nMaybe something like registerContext or unregisterContext is better?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495800774", "createdAt": "2020-09-28T09:18:51Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -65,5 +64,29 @@\n      * Hazelcast object from the tenant\n      * This is so the TenantControl itself can be garbage collected\n      */\n-    void unregister();\n+    void distributedObjectDestroyed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ==", "bodyText": "Umph. We are leaking private API here and this is a big problem in terms of compatibility. Operation is very private API and it's class name, package, methods and implementation may change heavily between releases or even get deleted completely. Can you provide less context here?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495802269", "createdAt": "2020-09-28T09:21:19Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -65,5 +64,29 @@\n      * Hazelcast object from the tenant\n      * This is so the TenantControl itself can be garbage collected\n      */\n-    void unregister();\n+    void distributedObjectDestroyed();\n+\n+    /**\n+     * Checks if tenant app is loaded at the current time and classes are available\n+     *\n+     * @param op passed so the tenant can filter on who is calling\n+     * @return true if tenant is loaded and classes are available\n+     */\n+    boolean isAvailable(Operation op);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMzE2Ng==", "bodyText": "What's the difference between this method and close? I would expect close to clear the context.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495803166", "createdAt": "2020-09-28T09:22:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -65,5 +64,29 @@\n      * Hazelcast object from the tenant\n      * This is so the TenantControl itself can be garbage collected\n      */\n-    void unregister();\n+    void distributedObjectDestroyed();\n+\n+    /**\n+     * Checks if tenant app is loaded at the current time and classes are available\n+     *\n+     * @param op passed so the tenant can filter on who is calling\n+     * @return true if tenant is loaded and classes are available\n+     */\n+    boolean isAvailable(Operation op);\n+\n+    /**\n+     * clean up the thread to avoid potential class loader leaks\n+     */\n+    void clearThreadContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwODU1NA==", "bodyText": "Why do we need to reserialise on cache destroy? Keep in mind this is concurrent with cache partition operations.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495808554", "createdAt": "2020-09-28T09:31:55Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheService.java", "diffHunk": "@@ -503,35 +489,18 @@ public CacheConfig findCacheConfig(String simpleName) {\n         try {\n             // Set name explicitly, because found config might have a wildcard name.\n             CacheConfig cacheConfig = new CacheConfig(cacheSimpleConfig).setName(simpleName);\n-            setTenantControl(cacheConfig);\n             return cacheConfig;\n         } catch (Exception e) {\n             throw new CacheException(e);\n         }\n     }\n \n-    @Override\n-    public void setTenantControl(CacheConfig cacheConfig) {\n-        if (!NOOP_TENANT_CONTROL.equals(getTenantControl(cacheConfig))) {\n-            // a tenant control has already been explicitly set for the cache config\n-            return;\n-        }\n-        // associate cache config with the current thread's tenant\n-        // and add hook so when the tenant is destroyed, so is the cache config\n-        TenantControlFactory tenantControlFactory = null;\n-        try {\n-            tenantControlFactory = ServiceLoader.load(TenantControlFactory.class,\n-                    TENANT_CONTROL_FACTORY, nodeEngine.getConfigClassLoader());\n-        } catch (Exception e) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Could not load service provider for TenantControl\", e);\n-            }\n-        }\n-        if (tenantControlFactory == null) {\n-            tenantControlFactory = NOOP_TENANT_CONTROL_FACTORY;\n-        }\n-        CacheConfigAccessor.setTenantControl(cacheConfig, tenantControlFactory.saveCurrentTenant(\n-                new CacheDestroyEventContext(cacheConfig.getName())));\n+    public void reSerializeCacheConfig(CacheConfig cacheConfig) {\n+        CompletableFuture<CacheConfig> future = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwOTMzMg==", "bodyText": "Can you add javadoc explaining what resolved is about?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495809332", "createdAt": "2020-09-28T09:33:16Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/DeferredValue.java", "diffHunk": "@@ -71,8 +71,12 @@ public Data getSerializedValue(SerializationService serializationService) {\n         return serializedValue;\n     }\n \n-    // returns a new DeferredValue representing the same value as this\n     public DeferredValue<V> shallowCopy() {\n+        return shallowCopy(true, null);\n+    }\n+\n+    // returns a new DeferredValue representing the same value as this\n+    public DeferredValue<V> shallowCopy(boolean resolved, SerializationService serializationService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMDUyOQ==", "bodyText": "Can you initialise the serialisation service on the config before calling this method instead of providing it as an argument?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495810529", "createdAt": "2020-09-28T09:35:25Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/config/CacheConfig.java", "diffHunk": "@@ -708,11 +688,11 @@ protected void readListenerConfigurations(ObjectDataInput in) throws IOException\n      *                 or will be resolved to loaded classes and the actual {@code keyType} and {@code valueType} will be copied.\n      *                 Otherwise, this configuration's {@code keyClassName} and {@code valueClassName} will be copied to the\n      *                 target config, to be resolved at a later time.\n+     * @param backupSerializationService in case serialization service isn't initialized", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzAzOQ==", "bodyText": "It's a bit hard reasoning about the states of DeferredValue. Isn't it the case that either serializedValueExists is true or valueExists is true and that we can simply use the previous code? Which scenario does this new case cover?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495813039", "createdAt": "2020-09-28T09:39:41Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/DeferredValue.java", "diffHunk": "@@ -81,7 +85,12 @@ public Data getSerializedValue(SerializationService serializationService) {\n             copy.serializedValueExists = true;\n             copy.serializedValue = serializedValue;\n         }\n-        if (valueExists) {\n+        if (!resolved && serializationService != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNDg2Mw==", "bodyText": "Can you revert this and ClassLoaderUtil?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495814863", "createdAt": "2020-09-28T09:42:37Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/atomiclong/proxy/AtomicLongProxy.java", "diffHunk": "@@ -251,5 +251,4 @@ public void destroy() {\n     public CPGroupId getGroupId() {\n         return groupId;\n     }\n-\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNzMzNA==", "bodyText": "Is there an example how much code duplication it actually introduces? I don't think it'll be too much and I must agree this approach is suprising to say the least. It also requires you to do code like this, which might not be necessary if you were passing around boolean:\nreturn currentRunner.run(operation) ? null : completedOperationCount;", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495817334", "createdAt": "2020-09-28T09:46:38Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -132,20 +132,27 @@ public final void executeRun() {\n \n     private void process(Object task) {\n         try {\n+            SwCounter counter;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, "originalCommit": {"oid": "9114bc47e3a6c8905aa9ab0257c8451f2183e064"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ==", "bodyText": "What if the proxies were propagated while the cluster version is 4.0 and then we switched to cluster version 4.1? Where do we react to this cluster version change to update the tenant control?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495821575", "createdAt": "2020-09-28T09:53:49Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/operations/PostJoinProxyOperation.java", "diffHunk": "@@ -125,7 +132,8 @@ public int getClassId() {\n         @Override\n         public void run() {\n             try {\n-                registry.createProxy(proxyInfo.getObjectName(), proxyInfo.getSource(), true, true);\n+                registry.createProxy(proxyInfo.getObjectName(), proxyInfo.getSource(), true, true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNDEwNw==", "bodyText": "Leftover", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495824107", "createdAt": "2020-09-28T09:58:01Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/cache/CacheTenantControlTest.java", "diffHunk": "@@ -137,69 +167,120 @@ public void testTenantControl_executionBeforeAfterOps() {\n \n         cache.destroy();\n \n-        assertEquals(1, saveCurrentCount.get());\n+        assertNotNull(savedTenant.get());\n         // expecting tenant context is created & closed 5 times:\n         // 2 times on creation of record store (wrapping initialization of eviction policy)\n         // + 3 times on before/afterRun of put, get & getAndPut operations\n         assertEquals(5, setTenantCount.get());\n         assertEquals(5, closeTenantCount.get());\n+        assertEquals(1, registerTenantCount.get());\n         assertEquals(1, unregisterTenantCount.get());\n+        assertEquals(3, clearedThreadInfoCount.get());\n     }\n \n     @Test\n     public void testDestroyEventContext_destroyRemovesTenantControl() {\n         Assume.assumeTrue(\"Requires CountingTenantControl explicitly configured\", hasTenantControl);\n-        HazelcastInstance hz = createHazelcastInstance(config);\n+        HazelcastInstance hz = createHazelcastInstance(getNewConfig());\n         ICache<Integer, Integer> cache = hz.getCacheManager().getCache(cacheName);\n \n         cache.put(1, 1);\n         cache.get(1);\n         cache.getAndPut(1, 2);\n \n-        destroyEventContext.get().destroy(cache);\n+        destroyEventContext.get().tenantUnavailable();\n \n-        assertEquals(TenantControl.NOOP_TENANT_CONTROL,\n-                getTenantControl(getCacheService(hz).getCacheConfig(cache.getPrefixedName())));\n+        assertInstanceOf(CountingTenantControl.class, getTenantControl(hz, cache));\n+    }\n+\n+    @Test\n+    public void basicMapTest() {\n+        Assume.assumeTrue(\"Requires CountingTenantControl explicitly configured\", hasTenantControl);\n+        HazelcastInstance hz = createHazelcastInstance(getNewConfig().setProperty(ClusterProperty.PARTITION_COUNT.getName(), \"1\"));\n+        IMap<String, Integer> map = hz.getMap(\"MyMap\");\n+        map.addEntryListener((EntryAddedListener) (EntryEvent event) -> System.out.format(\"Added: %s\\n\", event.getValue()), true);\n+        map.put(\"oneKey\", 1);\n+        map.destroy();\n+        assertNotNull(savedTenant.get());\n+        assertEquals(3, setTenantCount.get());\n+        assertEquals(1, registerTenantCount.get());\n+        assertEquals(1, unregisterTenantCount.get());\n     }\n \n     private void assertTenantControlCreated(HazelcastInstance instance) {\n         ICacheService cacheService = getCacheService(instance);\n         CacheConfig cacheConfig = cacheService.getCacheConfig(CacheUtil.getDistributedObjectName(cacheName));\n-        assertNotNull(\"TenantControl should not be null\", getTenantControl(cacheConfig));\n+        assertNotNull(\"TenantControl should not be null\", getTenantControl(instance, cacheConfig));\n         if (hasTenantControl) {\n-            assertInstanceOf(CountingTenantControl.class, getTenantControl(cacheConfig));\n+            assertInstanceOf(CountingTenantControl.class, getTenantControl(instance, cacheConfig));\n         } else {\n-            assertEquals(TenantControl.NOOP_TENANT_CONTROL, getTenantControl(cacheConfig));\n+            assertEquals(TenantControl.NOOP_TENANT_CONTROL, getTenantControl(instance, cacheConfig));\n         }\n     }\n \n     public static class CountingTenantControl implements TenantControl {\n-\n         @Override\n-        public Closeable setTenant(boolean createRequestScope) {\n-            new Exception().printStackTrace();\n+        public Closeable setTenant() {\n+//            new Exception().printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19db19f642b571041435a8469f4d0a3e65f09d9d"}, "originalPosition": 195}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00d88000801c254e6c2961085bf8ec595b6a3161", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/00d88000801c254e6c2961085bf8ec595b6a3161", "committedDate": "2020-10-19T22:32:51Z", "message": "tenant control moved out of cache and operation delays - squashed commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94b69a7f68903b45dc89eacf12a544c6347b4b12", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/94b69a7f68903b45dc89eacf12a544c6347b4b12", "committedDate": "2020-10-19T22:34:09Z", "message": "hopefully fixed the tenant control serialization compatibility"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ad6d3d3807dd9ee317681a52f8fb2ebac8ddf7a", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6ad6d3d3807dd9ee317681a52f8fb2ebac8ddf7a", "committedDate": "2020-10-16T19:00:22Z", "message": "hopefully fixed the tenant control serialization compatibility"}, "afterCommit": {"oid": "94b69a7f68903b45dc89eacf12a544c6347b4b12", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/94b69a7f68903b45dc89eacf12a544c6347b4b12", "committedDate": "2020-10-19T22:34:09Z", "message": "hopefully fixed the tenant control serialization compatibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6625431b8f351c569a58e62da87b2dfa68ffb6aa", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6625431b8f351c569a58e62da87b2dfa68ffb6aa", "committedDate": "2020-11-27T05:54:16Z", "message": "Merge branch 'master' into TENANT-CONTROL-CACHE-REPLICATION"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "committedDate": "2020-11-29T18:35:28Z", "message": "updated PR compatibility to version 4.2, fixed failing tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDkxOTg3", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-544091987", "createdAt": "2020-12-03T15:39:40Z", "commit": {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTozOTo0MVrOH-iwtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0Nzo0NFrOH_Wr5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MzI4Nw==", "bodyText": "minor: this method override can be removed, returns same as overridden method Operation#requiresTenantContext", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r535343287", "createdAt": "2020-12-03T15:39:41Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/operation/AddCacheConfigOperation.java", "diffHunk": "@@ -69,5 +68,8 @@ public int getClassId() {\n         return CacheDataSerializerHook.ADD_CACHE_CONFIG_OPERATION;\n     }\n \n-\n+    @Override\n+    public boolean requiresTenantContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjE2Mg==", "bodyText": "Always returning true here will result in adding the batch back to the queue twice, since it is already added in the finally block above. In a sense it is harmless, because batch.next() will return null each additional time it is requeued, still it breaks the completed operation batches metric (without an associated test failing -- something to be fixed in a further PR probably). We should always return false from this method.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536142162", "createdAt": "2020-12-04T14:34:28Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -196,6 +241,7 @@ private void process(TaskBatch batch) {\n         } finally {\n             queue.add(batch, false);\n         }\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3NDA5Nw==", "bodyText": "nit: update to 4.2", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536174097", "createdAt": "2020-12-04T15:19:28Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/tenantcontrol/impl/TenantControlReplicationOperation.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.spi.impl.tenantcontrol.impl;\n+\n+import com.hazelcast.internal.util.MapUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.SpiDataSerializerHook;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * Operation which exchanges tenant control between members.\n+ * Can be used to exchange a single or multiple tenant controls each belonging\n+ * to a different distributed object.\n+ *\n+ * @since 4.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NDAyMA==", "bodyText": "Why was this test changed? The second HazelcastInstance is anyway started with the filtering class loader and invoke will trigger the cache loader factory instantiation attempt. In the new version of the code, the following 2 lines will be anyway skipped because this line will throw the ClassNotFoundException.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536194020", "createdAt": "2020-12-04T15:47:44Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/test/java/com/hazelcast/cache/CacheTypesConfigTest.java", "diffHunk": "@@ -152,10 +154,19 @@ public void cacheConfigShouldBeAddedOnJoiningMember_whenCacheLoaderFactoryNotRes\n         assertClusterSize(2, hz1, hz2);\n \n         ICache<String, Person> cache = hz2.getCacheManager().getCache(cacheName);\n-        String key = generateKeyOwnedBy(hz2);\n-        expect.expectCause(new RootCauseMatcher(ClassNotFoundException.class, \"classloading.domain.PersonCacheLoaderFactory - \"\n-                + \"Package excluded explicitly\"));\n-        cache.invoke(key, new PersonEntryProcessor());\n+        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(hz2.getConfig().getClassLoader());\n+            CacheProxy cacheProxy = (CacheProxy) cache;\n+            CacheService cacheService = (CacheService) cacheProxy.getService();\n+            expect.expectCause(new RootCauseMatcher(ClassNotFoundException.class, \"classloading.domain.PersonCacheLoaderFactory - \"\n+                    + \"Package excluded explicitly\"));\n+            cacheService.getCacheConfig(cache.getPrefixedName()).getCacheLoaderFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2030b4a7363fc7b97e3d2ef7817902b2d34923af", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2030b4a7363fc7b97e3d2ef7817902b2d34923af", "committedDate": "2020-12-06T01:57:08Z", "message": "Merge branch 'master' into TENANT-CONTROL-CACHE-REPLICATION"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07ba61894c925b5855e5c2fc7521046490221c18", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/07ba61894c925b5855e5c2fc7521046490221c18", "committedDate": "2020-12-06T02:18:09Z", "message": "minor fixes based on review Dec 4 2020"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "committedDate": "2020-12-06T02:49:43Z", "message": "batch processing itself can never be deferred"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4014782a52c114d4fe2d200fd88f2008c458f5a5", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4014782a52c114d4fe2d200fd88f2008c458f5a5", "committedDate": "2020-12-07T16:20:38Z", "message": "Merge remote-tracking branch 'upstream/master' into TENANT-CONTROL-CACHE-REPLICATION"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d51643d53ebeec11456037c171193bb5c281cb16", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d51643d53ebeec11456037c171193bb5c281cb16", "committedDate": "2020-12-07T16:27:40Z", "message": "extracted changes for CacheTypesConfigTest into a separate test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2Mjc4OTg1", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-546278985", "createdAt": "2020-12-07T15:48:49Z", "commit": {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNTo0ODo0OVrOIAtQNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoyOTowNlrOIA0h4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxMjM0MA==", "bodyText": "How come this inject dependencies is here? The evaluator is initialised above.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537612340", "createdAt": "2020-12-07T15:48:49Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -164,64 +162,73 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n-        try {\n-            this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n-            this.evictionConfig = cacheConfig.getEvictionConfig();\n-            if (evictionConfig == null) {\n-                throw new IllegalStateException(\"Eviction config cannot be null!\");\n-            }\n-            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-            initializeStatisticsAndFactories(cacheNameWithPrefix);\n-\n-            EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n-            evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n-            this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n-            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-            this.records = createRecordCacheMap();\n-            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n-            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-            registerResourceIfItIsClosable(cacheWriter);\n-            registerResourceIfItIsClosable(cacheLoader);\n-            registerResourceIfItIsClosable(defaultExpiryPolicy);\n-            init();\n-        } finally {\n-            try {\n-                tenantContext.close();\n-            } catch (IOException ex) {\n-                ExceptionUtil.rethrow(ex);\n-            }\n-        }\n-    }\n+        this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n+        this.evictionConfig = cacheConfig.getEvictionConfig();\n+        if (evictionConfig == null) {\n+            throw new IllegalStateException(\"Eviction config cannot be null!\");\n+        }\n+        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+\n+        EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n+        evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n+        this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n+        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+        this.records = createRecordCacheMap();\n+        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n+        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n \n-    private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {\n         if (cacheConfig.isStatisticsEnabled()) {\n             statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n         }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            cacheLoaderFactory = injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            cacheLoader = injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            cacheWriterFactory = injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            cacheWriter = injectDependencies(cacheWriter);\n-        }\n+        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NTMxNQ==", "bodyText": "Is it no longer possible that this requires tenant control set?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537695315", "createdAt": "2020-12-07T17:36:14Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -353,12 +355,7 @@ protected EvictionChecker createCacheEvictionChecker(int size, MaxSizePolicy max\n     protected EvictionPolicyComparator createEvictionPolicyComparator(EvictionConfig evictionConfig) {\n         checkCacheEvictionConfig(evictionConfig);\n \n-        Closeable tenantContext = getTenantControl(cacheConfig).setTenant(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA==", "bodyText": "From which threads can this reassignment be called now? As I don't see safe publication of new values.", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537718440", "createdAt": "2020-12-07T18:09:12Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CacheProxySupport.java", "diffHunk": "@@ -92,7 +93,7 @@\n     private static final int TIMEOUT = 10;\n \n     protected final ILogger logger;\n-    protected final CacheConfig<K, V> cacheConfig;\n+    protected CacheConfig<K, V> cacheConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw==", "bodyText": "I think we can remove this whole backupSerializationService. The case which you seem to be referring to is when the CacheConfig is constructed using public CacheConfig(CacheSimpleConfig simpleConfig). I believe that if we set the serialization service in that constructor, it will always be non-null. Do you have a test (either on our side or on your side) which tests for this NPE?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537731553", "createdAt": "2020-12-07T18:29:06Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/PreJoinCacheConfig.java", "diffHunk": "@@ -56,7 +57,12 @@ public PreJoinCacheConfig(CacheConfig cacheConfig) {\n     }\n \n     public PreJoinCacheConfig(CacheConfig cacheConfig, boolean resolved) {\n-        cacheConfig.copy(this, resolved);\n+        this(cacheConfig, resolved, null);\n+    }\n+\n+    public PreJoinCacheConfig(CacheConfig cacheConfig, boolean resolved,\n+            SerializationService backupSerializationService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbe8cc1ac7ce8e10d4f86c6434f68f93a324528e", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bbe8cc1ac7ce8e10d4f86c6434f68f93a324528e", "committedDate": "2020-12-07T18:41:16Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4879f2594ff414018ec322debea65562054a41d6", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4879f2594ff414018ec322debea65562054a41d6", "committedDate": "2020-12-07T19:19:46Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce857745ccf908bf5f67e514c8f296790b7589e1", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ce857745ccf908bf5f67e514c8f296790b7589e1", "committedDate": "2020-12-08T18:54:35Z", "message": "Add caveats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0857136f01eebadb1b9c738238f1dca5c89e21d", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c0857136f01eebadb1b9c738238f1dca5c89e21d", "committedDate": "2020-12-09T11:33:56Z", "message": "Cleanup and remove backup serialization service. It should now be set in all cases for CacheConfig."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MTM5ODcy", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-548139872", "createdAt": "2020-12-09T12:37:21Z", "commit": {"oid": "c0857136f01eebadb1b9c738238f1dca5c89e21d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjozNzoyMVrOICSguA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjozNzoyMVrOICSguA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg==", "bodyText": "This classloader is not used. Is there a test missing?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539271352", "createdAt": "2020-12-09T12:37:21Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/cache/TenantUnavailableTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.cache.impl.ICacheService;\n+import com.hazelcast.config.CacheConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.CacheManager;\n+import java.io.Serializable;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static com.hazelcast.cache.CachePartitionIteratorMigrationTest.putValuesToPartition;\n+import static com.hazelcast.cache.CacheTestSupport.createServerCachingProvider;\n+import static com.hazelcast.cache.CacheTestSupport.getCacheService;\n+import static com.hazelcast.cache.HazelcastCacheManager.CACHE_MANAGER_PREFIX;\n+import static com.hazelcast.cache.TenantControlTest.classesAlwaysAvailable;\n+import static com.hazelcast.cache.TenantControlTest.destroyEventContext;\n+import static com.hazelcast.cache.TenantControlTest.initState;\n+import static com.hazelcast.cache.TenantControlTest.newConfig;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * App Server reload / app not loaded tests\n+ *\n+ * @author lprimak\n+ */\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(QuickTest.class)\n+public class TenantUnavailableTest extends HazelcastTestSupport {\n+    private String cacheName;\n+    private static final Set<String> disallowClassNames = new HashSet<>();\n+    private static final CountDownLatch latch = new CountDownLatch(1);\n+    private static boolean classLoadingFailed;\n+\n+    @Before\n+    public void setup() {\n+        cacheName = randomName();\n+        classLoadingFailed = false;\n+        initState();\n+        classesAlwaysAvailable = false;\n+    }\n+\n+    @Test\n+    public void testCacheWithTypesWithoutClassLoader() {\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n+        HazelcastInstance hz1 = factory.newHazelcastInstance(newConfig());\n+        CacheConfig<KeyType, ValueType> cacheConfig = new CacheConfig<>();\n+        cacheConfig.setTypes(KeyType.class, ValueType.class);\n+        Cache<KeyType, ValueType> cache1 = createServerCachingProvider(hz1)\n+                .getCacheManager()\n+                .createCache(cacheName, cacheConfig);\n+        cache1.put(new KeyType(), new ValueType());\n+        assertInstanceOf(ValueType.class, cache1.get(new KeyType()));\n+\n+        HazelcastInstance hz2 = factory.newHazelcastInstance(newConfig());\n+        ICacheService cacheService = getCacheService(hz2);\n+        disallowClassNames.add(KeyType.class.getName());\n+        hz1.shutdown(); // force migration\n+        CacheManager cacheManager = createServerCachingProvider(hz2).getCacheManager();\n+        Cache<KeyType, ValueType> cache2 = cacheManager.getCache(cacheName);\n+        disallowClassNames.clear();\n+        assertInstanceOf(ValueType.class, cache2.get(new KeyType()));\n+\n+        destroyEventContext.get().tenantUnavailable();\n+        disallowClassNames.add(KeyType.class.getName());\n+\n+        cacheConfig = cacheService.getCacheConfig(CACHE_MANAGER_PREFIX + cacheName);\n+        Cache<KeyType, ValueType> cache3 = cacheManager.getCache(cacheName);\n+        assertInstanceOf(ValueType.class, cache3.get(new KeyType()));\n+        Assert.assertFalse(\"Class Loading Failed\", classLoadingFailed);\n+    }\n+\n+    @Test\n+    public void testMigrationWithUnavailableClasses() throws InterruptedException {\n+        classesAlwaysAvailable = false;\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n+        HazelcastInstance hz1 = factory.newHazelcastInstance(newConfig());\n+        CacheConfig<String, ValueType> cacheConfig = new CacheConfig<>();\n+        cacheConfig.setTypes(String.class, ValueType.class);\n+\n+        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+        CacheProxy<String, ValueType> cache1 = (CacheProxy) createServerCachingProvider(hz1)\n+                .getCacheManager().createCache(cacheName, cacheConfig);\n+        ValueType value = new ValueType();\n+        putValuesToPartition(hz1, cache1, value, 0, 1);\n+        putValuesToPartition(hz1, cache1, value, 1, 1);\n+\n+        disallowClassNames.add(ValueType.class.getName());\n+        HazelcastInstance hz2 = factory.newHazelcastInstance(newConfig().setLiteMember(true));\n+        hz1.getPartitionService().addMigrationListener(new MigrationListenerImpl());\n+        CacheManager cacheManager = createServerCachingProvider(hz2).getCacheManager();\n+        Cache<String, ValueType> cache2 = cacheManager.getCache(cacheName);\n+        // force migration\n+        hz2.getCluster().promoteLocalLiteMember();\n+        latch.await(); // await migration\n+        disallowClassNames.clear();\n+        Iterator<Cache.Entry<String, ValueType>> it2 = cache2.iterator();\n+\n+        assertTrue(\"Iterator should not be empty\", it2.hasNext());\n+        while (it2.hasNext()) {\n+            Cache.Entry<String, ValueType> entry = it2.next();\n+            assertInstanceOf(ValueType.class, entry.getValue());\n+        }\n+        Assert.assertFalse(\"Class Loading Failed\", classLoadingFailed);\n+    }\n+\n+    public static class SimulateNonExistantClassLoader extends URLClassLoader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0857136f01eebadb1b9c738238f1dca5c89e21d"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MTQxNDY0", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-548141464", "createdAt": "2020-12-09T12:39:26Z", "commit": {"oid": "c0857136f01eebadb1b9c738238f1dca5c89e21d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjozOToyNlrOICSl4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjozOToyNlrOICSl4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MjY3NA==", "bodyText": "classesAlwaysAvailable is false in all tests. Is there a test where it is true? Should we have a test for that?", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539272674", "createdAt": "2020-12-09T12:39:26Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/cache/TenantUnavailableTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.cache.impl.ICacheService;\n+import com.hazelcast.config.CacheConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.CacheManager;\n+import java.io.Serializable;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static com.hazelcast.cache.CachePartitionIteratorMigrationTest.putValuesToPartition;\n+import static com.hazelcast.cache.CacheTestSupport.createServerCachingProvider;\n+import static com.hazelcast.cache.CacheTestSupport.getCacheService;\n+import static com.hazelcast.cache.HazelcastCacheManager.CACHE_MANAGER_PREFIX;\n+import static com.hazelcast.cache.TenantControlTest.classesAlwaysAvailable;\n+import static com.hazelcast.cache.TenantControlTest.destroyEventContext;\n+import static com.hazelcast.cache.TenantControlTest.initState;\n+import static com.hazelcast.cache.TenantControlTest.newConfig;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * App Server reload / app not loaded tests\n+ *\n+ * @author lprimak\n+ */\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(QuickTest.class)\n+public class TenantUnavailableTest extends HazelcastTestSupport {\n+    private String cacheName;\n+    private static final Set<String> disallowClassNames = new HashSet<>();\n+    private static final CountDownLatch latch = new CountDownLatch(1);\n+    private static boolean classLoadingFailed;\n+\n+    @Before\n+    public void setup() {\n+        cacheName = randomName();\n+        classLoadingFailed = false;\n+        initState();\n+        classesAlwaysAvailable = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0857136f01eebadb1b9c738238f1dca5c89e21d"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2563d35b480fb0369dc6c77b8a072f709654a129", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2563d35b480fb0369dc6c77b8a072f709654a129", "committedDate": "2020-12-09T13:01:28Z", "message": "Cleanup tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MTkxMzc0", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-548191374", "createdAt": "2020-12-09T13:40:46Z", "commit": {"oid": "2563d35b480fb0369dc6c77b8a072f709654a129"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e82b7a5a2d65c0b2dfc835ba70240ae1109b7a3a", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e82b7a5a2d65c0b2dfc835ba70240ae1109b7a3a", "committedDate": "2020-12-09T15:19:33Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a588c26c99febc8fdc45977d5bc79ab7bfb581f", "author": {"user": {"login": "lprimak", "name": "Lenny Primak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8a588c26c99febc8fdc45977d5bc79ab7bfb581f", "committedDate": "2020-12-09T17:43:12Z", "message": "restore TenantUnavailableTest functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ee9e71fdc16113e551125e6865f0d53a15a582e", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2ee9e71fdc16113e551125e6865f0d53a15a582e", "committedDate": "2020-12-10T14:25:09Z", "message": "Add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MjQ4MzUz", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-549248353", "createdAt": "2020-12-10T14:26:50Z", "commit": {"oid": "2ee9e71fdc16113e551125e6865f0d53a15a582e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODI5NTAy", "url": "https://github.com/hazelcast/hazelcast/pull/17184#pullrequestreview-549829502", "createdAt": "2020-12-11T06:24:00Z", "commit": {"oid": "2ee9e71fdc16113e551125e6865f0d53a15a582e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3542, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}