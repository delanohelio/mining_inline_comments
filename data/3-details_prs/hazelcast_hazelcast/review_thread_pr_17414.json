{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczODk1Mzgy", "number": 17414, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNToxOFrOEckbcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoyNTo1N1rOEckttw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzkyNDMzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNToxOFrOHHLgNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNzoyMVrOHHLlsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MDU0OQ==", "bodyText": "We already have a similar exception trying to run a map scan without index. Shall we reuse the code?", "url": "https://github.com/hazelcast/hazelcast/pull/17414#discussion_r477290549", "createdAt": "2020-08-26T13:15:18Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -174,11 +159,120 @@ private PartitionedMapTable createTable(\n         }\n     }\n \n-    private static PartitionedMapTable emptyMap(String mapName) {\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHeapMapFields(MapServiceContext context, String name) {\n+        for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+            // Resolve sample.\n+            RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+            if (recordStore == null) {\n+                continue;\n+            }\n+\n+            Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+            if (!recordStoreIterator.hasNext()) {\n+                continue;\n+            }\n+\n+            Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+            return getFieldMetadata(entry.getKey(), entry.getValue().getValue());\n+        }\n+\n+        return FieldsMetadata.EMPTY_ERROR;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHdMapFields(MapContainer mapContainer) {\n+        if (!nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED)) {\n+            // Cannot resolve fields when concurrent indexes are disabled\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex[] indexes = mapContainer.getIndexes().getIndexes();\n+\n+        if (indexes == null || indexes.length == 0) {\n+            // Cannot resolve fields when the map doesn't have concurrent indexes\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex index = indexes[0];\n+\n+        Iterator<QueryableEntry> entryIterator = index.getSqlRecordIterator();\n+\n+        if (!entryIterator.hasNext()) {\n+            return FieldsMetadata.EMPTY_ERROR;\n+        }\n+\n+        QueryableEntry entry = entryIterator.next();\n+\n+        return getFieldMetadata(entry.getKey(), entry.getValue());\n+    }\n+\n+    private static PartitionedMapTable emptyError(String mapName) {\n         QueryException error = QueryException.error(\n             \"Cannot resolve IMap schema because it doesn't have entries on the local member: \" + mapName\n         );\n \n         return new PartitionedMapTable(mapName, error);\n     }\n+\n+    private static PartitionedMapTable hdError(String mapName) {\n+        QueryException error = QueryException.error(\"Cannot query the IMap \\\"\" + mapName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e6181470541c4b2f029b4d25b6da6134afe76a"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MTc5OQ==", "bodyText": "The exception you mentioned is moved here", "url": "https://github.com/hazelcast/hazelcast/pull/17414#discussion_r477291799", "createdAt": "2020-08-26T13:17:07Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -174,11 +159,120 @@ private PartitionedMapTable createTable(\n         }\n     }\n \n-    private static PartitionedMapTable emptyMap(String mapName) {\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHeapMapFields(MapServiceContext context, String name) {\n+        for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+            // Resolve sample.\n+            RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+            if (recordStore == null) {\n+                continue;\n+            }\n+\n+            Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+            if (!recordStoreIterator.hasNext()) {\n+                continue;\n+            }\n+\n+            Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+            return getFieldMetadata(entry.getKey(), entry.getValue().getValue());\n+        }\n+\n+        return FieldsMetadata.EMPTY_ERROR;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHdMapFields(MapContainer mapContainer) {\n+        if (!nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED)) {\n+            // Cannot resolve fields when concurrent indexes are disabled\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex[] indexes = mapContainer.getIndexes().getIndexes();\n+\n+        if (indexes == null || indexes.length == 0) {\n+            // Cannot resolve fields when the map doesn't have concurrent indexes\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex index = indexes[0];\n+\n+        Iterator<QueryableEntry> entryIterator = index.getSqlRecordIterator();\n+\n+        if (!entryIterator.hasNext()) {\n+            return FieldsMetadata.EMPTY_ERROR;\n+        }\n+\n+        QueryableEntry entry = entryIterator.next();\n+\n+        return getFieldMetadata(entry.getKey(), entry.getValue());\n+    }\n+\n+    private static PartitionedMapTable emptyError(String mapName) {\n         QueryException error = QueryException.error(\n             \"Cannot resolve IMap schema because it doesn't have entries on the local member: \" + mapName\n         );\n \n         return new PartitionedMapTable(mapName, error);\n     }\n+\n+    private static PartitionedMapTable hdError(String mapName) {\n+        QueryException error = QueryException.error(\"Cannot query the IMap \\\"\" + mapName", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MDU0OQ=="}, "originalCommit": {"oid": "47e6181470541c4b2f029b4d25b6da6134afe76a"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MTk1Mw==", "bodyText": "Ahh, I see that the code has been moved.", "url": "https://github.com/hazelcast/hazelcast/pull/17414#discussion_r477291953", "createdAt": "2020-08-26T13:17:21Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -174,11 +159,120 @@ private PartitionedMapTable createTable(\n         }\n     }\n \n-    private static PartitionedMapTable emptyMap(String mapName) {\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHeapMapFields(MapServiceContext context, String name) {\n+        for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+            // Resolve sample.\n+            RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+            if (recordStore == null) {\n+                continue;\n+            }\n+\n+            Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+            if (!recordStoreIterator.hasNext()) {\n+                continue;\n+            }\n+\n+            Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+            return getFieldMetadata(entry.getKey(), entry.getValue().getValue());\n+        }\n+\n+        return FieldsMetadata.EMPTY_ERROR;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHdMapFields(MapContainer mapContainer) {\n+        if (!nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED)) {\n+            // Cannot resolve fields when concurrent indexes are disabled\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex[] indexes = mapContainer.getIndexes().getIndexes();\n+\n+        if (indexes == null || indexes.length == 0) {\n+            // Cannot resolve fields when the map doesn't have concurrent indexes\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex index = indexes[0];\n+\n+        Iterator<QueryableEntry> entryIterator = index.getSqlRecordIterator();\n+\n+        if (!entryIterator.hasNext()) {\n+            return FieldsMetadata.EMPTY_ERROR;\n+        }\n+\n+        QueryableEntry entry = entryIterator.next();\n+\n+        return getFieldMetadata(entry.getKey(), entry.getValue());\n+    }\n+\n+    private static PartitionedMapTable emptyError(String mapName) {\n         QueryException error = QueryException.error(\n             \"Cannot resolve IMap schema because it doesn't have entries on the local member: \" + mapName\n         );\n \n         return new PartitionedMapTable(mapName, error);\n     }\n+\n+    private static PartitionedMapTable hdError(String mapName) {\n+        QueryException error = QueryException.error(\"Cannot query the IMap \\\"\" + mapName", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MDU0OQ=="}, "originalCommit": {"oid": "47e6181470541c4b2f029b4d25b6da6134afe76a"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mzk3MTExOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoyNTo1N1rOHHL9PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzozNTo1MFrOHHMZZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5Nzk4MA==", "bodyText": "If we have NULL values in the index, the iterator will return an entry corresponding to it. I guess this is OK for further resolution logic? In the value, some attributes might be missing...", "url": "https://github.com/hazelcast/hazelcast/pull/17414#discussion_r477297980", "createdAt": "2020-08-26T13:25:57Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -174,11 +159,120 @@ private PartitionedMapTable createTable(\n         }\n     }\n \n-    private static PartitionedMapTable emptyMap(String mapName) {\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHeapMapFields(MapServiceContext context, String name) {\n+        for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+            // Resolve sample.\n+            RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+            if (recordStore == null) {\n+                continue;\n+            }\n+\n+            Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+            if (!recordStoreIterator.hasNext()) {\n+                continue;\n+            }\n+\n+            Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+            return getFieldMetadata(entry.getKey(), entry.getValue().getValue());\n+        }\n+\n+        return FieldsMetadata.EMPTY_ERROR;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHdMapFields(MapContainer mapContainer) {\n+        if (!nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED)) {\n+            // Cannot resolve fields when concurrent indexes are disabled\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex[] indexes = mapContainer.getIndexes().getIndexes();\n+\n+        if (indexes == null || indexes.length == 0) {\n+            // Cannot resolve fields when the map doesn't have concurrent indexes\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex index = indexes[0];\n+\n+        Iterator<QueryableEntry> entryIterator = index.getSqlRecordIterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e6181470541c4b2f029b4d25b6da6134afe76a"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwNTE5MQ==", "bodyText": "We do not read index keys here, only actual entries. Therefore, the resolution logic is not affected.", "url": "https://github.com/hazelcast/hazelcast/pull/17414#discussion_r477305191", "createdAt": "2020-08-26T13:35:50Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -174,11 +159,120 @@ private PartitionedMapTable createTable(\n         }\n     }\n \n-    private static PartitionedMapTable emptyMap(String mapName) {\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHeapMapFields(MapServiceContext context, String name) {\n+        for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+            // Resolve sample.\n+            RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+            if (recordStore == null) {\n+                continue;\n+            }\n+\n+            Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+            if (!recordStoreIterator.hasNext()) {\n+                continue;\n+            }\n+\n+            Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+            return getFieldMetadata(entry.getKey(), entry.getValue().getValue());\n+        }\n+\n+        return FieldsMetadata.EMPTY_ERROR;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private FieldsMetadata getHdMapFields(MapContainer mapContainer) {\n+        if (!nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED)) {\n+            // Cannot resolve fields when concurrent indexes are disabled\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex[] indexes = mapContainer.getIndexes().getIndexes();\n+\n+        if (indexes == null || indexes.length == 0) {\n+            // Cannot resolve fields when the map doesn't have concurrent indexes\n+            return FieldsMetadata.HD_ERROR;\n+        }\n+\n+        InternalIndex index = indexes[0];\n+\n+        Iterator<QueryableEntry> entryIterator = index.getSqlRecordIterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5Nzk4MA=="}, "originalCommit": {"oid": "47e6181470541c4b2f029b4d25b6da6134afe76a"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 346, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}