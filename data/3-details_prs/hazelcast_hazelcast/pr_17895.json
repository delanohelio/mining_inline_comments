{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3MjUwMjI3", "number": 17895, "title": "External Smart Client Public Address Discovery", "bodyText": "This PR makes discovery by external smart client way simpler and more secure in the cloud environments. From now on, all that the client needs to know is an address of any member (or a load balancer if members are exposed via load balancer).\n\nRelated PRD\nRelated TDD\n\n\nExample of how it works on Kubernetes (GKE)\n\nCreate 3 members, each exposed by a separate NodePort (or LoadBalancer) service.\n\nkubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml\nfor i in {1..3}; do \\\n  NAME=hazelcast-${i}; \\\n  kubectl create service nodeport $NAME --tcp=5701; \\\n  kubectl run $NAME --image=leszko/hazelcast:external-client --port=5701 -l \"app=${NAME},role=hazelcast\"; \\\ndone\n\n\n\nConnect the smart client to any of the IP:PORT or members and the smart client just works.\n\n\nYou can also expose all members via one LoadBalancer service\n\n\nkubectl create service loadbalancer hazelcast --tcp=5701 -o yaml --dry-run=client | kubectl set selector --local -f - \"role=hazelcast\" -o yaml | kubectl create -f -\n\n\nCheck the external IP\n\n$ kubectl get svc/hazelcast\nNAME        TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)          AGE\nhazelcast   LoadBalancer   10.127.245.180   35.223.84.167   5701:31368/TCP   8m57s\n\n\nConnect from the Java Client\n\nClientConfig config = new ClientConfig();\nconfig.getNetworkConfig().addAddress(\"35.223.84.167:5701\");\nHazelcastInstance instance = HazelcastClient.newHazelcastClient(config);\n\n\nExample of how it works on AWS\n\nStart 3 Hazelcast on 3 EC2 Instances\nAssuming EC2 Instances have public IPs, connect to any public IP and smart client works correctly.\n\nThe same works for any cloud environment (Azure, GCP).\nNote: client does not need to know any AWS/Azure/GCP credentials!\n\nSome considerations during the review process:\n\nI implemented auto-enabling of this feature, please check TDD for more details\nThe implementation is backward and forward compatible, no changes in the client protocol are needed", "createdAt": "2020-11-25T07:47:27Z", "url": "https://github.com/hazelcast/hazelcast/pull/17895", "merged": true, "mergeCommit": {"oid": "821791ddf164016a11fc5961cfa86ae49a243a80"}, "closed": true, "closedAt": "2020-12-09T10:11:14Z", "author": {"login": "sancar"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdh4G4QAH2gAyNTI3MjUwMjI3OjY5N2JhNzY4OWIzYjlhM2JkZmM3NGQ4MTgyNWNkMTY1MzI5MzQyYjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdjwu0bAFqTU0NTg5Njg3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "697ba7689b3b9a3bdfc74d81825cd165329342b8", "author": {"user": null}, "url": "https://github.com/hazelcast/hazelcast/commit/697ba7689b3b9a3bdfc74d81825cd165329342b8", "committedDate": "2020-12-01T11:18:56Z", "message": "External Smart Client Public Address Discovery\n\nThis PR makes discovery by external smart client way simpler and more secure in the cloud environments. From now on, all that the client needs to know is an address of any member (or a load balancer if members are exposed via load balancer).\n\n* Related [PRD](https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2280227357/External+Smart+Client+discovery+via+LoadBalancer)\n* Related [TDD](https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2689663054/External+Smart+Client+discovery+via+LoadBalancer+TDD)\n\n---------\n\nExample of how it works on **Kubernetes** (GKE)\n\n1. Create 3 members, each exposed by a separate NodePort (or LoadBalancer) service.\n```\nkubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml\nfor i in {1..3}; do \\\n  NAME=hazelcast-${i}; \\\n  kubectl create service nodeport $NAME --tcp=5701; \\\n  kubectl run $NAME --image=leszko/hazelcast:external-client --port=5701 -l \"app=${NAME},role=hazelcast\"; \\\ndone\n```\n\n2. Connect the smart client to any of the `IP:PORT` or members and the smart client just works.\n\n3. You can also expose all members via one LoadBalancer service\n```\nkubectl create service loadbalancer hazelcast --tcp=5701 -o yaml --dry-run=client | kubectl set selector --local -f - \"role=hazelcast\" -o yaml | kubectl create -f -\n```\n\n4. Check the external IP\n```\n$ kubectl get svc/hazelcast\nNAME        TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)          AGE\nhazelcast   LoadBalancer   10.127.245.180   35.223.84.167   5701:31368/TCP   8m57s\n```\n\n5. Connect from the Java Client\n```\nClientConfig config = new ClientConfig();\nconfig.getNetworkConfig().addAddress(\"35.223.84.167:5701\");\nHazelcastInstance instance = HazelcastClient.newHazelcastClient(config);\n```\n\n--------\n\nExample of how it works on **AWS**\n\n1. Start 3 Hazelcast on 3 EC2 Instances\n2. Assuming EC2 Instances have public IPs, connect to any public IP and smart client works correctly.\n\nThe same works for any cloud environment (Azure, GCP).\n\n**Note:** client does not need to know any AWS/Azure/GCP credentials!\n\n---------\n\nSome considerations during the review process:\n1. I implemented auto-enabling of this feature, please check [TDD](https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2689663054/External+Smart+Client+discovery+via+LoadBalancer+TDD) for more details\n2. The implementation is backward and forward compatible, no changes in the client protocol are needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67d4b187e6f8a3ffc9b375938ad2cefaffad0f39", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/67d4b187e6f8a3ffc9b375938ad2cefaffad0f39", "committedDate": "2020-12-01T11:18:56Z", "message": "test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0214a3958f2b77f6602b7d5d4fd526e5142aa852", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0214a3958f2b77f6602b7d5d4fd526e5142aa852", "committedDate": "2020-12-01T11:18:56Z", "message": "test fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e0f5f9e252d8ee7f5fec3203a6882b130743cd5e", "committedDate": "2020-11-25T11:09:15Z", "message": "test fixes"}, "afterCommit": {"oid": "0214a3958f2b77f6602b7d5d4fd526e5142aa852", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0214a3958f2b77f6602b7d5d4fd526e5142aa852", "committedDate": "2020-12-01T11:18:56Z", "message": "test fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDY1Njg3", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-541065687", "createdAt": "2020-11-30T16:16:22Z", "commit": {"oid": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjoxNjoyM1rOH8CkhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzowNToxNFrOH8Eywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcxODcyNA==", "bodyText": "minor: I guess changing this has no real effect, but does it make sense to change 4.1 XSD in 4.2 dev branch?", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532718724", "createdAt": "2020-11-30T16:16:23Z", "author": {"login": "vbekiaris"}, "path": "hazelcast-spring/src/main/resources/hazelcast-spring-4.1.xsd", "diffHunk": "@@ -4593,7 +4593,7 @@\n             </xs:element>\n             <xs:element name=\"socket-options\" type=\"endpoint-socket-options\" minOccurs=\"0\"/>\n         </xs:all>\n-        <xs:attribute name=\"name\" type=\"xs:string\" use=\"optional\" default=\"\"/>\n+        <xs:attribute name=\"name\" type=\"xs:string\" use=\"optional\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjczOTIyMg==", "bodyText": "nit: Returns {@code true} ...", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532739222", "createdAt": "2020-11-30T16:43:57Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/ClientClusterService.java", "diffHunk": "@@ -82,6 +82,13 @@\n      */\n     long getClusterTime();\n \n+    /**\n+     * Returns if member internal address should be translated into its public address.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NDUwOQ==", "bodyText": "DISCOVERY_SPI_PUBLIC_IP_ENABLED now operates like a tri-state boolean:\n\nexplicitly true -> performs address translation\nexplicitly false -> does not perform address translation\ndefault null or any other explicit value -> decides based on address matching logic below\n\nIn case someone changes the default null value back to false, TranslateToPublicAddress#membersReachableOnlyViaPublicAddress will fail, which is good. Maybe this non-standard treatment of the property is worth a mention in code comment here or in ClientProperty?\nAlso, a nit: in HazelcastProperties#getBoolean, the \"any other explicit value\" bucket results in a false outcome. Would it be more consistent to arrange this as:\n\ndefault null -> decides based on address matching logic below\nexplicitly true -> performs address translation\nexplicitly any other value (false or anything explicitly set) -> does not perform address translation", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532754509", "createdAt": "2020-11-30T17:04:24Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NTEzOA==", "bodyText": "typo: \"... the client is\"", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532755138", "createdAt": "2020-11-30T17:05:14Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (\"true\".equalsIgnoreCase(publicIpEnabledProperty)) {\n+            return true;\n+        } else if (\"false\".equalsIgnoreCase(publicIpEnabledProperty)) {\n+            return false;\n+        }\n+\n+        if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+            return false;\n+        }\n+\n+        return membersReachableOnlyViaPublicAddress(members);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that tje client is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09c612bb7da9e9a7be1117ede2285f73b290c1e0", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/09c612bb7da9e9a7be1117ede2285f73b290c1e0", "committedDate": "2020-12-02T07:04:41Z", "message": "addressing review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0a6b55029471cb951e686194872090d59f216da", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f0a6b55029471cb951e686194872090d59f216da", "committedDate": "2020-12-02T09:35:07Z", "message": "addressing review comments. fixing 4.2 xsd."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNzkwMjU2", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-542790256", "createdAt": "2020-12-02T12:33:42Z", "commit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjozMzo0MlrOH9Y1oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjozMzo0MlrOH9Y1oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMjEyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // we will try to decide if we should use private/public address automatically int that case.\n          \n          \n            \n                    // we will try to decide if we should use private/public address automatically in that case.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534132128", "createdAt": "2020-12-02T12:33:42Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically int that case.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "committedDate": "2020-12-02T13:45:26Z", "message": "Update hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java\n\nCo-authored-by: Vassilis Bekiaris <vbekiaris@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODI2MDMw", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-542826030", "createdAt": "2020-12-02T13:20:15Z", "commit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMzoyMDoxNVrOH9ak5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMzo0NTo1NFrOH9bmcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2MDYxNA==", "bodyText": "nit: EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\") creates a new object on each call. It could be avoided with a static field const. The same consideration applies to similar server-side usages.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534160614", "createdAt": "2020-12-02T13:20:15Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -679,6 +680,17 @@ protected TcpClientConnection createSocketConnection(Address target) {\n         }\n     }\n \n+    private Address translate(Member member) {\n+        if (client.getClientClusterService().translateToPublicAddress()) {\n+            Address publicAddress = member.getAddressMap().get(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2NDg4Mg==", "bodyText": "nit: this field could be final", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534164882", "createdAt": "2020-12-02T13:26:46Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/ClientClusterServiceImpl.java", "diffHunk": "@@ -86,6 +85,8 @@\n     //read and written under clusterViewLock\n     private CountDownLatch initialListFetchedLatch = new CountDownLatch(1);\n \n+    private TranslateToPublicAddressProvider translateToPublicAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2Njg1OQ==", "bodyText": "nit: _MILLIS suffix won't hurt here and in NON_REACHABLE_ADDRESS_TIMEOUT", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534166859", "createdAt": "2020-12-02T13:29:59Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2ODExMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n          \n          \n            \n                    // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534168113", "createdAt": "2020-12-02T13:31:55Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3MjM1OQ==", "bodyText": "Shouldn't we update the javadoc for this property? The current one duplicates member-side prop's javadoc and doesn't seem to be correct.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534172359", "createdAt": "2020-12-02T13:38:36Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/properties/ClientProperty.java", "diffHunk": "@@ -118,7 +118,7 @@\n      * <p>Discovery SPI is <b>disabled</b> by default</p>\n      */\n     public static final HazelcastProperty DISCOVERY_SPI_PUBLIC_IP_ENABLED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA==", "bodyText": "I didn't experiment with the code, but will java.net.Socket work in case of secure connections? I'd expect an exception in this case, but I may be wrong.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534176824", "createdAt": "2020-12-02T13:45:02Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically int that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        Iterator<MemberInfo> iter = members.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = members.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"));\n+            if (publicAddress == null) {\n+                return false;\n+            }\n+            Address internalAddress = member.getAddress();\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isReachable(Address address, int timeoutMs) {\n+        try (Socket s = new Socket()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NzM5Mw==", "bodyText": "nit: would be nice to add a meaningful message for the log entry.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534177393", "createdAt": "2020-12-02T13:45:54Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically int that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        Iterator<MemberInfo> iter = members.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = members.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"));\n+            if (publicAddress == null) {\n+                return false;\n+            }\n+            Address internalAddress = member.getAddress();\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isReachable(Address address, int timeoutMs) {\n+        try (Socket s = new Socket()) {\n+            s.connect(new InetSocketAddress(address.getHost(), address.getPort()), timeoutMs);\n+        } catch (Exception e) {\n+            logger.fine(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a6b55029471cb951e686194872090d59f216da"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODU0NzMw", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-542854730", "createdAt": "2020-12-02T13:53:12Z", "commit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMzo1MzoxM1rOH9b6Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDowODozN1rOH9clJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4MjQ4Mw==", "bodyText": "nit: newAddressMap may be a better name for this method.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534182483", "createdAt": "2020-12-02T13:53:13Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/cluster/impl/MemberImpl.java", "diffHunk": "@@ -217,4 +217,10 @@ public MemberImpl build() {\n                     attributes, liteMember, memberListJoinVersion, instance);\n         }\n     }\n+\n+    private static Map<EndpointQualifier, Address> newHashMap(EndpointQualifier member, Address address) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4Mzc4Mg==", "bodyText": "Why do we need this change in this PR? Seems that it only affects WAN protocol type.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534183782", "createdAt": "2020-12-02T13:54:57Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/instance/EndpointQualifier.java", "diffHunk": "@@ -85,10 +85,6 @@ public boolean equals(Object o) {\n             return false;\n         }\n \n-        // Single instance types - identifier doesn't matter\n-        if (type.getServerSocketCardinality() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4NDQzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HashMap<EndpointQualifier, Address> publicAddressMap = new HashMap<>();\n          \n          \n            \n                    Map<EndpointQualifier, Address> publicAddressMap = new HashMap<>();", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534184433", "createdAt": "2020-12-02T13:55:52Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/instance/impl/DefaultAddressPicker.java", "diffHunk": "@@ -436,7 +437,9 @@ public ServerSocketChannel getServerSocketChannel(EndpointQualifier qualifier) {\n \n     @Override\n     public Map<EndpointQualifier, Address> getPublicAddressMap() {\n-        return Collections.singletonMap(MEMBER, publicAddress);\n+        HashMap<EndpointQualifier, Address> publicAddressMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE5MzQ0NA==", "bodyText": "Is it ok to remove volatile modifier for this field?", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534193444", "createdAt": "2020-12-02T14:08:37Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManagerTranslateTest.java", "diffHunk": "@@ -72,9 +71,124 @@ public void teardown() {\n         Hazelcast.shutdownAll();\n     }\n \n+    @Test(expected = Exception.class)\n+    public void testTranslateIsUsed() {\n+        // given\n+        ClientConfig config = new ClientConfig();\n+        config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(1000);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(new TestAddressProvider(true), config);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        // when\n+        clientConnectionManager.start();\n+\n+        // then\n+        // throws exception because it can't connect to the cluster using translated public unreachable address\n+    }\n+\n+    @Test\n+    public void testTranslateIsNotUsedOnGettingExistingConnection() {\n+        // given\n+        TestAddressProvider provider = new TestAddressProvider(false);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(provider, new ClientConfig());\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        clientConnectionManager.start();\n+        clientConnectionManager.reset();\n+\n+        clientConnectionManager.getOrConnectToAddress(privateAddress);\n+        provider.shouldTranslate = true;\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToAddress(privateAddress);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test\n+    public void testTranslateIsUsedWhenMemberHasPublicClientAddress() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"true\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is unreachable\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false, UUID.randomUUID());\n+        // public member address is reachable\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),\n+                new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateIsNotUsedWhenPublicIpDisabled() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"false\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is incorrect\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false);\n+        // public member address is correct\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"), new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        // throws exception because it can't connect to the incorrect member address\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateFromMemberIsNotUsedWhenAlreadyTranslatedByAddressProvider() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"true\");\n+\n+        TestAddressProvider provider = new TestAddressProvider(false);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(provider, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+        provider.shouldTranslate = true;\n+        privateAddress = new Address(\"192.168.0.1\", 5702);\n+\n+        // private member address is correct\n+        Member member = new MemberImpl(privateAddress, VERSION, false);\n+        // public member address is correct\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),\n+                new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        // throws exception because it can't connect to the incorrect address\n+    }\n+\n     private class TestAddressProvider implements AddressProvider {\n \n-        volatile boolean shouldTranslate = false;\n+        private boolean shouldTranslate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODc3OTMz", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-542877933", "createdAt": "2020-12-02T14:17:55Z", "commit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDoxNzo1NVrOH9c_WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDoxNzo1NVrOH9c_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIwMDE1Mg==", "bodyText": "As MC uses address map for advanced networking support and matching some metrics, this change may affect it.\n@emre-aydin it may be a good idea to double check if this change doesn't break anything in MC. WDYT?", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534200152", "createdAt": "2020-12-02T14:17:55Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/DiscoveryJoiner.java", "diffHunk": "@@ -76,10 +78,29 @@ public DiscoveryJoiner(Node node, DiscoveryService discoveryService, boolean use\n         for (DiscoveryNode discoveryNode : discoveredNodes) {\n             Address discoveredAddress = usePublicAddress ? discoveryNode.getPublicAddress() : discoveryNode.getPrivateAddress();\n             if (localAddress.equals(discoveredAddress)) {\n+                if (!usePublicAddress && discoveryNode.getPublicAddress() != null) {\n+                    // enrich member with client public address\n+                    localMember.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyOTE2MTIx", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-542916121", "createdAt": "2020-12-02T14:54:27Z", "commit": {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d879bb29513dc69d554ebdbc67b0ddf4b9419ac8", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d879bb29513dc69d554ebdbc67b0ddf4b9419ac8", "committedDate": "2020-12-03T06:49:17Z", "message": "addressing review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNjY0OTEx", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-543664911", "createdAt": "2020-12-03T07:21:12Z", "commit": {"oid": "d879bb29513dc69d554ebdbc67b0ddf4b9419ac8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNzoyMToxM1rOH-BR-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNzoyMToxM1rOH-BR-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc5NDc0Nw==", "bodyText": "@leszko It looks like we are retrying some members twice if the number of members is less than REACHABLE_CHECK_NUMBER.  If so, I think we should not. Am I missing something?", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534794747", "createdAt": "2020-12-03T07:21:13Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        Iterator<MemberInfo> iter = members.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = members.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d879bb29513dc69d554ebdbc67b0ddf4b9419ac8"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3845c8fa7dd4b9c26f16663efa0dbe3e6333f8", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fa3845c8fa7dd4b9c26f16663efa0dbe3e6333f8", "committedDate": "2020-12-03T08:48:52Z", "message": "add randomization to reachable check to avoid loading single member when large number of clients are used"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzAzMTQ0", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-544703144", "createdAt": "2020-12-04T07:10:12Z", "commit": {"oid": "237e87732e0e1ffb06354b29f76288f11acb013e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoxMDoxMlrOH_Dpqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoxMDoxMlrOH_Dpqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA==", "bodyText": "Current implementation forces detection of unreachable internal address and reachable public address for 3 members in public client-server comms scenario. It follows what's written in the TDD, but it may be a bit too pessimistic. We could change this check to the following:\n            if (isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n                return true;\n            }\n        }\n        return false;\nLet's consider the success path, i.e. situation when all members are up and running and network works as expected. With this check we would return early in the public client-server comm scenario, once we detect the situation for the first member. In scenario when a member is not reachable, it shouldn't change anything. When the client and members are located in the same private network and members have configured public address (which seems to be a rare case), we're going to do only one check, just like before. So, the change should only reduce the number of attempts done in the public client-server comms scenario.\n@leszko did you consider this logic? If you did what are the benefits of the current implementation?", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535882154", "createdAt": "2020-12-04T07:10:12Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        List<MemberInfo> shuffledList = new ArrayList<>(members);\n+        Collections.shuffle(shuffledList);\n+        Iterator<MemberInfo> iter = shuffledList.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = shuffledList.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(CLIENT_PUBLIC_ENDPOINT_QUALIFIER);\n+            if (publicAddress == null) {\n+                return false;\n+            }\n+            Address internalAddress = member.getAddress();\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237e87732e0e1ffb06354b29f76288f11acb013e"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzkzMDgy", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-544793082", "createdAt": "2020-12-04T09:33:58Z", "commit": {"oid": "237e87732e0e1ffb06354b29f76288f11acb013e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozMzo1OFrOH_Iedg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozMzo1OFrOH_Iedg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTIwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            asList(member(REACHABLE_HOST, UNREACHABLE_HOST), member(UNREACHABLE_HOST, UNREACHABLE_HOST)));\n          \n          \n            \n                            asList(member(REACHABLE_HOST, UNREACHABLE_HOST), member(REACHABLE_HOST, UNREACHABLE_HOST)));", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535961206", "createdAt": "2020-12-04T09:33:58Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProviderTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.impl.connection.Addresses;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.core.Hazelcast;\n+import com.hazelcast.instance.BuildInfoProvider;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.annotation.QuickTest;\n+import com.hazelcast.version.MemberVersion;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.net.UnknownHostException;\n+import java.util.UUID;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonMap;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(QuickTest.class)\n+public class TranslateToPublicAddressProviderTest {\n+    private static final MemberVersion VERSION = MemberVersion.of(BuildInfoProvider.getBuildInfo().getVersion());\n+    public static final String REACHABLE_HOST = \"127.0.0.1\";\n+    public static final String UNREACHABLE_HOST = \"192.168.0.1\";\n+\n+    private final ClientConfig config = new ClientConfig();\n+\n+    @After\n+    public void teardown() {\n+        Hazelcast.shutdownAll();\n+    }\n+\n+    @Test\n+    public void nonDefaultAddressProvider() {\n+        // given\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(new TestAddressProvider(), null);\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void propertyTrue() {\n+        // given\n+        config.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.toString(), \"true\");\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), null);\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertTrue(result);\n+    }\n+\n+    @Test\n+    public void propertyFalse() {\n+        // given\n+        config.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.toString(), \"false\");\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), null);\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void emptyMemberList() {\n+        // given\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), emptyList());\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void memberInternalAddressAsDefinedInClientConfig() {\n+        // given\n+        config.getNetworkConfig().addAddress(\"127.0.0.1\");\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), asList(member(\"192.168.0.1\"), member(\"127.0.0.1\")));\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void membersWithoutPublicAddresses() {\n+        // given\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), asList(member(\"127.0.0.1\")));\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void membersReachableViaInternalAddress() {\n+        // given\n+        Hazelcast.newHazelcastInstance();\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(),\n+                asList(member(REACHABLE_HOST, UNREACHABLE_HOST), member(UNREACHABLE_HOST, UNREACHABLE_HOST)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237e87732e0e1ffb06354b29f76288f11acb013e"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0OTM4NjM5", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-544938639", "createdAt": "2020-12-04T13:02:23Z", "commit": {"oid": "4e81997aa7804a461ae665e3dbef08a6df1a4b60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzowMjoyNFrOH_P9Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzowMjoyNFrOH_P9Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4Mzc5MA==", "bodyText": "This test leads to a NPE (because member.getUuid() is null) which doesn't seems to be what it's supposed to be testing. Same story with testTranslateIsNotUsedWhenPublicIpDisabled.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536083790", "createdAt": "2020-12-04T13:02:24Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/test/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManagerTranslateTest.java", "diffHunk": "@@ -72,9 +71,124 @@ public void teardown() {\n         Hazelcast.shutdownAll();\n     }\n \n+    @Test(expected = Exception.class)\n+    public void testTranslateIsUsed() {\n+        // given\n+        ClientConfig config = new ClientConfig();\n+        config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(1000);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(new TestAddressProvider(true), config);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        // when\n+        clientConnectionManager.start();\n+\n+        // then\n+        // throws exception because it can't connect to the cluster using translated public unreachable address\n+    }\n+\n+    @Test\n+    public void testTranslateIsNotUsedOnGettingExistingConnection() {\n+        // given\n+        TestAddressProvider provider = new TestAddressProvider(false);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(provider, new ClientConfig());\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        clientConnectionManager.start();\n+        clientConnectionManager.reset();\n+\n+        clientConnectionManager.getOrConnectToAddress(privateAddress);\n+        provider.shouldTranslate = true;\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToAddress(privateAddress);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test\n+    public void testTranslateIsUsedWhenMemberHasPublicClientAddress() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"true\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is unreachable\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false, UUID.randomUUID());\n+        // public member address is reachable\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),\n+                new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateIsNotUsedWhenPublicIpDisabled() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"false\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is incorrect\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false);\n+        // public member address is correct\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"), new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        // throws exception because it can't connect to the incorrect member address\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateFromMemberIsNotUsedWhenAlreadyTranslatedByAddressProvider() throws UnknownHostException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e81997aa7804a461ae665e3dbef08a6df1a4b60"}, "originalPosition": 154}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e81997aa7804a461ae665e3dbef08a6df1a4b60", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4e81997aa7804a461ae665e3dbef08a6df1a4b60", "committedDate": "2020-12-04T12:41:28Z", "message": "Update hazelcast/src/test/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProviderTest.java\n\nCo-authored-by: Andrey Pechkurov <37772591+puzpuzpuz@users.noreply.github.com>"}, "afterCommit": {"oid": "900fc0f3810227c0868a2b4d58a73dd9326c4498", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/900fc0f3810227c0868a2b4d58a73dd9326c4498", "committedDate": "2020-12-06T14:47:49Z", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "committedDate": "2020-12-06T15:03:15Z", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "900fc0f3810227c0868a2b4d58a73dd9326c4498", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/900fc0f3810227c0868a2b4d58a73dd9326c4498", "committedDate": "2020-12-06T14:47:49Z", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest"}, "afterCommit": {"oid": "0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "committedDate": "2020-12-06T15:03:15Z", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2752792cffc4a364488156627f5d432c857dc17f", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2752792cffc4a364488156627f5d432c857dc17f", "committedDate": "2020-12-06T17:24:57Z", "message": "resolve the case where one side configures hostname while other side configures ip"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f5574af010bebca2ce41bfb94530a5ed1271657", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9f5574af010bebca2ce41bfb94530a5ed1271657", "committedDate": "2020-12-06T17:24:26Z", "message": "resolve the case where one side configures hostname while other side configures ip"}, "afterCommit": {"oid": "2752792cffc4a364488156627f5d432c857dc17f", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2752792cffc4a364488156627f5d432c857dc17f", "committedDate": "2020-12-06T17:24:57Z", "message": "resolve the case where one side configures hostname while other side configures ip"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1ODc0MzI1", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-545874325", "createdAt": "2020-12-07T07:05:07Z", "commit": {"oid": "2752792cffc4a364488156627f5d432c857dc17f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzowNTowN1rOIAYl9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzowNTowN1rOIAYl9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3Mzg0Nw==", "bodyText": "This check looks incorrect, as further logging is done with info level.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537273847", "createdAt": "2020-12-07T07:05:07Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientNetworkConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.config.SSLConfig;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.internal.util.AddressUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientNetworkConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientNetworkConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            SSLConfig sslConfig = config.getSSLConfig();\n+            if (sslConfig != null && sslConfig.isEnabled()) {\n+                if (logger.isFineEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2752792cffc4a364488156627f5d432c857dc17f"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31da1e40c468854f17a845687636f366f98b9a81", "author": {"user": {"login": "sancar", "name": "sancar"}}, "url": "https://github.com/hazelcast/hazelcast/commit/31da1e40c468854f17a845687636f366f98b9a81", "committedDate": "2020-12-07T07:07:53Z", "message": "fix log level typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1ODkzOTEw", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-545893910", "createdAt": "2020-12-07T07:45:57Z", "commit": {"oid": "31da1e40c468854f17a845687636f366f98b9a81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzo0NTo1N1rOIAZtOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzo0NTo1N1rOIAZtOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI5MjA5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * able to connect to members via configured address. No need to use make any address translation.\n          \n          \n            \n                 * able to connect to members via configured address. No need to use any address translation.", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537292090", "createdAt": "2020-12-07T07:45:57Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientNetworkConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.config.SSLConfig;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.internal.util.AddressUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientNetworkConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientNetworkConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            SSLConfig sslConfig = config.getSSLConfig();\n+            if (sslConfig != null && sslConfig.isEnabled()) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"SSL is configured. The client will use internal addresses to communicate with the cluster. If \"\n+                            + \"members are not reachable via private addresses, \"\n+                            + \"please set \\\"hazelcast.discovery.public.ip.enabled\\\" to true \");\n+                }\n+                return false;\n+            }\n+\n+            if (memberInternalAddressAsDefinedInClientConfig(members)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"There are internal addresses of members used in the config.\"\n+                            + \" The client will use internal addresses\");\n+                }\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da1e40c468854f17a845687636f366f98b9a81"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1ODk2ODc0", "url": "https://github.com/hazelcast/hazelcast/pull/17895#pullrequestreview-545896874", "createdAt": "2020-12-07T07:51:10Z", "commit": {"oid": "31da1e40c468854f17a845687636f366f98b9a81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzo1MToxMFrOIAZ3RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzo1MToxMFrOIAZ3RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI5NDY2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        + \"  is not reachable. The client will use internal addresses\");\n          \n          \n            \n                                        + \" is not reachable. The client will use internal addresses\");", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537294661", "createdAt": "2020-12-07T07:51:10Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientNetworkConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.config.SSLConfig;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.internal.util.AddressUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientNetworkConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientNetworkConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            SSLConfig sslConfig = config.getSSLConfig();\n+            if (sslConfig != null && sslConfig.isEnabled()) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"SSL is configured. The client will use internal addresses to communicate with the cluster. If \"\n+                            + \"members are not reachable via private addresses, \"\n+                            + \"please set \\\"hazelcast.discovery.public.ip.enabled\\\" to true \");\n+                }\n+                return false;\n+            }\n+\n+            if (memberInternalAddressAsDefinedInClientConfig(members)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"There are internal addresses of members used in the config.\"\n+                            + \" The client will use internal addresses\");\n+                }\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getAddresses();\n+        List<String> resolvedHosts = addresses.stream().map(s -> {\n+            try {\n+                return InetAddress.getByName(AddressUtil.getAddressHolder(s, -1).getAddress()).getHostAddress();\n+            } catch (UnknownHostException e) {\n+                return null;\n+            }\n+        }).filter(Objects::nonNull).collect(Collectors.toList());\n+        return members.stream()\n+                .map(memberInfo -> {\n+                    try {\n+                        return memberInfo.getAddress().getInetAddress().getHostAddress();\n+                    } catch (UnknownHostException e) {\n+                        return null;\n+                    }\n+                }).anyMatch(resolvedHosts::contains);\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        List<MemberInfo> shuffledList = new ArrayList<>(members);\n+        Collections.shuffle(shuffledList);\n+        Iterator<MemberInfo> iter = shuffledList.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = shuffledList.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(CLIENT_PUBLIC_ENDPOINT_QUALIFIER);\n+            Address internalAddress = member.getAddress();\n+            if (publicAddress == null) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"The public address is not available on the member. The client will use internal addresses\");\n+                }\n+                return false;\n+            }\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"The internal address is reachable. The client will use the internal addresses\");\n+                }\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"Public address + \" + publicAddress\n+                            + \"  is not reachable. The client will use internal addresses\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da1e40c468854f17a845687636f366f98b9a81"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3161, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}