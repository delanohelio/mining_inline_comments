{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMTYzNzE4", "number": 16995, "title": "SQL: IMap table metadata resolution (#16984)", "bodyText": "This PR introduces automatic metadata resolution for IMaps. Implementation notes:\n\nEvery IMap is represented as a table in the schema partitioned with the same name\nThere is a search path hazelcast.partitioned that allows us to refer to the table both as SELECT ... FROM table and SELECT ... FROM partitioned.table\nTo resolve the fields, we analyze the first local key-value pair and extract public getters and public fields from it. Getters take precedence over fields in case of conflict. Likewise, child class members take precedence over parent class members. If there is no local entry on the member, an exception will be thrown lazily when the map is accessed during query evaluation\nSupported in-memory formats are OBJECT and BINARY. NATIVE will throw an exception since we do not support HD yet\nJSON type is not supported\nTable statistics are calculated by counting local owning entries and then multiplying them to the member count\nCurrently, resolution happens eagerly on every SQL request. We may want to implement some caching in the future, but this is not a concern of the current implementation\n\nCloses #16984", "createdAt": "2020-05-19T14:39:26Z", "url": "https://github.com/hazelcast/hazelcast/pull/16995", "merged": true, "mergeCommit": {"oid": "2ff9cf8f33513922c2d5ebabd8319e4e98a2b94d"}, "closed": true, "closedAt": "2020-05-27T09:43:36Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcg3YwugH2gAyNDIwMTYzNzE4OjEzZDM0OGNhMGZhZGYxZTRiYjBlYTI4ZWJmMzI3MGEwNDQyNTU1OTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclVIyUgFqTQxODk3NjYyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "13d348ca0fadf1e4bb0ea28ebf3270a044255591", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/13d348ca0fadf1e4bb0ea28ebf3270a044255591", "committedDate": "2020-05-13T11:43:29Z", "message": "Initial integration with Apache Calcite (#16979)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fc43c85404605c5f8e93f54c1b75b8e6a48f50c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5fc43c85404605c5f8e93f54c1b75b8e6a48f50c", "committedDate": "2020-05-15T06:54:43Z", "message": "Merge branch 'master' into issues/16979"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ddc10c7c9d8cfe1053b540dfc10e5318edfc555", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7ddc10c7c9d8cfe1053b540dfc10e5318edfc555", "committedDate": "2020-05-15T07:27:51Z", "message": "Moved the code from the branch."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b23c75599ae062f89a16c76473cfc3f3e96297ec", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b23c75599ae062f89a16c76473cfc3f3e96297ec", "committedDate": "2020-05-15T10:30:56Z", "message": "WIP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65947aa7eacfdf6ef3caa05f84b031ee2176a63a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/65947aa7eacfdf6ef3caa05f84b031ee2176a63a", "committedDate": "2020-05-15T14:13:57Z", "message": "Minors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bfdc860e2278e1bcfb3f375572b1a99869964f9", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2bfdc860e2278e1bcfb3f375572b1a99869964f9", "committedDate": "2020-05-18T13:01:12Z", "message": "Sampling tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3fbb27a5cb1d9760673fa245bcb09832030636b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c3fbb27a5cb1d9760673fa245bcb09832030636b", "committedDate": "2020-05-18T17:38:01Z", "message": "HD resolver test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9ca63a401fe8ab0567e7db9bd5c228d0e1c2899", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e9ca63a401fe8ab0567e7db9bd5c228d0e1c2899", "committedDate": "2020-05-19T11:52:19Z", "message": "Merge branch 'master' into issues/16984\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/QueryUtils.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/TableField.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/TableResolver.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/MapScanExecTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e99cd189a8f93c331872eb68fb5fee97df3f124c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e99cd189a8f93c331872eb68fb5fee97df3f124c", "committedDate": "2020-05-19T14:20:41Z", "message": "Done with tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d38067928911e69167e71056275faea1711e38e1", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d38067928911e69167e71056275faea1711e38e1", "committedDate": "2020-05-19T14:29:58Z", "message": "Done."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46522463d6f5773db5406817135d6d4c4fea24c4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/46522463d6f5773db5406817135d6d4c4fea24c4", "committedDate": "2020-05-19T17:32:19Z", "message": "Made QueryPath IDS."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "499dc4fc1d46387a492ea7723df7333a1aed7655", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/499dc4fc1d46387a492ea7723df7333a1aed7655", "committedDate": "2020-05-21T07:20:25Z", "message": "Merge branch 'master' into issues/16984"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61ad93acb29fc77d725c93f9b13bf4791114d52f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/61ad93acb29fc77d725c93f9b13bf4791114d52f", "committedDate": "2020-05-25T07:05:38Z", "message": "Fix for Portable."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NzQ2MTEw", "url": "https://github.com/hazelcast/hazelcast/pull/16995#pullrequestreview-417746110", "createdAt": "2020-05-25T14:26:58Z", "commit": {"oid": "61ad93acb29fc77d725c93f9b13bf4791114d52f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyNjo1OFrOGaC4Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDo0NDowOVrOGaDXqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MzI2Ng==", "bodyText": "Minor : parentheses are not needed", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r429963266", "createdAt": "2020-05-25T14:26:58Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/extract/QueryPath.java", "diffHunk": "@@ -94,4 +104,59 @@ private static boolean isEmpty(String path) {\n     private static QueryException badPathException(String path) {\n         throw QueryException.error(\"Field cannot be empty: \" + path);\n     }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.QUERY_PATH;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeBoolean(key);\n+        out.writeUTF(path);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        key = in.readBoolean();\n+        path = in.readUTF();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        QueryPath path1 = (QueryPath) o;\n+\n+        if (key != path1.key) {\n+            return false;\n+        }\n+\n+        return path != null ? path.equals(path1.path) : path1.path == null;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = (key ? 1 : 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ad93acb29fc77d725c93f9b13bf4791114d52f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3MTM3MQ==", "bodyText": "Return directly return new PartitionedMapTable(mapName, e); instead of doing this on the higher level?", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r429971371", "createdAt": "2020-05-25T14:44:09Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map;\n+\n+import com.hazelcast.cluster.memberselector.MemberSelectors;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.MapService;\n+import com.hazelcast.map.impl.MapServiceContext;\n+import com.hazelcast.map.impl.PartitionContainer;\n+import com.hazelcast.map.impl.record.Record;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.sample.MapSampleMetadata;\n+import com.hazelcast.sql.impl.schema.map.sample.MapSampleMetadataResolver;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.hazelcast.sql.impl.QueryUtils.SCHEMA_NAME_PARTITIONED;\n+\n+public class PartitionedMapTableResolver extends AbstractMapTableResolver {\n+\n+    private static final List<List<String>> SEARCH_PATHS =\n+        Collections.singletonList(Arrays.asList(QueryUtils.CATALOG, SCHEMA_NAME_PARTITIONED));\n+\n+    public PartitionedMapTableResolver(NodeEngine nodeEngine) {\n+        super(nodeEngine, SEARCH_PATHS);\n+    }\n+\n+    @Override\n+    public Collection<Table> getTables() {\n+        MapService mapService = nodeEngine.getService(MapService.SERVICE_NAME);\n+        MapServiceContext context = mapService.getMapServiceContext();\n+\n+        List<Table> res = new ArrayList<>();\n+        Set<String> knownNames = new HashSet<>();\n+\n+        // Get started maps.\n+        for (String mapName : context.getMapContainers().keySet()) {\n+            PartitionedMapTable table;\n+\n+            try {\n+                table = createTable(context, mapName);\n+            } catch (QueryException e) {\n+                table = new PartitionedMapTable(mapName, e);\n+            }\n+\n+            if (table == null) {\n+                continue;\n+            }\n+\n+            res.add(table);\n+            knownNames.add(mapName);\n+        }\n+\n+        // Get maps that are not started locally yet.\n+        for (Map.Entry<String, MapConfig> configEntry : nodeEngine.getConfig().getMapConfigs().entrySet()) {\n+            String configMapName = configEntry.getKey();\n+\n+            // Skip templates.\n+            if (configMapName.contains(\"*\")) {\n+                continue;\n+            }\n+\n+            if (knownNames.add(configMapName)) {\n+                res.add(emptyMap(configMapName));\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"checkstyle:MethodLength\", \"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    private PartitionedMapTable createTable(MapServiceContext context, String name) {\n+        try {\n+            MapContainer mapContainer = context.getMapContainer(name);\n+\n+            // Handle concurrent map destroy.\n+            if (mapContainer == null) {\n+                return null;\n+            }\n+\n+            MapConfig config = mapContainer.getMapConfig();\n+\n+            // HD maps are not supported at the moment.\n+            if (config.getInMemoryFormat() == InMemoryFormat.NATIVE) {\n+                throw QueryException.error(\"IMap with InMemoryFormat.NATIVE is not supported: \" + name);\n+            }\n+\n+            boolean binary = config.getInMemoryFormat() == InMemoryFormat.BINARY;\n+\n+            for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+                // Resolve sample.\n+                RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+                if (recordStore == null) {\n+                    continue;\n+                }\n+\n+                Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+                if (!recordStoreIterator.hasNext()) {\n+                    continue;\n+                }\n+\n+                Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+                InternalSerializationService ss = (InternalSerializationService) nodeEngine.getSerializationService();\n+\n+                MapSampleMetadata keyMetadata = MapSampleMetadataResolver.resolve(\n+                    ss,\n+                    entry.getKey(),\n+                    binary,\n+                    true\n+                );\n+                MapSampleMetadata valueMetadata = MapSampleMetadataResolver.resolve(\n+                    ss,\n+                    entry.getValue().getValue(),\n+                    binary,\n+                    false\n+                );\n+\n+                List<TableField> fields = mergeMapFields(keyMetadata.getFields(), valueMetadata.getFields());\n+\n+                long estimatedRowCount = getEstimatedRowCount(name, context);\n+\n+                // Done.\n+                return new PartitionedMapTable(\n+                    name,\n+                    fields,\n+                    new ConstantTableStatistics(estimatedRowCount),\n+                    keyMetadata.getDescriptor(),\n+                    valueMetadata.getDescriptor()\n+                );\n+            }\n+\n+            return emptyMap(name);\n+        } catch (QueryException e) {\n+            throw e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ad93acb29fc77d725c93f9b13bf4791114d52f"}, "originalPosition": 170}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/eefa5a4a400434aae14c1b84b9733584b5aaad8c", "committedDate": "2020-05-26T09:01:02Z", "message": "Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MTMxODEz", "url": "https://github.com/hazelcast/hazelcast/pull/16995#pullrequestreview-418131813", "createdAt": "2020-05-26T09:37:23Z", "commit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwOTozNzoyNFrOGaWctg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwOTozNzoyNFrOGaWctg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI4Mzk1OA==", "bodyText": "Do we have to expose here LinkedHashMap? Maybe Map is enough?", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430283958", "createdAt": "2020-05-26T09:37:24Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/sample/MapSampleMetadata.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map.sample;\n+\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.schema.TableField;\n+\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * Metadata from sample resolution.\n+ */\n+public class MapSampleMetadata {\n+\n+    private final QueryTargetDescriptor descriptor;\n+    private final LinkedHashMap<String, TableField> fields;\n+\n+    public MapSampleMetadata(QueryTargetDescriptor descriptor, LinkedHashMap<String, TableField> fields) {\n+        this.descriptor = descriptor;\n+        this.fields = fields;\n+    }\n+\n+    public QueryTargetDescriptor getDescriptor() {\n+        return descriptor;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:IllegalType\")\n+    public LinkedHashMap<String, TableField> getFields() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MTQ0OTQ3", "url": "https://github.com/hazelcast/hazelcast/pull/16995#pullrequestreview-418144947", "createdAt": "2020-05-26T09:55:18Z", "commit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODk3MjI0", "url": "https://github.com/hazelcast/hazelcast/pull/16995#pullrequestreview-418897224", "createdAt": "2020-05-27T06:42:28Z", "commit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNjo0MjoyOFrOGa7cAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNjo0MjoyOFrOGa7cAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4OTk4Nw==", "bodyText": "checkException()?", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430889987", "createdAt": "2020-05-27T06:42:28Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/AbstractMapTable.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.TableStatistics;\n+\n+import java.util.List;\n+\n+/**\n+ * Table backed by IMap or ReplicatedMap.\n+ */\n+public abstract class AbstractMapTable extends Table {\n+\n+    private final QueryTargetDescriptor keyDescriptor;\n+    private final QueryTargetDescriptor valueDescriptor;\n+    private final QueryException exception;\n+\n+    protected AbstractMapTable(\n+        String schemaName,\n+        String name,\n+        List<TableField> fields,\n+        TableStatistics statistics,\n+        QueryTargetDescriptor keyDescriptor,\n+        QueryTargetDescriptor valueDescriptor\n+    ) {\n+        super(schemaName, name, fields, statistics);\n+\n+        this.keyDescriptor = keyDescriptor;\n+        this.valueDescriptor = valueDescriptor;\n+\n+        exception = null;\n+    }\n+\n+    protected AbstractMapTable(String schemaName, String name, QueryException exception) {\n+        super(schemaName, name, null, null);\n+\n+        this.keyDescriptor = null;\n+        this.valueDescriptor = null;\n+\n+        this.exception = exception;\n+    }\n+\n+    @Override\n+    public int getFieldCount() {\n+        checkException();\n+\n+        return super.getFieldCount();\n+    }\n+\n+    @Override\n+    public <T extends TableField> T getField(int index) {\n+        checkException();\n+\n+        return super.getField(index);\n+    }\n+\n+    @Override\n+    public TableStatistics getStatistics() {\n+        checkException();\n+\n+        return super.getStatistics();\n+    }\n+\n+    public QueryTargetDescriptor getKeyDescriptor() {\n+        return keyDescriptor;\n+    }\n+\n+    public QueryTargetDescriptor getValueDescriptor() {\n+        return valueDescriptor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4OTIwMTE3", "url": "https://github.com/hazelcast/hazelcast/pull/16995#pullrequestreview-418920117", "createdAt": "2020-05-27T07:21:48Z", "commit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyMTo0OFrOGa8gcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyMTo0OFrOGa8gcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzUwNA==", "bodyText": "Is there any specific reason for using portable style resolution only for binary? If user would change the storage format, we may end up with a different schema.", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430907504", "createdAt": "2020-05-27T07:21:48Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/sample/MapSampleMetadataResolver.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map.sample;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.serialization.ClassDefinition;\n+import com.hazelcast.nio.serialization.FieldType;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.nio.serialization.Portable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.MapTableField;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeUtils;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.LinkedHashMap;\n+import java.util.TreeMap;\n+\n+/**\n+ * Helper class that resolves a map-backed table from a key/value sample.\n+ */\n+public final class MapSampleMetadataResolver {\n+\n+    private static final String METHOD_PREFIX_GET = \"get\";\n+    private static final String METHOD_PREFIX_IS = \"is\";\n+    private static final String METHOD_GET_FACTORY_ID = \"getFactoryId\";\n+    private static final String METHOD_GET_CLASS_ID = \"getClassId\";\n+\n+    private MapSampleMetadataResolver() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Resolves the metadata associated with the given key-value sample.\n+     *\n+     * @param ss Serialization service.\n+     * @param target Target to be analyzed.\n+     * @param binary Whether map objects are stored in binary form.\n+     * @param key Whether passed target is key or value.\n+     * @return Sample metadata.\n+     * @throws QueryException If metadata cannot be resolved.\n+     */\n+    public static MapSampleMetadata resolve(\n+        InternalSerializationService ss,\n+        Object target,\n+        boolean binary,\n+        boolean key\n+    ) {\n+        try {\n+            if (target instanceof Data) {\n+                Data data = (Data) target;\n+\n+                if (data.isPortable() && binary) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4OTc2NjIy", "url": "https://github.com/hazelcast/hazelcast/pull/16995#pullrequestreview-418976622", "createdAt": "2020-05-27T08:38:53Z", "commit": {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3632, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}