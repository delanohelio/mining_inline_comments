{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxODUxNjc1", "number": 17142, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoxNTozN1rOEMA15A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo1NTozMVrOEQ7thg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDMyMTY0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDoxNTozN1rOGt4Hng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo0NjowOFrOGt5ELw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc1ODU1OA==", "bodyText": "Was this change for testing? I'm asking since some issues does not appear with very low partition counts.", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r450758558", "createdAt": "2020-07-07T10:15:37Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java", "diffHunk": "@@ -76,7 +76,7 @@\n     @Parameterized.Parameter(1)\n     public int nodeCount;\n \n-    protected int partitionCount = 111;\n+    protected int partitionCount = 11;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fe93a65286ea1d1ea076e47b3deae38bc227bfd"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDA2Mw==", "bodyText": "removed leftover", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r450774063", "createdAt": "2020-07-07T10:46:08Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java", "diffHunk": "@@ -76,7 +76,7 @@\n     @Parameterized.Parameter(1)\n     public int nodeCount;\n \n-    protected int partitionCount = 111;\n+    protected int partitionCount = 11;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc1ODU1OA=="}, "originalCommit": {"oid": "6fe93a65286ea1d1ea076e47b3deae38bc227bfd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzM4ODM2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNzozODoxNVrOG0r2WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOToyNTowNVrOG2CzUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg5NzU2MA==", "bodyText": "minor: you can probably use PartitionIdSet instead of BitSet here. It is backed by a BitSet while providing a Set<Integer> interface as well as methods with primitive int arguments to avoid unnecessary boxing/unboxing.", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r457897560", "createdAt": "2020-07-21T07:38:15Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "diffHunk": "@@ -516,31 +517,116 @@ public void process(EntryTaskScheduler<ReplicaFragmentSyncInfo, Void> scheduler,\n     }\n \n     private class AntiEntropyTask implements Runnable {\n+\n+        private static final int UNSET = -1;\n+\n+        private final long firstRunNanos;\n+        private final long backupSyncCheckIntervalSeconds;\n+        private final Semaphore semaphore = new Semaphore(0);\n+\n+        private int numInOneGo;\n+        private Queue<Integer> localPartitionIds;\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds) {\n+            this(backupSyncCheckIntervalSeconds, null, UNSET, UNSET);\n+        }\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds, Queue<Integer> localPartitionIds,\n+                        long firstRunNanos, int numInOneGo) {\n+            this.backupSyncCheckIntervalSeconds = backupSyncCheckIntervalSeconds;\n+            this.localPartitionIds = localPartitionIds;\n+            this.firstRunNanos = firstRunNanos;\n+            this.numInOneGo = numInOneGo;\n+        }\n+\n         @Override\n         public void run() {\n+            long initialStartTimeInNanos = firstRunNanos == UNSET ? System.nanoTime() : firstRunNanos;\n+\n             if (!node.isRunning() || !node.getNodeExtension().isStartCompleted()\n                     || !partitionService.areMigrationTasksAllowed()) {\n                 return;\n             }\n-            nodeEngine.getOperationService().executeOnPartitions(new PartitionAntiEntropyTaskFactory(), getLocalPartitions());\n+\n+            initLocalPartitionsIfNull();\n+\n+            BitSet partitionsBitSet = convertLocalPartitionsToBitSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5409e4b82b56c9c879a2565f34bf90b90baf362f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyMjE5NQ==", "bodyText": "BitSet is given to nodeEngine.getOperationService().executeOnPartitions. This is the reason i kept it as is.", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r459322195", "createdAt": "2020-07-23T09:25:05Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "diffHunk": "@@ -516,31 +517,116 @@ public void process(EntryTaskScheduler<ReplicaFragmentSyncInfo, Void> scheduler,\n     }\n \n     private class AntiEntropyTask implements Runnable {\n+\n+        private static final int UNSET = -1;\n+\n+        private final long firstRunNanos;\n+        private final long backupSyncCheckIntervalSeconds;\n+        private final Semaphore semaphore = new Semaphore(0);\n+\n+        private int numInOneGo;\n+        private Queue<Integer> localPartitionIds;\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds) {\n+            this(backupSyncCheckIntervalSeconds, null, UNSET, UNSET);\n+        }\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds, Queue<Integer> localPartitionIds,\n+                        long firstRunNanos, int numInOneGo) {\n+            this.backupSyncCheckIntervalSeconds = backupSyncCheckIntervalSeconds;\n+            this.localPartitionIds = localPartitionIds;\n+            this.firstRunNanos = firstRunNanos;\n+            this.numInOneGo = numInOneGo;\n+        }\n+\n         @Override\n         public void run() {\n+            long initialStartTimeInNanos = firstRunNanos == UNSET ? System.nanoTime() : firstRunNanos;\n+\n             if (!node.isRunning() || !node.getNodeExtension().isStartCompleted()\n                     || !partitionService.areMigrationTasksAllowed()) {\n                 return;\n             }\n-            nodeEngine.getOperationService().executeOnPartitions(new PartitionAntiEntropyTaskFactory(), getLocalPartitions());\n+\n+            initLocalPartitionsIfNull();\n+\n+            BitSet partitionsBitSet = convertLocalPartitionsToBitSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg5NzU2MA=="}, "originalCommit": {"oid": "5409e4b82b56c9c879a2565f34bf90b90baf362f"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTkwOTgyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo1NTozMVrOG1XCRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOToyNToxOVrOG2Cz2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwNTEyNA==", "bodyText": "Here if partitionId is not null and we reach numInOneGo, then that partitionId is lost from this batch because it was already removed from the queue.", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r458605124", "createdAt": "2020-07-22T07:55:31Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "diffHunk": "@@ -516,31 +517,116 @@ public void process(EntryTaskScheduler<ReplicaFragmentSyncInfo, Void> scheduler,\n     }\n \n     private class AntiEntropyTask implements Runnable {\n+\n+        private static final int UNSET = -1;\n+\n+        private final long firstRunNanos;\n+        private final long backupSyncCheckIntervalSeconds;\n+        private final Semaphore semaphore = new Semaphore(0);\n+\n+        private int numInOneGo;\n+        private Queue<Integer> localPartitionIds;\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds) {\n+            this(backupSyncCheckIntervalSeconds, null, UNSET, UNSET);\n+        }\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds, Queue<Integer> localPartitionIds,\n+                        long firstRunNanos, int numInOneGo) {\n+            this.backupSyncCheckIntervalSeconds = backupSyncCheckIntervalSeconds;\n+            this.localPartitionIds = localPartitionIds;\n+            this.firstRunNanos = firstRunNanos;\n+            this.numInOneGo = numInOneGo;\n+        }\n+\n         @Override\n         public void run() {\n+            long initialStartTimeInNanos = firstRunNanos == UNSET ? System.nanoTime() : firstRunNanos;\n+\n             if (!node.isRunning() || !node.getNodeExtension().isStartCompleted()\n                     || !partitionService.areMigrationTasksAllowed()) {\n                 return;\n             }\n-            nodeEngine.getOperationService().executeOnPartitions(new PartitionAntiEntropyTaskFactory(), getLocalPartitions());\n+\n+            initLocalPartitionsIfNull();\n+\n+            BitSet partitionsBitSet = convertLocalPartitionsToBitSet();\n+\n+            runAntiEntropyTask(partitionsBitSet);\n+\n+            waitAntiEntropyTaskEnd(partitionsBitSet.cardinality());\n+\n+            scheduleNextRun(initialStartTimeInNanos);\n         }\n \n-        private BitSet getLocalPartitions() {\n-            BitSet localPartitions = new BitSet(partitionService.getPartitionCount());\n+        private void scheduleNextRun(long initialStartTimeInNanos) {\n+            ExecutionService executionService = nodeEngine.getExecutionService();\n+\n+            if (!localPartitionIds.isEmpty()) {\n+                // we still have local partitions to check\n+                executionService.schedule(new AntiEntropyTask(backupSyncCheckIntervalSeconds,\n+                        localPartitionIds, initialStartTimeInNanos, numInOneGo), 1, TimeUnit.SECONDS);\n+            } else {\n+                // we have finished checking of all local partitions, time to decide when to commence next run.\n+                long elapsedSeconds = TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - initialStartTimeInNanos);\n+                long delayBeforeNextRunSeconds = Math.max(1, backupSyncCheckIntervalSeconds - elapsedSeconds);\n+                executionService.schedule(new AntiEntropyTask(backupSyncCheckIntervalSeconds),\n+                        delayBeforeNextRunSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+\n+        private void runAntiEntropyTask(BitSet partitionsBitSet) {\n+            nodeEngine.getOperationService().executeOnPartitions(partitionId -> {\n+                semaphore.release();\n+                return new PartitionPrimaryReplicaAntiEntropyTask(nodeEngine, partitionId);\n+            }, partitionsBitSet);\n+        }\n+\n+        private void waitAntiEntropyTaskEnd(int partitionCount) {\n+            try {\n+                semaphore.acquire(partitionCount);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw ExceptionUtil.rethrow(e);\n+            }\n+        }\n+\n+        private void initLocalPartitionsIfNull() {\n+            if (localPartitionIds != null) {\n+                return;\n+            }\n+\n+            localPartitionIds = getLocalPartitionIds();\n+            numInOneGo = Math.max(1, (int) Math.ceil(1D * localPartitionIds.size() / backupSyncCheckIntervalSeconds));\n+        }\n+\n+        @Nonnull\n+        private BitSet convertLocalPartitionsToBitSet() {\n+            BitSet bitSet = new BitSet(partitionService.getPartitionCount());\n+\n+            do {\n+                Integer partitionId = localPartitionIds.poll();\n+                if (partitionId == null || bitSet.cardinality() == numInOneGo) {\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5409e4b82b56c9c879a2565f34bf90b90baf362f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyMjMzMA==", "bodyText": "Good catch, now it should be fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r459322330", "createdAt": "2020-07-23T09:25:19Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "diffHunk": "@@ -516,31 +517,116 @@ public void process(EntryTaskScheduler<ReplicaFragmentSyncInfo, Void> scheduler,\n     }\n \n     private class AntiEntropyTask implements Runnable {\n+\n+        private static final int UNSET = -1;\n+\n+        private final long firstRunNanos;\n+        private final long backupSyncCheckIntervalSeconds;\n+        private final Semaphore semaphore = new Semaphore(0);\n+\n+        private int numInOneGo;\n+        private Queue<Integer> localPartitionIds;\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds) {\n+            this(backupSyncCheckIntervalSeconds, null, UNSET, UNSET);\n+        }\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds, Queue<Integer> localPartitionIds,\n+                        long firstRunNanos, int numInOneGo) {\n+            this.backupSyncCheckIntervalSeconds = backupSyncCheckIntervalSeconds;\n+            this.localPartitionIds = localPartitionIds;\n+            this.firstRunNanos = firstRunNanos;\n+            this.numInOneGo = numInOneGo;\n+        }\n+\n         @Override\n         public void run() {\n+            long initialStartTimeInNanos = firstRunNanos == UNSET ? System.nanoTime() : firstRunNanos;\n+\n             if (!node.isRunning() || !node.getNodeExtension().isStartCompleted()\n                     || !partitionService.areMigrationTasksAllowed()) {\n                 return;\n             }\n-            nodeEngine.getOperationService().executeOnPartitions(new PartitionAntiEntropyTaskFactory(), getLocalPartitions());\n+\n+            initLocalPartitionsIfNull();\n+\n+            BitSet partitionsBitSet = convertLocalPartitionsToBitSet();\n+\n+            runAntiEntropyTask(partitionsBitSet);\n+\n+            waitAntiEntropyTaskEnd(partitionsBitSet.cardinality());\n+\n+            scheduleNextRun(initialStartTimeInNanos);\n         }\n \n-        private BitSet getLocalPartitions() {\n-            BitSet localPartitions = new BitSet(partitionService.getPartitionCount());\n+        private void scheduleNextRun(long initialStartTimeInNanos) {\n+            ExecutionService executionService = nodeEngine.getExecutionService();\n+\n+            if (!localPartitionIds.isEmpty()) {\n+                // we still have local partitions to check\n+                executionService.schedule(new AntiEntropyTask(backupSyncCheckIntervalSeconds,\n+                        localPartitionIds, initialStartTimeInNanos, numInOneGo), 1, TimeUnit.SECONDS);\n+            } else {\n+                // we have finished checking of all local partitions, time to decide when to commence next run.\n+                long elapsedSeconds = TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - initialStartTimeInNanos);\n+                long delayBeforeNextRunSeconds = Math.max(1, backupSyncCheckIntervalSeconds - elapsedSeconds);\n+                executionService.schedule(new AntiEntropyTask(backupSyncCheckIntervalSeconds),\n+                        delayBeforeNextRunSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+\n+        private void runAntiEntropyTask(BitSet partitionsBitSet) {\n+            nodeEngine.getOperationService().executeOnPartitions(partitionId -> {\n+                semaphore.release();\n+                return new PartitionPrimaryReplicaAntiEntropyTask(nodeEngine, partitionId);\n+            }, partitionsBitSet);\n+        }\n+\n+        private void waitAntiEntropyTaskEnd(int partitionCount) {\n+            try {\n+                semaphore.acquire(partitionCount);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw ExceptionUtil.rethrow(e);\n+            }\n+        }\n+\n+        private void initLocalPartitionsIfNull() {\n+            if (localPartitionIds != null) {\n+                return;\n+            }\n+\n+            localPartitionIds = getLocalPartitionIds();\n+            numInOneGo = Math.max(1, (int) Math.ceil(1D * localPartitionIds.size() / backupSyncCheckIntervalSeconds));\n+        }\n+\n+        @Nonnull\n+        private BitSet convertLocalPartitionsToBitSet() {\n+            BitSet bitSet = new BitSet(partitionService.getPartitionCount());\n+\n+            do {\n+                Integer partitionId = localPartitionIds.poll();\n+                if (partitionId == null || bitSet.cardinality() == numInOneGo) {\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwNTEyNA=="}, "originalCommit": {"oid": "5409e4b82b56c9c879a2565f34bf90b90baf362f"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 410, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}