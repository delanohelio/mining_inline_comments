{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4ODI1NTI1", "number": 17365, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoxNDo1NlrOEZaIbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzoyOToxM1rOEZ16HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDc3OTk2OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoxNDo1NlrOHCM5Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoyMDoxOVrOHCNEiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDQ1NA==", "bodyText": "As far as I understand, these changes are needed for a convenient development setup for Jet. Could you please explain, how exactly the development setup will look like?\nAnother question - does this change introduce any changes to IMDG SQL artifacts produced during a default build?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472070454", "createdAt": "2020-08-18T10:14:56Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/pom.xml", "diffHunk": "@@ -71,6 +71,73 @@\n                 <version>${maven.shade.plugin.version}</version>\n                 <executions>\n                     <execution>\n+                        <id>fat-jar</id>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzM1NQ==", "bodyText": "There will be 2 artifacts produced:\n\nhazelcast-sql-{version}.jar, shaded dependencies etc. (no changes here)\nhazelcast-sql-{version}-jar-with-depepndencies.jar, dependencies included but not shaded, it will be used by Jet, so we get the same version of Calcite and other libraries as IMDG while being able to work with classes from Calcite (non shaded) packages", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472073355", "createdAt": "2020-08-18T10:20:19Z", "author": {"login": "gierlachg"}, "path": "hazelcast-sql/pom.xml", "diffHunk": "@@ -71,6 +71,73 @@\n                 <version>${maven.shade.plugin.version}</version>\n                 <executions>\n                     <execution>\n+                        <id>fat-jar</id>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDQ1NA=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDc5MDk1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoxNzo1OVrOHCM_5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzozMjoxNVrOHC513Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw==", "bodyText": "Why do we throw a new RuntimeException here? Will throw doneError; be proper to address #17160?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472072167", "createdAt": "2020-08-18T10:17:59Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NTEyNg==", "bodyText": "We wrap in another RuntimeException to have a proper stack trace: we want a stack trace from the place where the exception was thrown, not where it was created. This exception is not propagated to the user, it is used to tear down the jet job after a cancellation and will be logged on the member. It also cancels the scheduled imdg task.\nYes, it's a fix to #17160.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472075126", "createdAt": "2020-08-18T10:23:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MzQwMA==", "bodyText": "Is this condition specific to Jet only?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472083400", "createdAt": "2020-08-18T10:40:05Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MDAyOA==", "bodyText": "Nope, it's a general principle. Without this wrapping the stack trace will point you somewhere completely else than where the exception was actually thrown.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472240028", "createdAt": "2020-08-18T14:28:36Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxMTYxMA==", "bodyText": "I do not quite get how it plays with the IMDG engine. First question - why we choose RuntimeException, while in all other parts of the engine we work with QueryException that carries additional information, which is eventually converted to public SqlException?\nThe second question is more important - why should we rethrow an exception at all? The idea of doneError is that this is an exception that is propagated to the user eventually. But consume is an internal method. From the IMDG perspective, there is no sense to throw an exception there, because the error is already reported, so the executor will be terminate soon anyway, and throwing another exception from consume will do nothing. Why do we need to throw an exception from here for Jet?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472411610", "createdAt": "2020-08-18T18:54:19Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2NTg2Nw==", "bodyText": "Reverted that particular change", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472765867", "createdAt": "2020-08-19T06:41:45Z", "author": {"login": "gierlachg"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3MTc5NQ==", "bodyText": "But now we hit the problem with the wrong assert :-) What I meant is that for the IMDG engine, throwing error from here is basically no-op because the other error has already been installed. So the following code is most likely to work just fine:\npublic boolean consume(List<Row> batch, boolean last) {\n    synchronized (mux) {\n        if (done) {\n            return false;\n        }\n        ...\n    }  \n}\n\nIn this case, the RootExec will return WAIT and deactivate the fragment. This is ok because the original error already triggered cancel operation, which will clear the fragment eventually. Re-throwing the error here makes no difference because the original error is already installed, and the new error will be ignored in QueryState.cancel when doing CAS(null, error).\nThe question is whether Jet requires throwing an error from consume?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472771795", "createdAt": "2020-08-19T06:49:32Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3MzkwNA==", "bodyText": "I feel like addressing this issue should be part of a separate PR", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472773904", "createdAt": "2020-08-19T06:52:04Z", "author": {"login": "gierlachg"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgwNjg3Nw==", "bodyText": "I consider copying this whole class. It's tailored for IMDG needs, it's not a well-defined reusable API. For example, Jet doesn't need the setup or the callback. It's prone to incompatible changes in the future.\nThen the issue #17160 remains to be fixed by imdg guys.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472806877", "createdAt": "2020-08-19T07:32:15Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDc5NzU2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/Expression.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoyMDowMFrOHCND1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDo0MTo0M1rOHCX2tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzE3Mg==", "bodyText": "Does Jet still require Expression to be serializable? Ideally, we should avoid adding Serializable here, since this is just an internal class that is passed over the wire, and is not meant to be serialized by some generic mechanism in IMDG\nSame question for QueryPath, QueryDataType, Converter", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472073172", "createdAt": "2020-08-18T10:20:00Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/Expression.java", "diffHunk": "@@ -20,12 +20,15 @@\n import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.type.QueryDataType;\n \n+import java.io.Serializable;\n+\n /**\n  * Defines expression contract for SQL.\n  *\n  * @param <T> the return type of this expression.\n  */\n-public interface Expression<T> extends DataSerializable {\n+public interface Expression<T> extends DataSerializable, Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0NDc3NA==", "bodyText": "I tried to fix this. It's doable, but it's extremely lot of extra code and the gain is little. We have to replace a simple serializable lambda with a class that implements DataSerializable and writes all the captured state manually. For example:\n\nI started with it but stopped after few hours with the light at the end of the tunnel still far ahead. We use lambdas everywhere and often wrap them in another lambdas to modify some behavior.\nThe benefit is little: it makes the job initialization slightly faster, but Jet never aimed at maximum job deployment performance. My guess is that the speedup is less than 1ms per job.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472244774", "createdAt": "2020-08-18T14:34:47Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/Expression.java", "diffHunk": "@@ -20,12 +20,15 @@\n import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.type.QueryDataType;\n \n+import java.io.Serializable;\n+\n /**\n  * Defines expression contract for SQL.\n  *\n  * @param <T> the return type of this expression.\n  */\n-public interface Expression<T> extends DataSerializable {\n+public interface Expression<T> extends DataSerializable, Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzE3Mg=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1MDAzNw==", "bodyText": "Actually, I removed it from QueryPath", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472250037", "createdAt": "2020-08-18T14:41:43Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/Expression.java", "diffHunk": "@@ -20,12 +20,15 @@\n import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.type.QueryDataType;\n \n+import java.io.Serializable;\n+\n /**\n  * Defines expression contract for SQL.\n  *\n  * @param <T> the return type of this expression.\n  */\n-public interface Expression<T> extends DataSerializable {\n+public interface Expression<T> extends DataSerializable, Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzE3Mg=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDgyMDI1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoyNzowOFrOHCNRsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjo0MTo1M1rOHC3WGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ==", "bodyText": "Does Jet service have any state that needs to be cleaned or reinitialized on member stop or rejoin? If yes, we should consider adding callbacks to reset and shutdown methods.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472076721", "createdAt": "2020-08-18T10:27:08Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -99,21 +104,31 @@ public SqlServiceImpl(NodeEngineImpl nodeEngine) {\n         assert operationPoolSize > 0;\n         assert queryTimeout >= 0L;\n \n+        this.executorPoolSize = executorPoolSize;\n+        this.operationPoolSize = operationPoolSize;\n         this.queryTimeout = queryTimeout;\n+    }\n \n-        nodeServiceProvider = new NodeServiceProviderImpl(nodeEngine);\n+    public void start() {\n+        try {\n+            jetSqlService = nodeEngine.getService(JetSqlService.SERVICE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTU4NA==", "bodyText": "They are not needed at the moment but maybe it's safer to add them now", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472081584", "createdAt": "2020-08-18T10:36:43Z", "author": {"login": "gierlachg"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -99,21 +104,31 @@ public SqlServiceImpl(NodeEngineImpl nodeEngine) {\n         assert operationPoolSize > 0;\n         assert queryTimeout >= 0L;\n \n+        this.executorPoolSize = executorPoolSize;\n+        this.operationPoolSize = operationPoolSize;\n         this.queryTimeout = queryTimeout;\n+    }\n \n-        nodeServiceProvider = new NodeServiceProviderImpl(nodeEngine);\n+    public void start() {\n+        try {\n+            jetSqlService = nodeEngine.getService(JetSqlService.SERVICE_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MjgyNQ==", "bodyText": "I also think so. It is better to have no-op implementations now rather than waiting for the next IMDG release in case the risk becomes real.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472082825", "createdAt": "2020-08-18T10:39:03Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -99,21 +104,31 @@ public SqlServiceImpl(NodeEngineImpl nodeEngine) {\n         assert operationPoolSize > 0;\n         assert queryTimeout >= 0L;\n \n+        this.executorPoolSize = executorPoolSize;\n+        this.operationPoolSize = operationPoolSize;\n         this.queryTimeout = queryTimeout;\n+    }\n \n-        nodeServiceProvider = new NodeServiceProviderImpl(nodeEngine);\n+    public void start() {\n+        try {\n+            jetSqlService = nodeEngine.getService(JetSqlService.SERVICE_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2NTk3OQ==", "bodyText": "So it is done", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472765979", "createdAt": "2020-08-19T06:41:53Z", "author": {"login": "gierlachg"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -99,21 +104,31 @@ public SqlServiceImpl(NodeEngineImpl nodeEngine) {\n         assert operationPoolSize > 0;\n         assert queryTimeout >= 0L;\n \n+        this.executorPoolSize = executorPoolSize;\n+        this.operationPoolSize = operationPoolSize;\n         this.queryTimeout = queryTimeout;\n+    }\n \n-        nodeServiceProvider = new NodeServiceProviderImpl(nodeEngine);\n+    public void start() {\n+        try {\n+            jetSqlService = nodeEngine.getService(JetSqlService.SERVICE_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDgzMzE2OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDozMToyMFrOHCNZsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDozODoxNVrOHCNoBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3ODc3MA==", "bodyText": "What is the purpose of this whole check?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472078770", "createdAt": "2020-08-18T10:31:20Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -154,6 +161,16 @@ public Void visit(SqlNodeList nodeList) {\n \n     @Override\n     public Void visit(SqlIdentifier id) {\n+        SqlValidatorTable table = catalogReader.getTable(id.names);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MjQzOQ==", "bodyText": "For instance SELECT * FROM kafka should fail, even if all operators are supported by IMDG, it does not mean it can handle such statement", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472082439", "createdAt": "2020-08-18T10:38:15Z", "author": {"login": "gierlachg"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -154,6 +161,16 @@ public Void visit(SqlNodeList nodeList) {\n \n     @Override\n     public Void visit(SqlIdentifier id) {\n+        SqlValidatorTable table = catalogReader.getTable(id.names);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3ODc3MA=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDg0OTA5OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlBackend.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDozNjowMlrOHCNjUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo0Mzo1NFrOHDxBVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ==", "bodyText": "Minor comment: I still have a worry that this interface might render insufficient for some commands in the future, which will block Jet from making some changes until the relevant codebase is adjusted in IMDG.\nI do not have any specific examples right now, so this is not a comment to address immediately. We just need to be aware of the alternative approach, where the backend just consumes the SqlQuery and produces the abstract result. In this case, the risk of required changes in IMDG will be minimal at the cost of more complicated backend implementation in Jet (possibly with some code duplication).\nHopefully, the current approach will work well enough for us.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472081235", "createdAt": "2020-08-18T10:36:02Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlBackend.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.prepare.Prepare;\n+import org.apache.calcite.prepare.Prepare.CatalogReader;\n+import org.apache.calcite.sql.parser.SqlParserImplFactory;\n+import org.apache.calcite.sql.util.SqlVisitor;\n+import org.apache.calcite.sql.validate.SqlConformance;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql2rel.SqlRexConvertletTable;\n+import org.apache.calcite.sql2rel.SqlToRelConverter;\n+import org.apache.calcite.sql2rel.SqlToRelConverter.Config;\n+\n+/**\n+ * Provides various customization points for the optimization engine.\n+ */\n+public interface SqlBackend {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MzA0OQ==", "bodyText": "Right, that would require duplicating fair amount of code. Not mentioning, we (Jet) would need to carefully monitor all the commits that go into sql module to replicate the changes on the Jet side (we want exactly same behavior for IMDG queries as if Jet would not be there). Moreover, the logic would most probably look exactly as it does currently in IMDG...\nRegarding unknown unknowns, I was thinking about introducing JetSqlService.execute(SqlQuery sql) - the logic would could go like this:\nif (jetSqlService != null) {\n    SqlResult result = jetSqlService.execute(query);\n    if (result != null) {\n         return result;\n    }\n}\n// otherwise continue with current flow\n\nRight now, we would leave it returning null but if we really encounter a case which does not fit the current solution we could plugin required logic until we get another IMDG release. WDYT?", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472093049", "createdAt": "2020-08-18T10:59:34Z", "author": {"login": "gierlachg"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlBackend.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.prepare.Prepare;\n+import org.apache.calcite.prepare.Prepare.CatalogReader;\n+import org.apache.calcite.sql.parser.SqlParserImplFactory;\n+import org.apache.calcite.sql.util.SqlVisitor;\n+import org.apache.calcite.sql.validate.SqlConformance;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql2rel.SqlRexConvertletTable;\n+import org.apache.calcite.sql2rel.SqlToRelConverter;\n+import org.apache.calcite.sql2rel.SqlToRelConverter.Config;\n+\n+/**\n+ * Provides various customization points for the optimization engine.\n+ */\n+public interface SqlBackend {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDg4MQ==", "bodyText": "AFAIU we do not have concrete examples where the current approach doesn't work. So perhaps we may leave it as is for now.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472094881", "createdAt": "2020-08-18T11:03:22Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlBackend.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.prepare.Prepare;\n+import org.apache.calcite.prepare.Prepare.CatalogReader;\n+import org.apache.calcite.sql.parser.SqlParserImplFactory;\n+import org.apache.calcite.sql.util.SqlVisitor;\n+import org.apache.calcite.sql.validate.SqlConformance;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql2rel.SqlRexConvertletTable;\n+import org.apache.calcite.sql2rel.SqlToRelConverter;\n+import org.apache.calcite.sql2rel.SqlToRelConverter.Config;\n+\n+/**\n+ * Provides various customization points for the optimization engine.\n+ */\n+public interface SqlBackend {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxMDkzNA==", "bodyText": "Also, we might add a default method on the interface with the more generic signature. Shared code can be located in that method and it might call another, more concrete, method on the same interface. If at some point jet needs more control, it can switch from implementing the more concrete method to implementing the more generic method. Hopefully this comment makes sense :)", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r473710934", "createdAt": "2020-08-20T07:43:54Z", "author": {"login": "mmedenjak"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlBackend.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.prepare.Prepare;\n+import org.apache.calcite.prepare.Prepare.CatalogReader;\n+import org.apache.calcite.sql.parser.SqlParserImplFactory;\n+import org.apache.calcite.sql.util.SqlVisitor;\n+import org.apache.calcite.sql.validate.SqlConformance;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql2rel.SqlRexConvertletTable;\n+import org.apache.calcite.sql2rel.SqlToRelConverter;\n+import org.apache.calcite.sql2rel.SqlToRelConverter.Config;\n+\n+/**\n+ * Provides various customization points for the optimization engine.\n+ */\n+public interface SqlBackend {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ=="}, "originalCommit": {"oid": "5871fef9dde942c85c906a445a8103478542da3e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTMzMDg1OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/JetSqlTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzoyOToxM1rOHC5r2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzoyOToxM1rOHC5r2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgwNDMxMw==", "bodyText": "As far as I see, this is not a client test. TestHazelcastInstanceFactory should be enough instead of this one.", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472804313", "createdAt": "2020-08-19T07:29:13Z", "author": {"login": "sancar"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/JetSqlTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.instance.impl.DefaultNodeExtension;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.instance.impl.NodeContext;\n+import com.hazelcast.instance.impl.NodeExtension;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.impl.calcite.SqlBackend;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlOptimizer;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import com.hazelcast.sql.impl.plan.cache.PlanObjectKey;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableResolver;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import com.hazelcast.test.mocknetwork.MockNodeContext;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.Map;\n+\n+import static com.hazelcast.instance.impl.HazelcastInstanceFactory.newHazelcastInstance;\n+import static com.hazelcast.sql.impl.QueryUtils.CATALOG;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class JetSqlTest extends SqlTestSupport {\n+\n+    private static final TestHazelcastFactory FACTORY = new TestHazelcastFactory(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdfca2f03d0c70a414390d4670aec014c7f43208"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 301, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}