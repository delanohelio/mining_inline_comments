{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NDY2MTYx", "number": 17057, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1NTo0NFrOEDC7bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowMzoyMlrOEGXVXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjI5MTY3OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1NTo0NFrOGf38pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo0NTowMVrOGjms6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4Nw==", "bodyText": "This method is never overridden, do you plan that in the future?", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r436075687", "createdAt": "2020-06-05T17:55:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -17,109 +17,65 @@\n package com.hazelcast.sql.impl.calcite.opt;\n \n import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n import org.apache.calcite.plan.RelOptCluster;\n import org.apache.calcite.plan.RelOptCost;\n import org.apache.calcite.plan.RelOptPlanner;\n import org.apache.calcite.plan.RelOptTable;\n import org.apache.calcite.plan.RelTraitSet;\n-import org.apache.calcite.rel.RelWriter;\n import org.apache.calcite.rel.metadata.RelMetadataQuery;\n-import org.apache.calcite.rex.RexNode;\n-\n-import java.util.List;\n \n /**\n  * Base class for map scans.\n  */\n public abstract class AbstractMapScanRel extends AbstractScanRel {\n-    /** Filter. */\n-    protected final RexNode filter;\n-\n     public AbstractMapScanRel(\n         RelOptCluster cluster,\n         RelTraitSet traitSet,\n-        RelOptTable table,\n-        List<Integer> projects,\n-        RexNode filter\n+        RelOptTable table\n     ) {\n-        super(cluster, traitSet, table, projects);\n-\n-        this.filter = filter;\n-    }\n-\n-    public List<Integer> getProjects() {\n-        return projects != null ? projects : identity();\n-    }\n-\n-    public RexNode getFilter() {\n-        return filter;\n+        super(cluster, traitSet, table);\n     }\n \n     public AbstractMapTable getMap() {\n         return getTableUnwrapped().getTarget();\n     }\n \n-    @Override\n-    public RelWriter explainTerms(RelWriter pw) {\n-        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n-    }\n-\n-    @Override\n-    public final double estimateRowCount(RelMetadataQuery mq) {\n-        double rowCount = super.estimateRowCount(mq);\n-\n-        if (filter != null) {\n-            double selectivity = mq.getSelectivity(this, filter);\n-\n-            rowCount = rowCount * selectivity;\n-        }\n-\n-        return rowCount;\n-    }\n-\n     @Override\n     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+        HazelcastTable table0 = getTableUnwrapped();\n+\n         return computeSelfCost(\n             planner,\n-            mq,\n+            table0.getTotalRowCount(),\n+            CostUtils.TABLE_SCAN_CPU_MULTIPLIER, table0.getFilter() != null,\n             table.getRowCount(),\n-            filter,\n-            getProjects().size(),\n-            CostUtils.TABLE_SCAN_CPU_MULTIPLIER\n+            table0.getProjects().size()\n         );\n     }\n \n     protected RelOptCost computeSelfCost(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4NzQzMg==", "bodyText": "Yes, it will be overridden in the index scan operator.", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r439987432", "createdAt": "2020-06-15T07:45:01Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -17,109 +17,65 @@\n package com.hazelcast.sql.impl.calcite.opt;\n \n import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n import org.apache.calcite.plan.RelOptCluster;\n import org.apache.calcite.plan.RelOptCost;\n import org.apache.calcite.plan.RelOptPlanner;\n import org.apache.calcite.plan.RelOptTable;\n import org.apache.calcite.plan.RelTraitSet;\n-import org.apache.calcite.rel.RelWriter;\n import org.apache.calcite.rel.metadata.RelMetadataQuery;\n-import org.apache.calcite.rex.RexNode;\n-\n-import java.util.List;\n \n /**\n  * Base class for map scans.\n  */\n public abstract class AbstractMapScanRel extends AbstractScanRel {\n-    /** Filter. */\n-    protected final RexNode filter;\n-\n     public AbstractMapScanRel(\n         RelOptCluster cluster,\n         RelTraitSet traitSet,\n-        RelOptTable table,\n-        List<Integer> projects,\n-        RexNode filter\n+        RelOptTable table\n     ) {\n-        super(cluster, traitSet, table, projects);\n-\n-        this.filter = filter;\n-    }\n-\n-    public List<Integer> getProjects() {\n-        return projects != null ? projects : identity();\n-    }\n-\n-    public RexNode getFilter() {\n-        return filter;\n+        super(cluster, traitSet, table);\n     }\n \n     public AbstractMapTable getMap() {\n         return getTableUnwrapped().getTarget();\n     }\n \n-    @Override\n-    public RelWriter explainTerms(RelWriter pw) {\n-        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n-    }\n-\n-    @Override\n-    public final double estimateRowCount(RelMetadataQuery mq) {\n-        double rowCount = super.estimateRowCount(mq);\n-\n-        if (filter != null) {\n-            double selectivity = mq.getSelectivity(this, filter);\n-\n-            rowCount = rowCount * selectivity;\n-        }\n-\n-        return rowCount;\n-    }\n-\n     @Override\n     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+        HazelcastTable table0 = getTableUnwrapped();\n+\n         return computeSelfCost(\n             planner,\n-            mq,\n+            table0.getTotalRowCount(),\n+            CostUtils.TABLE_SCAN_CPU_MULTIPLIER, table0.getFilter() != null,\n             table.getRowCount(),\n-            filter,\n-            getProjects().size(),\n-            CostUtils.TABLE_SCAN_CPU_MULTIPLIER\n+            table0.getProjects().size()\n         );\n     }\n \n     protected RelOptCost computeSelfCost(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4Nw=="}, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjQ4Mjk1OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/ProjectIntoScanLogicalRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODo1Mzo1NVrOGf51HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo0NjoxNFrOGjmvhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjUyNA==", "bodyText": "Shouldn't we set use projects=[] for the scan? It should be able to handle zero fields...", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r436106524", "createdAt": "2020-06-05T18:53:55Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/ProjectIntoScanLogicalRule.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.core.TableScan;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexVisitorImpl;\n+import org.apache.calcite.util.mapping.Mapping;\n+import org.apache.calcite.util.mapping.Mappings;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Logical rule that pushes down a column references from a {@link Project} into a {@link TableScan} to allow for constrained\n+ * scans. See {@link HazelcastTable} for more information about constrained scans.\n+ * <p>\n+ * <b>Case 1: </b>projects that have only column expressions are eliminated completely, unused columns returned from the\n+ * {@code TableScan} are trimmed.\n+ * <p>\n+ * Before:\n+ * <pre>\n+ * LogicalProject[projects=[$2, $1]]]\n+ *   LogicalTableScan[table[projects=[0, 1, 2]]]\n+ * </pre>\n+ * After:\n+ * <pre>\n+ * LogicalTableScan[table[projects=[2, 1]]]\n+ * </pre>\n+ * <b>Case 2: </b>projects with non-column expressions trim the unused columns only.\n+ * <p>\n+ * Before:\n+ * <pre>\n+ * LogicalProject[projects=[+$2, $0]]]\n+ *   LogicalTableScan[table[projects=[0, 1, 2]]]\n+ * </pre>\n+ * After:\n+ * <pre>\n+ * LogicalProject[projects=[+$0, $1]]]\n+ *   LogicalTableScan[table[projects=[2, 0]]]\n+ * </pre>\n+ */\n+public final class ProjectIntoScanLogicalRule extends RelOptRule {\n+\n+    public static final ProjectIntoScanLogicalRule INSTANCE = new ProjectIntoScanLogicalRule();\n+\n+    private ProjectIntoScanLogicalRule() {\n+        super(\n+            operand(LogicalProject.class,\n+                operandJ(LogicalTableScan.class, null, OptUtils::isHazelcastTable, none())),\n+            RelFactories.LOGICAL_BUILDER,\n+            ProjectIntoScanLogicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+        Project project = call.rel(0);\n+        TableScan scan = call.rel(1);\n+\n+        Mappings.TargetMapping mapping = project.getMapping();\n+\n+        if (mapping != null) {\n+            processSimple(call, mapping, scan);\n+        } else {\n+            processComplex(call, project, scan);\n+        }\n+    }\n+\n+    /**\n+     * Process simple case when all project expressions are direct field access. The {@code Project} is eliminated completely.\n+     *\n+     * @param mapping Projects mapping.\n+     * @param scan Scan.\n+     */\n+    private static void processSimple(RelOptRuleCall call, Mappings.TargetMapping mapping, TableScan scan) {\n+        // Get columns defined in the original TableScan.\n+        HazelcastTable originalTable = OptUtils.getHazelcastTable(scan);\n+\n+        List<Integer> originalProjects = originalTable.getProjects();\n+\n+        // Remap columns from the Project. The result is the projects that will be pushed down to the new TableScan.\n+        // E.g. consider the table \"t[f0, f1, f2]\" and the SQL query \"SELECT f2, f0\":\n+        //   Original projects: [0(f0), 1(f1), 2(f2)]\n+        //   New projects:      [2(f2), 0(f0)]\n+        List<Integer> newProjects = Mappings.apply((Mapping) mapping, originalProjects);\n+\n+        // Construct the new TableScan with adjusted columns.\n+        LogicalTableScan newScan = OptUtils.createLogicalScanWithNewTable(\n+            scan,\n+            originalTable.withProject(newProjects)\n+        );\n+\n+        call.transformTo(newScan);\n+    }\n+\n+    /**\n+     * Process the complex project with expressions. The {@code Project} operator will remain, but the number and the order of\n+     * columns returned from the {@code TableScan} is adjusted.\n+     *\n+     * @param project Project.\n+     * @param scan Scan.\n+     */\n+    private void processComplex(RelOptRuleCall call, Project project, TableScan scan) {\n+        HazelcastTable originalTable = OptUtils.getHazelcastTable(scan);\n+\n+        // Map projected field references to real scan fields.\n+        ProjectFieldVisitor projectFieldVisitor = new ProjectFieldVisitor(originalTable.getProjects());\n+\n+        for (RexNode projectExp : project.getProjects()) {\n+            projectExp.accept(projectFieldVisitor);\n+        }\n+\n+        // Get new scan fields. These are the only fields that are accessed by the project operator.\n+        List<Integer> newScanProjects = projectFieldVisitor.createNewScanProjects();\n+\n+        if (newScanProjects.isEmpty()) {\n+            // No TableScan columns are referenced from within a project, i.e. the Project doesn't depend on column values\n+            // of the TableScan. E.g. \"SELECT CURRENT_TIME() FROM t\". In future we will introduce a special optimizer operator\n+            // for that case that will not do a real scan. It is not trivial, because we should take in count whether the\n+            // Project expressions are deterministic or not. Therefore, we simply ignore that case for now.\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4ODEwMQ==", "bodyText": "It was not supported in the first version with the explicit comment in the ProjectIntoScan rule.\nI added the support for this case in the last commit.", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r439988101", "createdAt": "2020-06-15T07:46:14Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/ProjectIntoScanLogicalRule.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.core.TableScan;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexVisitorImpl;\n+import org.apache.calcite.util.mapping.Mapping;\n+import org.apache.calcite.util.mapping.Mappings;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Logical rule that pushes down a column references from a {@link Project} into a {@link TableScan} to allow for constrained\n+ * scans. See {@link HazelcastTable} for more information about constrained scans.\n+ * <p>\n+ * <b>Case 1: </b>projects that have only column expressions are eliminated completely, unused columns returned from the\n+ * {@code TableScan} are trimmed.\n+ * <p>\n+ * Before:\n+ * <pre>\n+ * LogicalProject[projects=[$2, $1]]]\n+ *   LogicalTableScan[table[projects=[0, 1, 2]]]\n+ * </pre>\n+ * After:\n+ * <pre>\n+ * LogicalTableScan[table[projects=[2, 1]]]\n+ * </pre>\n+ * <b>Case 2: </b>projects with non-column expressions trim the unused columns only.\n+ * <p>\n+ * Before:\n+ * <pre>\n+ * LogicalProject[projects=[+$2, $0]]]\n+ *   LogicalTableScan[table[projects=[0, 1, 2]]]\n+ * </pre>\n+ * After:\n+ * <pre>\n+ * LogicalProject[projects=[+$0, $1]]]\n+ *   LogicalTableScan[table[projects=[2, 0]]]\n+ * </pre>\n+ */\n+public final class ProjectIntoScanLogicalRule extends RelOptRule {\n+\n+    public static final ProjectIntoScanLogicalRule INSTANCE = new ProjectIntoScanLogicalRule();\n+\n+    private ProjectIntoScanLogicalRule() {\n+        super(\n+            operand(LogicalProject.class,\n+                operandJ(LogicalTableScan.class, null, OptUtils::isHazelcastTable, none())),\n+            RelFactories.LOGICAL_BUILDER,\n+            ProjectIntoScanLogicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+        Project project = call.rel(0);\n+        TableScan scan = call.rel(1);\n+\n+        Mappings.TargetMapping mapping = project.getMapping();\n+\n+        if (mapping != null) {\n+            processSimple(call, mapping, scan);\n+        } else {\n+            processComplex(call, project, scan);\n+        }\n+    }\n+\n+    /**\n+     * Process simple case when all project expressions are direct field access. The {@code Project} is eliminated completely.\n+     *\n+     * @param mapping Projects mapping.\n+     * @param scan Scan.\n+     */\n+    private static void processSimple(RelOptRuleCall call, Mappings.TargetMapping mapping, TableScan scan) {\n+        // Get columns defined in the original TableScan.\n+        HazelcastTable originalTable = OptUtils.getHazelcastTable(scan);\n+\n+        List<Integer> originalProjects = originalTable.getProjects();\n+\n+        // Remap columns from the Project. The result is the projects that will be pushed down to the new TableScan.\n+        // E.g. consider the table \"t[f0, f1, f2]\" and the SQL query \"SELECT f2, f0\":\n+        //   Original projects: [0(f0), 1(f1), 2(f2)]\n+        //   New projects:      [2(f2), 0(f0)]\n+        List<Integer> newProjects = Mappings.apply((Mapping) mapping, originalProjects);\n+\n+        // Construct the new TableScan with adjusted columns.\n+        LogicalTableScan newScan = OptUtils.createLogicalScanWithNewTable(\n+            scan,\n+            originalTable.withProject(newProjects)\n+        );\n+\n+        call.transformTo(newScan);\n+    }\n+\n+    /**\n+     * Process the complex project with expressions. The {@code Project} operator will remain, but the number and the order of\n+     * columns returned from the {@code TableScan} is adjusted.\n+     *\n+     * @param project Project.\n+     * @param scan Scan.\n+     */\n+    private void processComplex(RelOptRuleCall call, Project project, TableScan scan) {\n+        HazelcastTable originalTable = OptUtils.getHazelcastTable(scan);\n+\n+        // Map projected field references to real scan fields.\n+        ProjectFieldVisitor projectFieldVisitor = new ProjectFieldVisitor(originalTable.getProjects());\n+\n+        for (RexNode projectExp : project.getProjects()) {\n+            projectExp.accept(projectFieldVisitor);\n+        }\n+\n+        // Get new scan fields. These are the only fields that are accessed by the project operator.\n+        List<Integer> newScanProjects = projectFieldVisitor.createNewScanProjects();\n+\n+        if (newScanProjects.isEmpty()) {\n+            // No TableScan columns are referenced from within a project, i.e. the Project doesn't depend on column values\n+            // of the TableScan. E.g. \"SELECT CURRENT_TIME() FROM t\". In future we will introduce a special optimizer operator\n+            // for that case that will not do a real scan. It is not trivial, because we should take in count whether the\n+            // Project expressions are deterministic or not. Therefore, we simply ignore that case for now.\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjUyNA=="}, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzQyNjI3OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwODoyNjoyMVrOGgCn2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo0NjoyN1rOGjmv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MDU4Ng==", "bodyText": "Shouldn't we allow empty projects as distinct from null. I guess null means \"all the table fields\", empty projects would mean no columns are actually selected. For the query SELECT current_date() FORM map", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r436250586", "createdAt": "2020-06-06T08:26:21Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -41,19 +50,83 @@\n  * <ul>\n  *     <li>Maps field types defined in the {@code core} module to Calcite types</li>\n  *     <li>Provides access to the underlying table and statistics</li>\n+ *     <li>Encapsulates projects and filter to allow for constained scans</li>\n  * </ul>\n+ * <p>\n+ * <h2>Constrained scans</h2>\n+ * For a sequence of logical project/filter/scan operators, we would like to ensure that the resulting relational tree is as\n+ * flat as possible because this minimizes processing overhead and memory usage. To achieve this we try to push projects and\n+ * filters into the table using {@link ProjectIntoScanLogicalRule} and {@link FilterIntoScanLogicalRule} rules. These rules\n+ * reduce the amount of data returned from the table during scanning. Pushed down projection ensures that only columns required\n+ * by parent operators are returned, thus implementing field trimming. Pushed down filter reduces the number of returned rows.\n+ * <p>\n+ * Projects are indexes of table fields that are returned. Initial projection (i.e. before optimization) returns all the columns.\n+ * After project pushdown the number and order of columns may change. For example, for the table {@code t[f1, f2, f3]} the\n+ * initial projection is {@code [0, 1, 2]}. After pushdown of a {@code \"SELECT f3, f1\"} the projection becomes {@code [2, 0]}\n+ * which means that the columns {@code [f3, f1]} are returned in that order.\n+ * <p>\n+ * Filter is a conjunctive expression that references table fields via their original indexes. That is, {@code [f3]} is\n+ * referenced as {@code [2]} even if it is projected as the first field in the example above. This is needed to allow for\n+ * projections and filters on disjoint sets of attributes.\n+ * <p>\n+ * Consider the following SQL statement:\n+ * <pre>\n+ * SELECT f3, f1 FROM t WHERE f2 > ?\n+ * </pre>\n+ * In this case {@code projects=[2, 0]}, {@code filter=[>$1,?]}.\n+ * <p>\n+ * We do not pushdown the project expressions other than columns because in this case it will be difficult to pushdown\n+ * filters, as it will require non-trivial rewrite of the filter expression to match to original scan columns.\n  */\n public class HazelcastTable extends AbstractTable {\n \n     private final Table target;\n     private final Statistic statistic;\n+    private final List<Integer> projects;\n+    private final RexNode filter;\n \n     private RelDataType rowType;\n     private Set<String> hiddenFieldNames;\n \n     public HazelcastTable(Table target, Statistic statistic) {\n+        this(target, statistic, null, null);\n+    }\n+\n+    private HazelcastTable(Table target, Statistic statistic, List<Integer> projects, RexNode filter) {\n         this.target = target;\n         this.statistic = statistic;\n+        this.projects = projects;\n+        this.filter = filter;\n+    }\n+\n+    public HazelcastTable withProject(List<Integer> projects) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public HazelcastTable withFilter(RexNode filter) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public List<Integer> getProjects() {\n+        assert projects == null || !projects.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4ODIxNw==", "bodyText": "Same as the previous comment.", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r439988217", "createdAt": "2020-06-15T07:46:27Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -41,19 +50,83 @@\n  * <ul>\n  *     <li>Maps field types defined in the {@code core} module to Calcite types</li>\n  *     <li>Provides access to the underlying table and statistics</li>\n+ *     <li>Encapsulates projects and filter to allow for constained scans</li>\n  * </ul>\n+ * <p>\n+ * <h2>Constrained scans</h2>\n+ * For a sequence of logical project/filter/scan operators, we would like to ensure that the resulting relational tree is as\n+ * flat as possible because this minimizes processing overhead and memory usage. To achieve this we try to push projects and\n+ * filters into the table using {@link ProjectIntoScanLogicalRule} and {@link FilterIntoScanLogicalRule} rules. These rules\n+ * reduce the amount of data returned from the table during scanning. Pushed down projection ensures that only columns required\n+ * by parent operators are returned, thus implementing field trimming. Pushed down filter reduces the number of returned rows.\n+ * <p>\n+ * Projects are indexes of table fields that are returned. Initial projection (i.e. before optimization) returns all the columns.\n+ * After project pushdown the number and order of columns may change. For example, for the table {@code t[f1, f2, f3]} the\n+ * initial projection is {@code [0, 1, 2]}. After pushdown of a {@code \"SELECT f3, f1\"} the projection becomes {@code [2, 0]}\n+ * which means that the columns {@code [f3, f1]} are returned in that order.\n+ * <p>\n+ * Filter is a conjunctive expression that references table fields via their original indexes. That is, {@code [f3]} is\n+ * referenced as {@code [2]} even if it is projected as the first field in the example above. This is needed to allow for\n+ * projections and filters on disjoint sets of attributes.\n+ * <p>\n+ * Consider the following SQL statement:\n+ * <pre>\n+ * SELECT f3, f1 FROM t WHERE f2 > ?\n+ * </pre>\n+ * In this case {@code projects=[2, 0]}, {@code filter=[>$1,?]}.\n+ * <p>\n+ * We do not pushdown the project expressions other than columns because in this case it will be difficult to pushdown\n+ * filters, as it will require non-trivial rewrite of the filter expression to match to original scan columns.\n  */\n public class HazelcastTable extends AbstractTable {\n \n     private final Table target;\n     private final Statistic statistic;\n+    private final List<Integer> projects;\n+    private final RexNode filter;\n \n     private RelDataType rowType;\n     private Set<String> hiddenFieldNames;\n \n     public HazelcastTable(Table target, Statistic statistic) {\n+        this(target, statistic, null, null);\n+    }\n+\n+    private HazelcastTable(Table target, Statistic statistic, List<Integer> projects, RexNode filter) {\n         this.target = target;\n         this.statistic = statistic;\n+        this.projects = projects;\n+        this.filter = filter;\n+    }\n+\n+    public HazelcastTable withProject(List<Integer> projects) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public HazelcastTable withFilter(RexNode filter) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public List<Integer> getProjects() {\n+        assert projects == null || !projects.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MDU4Ng=="}, "originalCommit": {"oid": "2962ff75a97b33f279f801bc7be654b5c019d04a"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTYwMTAxOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOToyNTo1N1rOGjqPSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjozMjowMVrOGkZECg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0NTM4Ng==", "bodyText": "Maybe we can annotate this method as @Nonnull", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440045386", "createdAt": "2020-06-15T09:25:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -17,43 +17,118 @@\n package com.hazelcast.sql.impl.calcite.schema;\n \n import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.calcite.opt.logical.FilterIntoScanLogicalRule;\n+import com.hazelcast.sql.impl.calcite.opt.logical.ProjectIntoScanLogicalRule;\n import com.hazelcast.sql.impl.schema.Table;\n import com.hazelcast.sql.impl.schema.TableField;\n import com.hazelcast.sql.impl.type.QueryDataType;\n import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelDistribution;\n+import org.apache.calcite.rel.RelReferentialConstraint;\n+import org.apache.calcite.rel.metadata.RelMdUtil;\n import org.apache.calcite.rel.type.RelDataType;\n import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n import org.apache.calcite.rel.type.StructKind;\n+import org.apache.calcite.rex.RexNode;\n import org.apache.calcite.schema.Statistic;\n import org.apache.calcite.schema.impl.AbstractTable;\n import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.util.ImmutableBitSet;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n+import java.util.StringJoiner;\n+\n+import static java.util.stream.Collectors.joining;\n \n /**\n  * Base class for all tables in the Calcite integration:\n  * <ul>\n  *     <li>Maps field types defined in the {@code core} module to Calcite types</li>\n  *     <li>Provides access to the underlying table and statistics</li>\n+ *     <li>Encapsulates projects and filter to allow for constrained scans</li>\n  * </ul>\n+ * <p>\n+ * <h2>Constrained scans</h2>\n+ * For a sequence of logical project/filter/scan operators we would like to ensure that the resulting relational tree is as\n+ * flat as possible because this minimizes the processing overhead and memory usage. To achieve this we try to push projects and\n+ * filters into the table using {@link ProjectIntoScanLogicalRule} and {@link FilterIntoScanLogicalRule}. These rules\n+ * reduce the amount of data returned from the table during scanning. Pushed-down projection ensures that only columns required\n+ * by parent operators are returned, thus implementing field trimming. Pushed-down filter reduces the number of returned rows.\n+ * <p>\n+ * Projects are indexes of table fields that are returned. Initial projection (i.e. before optimization) returns all the columns.\n+ * After project pushdown the number and order of columns may change. For example, for the table {@code t[f0, f1, f2]} the\n+ * initial projection is {@code [0, 1, 2]}. After pushdown of a {@code \"SELECT f2, f0\"} the projection becomes {@code [2, 0]}\n+ * which means that the columns {@code [f2, f0]} are returned, in that order.\n+ * <p>\n+ * Filter is a conjunctive expression that references table fields via their original indexes. That is, {@code [f2]} is\n+ * referenced as {@code [2]} even if it is projected as the first field in the example above. This is needed to allow for\n+ * projections and filters on disjoint sets of attributes.\n+ * <p>\n+ * Consider the following SQL statement:\n+ * <pre>\n+ * SELECT f2, f0 FROM t WHERE f1 > ?\n+ * </pre>\n+ * In this case {@code projects=[2, 0]}, {@code filter=[>$1, ?]}.\n+ * <p>\n+ * We do not pushdown the project expressions other than columns because in this case it will be difficult to pushdown\n+ * filters, as it will require non-trivial rewrite of the filter expression to match to original scan columns.\n  */\n public class HazelcastTable extends AbstractTable {\n \n     private final Table target;\n     private final Statistic statistic;\n+    private final List<Integer> projects;\n+    private final RexNode filter;\n \n     private RelDataType rowType;\n     private Set<String> hiddenFieldNames;\n \n     public HazelcastTable(Table target, Statistic statistic) {\n+        this(target, statistic, null, null);\n+    }\n+\n+    private HazelcastTable(Table target, Statistic statistic, List<Integer> projects, RexNode filter) {\n         this.target = target;\n         this.statistic = statistic;\n+        this.projects = projects;\n+        this.filter = filter;\n+    }\n+\n+    public HazelcastTable withProject(List<Integer> projects) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public HazelcastTable withFilter(RexNode filter) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public List<Integer> getProjects() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxMjU1NA==", "bodyText": "Added", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440812554", "createdAt": "2020-06-16T12:32:01Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -17,43 +17,118 @@\n package com.hazelcast.sql.impl.calcite.schema;\n \n import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.calcite.opt.logical.FilterIntoScanLogicalRule;\n+import com.hazelcast.sql.impl.calcite.opt.logical.ProjectIntoScanLogicalRule;\n import com.hazelcast.sql.impl.schema.Table;\n import com.hazelcast.sql.impl.schema.TableField;\n import com.hazelcast.sql.impl.type.QueryDataType;\n import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelDistribution;\n+import org.apache.calcite.rel.RelReferentialConstraint;\n+import org.apache.calcite.rel.metadata.RelMdUtil;\n import org.apache.calcite.rel.type.RelDataType;\n import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n import org.apache.calcite.rel.type.StructKind;\n+import org.apache.calcite.rex.RexNode;\n import org.apache.calcite.schema.Statistic;\n import org.apache.calcite.schema.impl.AbstractTable;\n import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.util.ImmutableBitSet;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n+import java.util.StringJoiner;\n+\n+import static java.util.stream.Collectors.joining;\n \n /**\n  * Base class for all tables in the Calcite integration:\n  * <ul>\n  *     <li>Maps field types defined in the {@code core} module to Calcite types</li>\n  *     <li>Provides access to the underlying table and statistics</li>\n+ *     <li>Encapsulates projects and filter to allow for constrained scans</li>\n  * </ul>\n+ * <p>\n+ * <h2>Constrained scans</h2>\n+ * For a sequence of logical project/filter/scan operators we would like to ensure that the resulting relational tree is as\n+ * flat as possible because this minimizes the processing overhead and memory usage. To achieve this we try to push projects and\n+ * filters into the table using {@link ProjectIntoScanLogicalRule} and {@link FilterIntoScanLogicalRule}. These rules\n+ * reduce the amount of data returned from the table during scanning. Pushed-down projection ensures that only columns required\n+ * by parent operators are returned, thus implementing field trimming. Pushed-down filter reduces the number of returned rows.\n+ * <p>\n+ * Projects are indexes of table fields that are returned. Initial projection (i.e. before optimization) returns all the columns.\n+ * After project pushdown the number and order of columns may change. For example, for the table {@code t[f0, f1, f2]} the\n+ * initial projection is {@code [0, 1, 2]}. After pushdown of a {@code \"SELECT f2, f0\"} the projection becomes {@code [2, 0]}\n+ * which means that the columns {@code [f2, f0]} are returned, in that order.\n+ * <p>\n+ * Filter is a conjunctive expression that references table fields via their original indexes. That is, {@code [f2]} is\n+ * referenced as {@code [2]} even if it is projected as the first field in the example above. This is needed to allow for\n+ * projections and filters on disjoint sets of attributes.\n+ * <p>\n+ * Consider the following SQL statement:\n+ * <pre>\n+ * SELECT f2, f0 FROM t WHERE f1 > ?\n+ * </pre>\n+ * In this case {@code projects=[2, 0]}, {@code filter=[>$1, ?]}.\n+ * <p>\n+ * We do not pushdown the project expressions other than columns because in this case it will be difficult to pushdown\n+ * filters, as it will require non-trivial rewrite of the filter expression to match to original scan columns.\n  */\n public class HazelcastTable extends AbstractTable {\n \n     private final Table target;\n     private final Statistic statistic;\n+    private final List<Integer> projects;\n+    private final RexNode filter;\n \n     private RelDataType rowType;\n     private Set<String> hiddenFieldNames;\n \n     public HazelcastTable(Table target, Statistic statistic) {\n+        this(target, statistic, null, null);\n+    }\n+\n+    private HazelcastTable(Table target, Statistic statistic, List<Integer> projects, RexNode filter) {\n         this.target = target;\n         this.statistic = statistic;\n+        this.projects = projects;\n+        this.filter = filter;\n+    }\n+\n+    public HazelcastTable withProject(List<Integer> projects) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public HazelcastTable withFilter(RexNode filter) {\n+        return new HazelcastTable(target, statistic, projects, filter);\n+    }\n+\n+    public List<Integer> getProjects() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0NTM4Ng=="}, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTYyOTYyOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTozMzo0OVrOGjqhLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTozMzo0OVrOGjqhLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0OTk2NA==", "bodyText": "Now we always add the projects, even if it's identity. StringBuilder can now be easier:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringJoiner res = new StringJoiner(\", \", \"[\", \"]\");\n          \n          \n            \n                    res.setEmptyValue(\"\");\n          \n          \n            \n            \n          \n          \n            \n                    res.add(\"projects=\" + getProjects().stream().map(Objects::toString).collect(joining(\", \", \"[\", \"]\")));\n          \n          \n            \n            \n          \n          \n            \n                    if (filter != null) {\n          \n          \n            \n                        res.add(\"filter=\" + filter);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return res.toString();\n          \n          \n            \n                    StringBuilder res = new StringBuilder();\n          \n          \n            \n                    res.add(\"[projects=\");\n          \n          \n            \n                    res.add(getProjects().stream().map(Objects::toString).collect(joining(\", \", \"[\", \"]\")));\n          \n          \n            \n                    if (filter != null) {\n          \n          \n            \n                        res.add(\", filter=\").add(filter);\n          \n          \n            \n                    }\n          \n          \n            \n                    return res.add(']').toString();", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440049964", "createdAt": "2020-06-15T09:33:49Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -102,12 +179,90 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n \n     @Override\n     public Statistic getStatistic() {\n-        return statistic;\n+        if (filter == null) {\n+            return statistic;\n+        } else {\n+            Double selectivity = RelMdUtil.guessSelectivity(filter);\n+\n+            double rowCount = CostUtils.adjustFilteredRowCount(statistic.getRowCount(), selectivity);\n+\n+            return new AdjustedStatistic(rowCount);\n+        }\n+    }\n+\n+    public double getTotalRowCount() {\n+        return statistic.getRowCount();\n     }\n \n     public boolean isHidden(String fieldName) {\n         assert hiddenFieldNames != null;\n \n         return hiddenFieldNames.contains(fieldName);\n     }\n+\n+    public int getOriginalFieldCount() {\n+        return target.getFieldCount();\n+    }\n+\n+    /**\n+     * Constructs a signature for the table.\n+     * <p>\n+     * See {@link HazelcastRelOptTable} for more information.\n+     *\n+     * @return Signature.\n+     */\n+    public String getSignature() {\n+        StringJoiner res = new StringJoiner(\", \", \"[\", \"]\");\n+        res.setEmptyValue(\"\");\n+\n+        res.add(\"projects=\" + getProjects().stream().map(Objects::toString).collect(joining(\", \", \"[\", \"]\")));\n+\n+        if (filter != null) {\n+            res.add(\"filter=\" + filter);\n+        }\n+\n+        return res.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTY1NzkzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/row/EmptyRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo0MTo0MFrOGjqy9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0MTozOFrOGkZZ3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NDUxNw==", "bodyText": "Doesn't matter much, but we should throw IndexOutOfBoundsException(\"index=\" + index). The operation doesn't have a missing implementation - it's implemented, but there's no valid index it can be called with.\nSame in EmptyRowBatch.getRow()", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440054517", "createdAt": "2020-06-15T09:41:40Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/row/EmptyRow.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.row;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Row with no columns. It may appear when the downstream operator doesn't need any columns from\n+ * the upstream, and only the number of returned rows is important.\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * SELECT GET_DATE() FROM person\n+ * </pre>\n+ */\n+public class EmptyRow implements Row, IdentifiedDataSerializable {\n+\n+    public static final EmptyRow INSTANCE = new EmptyRow();\n+\n+    public EmptyRow() {\n+        // No-op.\n+    }\n+\n+    @Override\n+    public <T> T get(int index) {\n+        throw new UnsupportedOperationException(\"Should not be called.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODE0Mg==", "bodyText": "Agree, fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440818142", "createdAt": "2020-06-16T12:41:38Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/row/EmptyRow.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.row;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Row with no columns. It may appear when the downstream operator doesn't need any columns from\n+ * the upstream, and only the number of returned rows is important.\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * SELECT GET_DATE() FROM person\n+ * </pre>\n+ */\n+public class EmptyRow implements Row, IdentifiedDataSerializable {\n+\n+    public static final EmptyRow INSTANCE = new EmptyRow();\n+\n+    public EmptyRow() {\n+        // No-op.\n+    }\n+\n+    @Override\n+    public <T> T get(int index) {\n+        throw new UnsupportedOperationException(\"Should not be called.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NDUxNw=="}, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTY4NjQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/MapScanExecTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo0OToxNlrOGjrEoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo0ODozN1rOGk33cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1OTA0MA==", "bodyText": "This might be easier to read:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Get local partition\n          \n          \n            \n                    int partitionId = 0;\n          \n          \n            \n            \n          \n          \n            \n                    for (Partition partition : instance1.getPartitionService().getPartitions()) {\n          \n          \n            \n                        if (instance1.getLocalEndpoint().getUuid().equals(partition.getOwner().getUuid())) {\n          \n          \n            \n                            partitionId = partition.getPartitionId();\n          \n          \n            \n            \n          \n          \n            \n                            break;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    // Get some local partition\n          \n          \n            \n                    int partitionId = instance1.getPartitionService().getPartitions().stream()\n          \n          \n            \n                            .filter(p -> instance1.getLocalEndpoint().getUuid().equals(p.getOwner().getUuid()))\n          \n          \n            \n                            .findAny().get()\n          \n          \n            \n                            .getPartitionId();", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r440059040", "createdAt": "2020-06-15T09:49:16Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/MapScanExecTest.java", "diffHunk": "@@ -111,6 +112,77 @@ public void testNormal_Binary() {\n         checkNormal(instance1.getMap(MAP_BINARY));\n     }\n \n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    @Test\n+    public void testEmptyRow() {\n+        MapProxyImpl<TestKey, TestValue> map = (MapProxyImpl) instance1.getMap(MAP_OBJECT);\n+\n+        // Get local partition\n+        int partitionId = 0;\n+\n+        for (Partition partition : instance1.getPartitionService().getPartitions()) {\n+            if (instance1.getLocalEndpoint().getUuid().equals(partition.getOwner().getUuid())) {\n+                partitionId = partition.getPartitionId();\n+\n+                break;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNzIzNQ==", "bodyText": "This is a matter of taste, so I'd prefer to leave a collection-based style since we are used to it in the core module.", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r441317235", "createdAt": "2020-06-17T06:48:37Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/MapScanExecTest.java", "diffHunk": "@@ -111,6 +112,77 @@ public void testNormal_Binary() {\n         checkNormal(instance1.getMap(MAP_BINARY));\n     }\n \n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    @Test\n+    public void testEmptyRow() {\n+        MapProxyImpl<TestKey, TestValue> map = (MapProxyImpl) instance1.getMap(MAP_OBJECT);\n+\n+        // Get local partition\n+        int partitionId = 0;\n+\n+        for (Partition partition : instance1.getPartitionService().getPartitions()) {\n+            if (instance1.getLocalEndpoint().getUuid().equals(partition.getOwner().getUuid())) {\n+                partitionId = partition.getPartitionId();\n+\n+                break;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1OTA0MA=="}, "originalCommit": {"oid": "e59686c12447f1bc63f89037733abae26399ab8c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTA5MjE1OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowMzoyMlrOGlHTyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowMzoyMlrOGlHTyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3MDI1MQ==", "bodyText": "It's never empty...", "url": "https://github.com/hazelcast/hazelcast/pull/17057#discussion_r441570251", "createdAt": "2020-06-17T14:03:22Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java", "diffHunk": "@@ -102,12 +181,91 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n \n     @Override\n     public Statistic getStatistic() {\n-        return statistic;\n+        if (filter == null) {\n+            return statistic;\n+        } else {\n+            Double selectivity = RelMdUtil.guessSelectivity(filter);\n+\n+            double rowCount = CostUtils.adjustFilteredRowCount(statistic.getRowCount(), selectivity);\n+\n+            return new AdjustedStatistic(rowCount);\n+        }\n+    }\n+\n+    public double getTotalRowCount() {\n+        return statistic.getRowCount();\n     }\n \n     public boolean isHidden(String fieldName) {\n         assert hiddenFieldNames != null;\n \n         return hiddenFieldNames.contains(fieldName);\n     }\n+\n+    public int getOriginalFieldCount() {\n+        return target.getFieldCount();\n+    }\n+\n+    /**\n+     * Constructs a signature for the table.\n+     * <p>\n+     * See {@link HazelcastRelOptTable} for more information.\n+     *\n+     * @return Signature.\n+     */\n+    public String getSignature() {\n+        StringJoiner res = new StringJoiner(\", \", \"[\", \"]\");\n+\n+        res.setEmptyValue(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429e4c8cd3ccf4b0877cc2d671974474c522f4a3"}, "originalPosition": 177}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 571, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}