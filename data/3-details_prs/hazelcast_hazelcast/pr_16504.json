{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0ODcxOTYy", "number": 16504, "title": "Fix HD ICache iterator consistency issue", "bodyText": "The hasNotBeenObserved method had an issue which might cause stable\nentries to be skipped.\nAlso:\n\nadded bouncing tests for on-heap and off-heap ICache\nmoved the hasNotBeenObserved method for a common parent class for both\noff-heap ICache and IMap\nmade it possible for ICache iterator to return an entry with a null\nvalue in case prefetchValues is false. This is the same way it is in the\nIMap iterator.\nfurther aligned the ICache and IMap code\n\nEE: hazelcast/hazelcast-enterprise#3494", "createdAt": "2020-01-20T14:50:07Z", "url": "https://github.com/hazelcast/hazelcast/pull/16504", "merged": true, "mergeCommit": {"oid": "059ef6a7c96c9ec1cad8581e5349d4aa4dbf731e"}, "closed": true, "closedAt": "2020-01-22T18:21:11Z", "author": {"login": "mmedenjak"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8PV9mgFqTM0NTM5NTI1OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8zuVOgFqTM0NjUwNjE5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Mzk1MjU5", "url": "https://github.com/hazelcast/hazelcast/pull/16504#pullrequestreview-345395259", "createdAt": "2020-01-20T15:46:27Z", "commit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNTo0NjoyN1rOFficOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNTo0NjoyN1rOFficOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNDQ1Ng==", "bodyText": "previously we checked for iteratorResult == null but the check seems redundant?", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r368614456", "createdAt": "2020-01-20T15:46:27Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CachePartitionsIterator.java", "diffHunk": "@@ -70,27 +70,24 @@ protected List fetch() {\n         final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n         if (prefetchValues) {\n             Operation operation = cacheProxy.operationProvider.createFetchEntriesOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheEntriesWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheEntriesWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getEntries(), iteratorResult.getPointers());\n-                return iteratorResult.getEntries();\n-            }\n+            CacheEntriesWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getEntries(), iteratorResult.getPointers());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1ODUxNTc3", "url": "https://github.com/hazelcast/hazelcast/pull/16504#pullrequestreview-345851577", "createdAt": "2020-01-21T12:50:14Z", "commit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6df55025d0d5023cfcfeea93181abc36300b102", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a6df55025d0d5023cfcfeea93181abc36300b102", "committedDate": "2020-01-22T09:37:27Z", "message": "Fix HD ICache iterator consistency issue\n\nThe hasNotBeenObserved method had an issue which might cause stable\nentries to be skipped.\n\nAlso:\n- added bouncing tests for on-heap and off-heap ICache\n- moved the hasNotBeenObserved method for a common parent class for both\noff-heap ICache and IMap\n- made it possible for ICache iterator to return an entry with a null\nvalue in case prefetchValues is false. This is the same way it is in the\n IMap iterator.\n- further aligned the ICache and IMap code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDYwOTkw", "url": "https://github.com/hazelcast/hazelcast/pull/16504#pullrequestreview-346460990", "createdAt": "2020-01-22T09:53:37Z", "commit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwOTo1MzozOFrOFgWJAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxMDowNFrOFgWr4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTUwNQ==", "bodyText": "@mmedenjak, it seems null is still possible?", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369461505", "createdAt": "2020-01-22T09:53:38Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CachePartitionsIterator.java", "diffHunk": "@@ -70,27 +70,24 @@ protected List fetch() {\n         final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n         if (prefetchValues) {\n             Operation operation = cacheProxy.operationProvider.createFetchEntriesOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheEntriesWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheEntriesWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getEntries(), iteratorResult.getPointers());\n-                return iteratorResult.getEntries();\n-            }\n+            CacheEntriesWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getEntries(), iteratorResult.getPointers());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNDQ1Ng=="}, "originalCommit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw==", "bodyText": "The same here regarding null iteratorResult?", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369461873", "createdAt": "2020-01-22T09:54:22Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CachePartitionsIterator.java", "diffHunk": "@@ -70,27 +70,24 @@ protected List fetch() {\n         final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n         if (prefetchValues) {\n             Operation operation = cacheProxy.operationProvider.createFetchEntriesOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheEntriesWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheEntriesWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getEntries(), iteratorResult.getPointers());\n-                return iteratorResult.getEntries();\n-            }\n+            CacheEntriesWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getEntries(), iteratorResult.getPointers());\n+            return iteratorResult.getEntries();\n         } else {\n             Operation operation = cacheProxy.operationProvider.createFetchKeysOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheKeysWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheKeysWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getKeys(), iteratorResult.getPointers());\n-                return iteratorResult.getKeys();\n-            }\n+            CacheKeysWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getKeys(), iteratorResult.getPointers());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NDM0NA==", "bodyText": "Typo?  successfulterations -> successfullterations?", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369464344", "createdAt": "2020-01-22T09:58:54Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/cache/CachePartitionIteratorBouncingTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.client.cache.impl.ClientCacheProxy;\n+import com.hazelcast.config.CacheSimpleConfig;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.MaxSizePolicy;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.SlowTest;\n+import com.hazelcast.test.bounce.BounceMemberRule;\n+import com.hazelcast.test.bounce.BounceTestConfiguration.DriverType;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.Cache.Entry;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import static com.hazelcast.config.EvictionConfig.DEFAULT_MAX_SIZE_POLICY;\n+import static com.hazelcast.config.MaxSizePolicy.USED_NATIVE_MEMORY_SIZE;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(SlowTest.class)\n+public class CachePartitionIteratorBouncingTest extends HazelcastTestSupport {\n+\n+    private final Logger logger = Logger.getLogger(getClass().getName());\n+    private static final String TEST_CACHE_NAME = \"testCache\";\n+    private static final int STABLE_ENTRY_COUNT = 10000;\n+    private static final int CONCURRENCY = 2;\n+    public static final int FETCH_SIZE = 100;\n+    public static final int MUTATION_ENTRY_FACTOR = 10;\n+    public AtomicInteger successfulIterations = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MDQzMg==", "bodyText": "We call the method twice with runnableIndex = 0 in both cases? Is this an idea of the test?", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369470432", "createdAt": "2020-01-22T10:10:04Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/cache/CachePartitionIteratorBouncingTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.client.cache.impl.ClientCacheProxy;\n+import com.hazelcast.config.CacheSimpleConfig;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.MaxSizePolicy;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.SlowTest;\n+import com.hazelcast.test.bounce.BounceMemberRule;\n+import com.hazelcast.test.bounce.BounceTestConfiguration.DriverType;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.Cache.Entry;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import static com.hazelcast.config.EvictionConfig.DEFAULT_MAX_SIZE_POLICY;\n+import static com.hazelcast.config.MaxSizePolicy.USED_NATIVE_MEMORY_SIZE;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(SlowTest.class)\n+public class CachePartitionIteratorBouncingTest extends HazelcastTestSupport {\n+\n+    private final Logger logger = Logger.getLogger(getClass().getName());\n+    private static final String TEST_CACHE_NAME = \"testCache\";\n+    private static final int STABLE_ENTRY_COUNT = 10000;\n+    private static final int CONCURRENCY = 2;\n+    public static final int FETCH_SIZE = 100;\n+    public static final int MUTATION_ENTRY_FACTOR = 10;\n+    public AtomicInteger successfulIterations = new AtomicInteger();\n+\n+    @Rule\n+    public BounceMemberRule bounceMemberRule =\n+            BounceMemberRule.with(getConfig())\n+                            .clusterSize(4)\n+                            .driverCount(4)\n+                            .driverType(isClientDriver() ? DriverType.CLIENT : DriverType.MEMBER)\n+                            .build();\n+\n+    @Override\n+    protected Config getConfig() {\n+        Config config = smallInstanceConfig();\n+        MaxSizePolicy maxSizePolicy = getInMemoryFormat() == InMemoryFormat.NATIVE\n+                ? USED_NATIVE_MEMORY_SIZE\n+                : DEFAULT_MAX_SIZE_POLICY;\n+        config.getCacheConfig(TEST_CACHE_NAME)\n+              .setInMemoryFormat(getInMemoryFormat())\n+              .getEvictionConfig()\n+              .setMaxSizePolicy(maxSizePolicy)\n+              .setSize(Integer.MAX_VALUE);\n+\n+        return config;\n+    }\n+\n+    @Test\n+    public void test() {\n+        ICache<Integer, Integer> cache = bounceMemberRule.getSteadyMember()\n+                                                         .getCacheManager()\n+                                                         .getCache(TEST_CACHE_NAME);\n+        populateCache(cache);\n+\n+        Runnable[] testTasks = new Runnable[CONCURRENCY];\n+        for (int i = 0; i < CONCURRENCY; ) {\n+            HazelcastInstance driver = bounceMemberRule.getNextTestDriver();\n+            testTasks[i++] = new IterationRunnable(driver);\n+            testTasks[i++] = new MutationRunnable(driver, i / 2);\n+        }\n+        bounceMemberRule.testRepeatedly(testTasks, MINUTES.toSeconds(3));\n+    }\n+\n+    private void populateCache(ICache<Integer, Integer> cache) {\n+        for (int i = 0; i < STABLE_ENTRY_COUNT; i++) {\n+            cache.put(i, i);\n+        }\n+    }\n+\n+    public class IterationRunnable implements Runnable {\n+\n+        private final HazelcastInstance hazelcastInstance;\n+        private ICache<Integer, Integer> cache;\n+\n+        public IterationRunnable(HazelcastInstance hazelcastInstance) {\n+            this.hazelcastInstance = hazelcastInstance;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (cache == null) {\n+                cache = hazelcastInstance.getCacheManager().getCache(TEST_CACHE_NAME);\n+            }\n+            HashSet<Integer> all = getAll();\n+            for (int i = 0; i < STABLE_ENTRY_COUNT; i++) {\n+                assertTrue(\"Missing stable entry \" + i + \" - \" + cache.get(i), all.contains(i));\n+            }\n+\n+            logger.info(\"Successfully finished iteration \" + successfulIterations.incrementAndGet());\n+        }\n+\n+        private HashSet<Integer> getAll() {\n+            HashSet<Integer> keys = new HashSet<>();\n+            int partitionCount = hazelcastInstance.getPartitionService().getPartitions().size();\n+            for (int partitionId = 0; partitionId < partitionCount; partitionId++) {\n+                Iterator<Cache.Entry<Integer, Integer>> iterator = createIterator(cache, FETCH_SIZE, partitionId, false);\n+                while (iterator.hasNext()) {\n+                    Entry<Integer, Integer> e = iterator.next();\n+                    assertTrue(\"Got the same key twice\", keys.add(e.getKey()));\n+                }\n+            }\n+            return keys;\n+        }\n+\n+    }\n+\n+    private Iterator<Cache.Entry<Integer, Integer>> createIterator(\n+            ICache<Integer, Integer> cache, int fetchSize, int partitionId, boolean prefetchValues) {\n+        return isClientDriver()\n+                ? ((ClientCacheProxy<Integer, Integer>) cache).iterator(fetchSize, partitionId, prefetchValues)\n+                : ((CacheProxy<Integer, Integer>) cache).iterator(fetchSize, partitionId, prefetchValues);\n+    }\n+\n+    protected boolean isClientDriver() {\n+        return false;\n+    }\n+\n+    protected InMemoryFormat getInMemoryFormat() {\n+        return CacheSimpleConfig.DEFAULT_IN_MEMORY_FORMAT;\n+    }\n+\n+    public static class MutationRunnable implements Runnable {\n+        private final HazelcastInstance hazelcastInstance;\n+        private final int startIndex;\n+        private final int endIndex;\n+        private ICache<Integer, Integer> cache;\n+\n+        public MutationRunnable(HazelcastInstance hazelcastInstance, int runnableIndex) {\n+            this.hazelcastInstance = hazelcastInstance;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd"}, "originalPosition": 164}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ab677bc77c66eb02f9e026b9faceb920fd93c9f", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5ab677bc77c66eb02f9e026b9faceb920fd93c9f", "committedDate": "2020-01-22T10:17:33Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "committedDate": "2020-01-22T10:28:34Z", "message": "Address review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd", "committedDate": "2020-01-20T14:49:16Z", "message": "Fix HD ICache iterator consistency issue\n\nThe hasNotBeenObserved method had an issue which might cause stable\nentries to be skipped.\n\nAlso:\n- added bouncing tests for on-heap and off-heap ICache\n- moved the hasNotBeenObserved method for a common parent class for both\noff-heap ICache and IMap\n- made it possible for ICache iterator to return an entry with a null\nvalue in case prefetchValues is false. This is the same way it is in the\n IMap iterator.\n- further aligned the ICache and IMap code"}, "afterCommit": {"oid": "1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "author": {"user": {"login": "mmedenjak", "name": "Matko Medenjak"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "committedDate": "2020-01-22T10:28:34Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTA2MTkz", "url": "https://github.com/hazelcast/hazelcast/pull/16504#pullrequestreview-346506193", "createdAt": "2020-01-22T11:06:09Z", "commit": {"oid": "1d2a1a27ae79b3f959b18250c1d5176bc62d0f58"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4034, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}