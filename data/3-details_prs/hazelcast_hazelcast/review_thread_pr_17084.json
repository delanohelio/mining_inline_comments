{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NTIxMTUy", "number": 17084, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0NjoxNVrOEF0h9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0NjoxNVrOEF0h9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTM4OTk5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/util/ClientMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0NjoxNVrOGkPOhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzowNjo0M1rOGkaXyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MTM5Nw==", "bodyText": "Good finding. I think we can make further cleanups. Instead of creating a new message, we put the message directly to builderBySessionIdMap . We just need to dropFragmentationFrame .\n                   ClientMessage message = activeReader.getClientMessage();\n                    message.dropFragmentationFrame();\n                    long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                    if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n                        builderBySessionIdMap.put(fragmentationId, message);\n\nWe have a new method on ClientMessage:\n  public void dropFragmentationFrame() {\n        startFrame = startFrame.next;\n    }\n\nand merge method should change accordingly. Dropping the fragmentation logic was there, and feeling wrong to begin with.\n public void merge(ClientMessage fragment) {\n        endFrame.next = fragment.startFrame;\n        endFrame = fragment.endFrame;\n    }\n\n@mdumandag How does that look ?", "url": "https://github.com/hazelcast/hazelcast/pull/17084#discussion_r440651397", "createdAt": "2020-06-16T07:46:15Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/util/ClientMessageDecoder.java", "diffHunk": "@@ -90,13 +90,14 @@ public HandlerStatus onRead() {\n                     throw new IllegalStateException(\n                             \"Fragmented client messages are not allowed before the client is authenticated.\");\n                 } else {\n-                    ClientMessage.ForwardFrameIterator frameIterator = activeReader.getClientMessage().frameIterator();\n+                    ClientMessage message = activeReader.getClientMessage();\n+                    ClientMessage.ForwardFrameIterator frameIterator = message.frameIterator();\n                     //ignore the fragmentationFrame\n                     frameIterator.next();\n                     ClientMessage.Frame startFrame = frameIterator.next();\n                     long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                     if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n-                        builderBySessionIdMap.put(fragmentationId, ClientMessage.createForDecode(startFrame));\n+                        builderBySessionIdMap.put(fragmentationId, new ClientMessage(startFrame, message.getEndFrame()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d15d42b9c9727e76327d43d977bc184abec02e3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgzMzk5Mg==", "bodyText": "Thanks for the suggestion. That version looks better.", "url": "https://github.com/hazelcast/hazelcast/pull/17084#discussion_r440833992", "createdAt": "2020-06-16T13:06:43Z", "author": {"login": "mdumandag"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/util/ClientMessageDecoder.java", "diffHunk": "@@ -90,13 +90,14 @@ public HandlerStatus onRead() {\n                     throw new IllegalStateException(\n                             \"Fragmented client messages are not allowed before the client is authenticated.\");\n                 } else {\n-                    ClientMessage.ForwardFrameIterator frameIterator = activeReader.getClientMessage().frameIterator();\n+                    ClientMessage message = activeReader.getClientMessage();\n+                    ClientMessage.ForwardFrameIterator frameIterator = message.frameIterator();\n                     //ignore the fragmentationFrame\n                     frameIterator.next();\n                     ClientMessage.Frame startFrame = frameIterator.next();\n                     long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                     if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n-                        builderBySessionIdMap.put(fragmentationId, ClientMessage.createForDecode(startFrame));\n+                        builderBySessionIdMap.put(fragmentationId, new ClientMessage(startFrame, message.getEndFrame()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MTM5Nw=="}, "originalCommit": {"oid": "8d15d42b9c9727e76327d43d977bc184abec02e3"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 581, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}