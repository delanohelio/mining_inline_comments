{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2MjQzNTI5", "number": 17659, "title": "SQL scan operator design document", "bodyText": "This PR adds the design document for distributed scans, covering the following topics:\n\nHow the scan access path is chosen\nBehavior in the case of concurrent data update\nBehavior in the case of cluster reconfiguration\n\nCloses #17468", "createdAt": "2020-10-01T13:04:29Z", "url": "https://github.com/hazelcast/hazelcast/pull/17659", "merged": true, "mergeCommit": {"oid": "ac7c9cb9d30b036fe283811fe5147aa3b523a342"}, "closed": true, "closedAt": "2020-10-05T09:04:53Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOQ_1lgH2gAyNDk2MjQzNTI5OmZlY2M1N2E4ZjgxZGJlZjAwYzU4ZTUxNDgzYzNmNTA4M2NjY2ZjZDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOnJtugFqTUwMTIwMjE5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fecc57a8f81dbef00c58e51483c3f5083cccfcd6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fecc57a8f81dbef00c58e51483c3f5083cccfcd6", "committedDate": "2020-10-01T13:00:23Z", "message": "SQL: design document for the scan operators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4695be9542227e968384adcb79bd569a5007257f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4695be9542227e968384adcb79bd569a5007257f", "committedDate": "2020-10-01T13:00:40Z", "message": "Minors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODg2MzA4", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-500886308", "createdAt": "2020-10-02T06:33:31Z", "commit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjozMzozMVrOHbibow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjo1ODo1NlrOHbi6hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzNzczMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n          \n          \n            \n            a distributed data structure. Every member stores part of the index that is built for the local entries of the member.", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498637731", "createdAt": "2020-10-02T06:33:31Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODI5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n          \n          \n            \n            expression, and `exp` is an expression that has only constants or parameters at leaves (i.e. it doesn't refer to other columns).", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498638294", "createdAt": "2020-10-02T06:35:34Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODYwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n          \n          \n            \n            1. `col = exp1 OR col = exp2` can be treated as union of two equality predicates", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498638605", "createdAt": "2020-10-02T06:36:38Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzOTQwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n          \n          \n            \n            1. Only a continuous prefix of index columns can be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498639404", "createdAt": "2020-10-02T06:39:26Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0MDE5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.\n          \n          \n            \n            At last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space.", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498640191", "createdAt": "2020-10-02T06:41:53Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0MDY4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For the direct map scan (`MapScanExec`), the iterator scan all local partitions one by one. For the index scan \n          \n          \n            \n            For the direct map scan (`MapScanExec`), the iterator scans all local partitions one by one. For the index scan", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498640681", "createdAt": "2020-10-02T06:43:34Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scan all local partitions one by one. For the index scan ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0MTQxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            behavior is possible in many databases, including transactional one. Examples are: Redis [[1]], MongoDB [[2]], Microsoft \n          \n          \n            \n            behavior is possible in many databases, including transactional ones. Examples are: Redis [[1]], MongoDB [[2]], Microsoft", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498641410", "createdAt": "2020-10-02T06:46:03Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scan all local partitions one by one. For the index scan \n+(`MapIndexScanExec`), the iterator is opened against the index, based on the optional index condition. In both cases,\n+the full result set of the scan is never materialized, unlike the legacy predicate engine.\n+\n+An entry might be changed concurrently during execution of the query. Since the engine doesn't have transactions, it is\n+possible that the updated entry will be observed zero, one or several times, due to entry relocation within the underlying\n+data structure. To solve this problem, we would need a transactional engine, but we do not have one. Note that the described \n+behavior is possible in many databases, including transactional one. Examples are: Redis [[1]], MongoDB [[2]], Microsoft ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0MjE3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            actually owned partitions do not match, and exception is thrown. For example, if the member is expected to have partitions \n          \n          \n            \n            actually owned partitions do not match, an exception is thrown. For example, if the member is expected to have partitions", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498642176", "createdAt": "2020-10-02T06:48:33Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scan all local partitions one by one. For the index scan \n+(`MapIndexScanExec`), the iterator is opened against the index, based on the optional index condition. In both cases,\n+the full result set of the scan is never materialized, unlike the legacy predicate engine.\n+\n+An entry might be changed concurrently during execution of the query. Since the engine doesn't have transactions, it is\n+possible that the updated entry will be observed zero, one or several times, due to entry relocation within the underlying\n+data structure. To solve this problem, we would need a transactional engine, but we do not have one. Note that the described \n+behavior is possible in many databases, including transactional one. Examples are: Redis [[1]], MongoDB [[2]], Microsoft \n+SQL Server with `READ_COMMITTED` isolation (the default behavior) [[3]]. \n+\n+## 4 Cluster Reconfiguration\n+\n+Cluster configuration may change during query execution: partitions may migrate between members, distributed objects may be \n+created and destroyed. This section describes the behavior of scan operators in the case of concurrent cluster reconfiguration.\n+\n+### 4.1 Partition Migration\n+\n+If the query is executed concurrently with partition migration, it is possible that some partitions will be scanned several \n+times, or missed completely. To avoid that we need a mechanics to ensure that the engine observed every partition exactly\n+once.  \n+\n+When the plan is created, we create the so-called **partition map**, that maps members to partitions. The partition map is saved\n+in the plan. If the partition distribution changes due to member join/leave, the plan is invalidated.  \n+\n+When the query is about to start, we explicitly assign partitions to every participant. For example:\n+```\n+member1 -> [1, 2]\n+member2 -> [3, 4]\n+```  \n+\n+When the scan operation is started on the member, we first check whether it contains expected partitions. If the expected and \n+actually owned partitions do not match, and exception is thrown. For example, if the member is expected to have partitions ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0MjU3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            concurrently, leading to missed entries. To avoid inconsistent results we **re-check** the partition distribution, before any\n          \n          \n            \n            concurrently, leading to missed entries. To avoid inconsistent results we **re-check** the partition distribution before any", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498642573", "createdAt": "2020-10-02T06:49:58Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scan all local partitions one by one. For the index scan \n+(`MapIndexScanExec`), the iterator is opened against the index, based on the optional index condition. In both cases,\n+the full result set of the scan is never materialized, unlike the legacy predicate engine.\n+\n+An entry might be changed concurrently during execution of the query. Since the engine doesn't have transactions, it is\n+possible that the updated entry will be observed zero, one or several times, due to entry relocation within the underlying\n+data structure. To solve this problem, we would need a transactional engine, but we do not have one. Note that the described \n+behavior is possible in many databases, including transactional one. Examples are: Redis [[1]], MongoDB [[2]], Microsoft \n+SQL Server with `READ_COMMITTED` isolation (the default behavior) [[3]]. \n+\n+## 4 Cluster Reconfiguration\n+\n+Cluster configuration may change during query execution: partitions may migrate between members, distributed objects may be \n+created and destroyed. This section describes the behavior of scan operators in the case of concurrent cluster reconfiguration.\n+\n+### 4.1 Partition Migration\n+\n+If the query is executed concurrently with partition migration, it is possible that some partitions will be scanned several \n+times, or missed completely. To avoid that we need a mechanics to ensure that the engine observed every partition exactly\n+once.  \n+\n+When the plan is created, we create the so-called **partition map**, that maps members to partitions. The partition map is saved\n+in the plan. If the partition distribution changes due to member join/leave, the plan is invalidated.  \n+\n+When the query is about to start, we explicitly assign partitions to every participant. For example:\n+```\n+member1 -> [1, 2]\n+member2 -> [3, 4]\n+```  \n+\n+When the scan operation is started on the member, we first check whether it contains expected partitions. If the expected and \n+actually owned partitions do not match, and exception is thrown. For example, if the member is expected to have partitions \n+`[1, 2]`, then:\n+```\n+[1] - error, because we may miss the partition [2]\n+[1, 2] - ok\n+[1, 2, 3] - error, because we may return duplicates for the partition [3]\n+```\n+\n+The check before the query start is not sufficient to guarantee the correctness of the results. The partition may migrate to the \n+member during execution of the query, leading to duplicates. Conversely, the partition may be removed from the member \n+concurrently, leading to missed entries. To avoid inconsistent results we **re-check** the partition distribution, before any", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0Mzc3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Better solution would hide the partitioning problems from the user completely. This is, however, is difficult to achieve \n          \n          \n            \n            in practice. To avoid duplicates and missed entries, we would have to track which parts of the operator input is processed, and \n          \n          \n            \n            re-schedule scans to other members in runtime. Therefore, the current design ensures that user does not see an inconsistent\n          \n          \n            \n            result, but forces the user to re-run the query manually if the result correctness cannot be guaranteed by the engine. In the\n          \n          \n            \n            A better solution would hide the partitioning problems from the user completely. This, however, is difficult to achieve \n          \n          \n            \n            in practice. To avoid duplicates and missed entries we would have to track which part of the operator input is processed, and \n          \n          \n            \n            re-schedule scans to other members at runtime. Therefore, the current design ensures that the user does not see an inconsistent\n          \n          \n            \n            result, but forces the user to re-run the query manually if the result correctness cannot be guaranteed by the engine. In the", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498643772", "createdAt": "2020-10-02T06:53:32Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that have only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. 'col = exp1 OR col = exp2' can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only continuous prefix of index columns could be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator, that is added to the planner search space.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scan all local partitions one by one. For the index scan \n+(`MapIndexScanExec`), the iterator is opened against the index, based on the optional index condition. In both cases,\n+the full result set of the scan is never materialized, unlike the legacy predicate engine.\n+\n+An entry might be changed concurrently during execution of the query. Since the engine doesn't have transactions, it is\n+possible that the updated entry will be observed zero, one or several times, due to entry relocation within the underlying\n+data structure. To solve this problem, we would need a transactional engine, but we do not have one. Note that the described \n+behavior is possible in many databases, including transactional one. Examples are: Redis [[1]], MongoDB [[2]], Microsoft \n+SQL Server with `READ_COMMITTED` isolation (the default behavior) [[3]]. \n+\n+## 4 Cluster Reconfiguration\n+\n+Cluster configuration may change during query execution: partitions may migrate between members, distributed objects may be \n+created and destroyed. This section describes the behavior of scan operators in the case of concurrent cluster reconfiguration.\n+\n+### 4.1 Partition Migration\n+\n+If the query is executed concurrently with partition migration, it is possible that some partitions will be scanned several \n+times, or missed completely. To avoid that we need a mechanics to ensure that the engine observed every partition exactly\n+once.  \n+\n+When the plan is created, we create the so-called **partition map**, that maps members to partitions. The partition map is saved\n+in the plan. If the partition distribution changes due to member join/leave, the plan is invalidated.  \n+\n+When the query is about to start, we explicitly assign partitions to every participant. For example:\n+```\n+member1 -> [1, 2]\n+member2 -> [3, 4]\n+```  \n+\n+When the scan operation is started on the member, we first check whether it contains expected partitions. If the expected and \n+actually owned partitions do not match, and exception is thrown. For example, if the member is expected to have partitions \n+`[1, 2]`, then:\n+```\n+[1] - error, because we may miss the partition [2]\n+[1, 2] - ok\n+[1, 2, 3] - error, because we may return duplicates for the partition [3]\n+```\n+\n+The check before the query start is not sufficient to guarantee the correctness of the results. The partition may migrate to the \n+member during execution of the query, leading to duplicates. Conversely, the partition may be removed from the member \n+concurrently, leading to missed entries. To avoid inconsistent results we **re-check** the partition distribution, before any\n+result is returned from the scan operator. \n+\n+Partition check logic depends on the operator type. For the direct map scan, we use the migration stamps \n+(`MapService.validateMigrationStamp`). For the index scans, we use index partition stamps \n+(`InternalIndex.validatePartitionStamp`).\n+\n+Better solution would hide the partitioning problems from the user completely. This is, however, is difficult to achieve \n+in practice. To avoid duplicates and missed entries, we would have to track which parts of the operator input is processed, and \n+re-schedule scans to other members in runtime. Therefore, the current design ensures that user does not see an inconsistent\n+result, but forces the user to re-run the query manually if the result correctness cannot be guaranteed by the engine. In the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NTYzOQ==", "bodyText": "What if we have an index for (a, b): if we split the predicate like this, will we find the index? If yes, this algorithm isn't described.", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498645639", "createdAt": "2020-10-02T06:58:56Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is build for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4695be9542227e968384adcb79bd569a5007257f"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f409caa844883a533cea01ba40ca6b3b8f2fe67f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f409caa844883a533cea01ba40ca6b3b8f2fe67f", "committedDate": "2020-10-02T07:12:14Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5504d1e1ea1efe4dbd049238b275ca83e62d9f3a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5504d1e1ea1efe4dbd049238b275ca83e62d9f3a", "committedDate": "2020-10-02T07:12:24Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b24b20ea0ba75b1b9f7aaf123a9043b9297fa8e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0b24b20ea0ba75b1b9f7aaf123a9043b9297fa8e", "committedDate": "2020-10-02T07:12:31Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3beaad1c8df5b67bb673a6c41e671bf1d9fa0e9b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3beaad1c8df5b67bb673a6c41e671bf1d9fa0e9b", "committedDate": "2020-10-02T07:12:40Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deb989b4bf2ec12a0faf32c2c9aa165aa9ac5f70", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/deb989b4bf2ec12a0faf32c2c9aa165aa9ac5f70", "committedDate": "2020-10-02T07:12:46Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed95a59995ab042bcfd254399ce0dcf197585a57", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ed95a59995ab042bcfd254399ce0dcf197585a57", "committedDate": "2020-10-02T07:12:56Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9914ade8fdac2c67bb09a013afb4188e197d6d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1f9914ade8fdac2c67bb09a013afb4188e197d6d", "committedDate": "2020-10-02T07:13:05Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4972e42667e1a6656c84c52bc3a5e32d56bc1142", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4972e42667e1a6656c84c52bc3a5e32d56bc1142", "committedDate": "2020-10-02T07:13:13Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efc7050503ceb22ee330c90fd743725f1340f8da", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/efc7050503ceb22ee330c90fd743725f1340f8da", "committedDate": "2020-10-02T07:13:20Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55af70162f3068e4b317444d7090fe82d414d713", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/55af70162f3068e4b317444d7090fe82d414d713", "committedDate": "2020-10-02T07:13:29Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwOTg1NDg5", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-500985489", "createdAt": "2020-10-02T09:24:18Z", "commit": {"oid": "55af70162f3068e4b317444d7090fe82d414d713"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyNDoxOFrOHbm_cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyNDoxOFrOHbm_cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMjQzNA==", "bodyText": "It would be great to have a paragraph on costing, how and why one scan is preferred over another index or map scan.", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498712434", "createdAt": "2020-10-02T09:24:18Z", "author": {"login": "taburet"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is built for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that has only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. `col = exp1 OR col = exp2` can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only a continuous prefix of index columns can be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+At last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55af70162f3068e4b317444d7090fe82d414d713"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwOTk2NTM2", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-500996536", "createdAt": "2020-10-02T09:41:58Z", "commit": {"oid": "55af70162f3068e4b317444d7090fe82d414d713"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTo0MTo1OFrOHbnfjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTo0MTo1OFrOHbnfjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMDY1Mw==", "bodyText": "Is there any specific reason why partitions are scanned one by one and not in parallel?", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498720653", "createdAt": "2020-10-02T09:41:58Z", "author": {"login": "taburet"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is built for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that has only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. `col = exp1 OR col = exp2` can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only a continuous prefix of index columns can be used. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can use only `a=1`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+At last, for every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scans all local partitions one by one. For the index scan ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55af70162f3068e4b317444d7090fe82d414d713"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "523bf5916fdda5527ae47cbc6b6429a94f97e1b3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/523bf5916fdda5527ae47cbc6b6429a94f97e1b3", "committedDate": "2020-10-02T09:47:54Z", "message": "Clarify scan cost model."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612958c5dffa19fe79cf5b6f45c12db76efc4bc4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/612958c5dffa19fe79cf5b6f45c12db76efc4bc4", "committedDate": "2020-10-02T09:54:20Z", "message": "Clarification on the index binding"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDA4NTIw", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-501008520", "createdAt": "2020-10-02T10:01:13Z", "commit": {"oid": "612958c5dffa19fe79cf5b6f45c12db76efc4bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDE0MjYw", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-501014260", "createdAt": "2020-10-02T10:10:57Z", "commit": {"oid": "612958c5dffa19fe79cf5b6f45c12db76efc4bc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5caaa9f040eb701e08bf9e866e96eb0d06896f67", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5caaa9f040eb701e08bf9e866e96eb0d06896f67", "committedDate": "2020-10-02T10:16:03Z", "message": "Clarification on search space explosion for index scans."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDE5MjI5", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-501019229", "createdAt": "2020-10-02T10:19:17Z", "commit": {"oid": "5caaa9f040eb701e08bf9e866e96eb0d06896f67"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxOToxOFrOHbohrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxOToxOFrOHbohrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzU4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space. At the \n          \n          \n            \n            moment we add all viable indexes to the search space. This might become a problem in the future releases, when we have \n          \n          \n            \n            joins and multiple table, because there will be too many alternatives to consider. The solution could be not to add certain\n          \n          \n            \n            indexes to the search space based on some heuristics. \n          \n          \n            \n            For every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space. \n          \n          \n            \n            Currently, we add all usable indexes to the search space. This might become a problem in future releases, when we have \n          \n          \n            \n            joins and multiple tables, because there will be too many alternatives to consider. The solution could be to not add certain\n          \n          \n            \n            indexes to the search space based on some heuristics.", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498737581", "createdAt": "2020-10-02T10:19:18Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,164 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is built for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that has only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. `col = exp1 OR col = exp2` can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only a continuous prefix of index columns can be bound. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can bind only `a=1`, while for `a=1 AND b=2` we may bind both `a=1` and `b=2`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, b)`, `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, b) -> [a=1, b>2 AND b<4]\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Once the index filter is built, we calculate the remainder filter, such that `indexFilter AND remainderFilter` is equivalent\n+to the original filter. \n+\n+For every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space. At the \n+moment we add all viable indexes to the search space. This might become a problem in the future releases, when we have \n+joins and multiple table, because there will be too many alternatives to consider. The solution could be not to add certain\n+indexes to the search space based on some heuristics. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5caaa9f040eb701e08bf9e866e96eb0d06896f67"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "660f8e377f64923efaf91689ba90e6b45c2fa194", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/660f8e377f64923efaf91689ba90e6b45c2fa194", "committedDate": "2020-10-02T10:27:24Z", "message": "Update docs/design/sql/10-distributed-scan.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDI1OTEz", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-501025913", "createdAt": "2020-10-02T10:31:17Z", "commit": {"oid": "660f8e377f64923efaf91689ba90e6b45c2fa194"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozMToxN1rOHbo2gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozMToxN1rOHbo2gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0MjkxMg==", "bodyText": "What happens if the object is deleted during the scan execution?", "url": "https://github.com/hazelcast/hazelcast/pull/17659#discussion_r498742912", "createdAt": "2020-10-02T10:31:17Z", "author": {"login": "taburet"}, "path": "docs/design/sql/10-distributed-scan.md", "diffHunk": "@@ -0,0 +1,164 @@\n+# Distributed Scan\n+\n+## Overview\n+\n+The Hazelcast Mustang is a distributed query engine. When an SQL string is submitted for execution, it is converted into a \n+query plan, that contains the tree of relational operators, such as `scan`, `project` and `filter`. Leaf operators of the plan \n+act as data sources for the parent operators. The `scan` operator iterates over the `IMap` data structure. This document \n+explains how the distributed scan is performed.\n+\n+In this document, we describe the main design points of the scan operators: access path selection, local execution semantics,\n+and reaction to cluster reconfiguration.\n+\n+## 1 Background\n+\n+The Hazelcast IMDG is a distributed in-memory key-value storage. Data is stored in distributed objects, such as an `IMap`.\n+The cluster has a predefined number of partitions, 271 by default. Each partition is stored on a single member, and may have \n+zero, one or more backups on other members. Every distributed object is split across one or more partitions. Partitions may\n+migrate between members due to topology change events, such as member leave or join.\n+\n+The `IMap` is a distributed map. It could be accessed either directly, or through a secondary index. The secondary index is \n+a distributed data structure. Every member stores part of the index that is built for the local entries of the member. \n+\n+The goal of the Hazelcast Mustang engine is to pick the proper access method - direct scan or index scan, start execution of \n+the scan on members, and collect the results. In the above sections we describe how it is implemented.   \n+\n+## 2 Access Path Selection\n+\n+There are two ways to scan the `IMap` - iterate over the record store directly, or use one of the secondary indexes. During the\n+planning stage the proper access method is chosen. \n+\n+If there are no indexes on the table, the direct scan is chosen and no further optimization is performed.    \n+\n+If there are indexes on the table, we analyze the predicate stored in the table of the `TableScan` operator. The entry point\n+is `IndexResolver.createIndexScans`. \n+\n+First, we split the predicate into conjunctive normal form (CNF). For example, the predicate `a=1 AND b=2` is split into \n+`a=1` and `b=2`, while the predicate `a=1 OR b=2` remains unchanged.\n+\n+Second, for every sub-predicate we find those that could be used by some index. Assume that `col` is a simple column\n+expression, and `exp` is an expression that has only constants or parameters at leaves (i.e. it doesn't refer to other columns). \n+We use the following rules:\n+1. `col = exp` can be used with `SORTED` and `HASH` indexes\n+1. `col [comparison] exp` can be used with `SORTED` indexes\n+1. `col IS NULL/TRUE/FALSE` can be treated as equality expression (with slightly different semantics for `NULL` values)\n+1. `col = exp1 OR col = exp2` can be treated as union of two equality predicates \n+\n+The result of this step is a map from column to candidate expressions that could be used with indexes. For example, \n+`a=1 AND b>2 AND b<4` is returned as: \n+```\n+a -> [=1] \n+b -> [>2], [<4]\n+```\n+\n+Next, we iterate over every index, and try to bind candidates to the index based on the index columns and index type.\n+General rules are:\n+1. `SORTED` index may use equality and comparison conditions, while `HASH` index may use only equality conditions\n+1. Only a continuous prefix of index columns can be bound. E.g. for the index `(a, b, c)` and the condition `a=1 AND c=2` we \n+can bind only `a=1`, while for `a=1 AND b=2` we may bind both `a=1` and `b=2`\n+1. All expressions in the prefix except for the last one must be equality conditions. E.g. for the index `(a, b)` and the \n+condition `a>1 AND b>2`, we can use only `a>1`   \n+\n+The result of this step is a map from index to the filter that should be used. For example, for the expression \n+`a=1 AND b>2 AND b<4`, and indexes on `(a, b)`, `(a, c)` and `(b)`, the result would be:\n+```\n+index(a, b) -> [a=1, b>2 AND b<4]\n+index(a, c) -> [a=1, NULL]\n+index(b) -> [b>2 AND b<4]\n+```\n+\n+Once the index filter is built, we calculate the remainder filter, such that `indexFilter AND remainderFilter` is equivalent\n+to the original filter. \n+\n+For every proposed index, we create a `MapIndexScanPhysicalRel` operator that is added to the planner search space. \n+Currently, we add all usable indexes to the search space. This might become a problem in future releases, when we have \n+joins and multiple tables, because there will be too many alternatives to consider. The solution could be to not add certain\n+indexes to the search space based on some heuristics. \n+\n+The cost model works as follows:\n+1. Get the expected number of rows to scan (`SCANNED_ROWS`). For the direct scan it equals to the number of rows in the map. For \n+the index scan this is `mapRowCount * selectivity(indexFilter)`.\n+1. Get the expected number of returned rows (`RETURNED_ROWS`), that depend on the selectivity of the original filter.\n+1. Assign a weight to the scanned rows, based on the access method (`SCAN_MULTIPLIER`). We assume that a direct scan is cheaper \n+than an index scan, because the latter requires indirection. Also, we assume that a scan of the `HASH` index is cheaper that \n+a scan of the `SORTED` index, because it requires less CPU for the lookup.\n+1. The final formula is `COST = SCANNED_ROWS * SCAN_MULTIPLIER + RETURNED_ROWS * PROJECTION_COST`. It ensures, that a direct\n+scan is picked when the filter has poor selectivity, and that an index scan is picked otherwise, giving a priority to `HASH`\n+index.\n+\n+## 3 Local Execution\n+\n+Scan operators consist of three parts:\n+1. Access path (direct scan, index scan)\n+1. Optional filter\n+1. Column list\n+\n+The execution proceeds as follows. First, an iterator over the underlying data is opened (record stores, index). Then every \n+returned record is evaluated against the optional filter. If record is not filtered out, it is converted to a `Row` instance\n+based on the column list. The `Row` is added to the internal batch. When the batch reaches a certain size, or there are no\n+more records, the batch of rows is returned to the parent operator. \n+\n+For the direct map scan (`MapScanExec`), the iterator scans all local partitions one by one. For the index scan \n+(`MapIndexScanExec`), the iterator is opened against the index, based on the optional index condition. In both cases,\n+the full result set of the scan is never materialized, unlike the legacy predicate engine.\n+\n+An entry might be changed concurrently during execution of the query. Since the engine doesn't have transactions, it is\n+possible that the updated entry will be observed zero, one or several times, due to entry relocation within the underlying\n+data structure. To solve this problem, we would need a transactional engine, but we do not have one. Note that the described \n+behavior is possible in many databases, including transactional ones. Examples are: Redis [[1]], MongoDB [[2]], Microsoft \n+SQL Server with `READ_COMMITTED` isolation (the default behavior) [[3]]. \n+\n+## 4 Cluster Reconfiguration\n+\n+Cluster configuration may change during query execution: partitions may migrate between members, distributed objects may be \n+created and destroyed. This section describes the behavior of scan operators in the case of concurrent cluster reconfiguration.\n+\n+### 4.1 Partition Migration\n+\n+If the query is executed concurrently with partition migration, it is possible that some partitions will be scanned several \n+times, or missed completely. To avoid that we need a mechanics to ensure that the engine observed every partition exactly\n+once.  \n+\n+When the plan is created, we create the so-called **partition map**, that maps members to partitions. The partition map is saved\n+in the plan. If the partition distribution changes due to member join/leave, the plan is invalidated.  \n+\n+When the query is about to start, we explicitly assign partitions to every participant. For example:\n+```\n+member1 -> [1, 2]\n+member2 -> [3, 4]\n+```  \n+\n+When the scan operation is started on the member, we first check whether it contains expected partitions. If the expected and \n+actually owned partitions do not match, an exception is thrown. For example, if the member is expected to have partitions \n+`[1, 2]`, then:\n+```\n+[1] - error, because we may miss the partition [2]\n+[1, 2] - ok\n+[1, 2, 3] - error, because we may return duplicates for the partition [3]\n+```\n+\n+The check before the query start is not sufficient to guarantee the correctness of the results. The partition may migrate to the \n+member during execution of the query, leading to duplicates. Conversely, the partition may be removed from the member \n+concurrently, leading to missed entries. To avoid inconsistent results we **re-check** the partition distribution before any\n+result is returned from the scan operator. \n+\n+Partition check logic depends on the operator type. For the direct map scan, we use the migration stamps \n+(`MapService.validateMigrationStamp`). For the index scans, we use index partition stamps \n+(`InternalIndex.validatePartitionStamp`).\n+\n+A better solution would hide the partitioning problems from the user completely. This, however, is difficult to achieve \n+in practice. To avoid duplicates and missed entries we would have to track which part of the operator input is processed, and \n+re-schedule scans to other members at runtime. Therefore, the current design ensures that the user does not see an inconsistent\n+result, but forces the user to re-run the query manually if the result correctness cannot be guaranteed by the engine. In the\n+long term we would like to avoid, or at least minimize, the number of cases when the error is thrown.\n+\n+### 4.2 Concurrent Schema Changes\n+\n+It may happen, that the referenced object (`IMap`, index) that was present during the query planning, no longer exists on the \n+local member. For example, because the map has been destroyed concurrently. Therefore, when the scan operation is about to\n+start, the existence of the required objects is checked. If the required object is not found, an exception is thrown, and the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "660f8e377f64923efaf91689ba90e6b45c2fa194"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d40f45d8a828f99617ed0ff334d338754592eb73", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d40f45d8a828f99617ed0ff334d338754592eb73", "committedDate": "2020-10-02T10:47:20Z", "message": "Clarify the behavior on the concurrent map destroy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28fc04ffd745ec8169b90e5f696a0294e8a604c9", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/28fc04ffd745ec8169b90e5f696a0294e8a604c9", "committedDate": "2020-10-02T10:47:29Z", "message": "Merge remote-tracking branch 'devozerov/sql-scan' into sql-scan"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjAyMTky", "url": "https://github.com/hazelcast/hazelcast/pull/17659#pullrequestreview-501202192", "createdAt": "2020-10-02T14:49:05Z", "commit": {"oid": "28fc04ffd745ec8169b90e5f696a0294e8a604c9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3214, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}