{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MzE3OTky", "number": 16925, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo0MDo0MlrOEIZY9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDoxMTo1NFrOEPEHpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjQwMDUzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo0MDo0MlrOGoVS2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1NjoxNVrOGt5YSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NTExNQ==", "bodyText": "Is this going to be the same in the final version? Can/shouldn't we allow setting the plane count without stopping the cluster and restarting the members?", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r444945115", "createdAt": "2020-06-24T14:40:42Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "diffHunk": "@@ -60,37 +60,46 @@ protected AbstractChannelInitializer(ServerContext serverContext, EndpointConfig\n         private final ILogger logger;\n         private final boolean spoofingChecks;\n         private final boolean unifiedEndpointManager;\n-\n         private final Set<ProtocolType> supportedProtocolTypes;\n+        private final int expectedPlaneCount;\n \n-        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager, ServerContext serverContext, ILogger logger,\n+        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager,\n+                                      ServerContext serverContext,\n+                                      ILogger logger,\n                                       Set<ProtocolType> supportedProtocolTypes) {\n             this.connectionManager = connectionManager;\n             this.serverContext = serverContext;\n             this.logger = logger;\n-            this.spoofingChecks = serverContext.properties().getBoolean(ClusterProperty.BIND_SPOOFING_CHECKS);\n+            this.spoofingChecks = serverContext.properties().getBoolean(BIND_SPOOFING_CHECKS);\n             this.supportedProtocolTypes = supportedProtocolTypes;\n             this.unifiedEndpointManager = connectionManager.getEndpointQualifier() == null;\n+            this.expectedPlaneCount = serverContext.properties().getInteger(CHANNEL_COUNT);\n         }\n \n         public void process(Packet packet) {\n-            Object o = serverContext.getSerializationService().toObject(packet);\n+            MemberHandshake handshake = serverContext.getSerializationService().toObject(packet);\n             TcpServerConnection connection = (TcpServerConnection) packet.getConn();\n-            if (connection.setHandshake()) {\n-                MemberHandshake handshake = (MemberHandshake) o;\n-                process(connection, handshake);\n-            } else {\n+            if (!connection.setHandshake()) {\n                 if (logger.isFinestEnabled()) {\n-                    logger.finest(\"Connection \" + connection + \" is already bound, ignoring incoming \" + o);\n+                    logger.finest(\"Connection \" + connection + \" handshake is already completed, ignoring incoming \" + handshake);\n                 }\n+                return;\n             }\n-        }\n \n-        private synchronized boolean process(TcpServerConnection connection, MemberHandshake handshake) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Handshake \" + connection + \", complete message is \" + handshake);\n+            if (handshake.getPlaneCount() != expectedPlaneCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7136d7ffc313eee72d82c93d1b0119c518507b54"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3OTIxMQ==", "bodyText": "In this POC it is fixed. In the final version is should be negotiated on a per connection basis. But this opens a can of worms when one of the connections is established, but the handshake hasn't completed yet and we don't know how many connections are actually going to be created. This can lead to the wrong number of connections or packets ending up in the wrong connection.", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r450779211", "createdAt": "2020-07-07T10:56:15Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "diffHunk": "@@ -60,37 +60,46 @@ protected AbstractChannelInitializer(ServerContext serverContext, EndpointConfig\n         private final ILogger logger;\n         private final boolean spoofingChecks;\n         private final boolean unifiedEndpointManager;\n-\n         private final Set<ProtocolType> supportedProtocolTypes;\n+        private final int expectedPlaneCount;\n \n-        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager, ServerContext serverContext, ILogger logger,\n+        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager,\n+                                      ServerContext serverContext,\n+                                      ILogger logger,\n                                       Set<ProtocolType> supportedProtocolTypes) {\n             this.connectionManager = connectionManager;\n             this.serverContext = serverContext;\n             this.logger = logger;\n-            this.spoofingChecks = serverContext.properties().getBoolean(ClusterProperty.BIND_SPOOFING_CHECKS);\n+            this.spoofingChecks = serverContext.properties().getBoolean(BIND_SPOOFING_CHECKS);\n             this.supportedProtocolTypes = supportedProtocolTypes;\n             this.unifiedEndpointManager = connectionManager.getEndpointQualifier() == null;\n+            this.expectedPlaneCount = serverContext.properties().getInteger(CHANNEL_COUNT);\n         }\n \n         public void process(Packet packet) {\n-            Object o = serverContext.getSerializationService().toObject(packet);\n+            MemberHandshake handshake = serverContext.getSerializationService().toObject(packet);\n             TcpServerConnection connection = (TcpServerConnection) packet.getConn();\n-            if (connection.setHandshake()) {\n-                MemberHandshake handshake = (MemberHandshake) o;\n-                process(connection, handshake);\n-            } else {\n+            if (!connection.setHandshake()) {\n                 if (logger.isFinestEnabled()) {\n-                    logger.finest(\"Connection \" + connection + \" is already bound, ignoring incoming \" + o);\n+                    logger.finest(\"Connection \" + connection + \" handshake is already completed, ignoring incoming \" + handshake);\n                 }\n+                return;\n             }\n-        }\n \n-        private synchronized boolean process(TcpServerConnection connection, MemberHandshake handshake) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Handshake \" + connection + \", complete message is \" + handshake);\n+            if (handshake.getPlaneCount() != expectedPlaneCount) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NTExNQ=="}, "originalCommit": {"oid": "7136d7ffc313eee72d82c93d1b0119c518507b54"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjUwNDE3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/Invocation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNTowMTo1NVrOGoWT2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMDo0NDoxMVrOGvLuag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTc1NA==", "bodyText": "Will streamId always be the partitionId? These are different concerns though, but it feels (so far) we just introduce a different term for the same thing. The property talks about channel count, its description partition count. So just a reminder for the final version: we need to agree on the term and use it consistently.", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r444961754", "createdAt": "2020-06-24T15:01:55Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/Invocation.java", "diffHunk": "@@ -595,9 +595,16 @@ private void doInvokeLocal(boolean isAsync) {\n     private void doInvokeRemote() {\n         assert connectionManager != null : \"Endpoint manager was null\";\n \n-        ServerConnection connection = connectionManager.getOrConnect(targetAddress);\n+        ServerConnection connection = connectionManager.getOrConnect(targetAddress, op.getPartitionId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7136d7ffc313eee72d82c93d1b0119c518507b54"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0MjM3OA==", "bodyText": "Channel count is not partition count. Channel count will be very low; partition count is much higher.\nAbout partition id and stream id; n this PR it is the same thing although partition id -1 will always be mapped to stream 0. But streams could be used for other things that want to guarantee ordering within the stream.", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r452042378", "createdAt": "2020-07-09T08:13:14Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/Invocation.java", "diffHunk": "@@ -595,9 +595,16 @@ private void doInvokeLocal(boolean isAsync) {\n     private void doInvokeRemote() {\n         assert connectionManager != null : \"Endpoint manager was null\";\n \n-        ServerConnection connection = connectionManager.getOrConnect(targetAddress);\n+        ServerConnection connection = connectionManager.getOrConnect(targetAddress, op.getPartitionId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTc1NA=="}, "originalCommit": {"oid": "7136d7ffc313eee72d82c93d1b0119c518507b54"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEyODM2Mg==", "bodyText": "Also partitions can move around. So it could be that one moment your partition is one one machine and one moment later on another. But streams do not move around; streams are within a connection.", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r452128362", "createdAt": "2020-07-09T10:44:11Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/Invocation.java", "diffHunk": "@@ -595,9 +595,16 @@ private void doInvokeLocal(boolean isAsync) {\n     private void doInvokeRemote() {\n         assert connectionManager != null : \"Endpoint manager was null\";\n \n-        ServerConnection connection = connectionManager.getOrConnect(targetAddress);\n+        ServerConnection connection = connectionManager.getOrConnect(targetAddress, op.getPartitionId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTc1NA=="}, "originalCommit": {"oid": "7136d7ffc313eee72d82c93d1b0119c518507b54"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzk2OTU4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjoxNjoyNVrOGwct7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTowNDoyMVrOGwjyEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NTM0Mg==", "bodyText": "re-enable?", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r453455342", "createdAt": "2020-07-13T06:16:25Z", "author": {"login": "tkountis"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "diffHunk": "@@ -60,37 +61,49 @@ protected AbstractChannelInitializer(ServerContext serverContext, EndpointConfig\n         private final ILogger logger;\n         private final boolean spoofingChecks;\n         private final boolean unifiedEndpointManager;\n-\n         private final Set<ProtocolType> supportedProtocolTypes;\n+        private final int expectedPlaneCount;\n \n-        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager, ServerContext serverContext, ILogger logger,\n+        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager,\n+                                      ServerContext serverContext,\n+                                      ILogger logger,\n                                       Set<ProtocolType> supportedProtocolTypes) {\n             this.connectionManager = connectionManager;\n             this.serverContext = serverContext;\n             this.logger = logger;\n-            this.spoofingChecks = serverContext.properties().getBoolean(ClusterProperty.BIND_SPOOFING_CHECKS);\n+            this.spoofingChecks = serverContext.properties().getBoolean(BIND_SPOOFING_CHECKS);\n             this.supportedProtocolTypes = supportedProtocolTypes;\n             this.unifiedEndpointManager = connectionManager.getEndpointQualifier() == null;\n+            this.expectedPlaneCount = serverContext.properties().getInteger(CHANNEL_COUNT);\n         }\n \n         public void process(Packet packet) {\n-            Object o = serverContext.getSerializationService().toObject(packet);\n+            MemberHandshake handshake = serverContext.getSerializationService().toObject(packet);\n             TcpServerConnection connection = (TcpServerConnection) packet.getConn();\n-            if (connection.setHandshake()) {\n-                MemberHandshake handshake = (MemberHandshake) o;\n-                process(connection, handshake);\n-            } else {\n+            if (!connection.setHandshake()) {\n                 if (logger.isFinestEnabled()) {\n-                    logger.finest(\"Connection \" + connection + \" is already bound, ignoring incoming \" + o);\n+                    logger.finest(\"Connection \" + connection + \" handshake is already completed, ignoring incoming \" + handshake);\n                 }\n+                return;\n             }\n-        }\n \n-        private synchronized boolean process(TcpServerConnection connection, MemberHandshake handshake) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Handshake \" + connection + \", complete message is \" + handshake);\n+            if (handshake.getPlaneCount() != expectedPlaneCount) {\n+                connection.close(\"The connection handshake has incorrect number of planes. \"\n+                        + \"Expected \" + expectedPlaneCount + \" found \" + handshake.getPlaneCount(), null);\n+                return;\n             }\n \n+            // before we register the connection on the plane, we make sure the plane index is set on the connection\n+            // so that we can safely remove the connection from the plane.\n+            connection.setPlaneIndex(handshake.getPlaneIndex());\n+            process(connection, handshake);\n+        }\n+\n+        private synchronized void process(TcpServerConnection connection, MemberHandshake handshake) {\n+            // if (logger.isFinestEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c1ef6b67bf749a65f6792d18d34f46118905b5"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU3MTA5MA==", "bodyText": "Fixed", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r453571090", "createdAt": "2020-07-13T11:04:21Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "diffHunk": "@@ -60,37 +61,49 @@ protected AbstractChannelInitializer(ServerContext serverContext, EndpointConfig\n         private final ILogger logger;\n         private final boolean spoofingChecks;\n         private final boolean unifiedEndpointManager;\n-\n         private final Set<ProtocolType> supportedProtocolTypes;\n+        private final int expectedPlaneCount;\n \n-        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager, ServerContext serverContext, ILogger logger,\n+        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager,\n+                                      ServerContext serverContext,\n+                                      ILogger logger,\n                                       Set<ProtocolType> supportedProtocolTypes) {\n             this.connectionManager = connectionManager;\n             this.serverContext = serverContext;\n             this.logger = logger;\n-            this.spoofingChecks = serverContext.properties().getBoolean(ClusterProperty.BIND_SPOOFING_CHECKS);\n+            this.spoofingChecks = serverContext.properties().getBoolean(BIND_SPOOFING_CHECKS);\n             this.supportedProtocolTypes = supportedProtocolTypes;\n             this.unifiedEndpointManager = connectionManager.getEndpointQualifier() == null;\n+            this.expectedPlaneCount = serverContext.properties().getInteger(CHANNEL_COUNT);\n         }\n \n         public void process(Packet packet) {\n-            Object o = serverContext.getSerializationService().toObject(packet);\n+            MemberHandshake handshake = serverContext.getSerializationService().toObject(packet);\n             TcpServerConnection connection = (TcpServerConnection) packet.getConn();\n-            if (connection.setHandshake()) {\n-                MemberHandshake handshake = (MemberHandshake) o;\n-                process(connection, handshake);\n-            } else {\n+            if (!connection.setHandshake()) {\n                 if (logger.isFinestEnabled()) {\n-                    logger.finest(\"Connection \" + connection + \" is already bound, ignoring incoming \" + o);\n+                    logger.finest(\"Connection \" + connection + \" handshake is already completed, ignoring incoming \" + handshake);\n                 }\n+                return;\n             }\n-        }\n \n-        private synchronized boolean process(TcpServerConnection connection, MemberHandshake handshake) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Handshake \" + connection + \", complete message is \" + handshake);\n+            if (handshake.getPlaneCount() != expectedPlaneCount) {\n+                connection.close(\"The connection handshake has incorrect number of planes. \"\n+                        + \"Expected \" + expectedPlaneCount + \" found \" + handshake.getPlaneCount(), null);\n+                return;\n             }\n \n+            // before we register the connection on the plane, we make sure the plane index is set on the connection\n+            // so that we can safely remove the connection from the plane.\n+            connection.setPlaneIndex(handshake.getPlaneIndex());\n+            process(connection, handshake);\n+        }\n+\n+        private synchronized void process(TcpServerConnection connection, MemberHandshake handshake) {\n+            // if (logger.isFinestEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NTM0Mg=="}, "originalCommit": {"oid": "61c1ef6b67bf749a65f6792d18d34f46118905b5"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzk3OTA3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/internal/server/FirewallingServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjoyMDo0OFrOGwczlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjoyMDo0OFrOGwczlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1Njc5MA==", "bodyText": "?", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r453456790", "createdAt": "2020-07-13T06:20:48Z", "author": {"login": "tkountis"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/server/FirewallingServer.java", "diffHunk": "@@ -236,27 +240,27 @@ private long getRandomBetween(long max, long min) {\n             return (long) ((max - min) * Math.random() + min);\n         }\n \n-        @Override\n-        public boolean transmit(Packet packet, ServerConnection connection) {\n-            if (connection != null) {\n-                PacketFilter.Action action = applyFilter(packet, connection.getRemoteAddress());\n-                switch (action) {\n-                    case DROP:\n-                        return true;\n-                    case REJECT:\n-                        return false;\n-                    case DELAY:\n-                        scheduledExecutor.schedule(new DelayedPacketTask(packet, connection), getDelayMs(), MILLISECONDS);\n-                        return true;\n-                    default:\n-                        // NOP\n-                }\n-            }\n-            return delegate.transmit(packet, connection);\n-        }\n+//        @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c1ef6b67bf749a65f6792d18d34f46118905b5"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjMxNTg4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/ServerConnectionManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDoxMTo1NFrOGykWpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDoxMTo1NFrOGykWpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY3NzYwNg==", "bodyText": "Needs javadoc update.", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r455677606", "createdAt": "2020-07-16T10:11:54Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/server/ServerConnectionManager.java", "diffHunk": "@@ -73,15 +78,19 @@ default int connectionCount() {\n      * @param connection    - The connection to be registered\n      * @return True if the call was successful\n      */\n-    boolean register(Address remoteAddress, ServerConnection connection);\n+    boolean register(Address remoteAddress, ServerConnection connection, int streamId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b123a55b9d52fca7d7c3010066c0538b5e6c7b21"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 688, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}