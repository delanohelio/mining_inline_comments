{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MDM0MTQ0", "number": 16682, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0OTo1M1rOEKkQZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzo0Mjo0MFrOEMFVAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTE1MjM3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/wan/impl/merkletree/ArrayMerkleTreeTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0OTo1M1rOGrrrPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0OTo1M1rOGrrrPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NzUzMw==", "bodyText": "It was really nice seeing the footprint no longer increases with entry count.", "url": "https://github.com/hazelcast/hazelcast/pull/16682#discussion_r448457533", "createdAt": "2020-07-01T15:49:53Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/wan/impl/merkletree/ArrayMerkleTreeTest.java", "diffHunk": "@@ -67,11 +60,11 @@ public void testFootprint() {\n             merkleTree2.updateAdd(i, i);\n         }\n \n-        assertTrue(merkleTree2.footprint() > merkleTree1.footprint());\n+        assertEquals(merkleTree2.footprint(), merkleTree1.footprint());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c009f562c566d61c0d0cc9756ffad49b165bc48a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTA1NjY2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/wan/impl/merkletree/ArrayMerkleTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzo0Mjo0MFrOGt_JsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMDoxNzozNFrOGvK5kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3Mzc3Ng==", "bodyText": "I think we don't have this anymore since leafKeys is removed", "url": "https://github.com/hazelcast/hazelcast/pull/16682#discussion_r450873776", "createdAt": "2020-07-07T13:42:40Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/wan/impl/merkletree/ArrayMerkleTree.java", "diffHunk": "@@ -81,32 +80,29 @@\n  * {@link MerkleTreeUtil#sumHash(int, int)}\n  */\n public class ArrayMerkleTree extends AbstractMerkleTreeView implements MerkleTree {\n-    private final OAHashSet<Object>[] leafKeys;\n     private final int leafLevel;\n \n     /**\n-     * Footprint holds the total memory footprint of the Merkle tree and\n-     * the leaf data blocks.\n-     * <p>\n-     * Note that this field leverages a single-writer and a non-atomic\n-     * operation is executed on the field. See {@link #adjustFootprintWithLeafKeySetChange}\n+     * Footprint holds the total memory footprint of the Merkle tree.\n      */\n-    private volatile long footprint;\n+    private final long footprint;\n \n-    @SuppressWarnings(\"unchecked\")\n     public ArrayMerkleTree(int depth) {\n         super(depth);\n-\n         this.leafLevel = depth - 1;\n-\n-        final int leaves = MerkleTreeUtil.getNodesOnLevel(leafLevel);\n-\n-        leafKeys = new OAHashSet[leaves];\n-        for (int i = 0; i < leaves; i++) {\n-            leafKeys[i] = new OAHashSet<Object>(1);\n-        }\n-\n-        initializeFootprint();\n+        this.footprint = INT_SIZE_IN_BYTES * tree.length\n+                // reference to the tree\n+                + REFERENCE_COST_IN_BYTES\n+                // reference to leafKeys array", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ee677389d9a21defcaec3dfa05e0b1bd69a5cae"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExNDgzNA==", "bodyText": "Removed.", "url": "https://github.com/hazelcast/hazelcast/pull/16682#discussion_r452114834", "createdAt": "2020-07-09T10:17:34Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/wan/impl/merkletree/ArrayMerkleTree.java", "diffHunk": "@@ -81,32 +80,29 @@\n  * {@link MerkleTreeUtil#sumHash(int, int)}\n  */\n public class ArrayMerkleTree extends AbstractMerkleTreeView implements MerkleTree {\n-    private final OAHashSet<Object>[] leafKeys;\n     private final int leafLevel;\n \n     /**\n-     * Footprint holds the total memory footprint of the Merkle tree and\n-     * the leaf data blocks.\n-     * <p>\n-     * Note that this field leverages a single-writer and a non-atomic\n-     * operation is executed on the field. See {@link #adjustFootprintWithLeafKeySetChange}\n+     * Footprint holds the total memory footprint of the Merkle tree.\n      */\n-    private volatile long footprint;\n+    private final long footprint;\n \n-    @SuppressWarnings(\"unchecked\")\n     public ArrayMerkleTree(int depth) {\n         super(depth);\n-\n         this.leafLevel = depth - 1;\n-\n-        final int leaves = MerkleTreeUtil.getNodesOnLevel(leafLevel);\n-\n-        leafKeys = new OAHashSet[leaves];\n-        for (int i = 0; i < leaves; i++) {\n-            leafKeys[i] = new OAHashSet<Object>(1);\n-        }\n-\n-        initializeFootprint();\n+        this.footprint = INT_SIZE_IN_BYTES * tree.length\n+                // reference to the tree\n+                + REFERENCE_COST_IN_BYTES\n+                // reference to leafKeys array", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3Mzc3Ng=="}, "originalCommit": {"oid": "8ee677389d9a21defcaec3dfa05e0b1bd69a5cae"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 708, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}