{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMTgwMzMw", "number": 17382, "title": "SQL index support (#17381)", "bodyText": "This PR introduces indexes support for the SQL engine. High-level design:\n\nThere is a new operator MapIndexScanExec that extracts entries from the index storage using a filter\nThere are three supported filter types: equals, range, and IN\nThe map scan condition is split into conjunctive expressions. Every such expression is analyzed. It is either discarded or converted to a \"candidate\" - a filter that could be used for the index lookup/scan\nThen we take available candidates and try to apply them for every available index. During this phase, atomic candidates are converted to possibly more complicated final index conditions. For example, the condition WHERE a=1 AND b>1 AND b<10 could be converted to a composite filter EQ(a=1), RANGE(b>1, b<10) if there is a composite index on (a, b). Or it could be converted to RANGE(b>1, b<10) if there is an index on (b)\nIf a filter for the index is created successfully, we create a new MapScanPhysicalRel node, that is added to the optimizer search space. The cost function is designed in a way, that a full map scan is cheaper than a full index scan, but index lookup is much cheaper than a full map scan. Therefore, index scan is preferred over map scan during planning in most cases\nWe do not do index joins because we do not have a memory manager to deal with large result sets. E.g., if there are indexes on (a) and (b), and there is a condition WHERE a=1 OR b=2, no index will be used\nFor HD maps we construct an index scan from the first available index. If no indexes are available, we throw an exception with a suggestion to add an index to the map\n\nThe key class is IndexResolver.\nEnterprise PR: https://github.com/hazelcast/hazelcast-enterprise/pull/3727\nCloses #17381", "createdAt": "2020-08-19T13:53:07Z", "url": "https://github.com/hazelcast/hazelcast/pull/17382", "merged": true, "mergeCommit": {"oid": "48f41186f6a28d42d090be20b499ab0deb71cf3d"}, "closed": true, "closedAt": "2020-08-25T09:37:10Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 56, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAbsOvgH2gAyNDcwMTgwMzMwOjBhZjg4MzI3NjFiY2YwZjcxMGRlOGEyZDM1NzlhZjE2Mjk0Y2Q2ODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCSbkKgH2gAyNDcwMTgwMzMwOmMyM2U2MWJiYjg5ODNkOWRiZjU4MDMwNTYxYzkxN2E0MDVmNzFkN2Q=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0af8832761bcf0f710de8a2d3579af16294cd689", "committedDate": "2020-08-19T13:32:59Z", "message": "SQL index support (#17378)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNTU2OTU3", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-470556957", "createdAt": "2020-08-19T15:10:30Z", "commit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToxMDozMVrOHDL_PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToxOToxNVrOHDMXgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDE4OA==", "bodyText": "Javadoc for the new methods would be useful.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473104188", "createdAt": "2020-08-19T15:10:31Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -109,6 +111,14 @@\n      */\n     Set<QueryableEntry> evaluate(Predicate predicate);\n \n+    Iterator<QueryableEntry> getRecordIterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNjI3OA==", "bodyText": "I'd return null values first because NULL is less than any other key.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473106278", "createdAt": "2020-08-19T15:13:26Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -110,6 +115,81 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(iterator, nullIterator).iterator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMDQwMA==", "bodyText": "In the old Set based implementation we supported a similar method. Yes, not efficiently, but we didn't throw an exception.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473110400", "createdAt": "2020-08-19T15:19:15Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/UnorderedIndexStore.java", "diffHunk": "@@ -136,6 +140,44 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(iterator, nullIterator).iterator());\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator(Comparable value) {\n+        if (value == NULL) {\n+            return recordsWithNullValue.values().iterator();\n+        } else {\n+            Map<Data, QueryableEntry> res = recordMap.get(canonicalize(value));\n+\n+            if (res == null) {\n+                return Collections.emptyIterator();\n+            }\n+\n+            return res.values().iterator();\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator(Comparison comparison, Comparable value) {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNTcwNjI5", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-470570629", "createdAt": "2020-08-19T15:24:16Z", "commit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToyNDoxNlrOHDMnKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToyNjozNlrOHDMtsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNDQxMQ==", "bodyText": "Why for NULL we don't get them from the index?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473114411", "createdAt": "2020-08-19T15:24:16Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;\n+    private boolean fromInclusive;\n+    private IndexFilterValue to;\n+    private boolean toInclusive;\n+\n+    public IndexRangeFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexRangeFilter(IndexFilterValue from, boolean fromInclusive, IndexFilterValue to, boolean toInclusive) {\n+        this.from = from;\n+        this.fromInclusive = fromInclusive;\n+        this.to = to;\n+        this.toInclusive = toInclusive;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        if (from != null && to == null) {\n+            // Left bound only\n+            Comparable fromValue = from.getValue(evalContext);\n+            Comparison fromComparison = fromInclusive ? Comparison.GREATER_OR_EQUAL : Comparison.GREATER;\n+\n+            if (fromValue == null || fromValue == AbstractIndex.NULL) {\n+                return Collections.emptyIterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNjA4Mg==", "bodyText": "if from == null and to == null then we will go to this branch?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473116082", "createdAt": "2020-08-19T15:26:36Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;\n+    private boolean fromInclusive;\n+    private IndexFilterValue to;\n+    private boolean toInclusive;\n+\n+    public IndexRangeFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexRangeFilter(IndexFilterValue from, boolean fromInclusive, IndexFilterValue to, boolean toInclusive) {\n+        this.from = from;\n+        this.fromInclusive = fromInclusive;\n+        this.to = to;\n+        this.toInclusive = toInclusive;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        if (from != null && to == null) {\n+            // Left bound only\n+            Comparable fromValue = from.getValue(evalContext);\n+            Comparison fromComparison = fromInclusive ? Comparison.GREATER_OR_EQUAL : Comparison.GREATER;\n+\n+            if (fromValue == null || fromValue == AbstractIndex.NULL) {\n+                return Collections.emptyIterator();\n+            }\n+\n+            return index.getRecordIterator(fromComparison, fromValue);\n+        } else if (from == null && to != null) {\n+            // Right bound only\n+            Comparable toValue = to.getValue(evalContext);\n+            Comparison toComparison = toInclusive ? Comparison.LESS_OR_EQUAL : Comparison.LESS;\n+\n+            if (toValue == null || toValue == AbstractIndex.NULL) {\n+                return Collections.emptyIterator();\n+            }\n+\n+            return index.getRecordIterator(toComparison, toValue);\n+        } else {\n+            assert from != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eec916ef782651bfc4e1eb4ff2ea5bdcb8728a0b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/eec916ef782651bfc4e1eb4ff2ea5bdcb8728a0b", "committedDate": "2020-08-19T18:46:47Z", "message": "Fixed MapIndexScanPlanNode serialization and equality."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1fddde298baf41fe4bc201d6c637b424b7b6667", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b1fddde298baf41fe4bc201d6c637b424b7b6667", "committedDate": "2020-08-19T18:51:54Z", "message": "JavaDoc for new index methods. Added \"sql\" word to them to stress out that they should be used for SQL only."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "480b43d858d34b6dba0f27154c257c7523713928", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/480b43d858d34b6dba0f27154c257c7523713928", "committedDate": "2020-08-19T18:54:23Z", "message": "Move NULLs to the beginning for OrderedIndexStore."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93423f0e9262f722d2280c0032cb94420c7edf89", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/93423f0e9262f722d2280c0032cb94420c7edf89", "committedDate": "2020-08-19T19:01:28Z", "message": "Better code arrangement in IndexRangeFilter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73b642509f5df21624bdeaae4e3641cfea9a9412", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/73b642509f5df21624bdeaae4e3641cfea9a9412", "committedDate": "2020-08-20T08:44:40Z", "message": "Merge branch 'master' into issues/17381"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzUwMzY2", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-471350366", "createdAt": "2020-08-20T07:54:15Z", "commit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo1NDoxNVrOHDx2lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozNDowM1rOHD3aCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyNDU2Ng==", "bodyText": "Is there any real concurrency here?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473724566", "createdAt": "2020-08-20T07:54:15Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java", "diffHunk": "@@ -219,4 +229,119 @@ public static SqlInternalService sqlInternalService(HazelcastInstance instance)\n     public static void clearPlanCache(HazelcastInstance member) {\n         ((SqlServiceImpl) member.getSql()).getPlanCache().clear();\n     }\n+\n+    public static int getLocalPartition(HazelcastInstance member) {\n+        PartitionIdSet partitions = getLocalPartitions(member);\n+\n+        if (partitions.isEmpty()) {\n+            throw new RuntimeException(\"Member does nave local partitions\");\n+        }\n+\n+        return partitions.iterator().next();\n+    }\n+\n+    public static PartitionIdSet getLocalPartitions(HazelcastInstance member) {\n+        PartitionService partitionService = member.getPartitionService();\n+\n+        PartitionIdSet res = new PartitionIdSet(partitionService.getPartitions().size());\n+\n+        for (Partition partition : partitionService.getPartitions()) {\n+            if (partition.getOwner().localMember()) {\n+                res.add(partition.getPartitionId());\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    public static <K> K getLocalKey(\n+        HazelcastInstance member,\n+        IntFunction<K> keyProducer\n+    ) {\n+        return getLocalKeys(member, 1, keyProducer).get(0);\n+    }\n+\n+    public static <K> List<K> getLocalKeys(\n+        HazelcastInstance member,\n+        int count,\n+        IntFunction<K> keyProducer\n+    ) {\n+        return new ArrayList<>(getLocalEntries(member, count, keyProducer, keyProducer).keySet());\n+    }\n+\n+    public static <K, V> Map.Entry<K, V> getLocalEntry(\n+        HazelcastInstance member,\n+        IntFunction<K> keyProducer,\n+        IntFunction<V> valueProducer\n+    ) {\n+        return getLocalEntries(member, 1, keyProducer, valueProducer).entrySet().iterator().next();\n+    }\n+\n+    public static <K, V> Map<K, V> getLocalEntries(\n+        HazelcastInstance member,\n+        int count,\n+        IntFunction<K> keyProducer,\n+        IntFunction<V> valueProducer\n+    ) {\n+        if (count == 0) {\n+            return Collections.emptyMap();\n+        }\n+\n+        PartitionService partitionService = member.getPartitionService();\n+\n+        Map<K, V> res = new LinkedHashMap<>();\n+\n+        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n+            K key = keyProducer.apply(i);\n+\n+            if (key == null) {\n+                continue;\n+            }\n+\n+            Partition partition = partitionService.getPartition(key);\n+\n+            if (!partition.getOwner().localMember()) {\n+                continue;\n+            }\n+\n+            V value = valueProducer.apply(i);\n+\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            res.put(key, value);\n+\n+            if (res.size() == count) {\n+                break;\n+            }\n+        }\n+\n+        if (res.size() < count) {\n+            throw new RuntimeException(\"Failed to get the necesasry number of key: \" + res.size());\n+        }\n+\n+        return res;\n+    }\n+\n+    protected static MapIndexScanPlanNode findFirstIndexNode(SqlResult result) {\n+        SqlResultImpl result0 = (SqlResultImpl) result;\n+\n+        AtomicReference<MapIndexScanPlanNode> nodeRef = new AtomicReference<>();\n+\n+        for (int i = 0; i < result0.getPlan().getFragmentCount(); i++) {\n+            PlanNode fragment = result0.getPlan().getFragment(i);\n+\n+            fragment.visit(new TestPlanNodeVisitorAdapter() {\n+                @Override\n+                public void onMapIndexScanNode(MapIndexScanPlanNode node) {\n+                    nodeRef.compareAndSet(null, node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxMzQwNA==", "bodyText": "Do we have HD version of the test in the EE PR?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473813404", "createdAt": "2020-08-20T09:31:25Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilterTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class IndexRangeFilterTest extends IndexFilterTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNDU4NQ==", "bodyText": "Cannot find HD version of the test in the EE PR.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473814585", "createdAt": "2020-08-20T09:32:51Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecTest.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.IndexConfig;\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.exec.IterationResult;\n+import com.hazelcast.sql.impl.exec.scan.AbstractMapScanExec;\n+import com.hazelcast.sql.impl.expression.ColumnExpression;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonMode;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonPredicate;\n+import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MapIndexScanExecTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNTU2Mg==", "bodyText": "Add HD version as well?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473815562", "createdAt": "2020-08-20T09:34:03Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/schema/map/MapTableIndexTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.List;\n+\n+import static com.hazelcast.config.IndexType.HASH;\n+import static com.hazelcast.config.IndexType.SORTED;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static java.util.Collections.singletonList;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MapTableIndexTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0af8832761bcf0f710de8a2d3579af16294cd689"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66b59b835ca52cdfacaf6035fe10835e61c096cd", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/66b59b835ca52cdfacaf6035fe10835e61c096cd", "committedDate": "2020-08-20T09:34:19Z", "message": "Make sure that the engine do not use non-concurrent HD indexes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNDI4OTA2", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-471428906", "createdAt": "2020-08-20T09:41:53Z", "commit": {"oid": "73b642509f5df21624bdeaae4e3641cfea9a9412"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTo0MTo1M1rOHD30Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMDowNTowNFrOHD5AQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMjIzMQ==", "bodyText": "What is about BITMAP indexes? Are they filtered out on a higher level?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473822231", "createdAt": "2020-08-20T09:41:53Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/CostUtils.java", "diffHunk": "@@ -43,6 +50,29 @@ private CostUtils() {\n         // No-op.\n     }\n \n+    /**\n+     * Get CPU multiplier for index scan. It ensures that normal scans are preferred over index scans when there are no\n+     * conditions and collation provided by the index is not important for the specific query.\n+     * <p>\n+     * We assume that index scan is more expensive than normal scan due to additional level of indirection. This is not the\n+     * case for covering index scans, but we do not support them yet.\n+     * <p>\n+     * We assume that HASH index lookup is cheaper than SORTED index lookup in general case, because the former has O(1)\n+     * complexity, while the latter has O(N) complexity.\n+     *\n+     * @param type Index type.\n+     * @return CPU multiplier.\n+     */\n+    public static double indexScanCpuMultiplier(IndexType type) {\n+        if (type == IndexType.HASH) {\n+            return INDEX_SCAN_CPU_MULTIPLIER_HASH;\n+        } else {\n+            assert type == IndexType.SORTED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73b642509f5df21624bdeaae4e3641cfea9a9412"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyNjExNA==", "bodyText": "Typo: thos", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473826114", "createdAt": "2020-08-20T09:46:36Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexComponentCandidate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilter;\n+import org.apache.calcite.rex.RexNode;\n+\n+/**\n+ * A candidate expression that could potentially be used to form a filter on some index component.\n+ * <p>\n+ * Consider the query {@code SELECT * FROM person WHERE name=? AND age=?}. After analysis two candidates would be\n+ * created: one for the {@code name=?} expression, and another for the {@code age=?} expression. If there is an index\n+ * on any of thos columns, the engine will attempt to apply the candidate to the index to form an {@link IndexComponentFilter}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73b642509f5df21624bdeaae4e3641cfea9a9412"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg0MTcyOQ==", "bodyText": "Do we expect here any specific Sql exception? I feel a bit uncomfortable to catch a random exception and potentially hiding an issue in the code.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473841729", "createdAt": "2020-08-20T10:05:04Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -0,0 +1,1117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.query.impl.ComparableIdentifiedDataSerializable;\n+import com.hazelcast.query.impl.TypeConverters;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.logical.MapScanLogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapIndexScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastRelOptTable;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexEqualsFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilterValue;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexInFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexRangeFilter;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeFieldTypeProvider;\n+import com.hazelcast.sql.impl.schema.map.MapTableIndex;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.hazelcast.query.impl.CompositeValue.NEGATIVE_INFINITY;\n+import static com.hazelcast.query.impl.CompositeValue.POSITIVE_INFINITY;\n+import static java.util.Collections.singletonList;\n+import static org.apache.calcite.sql.type.SqlTypeFamily.NUMERIC;\n+\n+/**\n+ * Helper class to resolve indexes.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public final class IndexResolver {\n+    private IndexResolver() {\n+        // No-op.\n+    }\n+\n+    public static List<RelNode> createIndexScans(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        List<MapTableIndex> indexes\n+    ) {\n+        // Early return if there is no filter.\n+        RexNode filter = scan.getTableUnwrapped().getFilter();\n+\n+        if (filter == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Filter out unsupported indexes.\n+        List<MapTableIndex> supportedIndexes = new ArrayList<>(indexes.size());\n+        Set<Integer> allIndexedFieldOrdinals = new HashSet<>();\n+\n+        for (MapTableIndex index : indexes) {\n+            if (isIndexSupported(index)) {\n+                supportedIndexes.add(index);\n+\n+                allIndexedFieldOrdinals.addAll(index.getFieldOrdinals());\n+            }\n+        }\n+\n+        // Early return if there are no indexes to consider.\n+        if (supportedIndexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Convert expression into CNF\n+        List<RexNode> conjunctions = createConjunctiveFilter(filter);\n+\n+        // Prepare candidates from conjunctive expressions.\n+        Map<Integer, List<IndexComponentCandidate>> candidates = prepareSingleColumnCandidates(\n+            conjunctions,\n+            OptUtils.getCluster(scan).getParameterMetadata(),\n+            allIndexedFieldOrdinals\n+        );\n+\n+        if (candidates.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Create index relational operators based on candidates.\n+        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n+\n+        for (MapTableIndex index : supportedIndexes) {\n+            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+\n+            if (rel != null) {\n+                rels.add(rel);\n+            }\n+        }\n+\n+        return rels;\n+    }\n+\n+    /**\n+     * Creates an object for convenient access to part of the predicate in the CNF.\n+     */\n+    private static List<RexNode> createConjunctiveFilter(RexNode filter) {\n+        List<RexNode> conjunctions = new ArrayList<>(1);\n+\n+        RelOptUtil.decomposeConjunction(filter, conjunctions);\n+\n+        return conjunctions;\n+    }\n+\n+    /**\n+     * Creates a map from the scan column ordinal to expressions that could be potentially used by indexes created over\n+     * this column.\n+     *\n+     * @param nodes                   CNF nodes\n+     * @param allIndexedFieldOrdinals Ordinals of all columns that have some indexes. Helps to filter out candidates that\n+     *                                definitely cannot be used earlier.\n+     */\n+    private static Map<Integer, List<IndexComponentCandidate>> prepareSingleColumnCandidates(\n+        List<RexNode> nodes,\n+        QueryParameterMetadata parameterMetadata,\n+        Set<Integer> allIndexedFieldOrdinals\n+    ) {\n+        Map<Integer, List<IndexComponentCandidate>> res = new HashMap<>();\n+\n+        for (RexNode node : nodes) {\n+            IndexComponentCandidate candidate = prepareSingleColumnCandidate(node, parameterMetadata);\n+\n+            if (candidate == null) {\n+                // Expression cannot be used for indexes\n+                continue;\n+            }\n+\n+            if (!allIndexedFieldOrdinals.contains(candidate.getColumnIndex())) {\n+                // Expression could be used for indexes, but there are no matching indexes\n+                continue;\n+            }\n+\n+            res.computeIfAbsent(candidate.getColumnIndex(), (k) -> new ArrayList<>()).add(candidate);\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * Prepares an expression candidate for the given RexNode.\n+     * <p>\n+     * We consider two types of expressions: comparison predicates and OR condition. We try to interpret OR as IN, otherwise\n+     * it is ignored.\n+     *\n+     * @param exp calcite expression\n+     * @return candidate or {@code null} if the expression cannot be used with indexes\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    private static IndexComponentCandidate prepareSingleColumnCandidate(\n+        RexNode exp,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        SqlKind kind = exp.getKind();\n+\n+        switch (kind) {\n+            case INPUT_REF:\n+                // Special case for boolean columns: SELECT * FROM t WHERE f_boolean\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(exp, exp, SqlKind.IS_TRUE);\n+\n+            case IS_TRUE:\n+            case IS_FALSE:\n+            case IS_NOT_TRUE:\n+            case IS_NOT_FALSE:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    kind\n+                );\n+\n+            case NOT:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    SqlKind.IS_FALSE\n+                );\n+\n+            case IS_NULL:\n+                return prepareSingleColumnCandidateIsNull(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), true)\n+                );\n+\n+            case GREATER_THAN:\n+            case GREATER_THAN_OR_EQUAL:\n+            case LESS_THAN:\n+            case LESS_THAN_OR_EQUAL:\n+            case EQUALS:\n+                BiTuple<RexNode, RexNode> operands = extractComparisonOperands(exp);\n+\n+                return prepareSingleColumnCandidateComparison(\n+                    exp,\n+                    kind,\n+                    operands.element1(),\n+                    operands.element2(),\n+                    parameterMetadata\n+                );\n+\n+            case OR:\n+                return prepareSingleColumnCandidateOr(\n+                    exp,\n+                    ((RexCall) exp).getOperands(),\n+                    parameterMetadata\n+                );\n+\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    /**\n+     * Prepare a candidate for {@code IS (NOT) TRUE/FALSE} expression.\n+     * <p>\n+     * The fundamental observation is that boolean column may have only three values - TRUE/FALSE/NULL. Therefore, every\n+     * such expression could be converted to equivalent equals or IN predicate.\n+     *\n+     * @param exp expression\n+     * @param operand operand with CAST unwrapped\n+     * @param kind expression type\n+     * @return candidate or {@code null}\n+     */\n+    private static IndexComponentCandidate prepareSingleColumnCandidateBooleanIsTrueFalse(\n+        RexNode exp,\n+        RexNode operand,\n+        SqlKind kind\n+    ) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        if (operand.getType().getSqlTypeName() != SqlTypeName.BOOLEAN) {\n+            // Only boolean columns could be used with this optimization\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case IS_TRUE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_FALSE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_NOT_TRUE:\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.IS_NOT_FALSE;\n+\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+        }\n+\n+        return new IndexComponentCandidate(exp, columnIndex, filter);\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateIsNull(RexNode exp, RexNode operand) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        QueryDataType type = SqlToQueryType.map(operand.getType().getSqlTypeName());\n+\n+        IndexFilterValue filterValue = new IndexFilterValue(\n+            singletonList(ConstantExpression.create(null, type)),\n+            singletonList(true)\n+        );\n+\n+        IndexFilter filter = new IndexEqualsFilter(filterValue);\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateComparison(\n+        RexNode exp,\n+        SqlKind kind,\n+        RexNode operand1,\n+        RexNode operand2,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        // Normalize operand positions, so that the column is always goes first\n+        if (operand1.getKind() != SqlKind.INPUT_REF && operand2.getKind() == SqlKind.INPUT_REF) {\n+            kind = inverseIndexConditionKind(kind);\n+\n+            RexNode tmp = operand1;\n+            operand1 = operand2;\n+            operand2 = tmp;\n+        }\n+\n+        // Exit if the first operand is not a column\n+        if (operand1.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand1).getIndex();\n+\n+        if (!IndexRexVisitor.isValid(operand2)) {\n+            // The second operand cannot be used for index filter\n+            return null;\n+        }\n+\n+        Expression<?> filterValue = convertToExpression(operand2, parameterMetadata);\n+\n+        if (filterValue == null) {\n+            // Operand cannot be converted to expression. Do not throw an exception here, just do not use the faulty condition\n+            // for index. The proper exception will be thrown on later stages when attempting to convert Calcite rel tree to\n+            // Hazelcast plan.\n+            return null;\n+        }\n+\n+        IndexFilterValue filterValue0 = new IndexFilterValue(\n+            singletonList(filterValue),\n+            singletonList(false)\n+        );\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case EQUALS:\n+                filter = new IndexEqualsFilter(filterValue0);\n+\n+                break;\n+\n+            case GREATER_THAN:\n+                filter = new IndexRangeFilter(filterValue0, false, null, false);\n+\n+                break;\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                filter = new IndexRangeFilter(filterValue0, true, null, false);\n+\n+                break;\n+\n+            case LESS_THAN:\n+                filter = new IndexRangeFilter(null, false, filterValue0, false);\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.LESS_THAN_OR_EQUAL;\n+\n+                filter = new IndexRangeFilter(null, false, filterValue0, true);\n+        }\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static Expression<?> convertToExpression(RexNode operand, QueryParameterMetadata parameterMetadata) {\n+        try {\n+            RexToExpressionVisitor visitor = new RexToExpressionVisitor(FieldTypeProvider.INSTANCE, parameterMetadata);\n+\n+            return operand.accept(visitor);\n+        } catch (Exception e) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73b642509f5df21624bdeaae4e3641cfea9a9412"}, "originalPosition": 430}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c47b1e179b47dfce6ed488350060b7347a1c9052", "committedDate": "2020-08-20T11:58:44Z", "message": "Fixed typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjcyMTM5", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472272139", "createdAt": "2020-08-21T07:39:57Z", "commit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzozOTo1N1rOHEf2ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzozOTo1N1rOHEf2ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3ODIwMw==", "bodyText": "Do we need initialized flag? Can we check the currentIterator != null instead?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474478203", "createdAt": "2020-08-21T07:39:57Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/AbstractCompositeIterator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+public abstract class AbstractCompositeIterator<E> implements Iterator<E> {\n+\n+    private Iterator<E> currentIterator;\n+    private boolean initialized;\n+\n+    @Override\n+    public boolean hasNext() {\n+        if (!initialized) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjc0MzA4", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472274308", "createdAt": "2020-08-21T07:43:41Z", "commit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzo0Mzo0MVrOHEgCqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODowODowNVrOHEhTAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4MTMyMw==", "bodyText": "Why for not set converter we always return empty result? Is it a valid use case to have an empty converter?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474481323", "createdAt": "2020-08-21T07:43:41Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/AbstractIndex.java", "diffHunk": "@@ -173,6 +176,47 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         return indexStore.evaluate(predicate, converter);\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator() {\n+        if (converter == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4MzQ2NQ==", "bodyText": "I'd also specify that NULL values are also returned.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474483465", "createdAt": "2020-08-21T07:46:10Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -109,6 +111,33 @@\n      */\n     Set<QueryableEntry> evaluate(Predicate predicate);\n \n+    /**\n+     * @return iterator over all index entries\n+     */\n+    Iterator<QueryableEntry> getSqlRecordIterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5NTI1Nw==", "bodyText": "It seems IndexEntryFlatteningIterator name would fit better.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474495257", "createdAt": "2020-08-21T07:59:58Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -110,6 +115,81 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(nullIterator, iterator).iterator());\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator(Comparable value) {\n+        if (value == NULL) {\n+            return recordsWithNullValue.values().iterator();\n+        } else {\n+            Map<Data, QueryableEntry> entries = recordMap.get(value);\n+\n+            if (entries == null) {\n+                return Collections.emptyIterator();\n+            } else {\n+                return entries.values().iterator();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable searchedValue) {\n+        Iterator<Map<Data, QueryableEntry>> iterator;\n+\n+        switch (comparison) {\n+            case LESS:\n+                iterator = recordMap.headMap(searchedValue, false).values().iterator();\n+                break;\n+            case LESS_OR_EQUAL:\n+                iterator = recordMap.headMap(searchedValue, true).values().iterator();\n+                break;\n+            case GREATER:\n+                iterator = recordMap.tailMap(searchedValue, false).values().iterator();\n+                break;\n+            case GREATER_OR_EQUAL:\n+                iterator = recordMap.tailMap(searchedValue, true).values().iterator();\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unrecognized comparison: \" + comparison);\n+        }\n+\n+        return new IndexEntryCompositeIterator(iterator);\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator(\n+        Comparable from,\n+        boolean fromInclusive,\n+        Comparable to,\n+        boolean toInclusive\n+    ) {\n+        int order = Comparables.compare(from, to);\n+\n+        if (order == 0) {\n+            if (!fromInclusive || !toInclusive) {\n+                return emptyIterator();\n+            }\n+\n+            Map<Data, QueryableEntry> res = recordMap.get(from);\n+\n+            if (res == null) {\n+                return emptyIterator();\n+            }\n+\n+            return res.values().iterator();\n+        } else if (order > 0) {\n+            return emptyIterator();\n+        }\n+\n+        return new IndexEntryCompositeIterator(recordMap.subMap(from, fromInclusive, to, toInclusive).values().iterator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5NTc4Ng==", "bodyText": "nullIterator first?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474495786", "createdAt": "2020-08-21T08:00:37Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/UnorderedIndexStore.java", "diffHunk": "@@ -136,6 +140,44 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(iterator, nullIterator).iterator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5ODU2Nw==", "bodyText": "What if value == null. In the getEntries() method we do this check.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474498567", "createdAt": "2020-08-21T08:03:59Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexEqualsFilter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexEqualsFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue value;\n+\n+    public IndexEqualsFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexEqualsFilter(IndexFilterValue value) {\n+        this.value = value;\n+    }\n+\n+    public IndexFilterValue getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        Comparable value = getComparable(evalContext);\n+\n+        if (value == null) {\n+            return Collections.emptyIterator();\n+        }\n+\n+        return index.getSqlRecordIterator(value);\n+    }\n+\n+    @Override\n+    public Comparable getComparable(ExpressionEvalContext evalContext) {\n+        return value.getValue(evalContext);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.INDEX_FILTER_EQUALS;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeObject(value);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        value = in.readObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        IndexEqualsFilter that = (IndexEqualsFilter) o;\n+\n+        return value.equals(that.value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwMTg5MQ==", "bodyText": "What if allowNulls.get returns false? Do we handle this case?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474501891", "createdAt": "2020-08-21T08:08:05Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexFilterValue.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.CompositeValue;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Value that is used for filter lookup operations.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexFilterValue implements IdentifiedDataSerializable {\n+\n+    private List<Expression> components;\n+    private List<Boolean> allowNulls;\n+\n+    public IndexFilterValue() {\n+        // No-op.\n+    }\n+\n+    public IndexFilterValue(List<Expression> components, List<Boolean> allowNulls) {\n+        this.components = components;\n+        this.allowNulls = allowNulls;\n+    }\n+\n+    public Comparable getValue(ExpressionEvalContext evalContext) {\n+        if (components.size() == 1) {\n+            return getComponentValue(0, evalContext);\n+        } else {\n+            Comparable[] componentValues = new Comparable[components.size()];\n+\n+            for (int i = 0; i < components.size(); i++) {\n+                Comparable componentValue = getComponentValue(i, evalContext);\n+\n+                if (componentValue == null) {\n+                    return null;\n+                }\n+\n+                componentValues[i] = componentValue;\n+            }\n+\n+            return new CompositeValue(componentValues);\n+        }\n+    }\n+\n+    private Comparable getComponentValue(int index, ExpressionEvalContext evalContext) {\n+        Object value = components.get(index).eval(NoColumnAccessRow.INSTANCE, evalContext);\n+\n+        if (value == null && allowNulls.get(index)) {\n+            value = AbstractIndex.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjk2ODIz", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472296823", "createdAt": "2020-08-21T08:19:58Z", "commit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoxOTo1OFrOHEh7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoyNTo0OFrOHEiP8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxMjI5NQ==", "bodyText": "I'd make all these fields final", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474512295", "createdAt": "2020-08-21T08:19:58Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNzQ5MQ==", "bodyText": "If toValue is not null we still have to return empty result?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474517491", "createdAt": "2020-08-21T08:25:48Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;\n+    private boolean fromInclusive;\n+    private IndexFilterValue to;\n+    private boolean toInclusive;\n+\n+    public IndexRangeFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexRangeFilter(IndexFilterValue from, boolean fromInclusive, IndexFilterValue to, boolean toInclusive) {\n+        assert from != null || to != null;\n+\n+        this.from = from;\n+        this.fromInclusive = fromInclusive;\n+        this.to = to;\n+        this.toInclusive = toInclusive;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        if (from != null) {\n+            if (to != null) {\n+                // Lower and upper bounds\n+                Comparable fromValue = from.getValue(evalContext);\n+\n+                if (fromValue == null || fromValue == AbstractIndex.NULL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "committedDate": "2020-08-21T08:27:26Z", "message": "Merge branch 'master' into issues/17381\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMzAzMTA0", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472303104", "createdAt": "2020-08-21T08:29:43Z", "commit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoyOTo0M1rOHEidbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoyOTo0M1rOHEidbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMDk0Mw==", "bodyText": "If the index has been removed concurrently, shall we throw this exception to the user instead of falling back to the map scan?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474520943", "createdAt": "2020-08-21T08:29:43Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecIterator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.scan.KeyValueIterator;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.schema.map.MapTableUtils;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Iterator for index-based partitioned map access.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapIndexScanExecIterator implements KeyValueIterator {\n+\n+    private final Iterator<QueryableEntry> iterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapIndexScanExecIterator(\n+        MapContainer map,\n+        String indexName,\n+        int expectedComponentCount,\n+        IndexFilter indexFilter,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions,\n+        ExpressionEvalContext evalContext\n+    ) {\n+        iterator = getIndexEntries(\n+            map,\n+            indexName,\n+            indexFilter,\n+            evalContext,\n+            expectedComponentCount,\n+            expectedConverterTypes,\n+            expectedPartitions\n+        );\n+\n+        advance0();\n+    }\n+\n+    @Override\n+    public boolean tryAdvance() {\n+        if (!done()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean done() {\n+        return nextKey == null;\n+    }\n+\n+    @Override\n+    public Object getKey() {\n+        return currentKey;\n+    }\n+\n+    @Override\n+    public Object getValue() {\n+        return currentValue;\n+    }\n+\n+    private void advance0() {\n+        if (iterator.hasNext()) {\n+            QueryableEntry<?, ?> entry = iterator.next();\n+\n+            nextKey = entry.getKeyData();\n+            nextValue = entry.getValue();\n+        } else {\n+            nextKey = null;\n+            nextValue = null;\n+        }\n+    }\n+\n+    private Iterator<QueryableEntry> getIndexEntries(\n+        MapContainer map,\n+        String indexName,\n+        IndexFilter indexFilter,\n+        ExpressionEvalContext evalContext,\n+        int expectedComponentCount,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions\n+    ) {\n+        // Find the index\n+        InternalIndex index = map.getIndexes().getIndex(indexName);\n+\n+        if (index == null) {\n+            throw QueryException.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMzY4MDY2", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472368066", "createdAt": "2020-08-21T10:06:33Z", "commit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMDowNjozM1rOHEnfpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMDowNjozM1rOHEnfpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwMzQyOQ==", "bodyText": "It might make sense to document what this visitor considers valid (literals, parameters and calls on them?), otherwise it requires inspecting every method of the base class to understand what is valid and what is not.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474603429", "createdAt": "2020-08-21T10:06:33Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexRexVisitor.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import org.apache.calcite.rex.RexCorrelVariable;\n+import org.apache.calcite.rex.RexFieldAccess;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexLocalRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexOver;\n+import org.apache.calcite.rex.RexPatternFieldRef;\n+import org.apache.calcite.rex.RexRangeRef;\n+import org.apache.calcite.rex.RexSubQuery;\n+import org.apache.calcite.rex.RexTableInputRef;\n+import org.apache.calcite.rex.RexVisitorImpl;\n+\n+public final class IndexRexVisitor extends RexVisitorImpl<Void> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMzcxMzIy", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472371322", "createdAt": "2020-08-21T10:11:37Z", "commit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMDoxMTozN1rOHEno3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMDoxMTozN1rOHEno3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwNTc4OQ==", "bodyText": "Is this change intentional?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474605789", "createdAt": "2020-08-21T10:11:37Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/SqlErrorTest.java", "diffHunk": "@@ -96,7 +96,6 @@ public void testMemberLeave() {\n \n         // Start query\n         SqlException error = assertSqlException(instance1, query());\n-        assertEquals(SqlErrorCode.CONNECTION_PROBLEM, error.getCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fe83bcaf95fb6d4f41744e17cfb63f9a75d0711", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9fe83bcaf95fb6d4f41744e17cfb63f9a75d0711", "committedDate": "2020-08-21T10:57:20Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75bbc626ff4a720a28747fcc6e44319ff0d49e24", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/75bbc626ff4a720a28747fcc6e44319ff0d49e24", "committedDate": "2020-08-21T11:02:56Z", "message": "IndexEntryCompositeIterator -> IndexEntryFlatteningIterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99641cbb68434a0786bc3a1c6101c44c2091c793", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/99641cbb68434a0786bc3a1c6101c44c2091c793", "committedDate": "2020-08-21T11:03:37Z", "message": "NULLs first for UnorderedIndexStore."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4785941346d0f81e314abb834b57b08b717514ad", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4785941346d0f81e314abb834b57b08b717514ad", "committedDate": "2020-08-21T11:19:19Z", "message": "JavaDoc for IndexRexVisitor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3408445e08a927818f51db7b5754ab3fbae8e169", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3408445e08a927818f51db7b5754ab3fbae8e169", "committedDate": "2020-08-21T11:21:56Z", "message": "Fix to SqlErrorTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42786117b894e378590fa5cbae4eaf82f992a266", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/42786117b894e378590fa5cbae4eaf82f992a266", "committedDate": "2020-08-21T18:25:41Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05dbe61c23f0cff45417a815e083d5967e347502", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/05dbe61c23f0cff45417a815e083d5967e347502", "committedDate": "2020-08-22T06:38:37Z", "message": "Merge branch 'master' into issues/17381\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/SqlErrorTest.java\n#\thazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a181eda26e47a2ad0462ab359d63f33d577d0a7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5a181eda26e47a2ad0462ab359d63f33d577d0a7", "committedDate": "2020-08-22T06:44:42Z", "message": "Merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02543afd7f25a9983c3b03ede8faed477e1212f4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/02543afd7f25a9983c3b03ede8faed477e1212f4", "committedDate": "2020-08-22T07:01:09Z", "message": "Minors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMTUyNDg0", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473152484", "createdAt": "2020-08-24T06:32:38Z", "commit": {"oid": "02543afd7f25a9983c3b03ede8faed477e1212f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNjozMjozOFrOHFWSPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNjozMjozOFrOHFWSPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM3MDA0Ng==", "bodyText": "Range filters are never created for hash indexes and that's how preference of hash indexes (1.1 < 1.2) over sorted ones is avoided for range filters, right?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475370046", "createdAt": "2020-08-24T06:32:38Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/CostUtils.java", "diffHunk": "@@ -30,6 +31,12 @@\n     /** CPU multiplier applied to normal scan. */\n     public static final double TABLE_SCAN_CPU_MULTIPLIER = 1.0d;\n \n+    /** CPU multiplier applied to index scan (sorted). */\n+    public static final double INDEX_SCAN_CPU_MULTIPLIER_SORTED = 1.2d;\n+\n+    /** CPU multiplier applied to index scan (hash). */\n+    public static final double INDEX_SCAN_CPU_MULTIPLIER_HASH = 1.1d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02543afd7f25a9983c3b03ede8faed477e1212f4"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMTY3MDY2", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473167066", "createdAt": "2020-08-24T07:02:53Z", "commit": {"oid": "02543afd7f25a9983c3b03ede8faed477e1212f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNzowMjo1M1rOHFXAOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNzowMjo1M1rOHFXAOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM4MTgxOA==", "bodyText": "Doesn't look safe to remove it for any numeric-to-numeric conversion: cast(bigintColumn as tinyint) < 1 should produce an error for values outside of tinyint range.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475381818", "createdAt": "2020-08-24T07:02:53Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -0,0 +1,1117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.query.impl.ComparableIdentifiedDataSerializable;\n+import com.hazelcast.query.impl.TypeConverters;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.logical.MapScanLogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapIndexScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastRelOptTable;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexEqualsFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilterValue;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexInFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexRangeFilter;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeFieldTypeProvider;\n+import com.hazelcast.sql.impl.schema.map.MapTableIndex;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.hazelcast.query.impl.CompositeValue.NEGATIVE_INFINITY;\n+import static com.hazelcast.query.impl.CompositeValue.POSITIVE_INFINITY;\n+import static java.util.Collections.singletonList;\n+import static org.apache.calcite.sql.type.SqlTypeFamily.NUMERIC;\n+\n+/**\n+ * Helper class to resolve indexes.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public final class IndexResolver {\n+    private IndexResolver() {\n+        // No-op.\n+    }\n+\n+    public static List<RelNode> createIndexScans(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        List<MapTableIndex> indexes\n+    ) {\n+        // Early return if there is no filter.\n+        RexNode filter = scan.getTableUnwrapped().getFilter();\n+\n+        if (filter == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Filter out unsupported indexes.\n+        List<MapTableIndex> supportedIndexes = new ArrayList<>(indexes.size());\n+        Set<Integer> allIndexedFieldOrdinals = new HashSet<>();\n+\n+        for (MapTableIndex index : indexes) {\n+            if (isIndexSupported(index)) {\n+                supportedIndexes.add(index);\n+\n+                allIndexedFieldOrdinals.addAll(index.getFieldOrdinals());\n+            }\n+        }\n+\n+        // Early return if there are no indexes to consider.\n+        if (supportedIndexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Convert expression into CNF\n+        List<RexNode> conjunctions = createConjunctiveFilter(filter);\n+\n+        // Prepare candidates from conjunctive expressions.\n+        Map<Integer, List<IndexComponentCandidate>> candidates = prepareSingleColumnCandidates(\n+            conjunctions,\n+            OptUtils.getCluster(scan).getParameterMetadata(),\n+            allIndexedFieldOrdinals\n+        );\n+\n+        if (candidates.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Create index relational operators based on candidates.\n+        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n+\n+        for (MapTableIndex index : supportedIndexes) {\n+            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+\n+            if (rel != null) {\n+                rels.add(rel);\n+            }\n+        }\n+\n+        return rels;\n+    }\n+\n+    /**\n+     * Creates an object for convenient access to part of the predicate in the CNF.\n+     */\n+    private static List<RexNode> createConjunctiveFilter(RexNode filter) {\n+        List<RexNode> conjunctions = new ArrayList<>(1);\n+\n+        RelOptUtil.decomposeConjunction(filter, conjunctions);\n+\n+        return conjunctions;\n+    }\n+\n+    /**\n+     * Creates a map from the scan column ordinal to expressions that could be potentially used by indexes created over\n+     * this column.\n+     *\n+     * @param nodes                   CNF nodes\n+     * @param allIndexedFieldOrdinals Ordinals of all columns that have some indexes. Helps to filter out candidates that\n+     *                                definitely cannot be used earlier.\n+     */\n+    private static Map<Integer, List<IndexComponentCandidate>> prepareSingleColumnCandidates(\n+        List<RexNode> nodes,\n+        QueryParameterMetadata parameterMetadata,\n+        Set<Integer> allIndexedFieldOrdinals\n+    ) {\n+        Map<Integer, List<IndexComponentCandidate>> res = new HashMap<>();\n+\n+        for (RexNode node : nodes) {\n+            IndexComponentCandidate candidate = prepareSingleColumnCandidate(node, parameterMetadata);\n+\n+            if (candidate == null) {\n+                // Expression cannot be used for indexes\n+                continue;\n+            }\n+\n+            if (!allIndexedFieldOrdinals.contains(candidate.getColumnIndex())) {\n+                // Expression could be used for indexes, but there are no matching indexes\n+                continue;\n+            }\n+\n+            res.computeIfAbsent(candidate.getColumnIndex(), (k) -> new ArrayList<>()).add(candidate);\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * Prepares an expression candidate for the given RexNode.\n+     * <p>\n+     * We consider two types of expressions: comparison predicates and OR condition. We try to interpret OR as IN, otherwise\n+     * it is ignored.\n+     *\n+     * @param exp calcite expression\n+     * @return candidate or {@code null} if the expression cannot be used with indexes\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    private static IndexComponentCandidate prepareSingleColumnCandidate(\n+        RexNode exp,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        SqlKind kind = exp.getKind();\n+\n+        switch (kind) {\n+            case INPUT_REF:\n+                // Special case for boolean columns: SELECT * FROM t WHERE f_boolean\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(exp, exp, SqlKind.IS_TRUE);\n+\n+            case IS_TRUE:\n+            case IS_FALSE:\n+            case IS_NOT_TRUE:\n+            case IS_NOT_FALSE:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    kind\n+                );\n+\n+            case NOT:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    SqlKind.IS_FALSE\n+                );\n+\n+            case IS_NULL:\n+                return prepareSingleColumnCandidateIsNull(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), true)\n+                );\n+\n+            case GREATER_THAN:\n+            case GREATER_THAN_OR_EQUAL:\n+            case LESS_THAN:\n+            case LESS_THAN_OR_EQUAL:\n+            case EQUALS:\n+                BiTuple<RexNode, RexNode> operands = extractComparisonOperands(exp);\n+\n+                return prepareSingleColumnCandidateComparison(\n+                    exp,\n+                    kind,\n+                    operands.element1(),\n+                    operands.element2(),\n+                    parameterMetadata\n+                );\n+\n+            case OR:\n+                return prepareSingleColumnCandidateOr(\n+                    exp,\n+                    ((RexCall) exp).getOperands(),\n+                    parameterMetadata\n+                );\n+\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    /**\n+     * Prepare a candidate for {@code IS (NOT) TRUE/FALSE} expression.\n+     * <p>\n+     * The fundamental observation is that boolean column may have only three values - TRUE/FALSE/NULL. Therefore, every\n+     * such expression could be converted to equivalent equals or IN predicate.\n+     *\n+     * @param exp expression\n+     * @param operand operand with CAST unwrapped\n+     * @param kind expression type\n+     * @return candidate or {@code null}\n+     */\n+    private static IndexComponentCandidate prepareSingleColumnCandidateBooleanIsTrueFalse(\n+        RexNode exp,\n+        RexNode operand,\n+        SqlKind kind\n+    ) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        if (operand.getType().getSqlTypeName() != SqlTypeName.BOOLEAN) {\n+            // Only boolean columns could be used with this optimization\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case IS_TRUE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_FALSE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_NOT_TRUE:\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.IS_NOT_FALSE;\n+\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+        }\n+\n+        return new IndexComponentCandidate(exp, columnIndex, filter);\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateIsNull(RexNode exp, RexNode operand) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        QueryDataType type = SqlToQueryType.map(operand.getType().getSqlTypeName());\n+\n+        IndexFilterValue filterValue = new IndexFilterValue(\n+            singletonList(ConstantExpression.create(null, type)),\n+            singletonList(true)\n+        );\n+\n+        IndexFilter filter = new IndexEqualsFilter(filterValue);\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateComparison(\n+        RexNode exp,\n+        SqlKind kind,\n+        RexNode operand1,\n+        RexNode operand2,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        // Normalize operand positions, so that the column is always goes first\n+        if (operand1.getKind() != SqlKind.INPUT_REF && operand2.getKind() == SqlKind.INPUT_REF) {\n+            kind = inverseIndexConditionKind(kind);\n+\n+            RexNode tmp = operand1;\n+            operand1 = operand2;\n+            operand2 = tmp;\n+        }\n+\n+        // Exit if the first operand is not a column\n+        if (operand1.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand1).getIndex();\n+\n+        if (!IndexRexVisitor.isValid(operand2)) {\n+            // The second operand cannot be used for index filter\n+            return null;\n+        }\n+\n+        Expression<?> filterValue = convertToExpression(operand2, parameterMetadata);\n+\n+        if (filterValue == null) {\n+            // Operand cannot be converted to expression. Do not throw an exception here, just do not use the faulty condition\n+            // for index. The proper exception will be thrown on later stages when attempting to convert Calcite rel tree to\n+            // Hazelcast plan.\n+            return null;\n+        }\n+\n+        IndexFilterValue filterValue0 = new IndexFilterValue(\n+            singletonList(filterValue),\n+            singletonList(false)\n+        );\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case EQUALS:\n+                filter = new IndexEqualsFilter(filterValue0);\n+\n+                break;\n+\n+            case GREATER_THAN:\n+                filter = new IndexRangeFilter(filterValue0, false, null, false);\n+\n+                break;\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                filter = new IndexRangeFilter(filterValue0, true, null, false);\n+\n+                break;\n+\n+            case LESS_THAN:\n+                filter = new IndexRangeFilter(null, false, filterValue0, false);\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.LESS_THAN_OR_EQUAL;\n+\n+                filter = new IndexRangeFilter(null, false, filterValue0, true);\n+        }\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static Expression<?> convertToExpression(RexNode operand, QueryParameterMetadata parameterMetadata) {\n+        try {\n+            RexToExpressionVisitor visitor = new RexToExpressionVisitor(FieldTypeProvider.INSTANCE, parameterMetadata);\n+\n+            return operand.accept(visitor);\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateOr(\n+        RexNode exp,\n+        List<RexNode> nodes,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        Integer columnIndex = null;\n+\n+        List<IndexFilter> filters = new ArrayList<>();\n+\n+        for (RexNode node : nodes) {\n+            IndexComponentCandidate candidate = prepareSingleColumnCandidate(node, parameterMetadata);\n+\n+            if (candidate == null) {\n+                // Cannot resolve further, stop\n+                return null;\n+            }\n+\n+            // Work only with \"=\" expressions.\n+            IndexFilter candidateFilter = candidate.getFilter();\n+\n+            if (!(candidateFilter instanceof IndexEqualsFilter || candidateFilter instanceof IndexInFilter)) {\n+                // Support only equality for ORs\n+                return null;\n+            }\n+\n+            // Make sure that all '=' expressions relate to a single column\n+            if (columnIndex == null) {\n+                columnIndex = candidate.getColumnIndex();\n+            } else if (columnIndex != candidate.getColumnIndex()) {\n+                return null;\n+            }\n+\n+            // Flatten\n+            if (candidateFilter instanceof IndexEqualsFilter) {\n+                filters.add(candidateFilter);\n+            } else {\n+                filters.addAll(((IndexInFilter) candidateFilter).getFilters());\n+            }\n+        }\n+\n+        assert columnIndex != null;\n+\n+        IndexInFilter inFilter = new IndexInFilter(filters);\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            inFilter\n+        );\n+    }\n+\n+    /**\n+     * Create index scan for the given index if possible.\n+     *\n+     * @return Index scan or {@code null}.\n+     */\n+    public static RelNode createIndexScan(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        MapTableIndex index,\n+        List<RexNode> conjunctions,\n+        Map<Integer, List<IndexComponentCandidate>> candidates\n+    ) {\n+        List<IndexComponentFilter> filters = new ArrayList<>(index.getFieldOrdinals().size());\n+\n+        for (int i = 0; i < index.getFieldOrdinals().size(); i++) {\n+            int fieldOrdinal = index.getFieldOrdinals().get(i);\n+            QueryDataType fieldConverterType = index.getFieldConverterTypes().get(i);\n+\n+            List<IndexComponentCandidate> fieldCandidates = candidates.get(fieldOrdinal);\n+\n+            if (fieldCandidates == null) {\n+                // No candidates available for the given column, stop.\n+                break;\n+            }\n+\n+            IndexComponentFilter filter = selectComponentFilter(\n+                index.getType(),\n+                fieldCandidates,\n+                fieldConverterType\n+            );\n+\n+            if (filter == null) {\n+                // Cannot create a filter for the given candidates, stop.\n+                break;\n+            }\n+\n+            filters.add(filter);\n+\n+            if (!(filter.getFilter() instanceof IndexEqualsFilter)) {\n+                // For composite indexes, non-equals condition must always be the last part of the request.\n+                // If we found non-equals, then we must stop.\n+                break;\n+            }\n+        }\n+\n+        if (filters.isEmpty()) {\n+            // Failed to build any filters. The index cannot be used.\n+            return null;\n+        }\n+\n+        // Now as filters are determined, construct the physical entity.\n+        return createIndexScan(scan, distribution, index, conjunctions, filters);\n+    }\n+\n+    private static MapIndexScanPhysicalRel createIndexScan(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        MapTableIndex index,\n+        List<RexNode> conjunctions,\n+        List<IndexComponentFilter> filterDescriptors\n+    ) {\n+        // Collect filters and relevant expressions\n+        List<IndexFilter> filters = new ArrayList<>(filterDescriptors.size());\n+        List<QueryDataType> converterTypes = new ArrayList<>(filterDescriptors.size());\n+        Set<RexNode> exps = new HashSet<>();\n+\n+        for (IndexComponentFilter filterDescriptor : filterDescriptors) {\n+            filters.add(filterDescriptor.getFilter());\n+            converterTypes.add(filterDescriptor.getConverterType());\n+            exps.addAll(filterDescriptor.getExpressions());\n+        }\n+\n+        // Construct Calcite expressions.\n+        RexBuilder rexBuilder = scan.getCluster().getRexBuilder();\n+\n+        RexNode exp = RexUtil.composeConjunction(rexBuilder, exps);\n+\n+        List<RexNode> remainderConjunctiveExps = excludeNodes(conjunctions, exps);\n+        RexNode remainderExp =\n+            remainderConjunctiveExps.isEmpty() ? null : RexUtil.composeConjunction(rexBuilder, remainderConjunctiveExps);\n+\n+        // Prepare traits\n+        RelTraitSet traitSet = OptUtils.toPhysicalConvention(scan.getTraitSet(), distribution);\n+\n+        // Create the index scan\n+        HazelcastRelOptTable originalRelTable = (HazelcastRelOptTable) scan.getTable();\n+        HazelcastTable originalHazelcastTable = OptUtils.getHazelcastTable(scan);\n+\n+        RelOptTable newRelTable = OptUtils.createRelTable(\n+            originalRelTable,\n+            originalHazelcastTable.withFilter(null),\n+            scan.getCluster().getTypeFactory()\n+        );\n+\n+        IndexFilter filter = composeFilter(filters, index.getType(), index.getComponentsCount());\n+\n+        if (filter == null) {\n+            return null;\n+        }\n+\n+        return new MapIndexScanPhysicalRel(\n+            scan.getCluster(),\n+            traitSet,\n+            newRelTable,\n+            index,\n+            filter,\n+            converterTypes,\n+            exp,\n+            remainderExp\n+        );\n+    }\n+\n+    public static RelNode createFullIndexScan(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        List<MapTableIndex> indexes\n+    ) {\n+        MapTableIndex firstIndex = null;\n+\n+        for (MapTableIndex index : indexes) {\n+            if (isIndexSupported(index)) {\n+                firstIndex = index;\n+\n+                break;\n+            }\n+        }\n+\n+        if (firstIndex == null) {\n+            return null;\n+        }\n+\n+        RexNode scanFilter = scan.getTableUnwrapped().getFilter();\n+\n+        RelTraitSet traitSet = OptUtils.toPhysicalConvention(scan.getTraitSet(), distribution);\n+\n+        HazelcastRelOptTable originalRelTable = (HazelcastRelOptTable) scan.getTable();\n+        HazelcastTable originalHazelcastTable = OptUtils.getHazelcastTable(scan);\n+\n+        RelOptTable newRelTable = OptUtils.createRelTable(\n+            originalRelTable,\n+            originalHazelcastTable.withFilter(null),\n+            scan.getCluster().getTypeFactory()\n+        );\n+\n+        return new MapIndexScanPhysicalRel(\n+            scan.getCluster(),\n+            traitSet,\n+            newRelTable,\n+            firstIndex,\n+            null,\n+            Collections.emptyList(),\n+            null,\n+            scanFilter\n+        );\n+    }\n+\n+    /**\n+     * This method selects the best expression to be used as index filter from the list of candidates.\n+     *\n+     * @param type type of the index (SORTED, HASH)\n+     * @param candidates candidates that might be used as a filter\n+     * @param converterType expected converter type for the given component of the index\n+     * @return filter for the index component or {@code null} if no candidate could be applied\n+     */\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    private static IndexComponentFilter selectComponentFilter(\n+        IndexType type,\n+        List<IndexComponentCandidate> candidates,\n+        QueryDataType converterType\n+    ) {\n+        // First look for equality conditions, assuming that it is the most restrictive\n+        for (IndexComponentCandidate candidate : candidates) {\n+            if (candidate.getFilter() instanceof IndexEqualsFilter) {\n+                return new IndexComponentFilter(\n+                    candidate.getFilter(),\n+                    singletonList(candidate.getExpression()),\n+                    converterType\n+                );\n+            }\n+        }\n+\n+        // Next look for IN, as it is worse than equality on a single value, but better than range\n+        for (IndexComponentCandidate candidate : candidates) {\n+            if (candidate.getFilter() instanceof IndexInFilter) {\n+                return new IndexComponentFilter(\n+                    candidate.getFilter(),\n+                    singletonList(candidate.getExpression()),\n+                    converterType\n+                );\n+            }\n+        }\n+\n+        // Last, look for ranges\n+        if (type == IndexType.SORTED) {\n+            IndexFilterValue from = null;\n+            boolean fromInclusive = false;\n+            IndexFilterValue to = null;\n+            boolean toInclusive = false;\n+            List<RexNode> expressions = new ArrayList<>(2);\n+\n+            for (IndexComponentCandidate candidate : candidates) {\n+                if (!(candidate.getFilter() instanceof IndexRangeFilter)) {\n+                    continue;\n+                }\n+\n+                IndexRangeFilter candidateFilter = (IndexRangeFilter) candidate.getFilter();\n+\n+                if (from == null && candidateFilter.getFrom() != null) {\n+                    from = candidateFilter.getFrom();\n+                    fromInclusive = candidateFilter.isFromInclusive();\n+                    expressions.add(candidate.getExpression());\n+                } else if (to == null && candidateFilter.getTo() != null) {\n+                    to = candidateFilter.getTo();\n+                    toInclusive = candidateFilter.isToInclusive();\n+                    expressions.add(candidate.getExpression());\n+                }\n+            }\n+\n+            if (from != null || to != null) {\n+                IndexRangeFilter filter = new IndexRangeFilter(from, fromInclusive, to, toInclusive);\n+\n+                return new IndexComponentFilter(filter, expressions, converterType);\n+            }\n+        }\n+\n+        // Cannot create an index request for the given candidates\n+        return null;\n+    }\n+\n+    /**\n+     * Composes the final filter from the list of single-column filters.\n+     *\n+     * @param filters single-column filters\n+     * @param indexType type of the index\n+     * @param indexComponentsCount number of components in the index\n+     * @return final filter or {@code null} if the filter could not be built for the given index type\n+     */\n+    private static IndexFilter composeFilter(List<IndexFilter> filters, IndexType indexType, int indexComponentsCount) {\n+\n+        if (filters.size() == 1 && indexComponentsCount == 1) {\n+            IndexFilter res = filters.get(0);\n+\n+            assert !(res instanceof IndexRangeFilter) || indexType == IndexType.SORTED;\n+\n+            return res;\n+        } else {\n+            IndexFilter lastFilter = filters.get(filters.size() - 1);\n+\n+            if (lastFilter instanceof IndexEqualsFilter) {\n+                return composeEqualsFilter(filters, (IndexEqualsFilter) lastFilter, indexType, indexComponentsCount);\n+            } else if (lastFilter instanceof IndexInFilter) {\n+                return composeInFilter(filters, (IndexInFilter) lastFilter, indexType, indexComponentsCount);\n+            } else {\n+                assert lastFilter instanceof IndexRangeFilter;\n+\n+                assert indexType == IndexType.SORTED;\n+\n+                return composeRangeFilter(filters, (IndexRangeFilter) lastFilter, indexComponentsCount);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Composes an equality filter from multiple single-column components.\n+     * <p>\n+     * If the number of single-column filters is equal to the number of index components, the resulting filter is a composite\n+     * equality filter.\n+     * <p>\n+     * If the number of single-column filters is less than the number of index components, the resulting filter is a range\n+     * filter, with missing components filled with negative/positive infinities for the left and right bounds respectively.\n+     * <p>\n+     * If the range filter is required, and the target index type is not {@link IndexType#SORTED}, the result is {@code null}.\n+     *\n+     * @return composite filter or {@code null}\n+     */\n+    private static IndexFilter composeEqualsFilter(\n+        List<IndexFilter> filters,\n+        IndexEqualsFilter lastFilter,\n+        IndexType indexType,\n+        int indexComponentsCount\n+    ) {\n+        // Flatten all known values.\n+        List<Expression> components = new ArrayList<>(filters.size());\n+        List<Boolean> allowNulls = new ArrayList<>(filters.size());\n+\n+        fillNonTerminalComponents(filters, components, allowNulls);\n+\n+        components.addAll(lastFilter.getValue().getComponents());\n+        allowNulls.addAll(lastFilter.getValue().getAllowNulls());\n+\n+        if (indexComponentsCount == components.size()) {\n+            // If there is a full match, then leave it as equals filter\n+            return new IndexEqualsFilter(new IndexFilterValue(components, allowNulls));\n+        } else {\n+            // Otherwise convert it to a range request\n+            if (indexType == IndexType.HASH) {\n+                return null;\n+            }\n+\n+            List<Expression> fromComponents = components;\n+            List<Expression> toComponents = new ArrayList<>(components);\n+\n+            List<Boolean> fromAllowNulls = allowNulls;\n+            List<Boolean> toAllowNulls = new ArrayList<>(fromAllowNulls);\n+\n+            addInfiniteRanges(fromComponents, fromAllowNulls, true, toComponents, toAllowNulls, true, indexComponentsCount);\n+\n+            return new IndexRangeFilter(\n+                new IndexFilterValue(fromComponents, fromAllowNulls),\n+                true,\n+                new IndexFilterValue(toComponents, toAllowNulls),\n+                true\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Create the final IN filter from the collection of per-column filters.\n+     * <p>\n+     * Consider the expression {@code {a=1 AND b IN (2,3)}}. After the conversion, the composite filter will be\n+     * {@code {a,b} IN {{1, 2}, {1, 3}}}.\n+     *\n+     * @param filters per-column filters\n+     * @param lastFilter the last IN filter\n+     * @param indexComponentsCount the number of index components\n+     * @return composite IN filter\n+     */\n+    private static IndexFilter composeInFilter(\n+        List<IndexFilter> filters,\n+        IndexInFilter lastFilter,\n+        IndexType indexType,\n+        int indexComponentsCount\n+    ) {\n+        List<IndexFilter> newFilters = new ArrayList<>(lastFilter.getFilters().size());\n+\n+        for (IndexFilter filter : lastFilter.getFilters()) {\n+            assert filter instanceof IndexEqualsFilter;\n+\n+            IndexFilter newFilter = composeEqualsFilter(filters, (IndexEqualsFilter) filter, indexType, indexComponentsCount);\n+\n+            if (newFilter == null) {\n+                // Cannot create a filter for one of the values of the IN clause. Stop.\n+                return null;\n+            }\n+\n+            newFilters.add(newFilter);\n+        }\n+\n+        return new IndexInFilter(newFilters);\n+    }\n+\n+    /**\n+     * Create the composite range filter from the given per-column filters.\n+     * <p>\n+     * If there number of per-column filters if less than the number of index components, then infinite ranges are added\n+     * to the missing components.\n+     * <p>\n+     * Consider that we have two per-column filter as input: {@code {a=1}, {b>2 AND b<3}}.\n+     * <p>\n+     * If the index is defined as {@code {a, b}}, then the resulting filter would be {@code {a=1, b>2 AND a=1, b<3}}.\n+     * <p>\n+     * If the index is defined as {@code {a, b, c}}, then the resulting filter would be\n+     * {@code {a=1, b>2, c>NEGATIVE_INFINITY AND a=1, b<3, c<POSITIVE_INFINITY}}.\n+     *\n+     * @param filters all per-column filters\n+     * @param lastFilter the last filter (range)\n+     * @param componentsCount number of components in the filter\n+     * @return range filter\n+     */\n+    private static IndexFilter composeRangeFilter(List<IndexFilter> filters, IndexRangeFilter lastFilter, int componentsCount) {\n+        // Flatten non-terminal components.\n+        List<Expression> components = new ArrayList<>(filters.size());\n+        List<Boolean> allowNulls = new ArrayList<>();\n+\n+        fillNonTerminalComponents(filters, components, allowNulls);\n+\n+        // Add value of the current filter.\n+        List<Expression> fromComponents = components;\n+        List<Expression> toComponents = new ArrayList<>(components);\n+\n+        List<Boolean> fromAllowNulls = allowNulls;\n+        List<Boolean> toAllowNulls = new ArrayList<>(fromAllowNulls);\n+\n+        if (lastFilter.getFrom() != null) {\n+            fromComponents.add(lastFilter.getFrom().getComponents().get(0));\n+            fromAllowNulls.add(false);\n+        } else {\n+            if (componentsCount == 1) {\n+                fromComponents.add(ConstantExpression.create(NEGATIVE_INFINITY, QueryDataType.OBJECT));\n+                fromAllowNulls.add(false);\n+            } else {\n+                // In composite indexes null values are not stored separately. Therefore, we need to filter them out.\n+                fromComponents.add(ConstantExpression.create(null, QueryDataType.OBJECT));\n+                fromAllowNulls.add(true);\n+            }\n+        }\n+\n+        if (lastFilter.getTo() != null) {\n+            toComponents.add(lastFilter.getTo().getComponents().get(0));\n+        } else {\n+            toComponents.add(ConstantExpression.create(POSITIVE_INFINITY, QueryDataType.OBJECT));\n+        }\n+\n+        toAllowNulls.add(false);\n+\n+        // Fill missing part of the range request.\n+        addInfiniteRanges(\n+            fromComponents,\n+            fromAllowNulls,\n+            lastFilter.isFromInclusive(),\n+            toComponents,\n+            toAllowNulls,\n+            lastFilter.isToInclusive(),\n+            componentsCount\n+        );\n+\n+        return new IndexRangeFilter(\n+            new IndexFilterValue(fromComponents, fromAllowNulls),\n+            lastFilter.isFromInclusive(),\n+            new IndexFilterValue(toComponents, toAllowNulls),\n+            lastFilter.isToInclusive()\n+        );\n+    }\n+\n+    /**\n+     * Given the list of column filters, flatten their expressions and allow-null flags.\n+     * <p>\n+     * The operation is performed for all filters except for the last one, because treatment of the last filter might differ\n+     * depending on the total number of components in the index.\n+     *\n+     * @param filters column filters\n+     * @param components expressions that would form the final filter\n+     * @param allowNulls allow-null collection relevant to components\n+     */\n+    private static void fillNonTerminalComponents(\n+        List<IndexFilter> filters,\n+        List<Expression> components,\n+        List<Boolean> allowNulls\n+    ) {\n+        for (int i = 0; i < filters.size() - 1; i++) {\n+            IndexEqualsFilter filter0 = (IndexEqualsFilter) filters.get(i);\n+\n+            IndexFilterValue value = filter0.getValue();\n+\n+            assert value.getComponents().size() == 1;\n+\n+            components.add(value.getComponents().get(0));\n+            allowNulls.add(value.getAllowNulls().get(0));\n+        }\n+\n+        assert components.size() == filters.size() - 1;\n+        assert allowNulls.size() == filters.size() - 1;\n+    }\n+\n+    /**\n+     * Adds infinite ranges to filter components, to match the number of index components.\n+     * <p>\n+     * For example, for the index on {@code (a, b)} and the expression {@code a=1}, the original filter would be\n+     * {@code from={a=1}, to={a=1}}.\n+     * <p>\n+     * Since the index has two components, we need to add infinite ranges to components that do not have explicit filters.\n+     * After the method finishes, the filter would be {@code from={a=1, b=NEGATIVE_INFINITY}, to={a=1, b=POSITIVE_INFINITY}}.\n+     * <p>\n+     * The combination of ranges also depends on the inclusion. For example, {@code {a>1}} yields {@code NEGATIVE_INFINITY}\n+     * for {@code b} on the left side, while {@code {a>=1}} yields {@code POSITIVE_INFINITY}.\n+     *\n+     * @param fromComponents expressions for the \"from\" part\n+     * @param toComponents expressions for the \"to\" part\n+     * @param componentsCount the number of components in the index\n+     */\n+    private static void addInfiniteRanges(\n+        List<Expression> fromComponents,\n+        List<Boolean> fromAllowNulls,\n+        boolean fromInclusive,\n+        List<Expression> toComponents,\n+        List<Boolean> toAllowNulls,\n+        boolean toInclusive,\n+        int componentsCount\n+    ) {\n+        int count = componentsCount - fromComponents.size();\n+\n+        ComparableIdentifiedDataSerializable leftBound = fromInclusive ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n+        ComparableIdentifiedDataSerializable toBound = toInclusive ? POSITIVE_INFINITY : NEGATIVE_INFINITY;\n+\n+        for (int i = 0; i < count; i++) {\n+            fromComponents.add(ConstantExpression.create(leftBound, QueryDataType.OBJECT));\n+            toComponents.add(ConstantExpression.create(toBound, QueryDataType.OBJECT));\n+\n+            fromAllowNulls.add(false);\n+            toAllowNulls.add(false);\n+        }\n+    }\n+\n+    /**\n+     * Convert the comparison operator to the opposite operator. E.g. {@code >} becomes {@code <}.\n+     * <p>\n+     * This method is invoked during expression normalization to simplify further processing. E.g. {@code ? < a} is converted\n+     * into {@code a > ?}\n+     *\n+     * @param kind original operator\n+     * @return the opposite operator\n+     */\n+    private static SqlKind inverseIndexConditionKind(SqlKind kind) {\n+        switch (kind) {\n+            case GREATER_THAN:\n+                return SqlKind.LESS_THAN;\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                return SqlKind.LESS_THAN_OR_EQUAL;\n+\n+            case LESS_THAN:\n+                return SqlKind.GREATER_THAN;\n+\n+            case LESS_THAN_OR_EQUAL:\n+                return SqlKind.GREATER_THAN_OR_EQUAL;\n+\n+            default:\n+                assert kind == SqlKind.EQUALS;\n+\n+                return kind;\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the index could be used by the engine.\n+     * <p>\n+     * At the moment only SORTED and HASH indexes could be used.\n+     *\n+     * @param index the index\n+     * @return {@code true} if the index could be used, {@code false} otherwise\n+     */\n+    private static boolean isIndexSupported(MapTableIndex index) {\n+        return index.getType() == IndexType.SORTED || index.getType() == IndexType.HASH;\n+    }\n+\n+    /**\n+     * Extracts comparison operands, removing CAST when possible.\n+     *\n+     * @param node original comparison node\n+     * @return a pair of operands\n+     */\n+    private static BiTuple<RexNode, RexNode> extractComparisonOperands(RexNode node) {\n+        assert node instanceof RexCall;\n+\n+        RexCall node0 = (RexCall) node;\n+\n+        assert node0.getOperands().size() == 2;\n+\n+        RexNode operand1 = node0.getOperands().get(0);\n+        RexNode operand2 = node0.getOperands().get(1);\n+\n+        RexNode normalizedOperand1 = removeCastIfPossible(operand1, false);\n+        RexNode normalizedOperand2 = removeCastIfPossible(operand2, false);\n+\n+        return BiTuple.of(normalizedOperand1, normalizedOperand2);\n+    }\n+\n+    /**\n+     * Removes CAST operator from the column expression when possible.\n+     * <p>\n+     * The following expression might be found: {@code CAST(a AS BIGINT) > ?}. This may happen either due to type coercion\n+     * during sql->rel conversion, or due to explicit user request. In the general case, a function applied to the column makes\n+     * usage of the index on that column impossible.\n+     * <p>\n+     * In case of the {@code CAST} operator we may try to remove the CAST, thus relying on internal index converters to\n+     * downcast the other side of the comparison expression. See {@link TypeConverters}.\n+     *\n+     * @param node original node, possibly CAST\n+     * @param force whether to remove CAST forcefully even for conversion that is otherwise invalid wrt the storage (used for\n+     *              {@code IS NULL} operator)\n+     * @return original node if there is nothing to unwrap, or the operand of the CAST\n+     */\n+    private static RexNode removeCastIfPossible(RexNode node, boolean force) {\n+        if (node.getKind() == SqlKind.CAST) {\n+            RexCall node0 = (RexCall) node;\n+\n+            RexNode from = node0.getOperands().get(0);\n+\n+            if (from instanceof RexInputRef) {\n+                RelDataType fromType = from.getType();\n+                RelDataType toType = node0.getType();\n+\n+                if (force) {\n+                    // Forced unwrap for IS NULL expression\n+                    return from;\n+                }\n+\n+                if (fromType.equals(toType)) {\n+                    // Redundant conversion => unwrap\n+                    return from;\n+                }\n+\n+                if (fromType.getSqlTypeName().getFamily() == NUMERIC && toType.getSqlTypeName().getFamily() == NUMERIC) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02543afd7f25a9983c3b03ede8faed477e1212f4"}, "originalPosition": 1077}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f93e6d9d4e87eb13cceeb3e5cc4775ca9c648e6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7f93e6d9d4e87eb13cceeb3e5cc4775ca9c648e6", "committedDate": "2020-08-24T07:05:43Z", "message": "WIP on JavaDoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5", "committedDate": "2020-08-24T07:25:11Z", "message": "WIP on JavaDocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf01d4544629c364427a26c94ff0d9e41974378c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bf01d4544629c364427a26c94ff0d9e41974378c", "committedDate": "2020-08-24T08:15:02Z", "message": "Disallowed invalid uncasts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48afb200412a4efc130f8ecf1017da089d8813d1", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/48afb200412a4efc130f8ecf1017da089d8813d1", "committedDate": "2020-08-24T09:09:17Z", "message": "WIP on JavaDoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMjc1Mzgy", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473275382", "createdAt": "2020-08-24T09:18:23Z", "commit": {"oid": "0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOToxODoyM1rOHFbbgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOToxODoyM1rOHFbbgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NDMzOQ==", "bodyText": "in and between are now enabled, but looks like there are no tests targeting them specifically", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475454339", "createdAt": "2020-08-24T09:18:23Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -96,9 +96,11 @@\n         SUPPORTED_KINDS.add(SqlKind.GREATER_THAN);\n         SUPPORTED_KINDS.add(SqlKind.GREATER_THAN_OR_EQUAL);\n         SUPPORTED_KINDS.add(SqlKind.LESS_THAN_OR_EQUAL);\n+        SUPPORTED_KINDS.add(SqlKind.IN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb88151a7bcfb5df3af452f82c980b2504429d45", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/eb88151a7bcfb5df3af452f82c980b2504429d45", "committedDate": "2020-08-24T09:19:35Z", "message": "Finished with JavaDoc for IndexResolver."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "518c0bd230deec7101fd4523b232858949d3f6c2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/518c0bd230deec7101fd4523b232858949d3f6c2", "committedDate": "2020-08-24T09:39:18Z", "message": "Disallow IN/BETWEEN"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae47ee95effb89be6a1ca976ceb8d45606f05359", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ae47ee95effb89be6a1ca976ceb8d45606f05359", "committedDate": "2020-08-24T09:43:13Z", "message": "JavaDoc for IndexFilterValue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7fa8c0deb9ae9e81c3b6999ad9282f4865de48d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b7fa8c0deb9ae9e81c3b6999ad9282f4865de48d", "committedDate": "2020-08-24T09:43:46Z", "message": "JavaDoc for IndexFilterValue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMzA2NjU5", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-472306659", "createdAt": "2020-08-21T08:35:26Z", "commit": {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODozNjoxMFrOHEizqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODo0Nzo0OFrOHEjcUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyNjYzNA==", "bodyText": "Minor typo: indexed?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474526634", "createdAt": "2020-08-21T08:36:10Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecIterator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.scan.KeyValueIterator;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.schema.map.MapTableUtils;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Iterator for index-based partitioned map access.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapIndexScanExecIterator implements KeyValueIterator {\n+\n+    private final Iterator<QueryableEntry> iterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapIndexScanExecIterator(\n+        MapContainer map,\n+        String indexName,\n+        int expectedComponentCount,\n+        IndexFilter indexFilter,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions,\n+        ExpressionEvalContext evalContext\n+    ) {\n+        iterator = getIndexEntries(\n+            map,\n+            indexName,\n+            indexFilter,\n+            evalContext,\n+            expectedComponentCount,\n+            expectedConverterTypes,\n+            expectedPartitions\n+        );\n+\n+        advance0();\n+    }\n+\n+    @Override\n+    public boolean tryAdvance() {\n+        if (!done()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean done() {\n+        return nextKey == null;\n+    }\n+\n+    @Override\n+    public Object getKey() {\n+        return currentKey;\n+    }\n+\n+    @Override\n+    public Object getValue() {\n+        return currentValue;\n+    }\n+\n+    private void advance0() {\n+        if (iterator.hasNext()) {\n+            QueryableEntry<?, ?> entry = iterator.next();\n+\n+            nextKey = entry.getKeyData();\n+            nextValue = entry.getValue();\n+        } else {\n+            nextKey = null;\n+            nextValue = null;\n+        }\n+    }\n+\n+    private Iterator<QueryableEntry> getIndexEntries(\n+        MapContainer map,\n+        String indexName,\n+        IndexFilter indexFilter,\n+        ExpressionEvalContext evalContext,\n+        int expectedComponentCount,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions\n+    ) {\n+        // Find the index\n+        InternalIndex index = map.getIndexes().getIndex(indexName);\n+\n+        if (index == null) {\n+            throw QueryException.error(\n+                SqlErrorCode.MAP_INDEX_NOT_EXISTS,\n+                \"Index \\\"\" + indexName + \"\\\" of the map \\\"\" + map.getName() + \"\\\" doesn't exist\"\n+            ).withInvalidate();\n+        }\n+\n+        // Make sure that required partitions are indexes\n+        validatePartitions(index, expectedPartitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNzA0MA==", "bodyText": "I'd also explicitly add an assert here that the index is global because for partitioned index the method is not thread-safe.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474537040", "createdAt": "2020-08-21T08:47:48Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecIterator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.scan.KeyValueIterator;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.schema.map.MapTableUtils;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Iterator for index-based partitioned map access.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapIndexScanExecIterator implements KeyValueIterator {\n+\n+    private final Iterator<QueryableEntry> iterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapIndexScanExecIterator(\n+        MapContainer map,\n+        String indexName,\n+        int expectedComponentCount,\n+        IndexFilter indexFilter,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions,\n+        ExpressionEvalContext evalContext\n+    ) {\n+        iterator = getIndexEntries(\n+            map,\n+            indexName,\n+            indexFilter,\n+            evalContext,\n+            expectedComponentCount,\n+            expectedConverterTypes,\n+            expectedPartitions\n+        );\n+\n+        advance0();\n+    }\n+\n+    @Override\n+    public boolean tryAdvance() {\n+        if (!done()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean done() {\n+        return nextKey == null;\n+    }\n+\n+    @Override\n+    public Object getKey() {\n+        return currentKey;\n+    }\n+\n+    @Override\n+    public Object getValue() {\n+        return currentValue;\n+    }\n+\n+    private void advance0() {\n+        if (iterator.hasNext()) {\n+            QueryableEntry<?, ?> entry = iterator.next();\n+\n+            nextKey = entry.getKeyData();\n+            nextValue = entry.getValue();\n+        } else {\n+            nextKey = null;\n+            nextValue = null;\n+        }\n+    }\n+\n+    private Iterator<QueryableEntry> getIndexEntries(\n+        MapContainer map,\n+        String indexName,\n+        IndexFilter indexFilter,\n+        ExpressionEvalContext evalContext,\n+        int expectedComponentCount,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions\n+    ) {\n+        // Find the index\n+        InternalIndex index = map.getIndexes().getIndex(indexName);\n+\n+        if (index == null) {\n+            throw QueryException.error(\n+                SqlErrorCode.MAP_INDEX_NOT_EXISTS,\n+                \"Index \\\"\" + indexName + \"\\\" of the map \\\"\" + map.getName() + \"\\\" doesn't exist\"\n+            ).withInvalidate();\n+        }\n+\n+        // Make sure that required partitions are indexes\n+        validatePartitions(index, expectedPartitions);\n+\n+        if (indexFilter == null) {\n+            // No filter => this is a full scan (e.g. for HD)\n+            return index.getSqlRecordIterator();\n+        }\n+\n+        int actualComponentCount = index.getComponents().length;\n+\n+        if (actualComponentCount != expectedComponentCount) {\n+            throw QueryException.error(\"Index \\\"\" + indexName + \"\\\" has \" + actualComponentCount + \" component(s), but \"\n+                + expectedComponentCount + \" expected\").withInvalidate();\n+        }\n+\n+        // Validate component types\n+        List<QueryDataType> currentConverterTypes = MapTableUtils.indexConverterToSqlTypes(index.getConverter());\n+\n+        validateConverterTypes(index, expectedConverterTypes, currentConverterTypes);\n+\n+        // Query the index\n+        return indexFilter.getEntries(index, evalContext);\n+    }\n+\n+    private void validatePartitions(InternalIndex index, PartitionIdSet expectedPartitions) {\n+        List<Integer> missingPartitions = null;\n+\n+        for (int partition : expectedPartitions) {\n+            if (!index.hasPartitionIndexed(partition)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMzEwMjEx", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473310211", "createdAt": "2020-08-24T09:59:00Z", "commit": {"oid": "b7fa8c0deb9ae9e81c3b6999ad9282f4865de48d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bee5cff53cce90be3f4bb7464dc29ba09c7dc50", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1bee5cff53cce90be3f4bb7464dc29ba09c7dc50", "committedDate": "2020-08-24T10:04:28Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f9160f747258cba08741fbb6ecc013a4f0042bc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8f9160f747258cba08741fbb6ecc013a4f0042bc", "committedDate": "2020-08-24T10:05:23Z", "message": "JavaDocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d0b55f90467f4325ab61b9ae308ae3c8601d822", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9d0b55f90467f4325ab61b9ae308ae3c8601d822", "committedDate": "2020-08-24T10:05:37Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f748cc85501f3f8803e6b77230c4ff572a21221", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4f748cc85501f3f8803e6b77230c4ff572a21221", "committedDate": "2020-08-24T10:12:20Z", "message": "Added assertion for AbstractIndex.NULL in the IndexRangeFilter - it should never appear there."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMzUxOTg1", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473351985", "createdAt": "2020-08-24T10:45:17Z", "commit": {"oid": "4f748cc85501f3f8803e6b77230c4ff572a21221"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDo0NToxN1rOHFfBZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDo0NToxN1rOHFfBZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMzE4OA==", "bodyText": "It might make sense to log such indexes to avoid situations when an index is not used for no apparent reason.", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475513188", "createdAt": "2020-08-24T10:45:17Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/MapTableUtils.java", "diffHunk": "@@ -54,4 +73,179 @@ public static long estimatePartitionedMapRowCount(NodeEngine nodeEngine, MapServ\n \n         return entryCount * memberCount;\n     }\n+\n+    public static List<MapTableIndex> getPartitionedMapIndexes(\n+        NodeEngine nodeEngine,\n+        MapContainer mapContainer,\n+        List<TableField> fields\n+    ) {\n+        // Do no return non-concurrent indexes for HD maps.\n+        boolean hd = mapContainer.getMapConfig().getInMemoryFormat() == InMemoryFormat.NATIVE;\n+        boolean globalIndexEnabled = nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED);\n+\n+        if (hd && !globalIndexEnabled) {\n+            return Collections.emptyList();\n+        }\n+\n+        Map<QueryPath, Integer> pathToOrdinalMap = mapPathsToOrdinals(fields);\n+\n+        List<Index> indexes = mapContainer.getIndexList();\n+\n+        if (indexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<MapTableIndex> res = new ArrayList<>(indexes.size());\n+\n+        for (Index index : indexes) {\n+            IndexConfig indexConfig = index.getConfig();\n+\n+            List<QueryDataType> resolvedFieldConverterTypes = indexConverterToSqlTypes(index.getConverter());\n+\n+            List<Integer> indexFieldOrdinals = new ArrayList<>(indexConfig.getAttributes().size());\n+            List<QueryDataType> indexFieldConverterTypes = new ArrayList<>(indexConfig.getAttributes().size());\n+\n+            for (int i = 0; i < indexConfig.getAttributes().size(); i++) {\n+                String attribute = indexConfig.getAttributes().get(i);\n+\n+                QueryPath attributePath = QueryPath.create(attribute);\n+\n+                Integer ordinal = pathToOrdinalMap.get(attributePath);\n+\n+                if (ordinal == null) {\n+                    // No mapping for the field. Stop.\n+                    break;\n+                }\n+\n+                if (i >= resolvedFieldConverterTypes.size()) {\n+                    // No more resolved converters. Stop.\n+                    break;\n+                }\n+\n+                QueryDataType fieldType = fields.get(ordinal).getType();\n+                QueryDataType converterType = resolvedFieldConverterTypes.get(i);\n+\n+                if (!isCompatibleForIndexRequest(fieldType, converterType)) {\n+                    // Field and converter types are not compatible (e.g. INT vs VARCHAR).\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f748cc85501f3f8803e6b77230c4ff572a21221"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMzY1MzQ5", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473365349", "createdAt": "2020-08-24T11:07:34Z", "commit": {"oid": "4f748cc85501f3f8803e6b77230c4ff572a21221"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTowNzozNFrOHFfqFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTowNzozNFrOHFfqFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMzYwNA==", "bodyText": "Is this method really needed? Looks like for purpose of this PR it's never invoked if global indexes are not enabled, so it's basically equivalent to the existing MapContainer#getIndexes().", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475523604", "createdAt": "2020-08-24T11:07:34Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -431,6 +435,20 @@ public ObjectNamespace getObjectNamespace() {\n         return definitions;\n     }\n \n+    public List<Index> getIndexList() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f748cc85501f3f8803e6b77230c4ff572a21221"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95aff18367809a853babae6d6fb2a3742b0efbc7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/95aff18367809a853babae6d6fb2a3742b0efbc7", "committedDate": "2020-08-24T11:15:36Z", "message": "Fix test failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMzczMTUz", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473373153", "createdAt": "2020-08-24T11:21:09Z", "commit": {"oid": "95aff18367809a853babae6d6fb2a3742b0efbc7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToyMTowOVrOHFgCow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToyMTowOVrOHFgCow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyOTg5MQ==", "bodyText": "As far as I understand these getSqlRecord* methods are mostly for completeness here and not really used, right?", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475529891", "createdAt": "2020-08-24T11:21:09Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/AttributeIndexRegistry.java", "diffHunk": "@@ -235,6 +237,50 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n             return delegate.evaluate(predicate);\n         }\n \n+        @Override\n+        public Iterator<QueryableEntry> getSqlRecordIterator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95aff18367809a853babae6d6fb2a3742b0efbc7"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3be39d0677a15d3a3b66db80ddbba8cf82d046a6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3be39d0677a15d3a3b66db80ddbba8cf82d046a6", "committedDate": "2020-08-24T11:26:49Z", "message": "Remove MapContainer.getIndexList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "379c8df220f149b04aea8de06145302283432888", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/379c8df220f149b04aea8de06145302283432888", "committedDate": "2020-08-24T11:31:02Z", "message": "Removed implementations of new methods from AttributeIndexRegistry."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNDUyMTg0", "url": "https://github.com/hazelcast/hazelcast/pull/17382#pullrequestreview-473452184", "createdAt": "2020-08-24T13:15:11Z", "commit": {"oid": "379c8df220f149b04aea8de06145302283432888"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "563ba83a73298b537bb57c46e4629996ae3ee036", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/563ba83a73298b537bb57c46e4629996ae3ee036", "committedDate": "2020-08-24T13:30:20Z", "message": "Assert that indexes are global for MapIndexScanExecIterator."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab579d25518edfc81a5ff3ba2ce57069ccc978d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/dab579d25518edfc81a5ff3ba2ce57069ccc978d", "committedDate": "2020-08-24T13:31:51Z", "message": "Merge branch 'master' into issues/17381"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3477af0260189e266d5323ae85fc6040cd26b6d0", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3477af0260189e266d5323ae85fc6040cd26b6d0", "committedDate": "2020-08-25T07:50:19Z", "message": "Merge branch 'master' into issues/17381\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/impl/calcite/opt/OptimizerTestSupport.java\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c23e61bbb8983d9dbf58030561c917a405f71d7d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c23e61bbb8983d9dbf58030561c917a405f71d7d", "committedDate": "2020-08-25T07:53:29Z", "message": "Fixes after merge with master"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3409, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}