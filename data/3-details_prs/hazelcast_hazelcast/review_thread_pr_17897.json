{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTE2NDg0", "number": 17897, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMTo0Nzo0OVrOE9me6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODoxMjo0MVrOE_v0Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDI5MDk4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMTo0Nzo0OVrOH6YEQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDoxNDo0MVrOH6dHYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3Mzc2MA==", "bodyText": "Do we really need hasNext local variable here? return true seems enough.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r530973760", "createdAt": "2020-11-26T11:47:49Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {\n+                    T temp = givenIterator.next();\n+                    if (filter.test(temp)) {\n+                        next = temp;\n+                        hasNext = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQ4Mw==", "bodyText": "no need, fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056483", "createdAt": "2020-11-26T14:14:41Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {\n+                    T temp = givenIterator.next();\n+                    if (filter.test(temp)) {\n+                        next = temp;\n+                        hasNext = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3Mzc2MA=="}, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDMwMzI2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMTo1MTowNFrOH6YLNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDoxNDozOVrOH6dHTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NTU0Mw==", "bodyText": "We should throw NoSuchElementException only if there is no next element not expecting that the user called hasNext() before that. I'd put it like\nif (!hasNext()) {\n    throw new NoSuchElementException()\n}", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r530975543", "createdAt": "2020-11-26T11:51:04Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {\n+                    T temp = givenIterator.next();\n+                    if (filter.test(temp)) {\n+                        next = temp;\n+                        hasNext = true;\n+                        break;\n+                    }\n+                }\n+                return hasNext;\n+            }\n+\n+            @Override\n+            public T next() {\n+                if (next == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQ2MA==", "bodyText": "fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056460", "createdAt": "2020-11-26T14:14:39Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {\n+                    T temp = givenIterator.next();\n+                    if (filter.test(temp)) {\n+                        next = temp;\n+                        hasNext = true;\n+                        break;\n+                    }\n+                }\n+                return hasNext;\n+            }\n+\n+            @Override\n+            public T next() {\n+                if (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NTU0Mw=="}, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDMwNzA3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMTo1MjoxNVrOH6YNwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDoxNDozOFrOH6dHOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NjE5Mw==", "bodyText": "If I call hasNext() multiple times it shouldn't advance the iterator, but it seems it does.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r530976193", "createdAt": "2020-11-26T11:52:15Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQ0MA==", "bodyText": "good catch, fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056440", "createdAt": "2020-11-26T14:14:38Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NjE5Mw=="}, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDU1NzIyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowMzoxM1rOH6aj-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDoxNDozNlrOH6dHKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNDY1MQ==", "bodyText": "Is this method called on the partition thread?", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531014651", "createdAt": "2020-11-26T13:03:13Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -158,7 +159,24 @@ public Indexes createIndexes(boolean global) {\n                 .indexProvider(mapServiceContext.getIndexProvider(mapConfig))\n                 .usesCachedQueryableEntries(mapConfig.getCacheDeserializedValues() != CacheDeserializedValues.NEVER)\n                 .partitionCount(partitionCount)\n-                .build();\n+                .resultFilter(queryableEntry -> hasNotExpired(queryableEntry)).build();\n+    }\n+\n+    /**\n+     * @return {@code true} if queryableEntry has\n+     * not expired, otherwise returns {@code false}\n+     */\n+    private boolean hasNotExpired(QueryableEntry queryableEntry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQyNQ==", "bodyText": "yes, when it is not global index or i can't find counter example at least. I have added check assertRunningOnPartitionThread when index is not global.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056425", "createdAt": "2020-11-26T14:14:36Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -158,7 +159,24 @@ public Indexes createIndexes(boolean global) {\n                 .indexProvider(mapServiceContext.getIndexProvider(mapConfig))\n                 .usesCachedQueryableEntries(mapConfig.getCacheDeserializedValues() != CacheDeserializedValues.NEVER)\n                 .partitionCount(partitionCount)\n-                .build();\n+                .resultFilter(queryableEntry -> hasNotExpired(queryableEntry)).build();\n+    }\n+\n+    /**\n+     * @return {@code true} if queryableEntry has\n+     * not expired, otherwise returns {@code false}\n+     */\n+    private boolean hasNotExpired(QueryableEntry queryableEntry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNDY1MQ=="}, "originalCommit": {"oid": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDg5OTk0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDozMjowMFrOH6dzBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NzoyMVrOH6g5yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg==", "bodyText": "Not sure that we need hasNextCallCount and nextCallCount. Why not using just next? If it is not null the hasNext() returns true immediately. The next() will first call hasNext() and if it exists, return it (assigning next to null). Something similar to the HDBplusTree#EntryIterator.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531067652", "createdAt": "2020-11-26T14:32:00Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,72 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+            private int hasNextCallCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "087f511ac69d46eb4a29141ad41ed10acf43033b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMjkyOQ==", "bodyText": "but in that case consecutive hasNext calls advance state, i don't want it to happen.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531102929", "createdAt": "2020-11-26T15:30:23Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,72 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+            private int hasNextCallCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg=="}, "originalCommit": {"oid": "087f511ac69d46eb4a29141ad41ed10acf43033b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwNTE0OQ==", "bodyText": "No, it'll check that next variable is not null and return quickly.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531105149", "createdAt": "2020-11-26T15:34:08Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,72 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+            private int hasNextCallCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg=="}, "originalCommit": {"oid": "087f511ac69d46eb4a29141ad41ed10acf43033b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODUzOA==", "bodyText": "Oops i see now, my test was wrong, also fixed it, thx.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531118538", "createdAt": "2020-11-26T15:57:21Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,72 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+            private int hasNextCallCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg=="}, "originalCommit": {"oid": "087f511ac69d46eb4a29141ad41ed10acf43033b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1Mjc5MTk4OnYy", "diffSide": "LEFT", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODoxMjo0MVrOH9n51A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0MzowMlrOH-mD3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA==", "bodyText": "I'm a bit lost here. Now we don't update the isIndexStoreExpirable field anywhere but we still use the return value from BaseIndexStore#isExpirable in three places. Can you elaborate on this change?", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r534378964", "createdAt": "2020-12-02T18:12:41Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "diffHunk": "@@ -145,13 +145,6 @@ private Comparable sanitizeScalar(Object input) {\n         }\n     }\n \n-    void markIndexStoreExpirableIfNecessary(QueryableEntry record) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363350d26f61d1186dad831d737aa2426b40dd83"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNzIxMg==", "bodyText": "leftover, removed that method and related stuff.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r534427212", "createdAt": "2020-12-02T19:30:13Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "diffHunk": "@@ -145,13 +145,6 @@ private Comparable sanitizeScalar(Object input) {\n         }\n     }\n \n-    void markIndexStoreExpirableIfNecessary(QueryableEntry record) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, "originalCommit": {"oid": "363350d26f61d1186dad831d737aa2426b40dd83"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1NzExMA==", "bodyText": "Still, can you elaborate a bit on how it's safe to remove all of that code? With the removal, the dependant code now acts as if isExpirable() == false, always.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r535057110", "createdAt": "2020-12-03T10:18:43Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "diffHunk": "@@ -145,13 +145,6 @@ private Comparable sanitizeScalar(Object input) {\n         }\n     }\n \n-    void markIndexStoreExpirableIfNecessary(QueryableEntry record) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, "originalCommit": {"oid": "363350d26f61d1186dad831d737aa2426b40dd83"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzg4MQ==", "bodyText": "All filtering for expiry is done in one place now. In Indexes#query method,resultFilter will check for expiry. See the related part in that method:\n   if (result != null && resultFilter != null) {\n            return IterableUtil.filter(result, resultFilter);\n        } else {\n            return result;\n        }\n\nIn MapContainer we add new filter:\npublic Indexes createIndexes(boolean global) {\n        int partitionCount = mapServiceContext.getNodeEngine().getPartitionService().getPartitionCount();\n\n        return Indexes.newBuilder(serializationService, mapServiceContext.getIndexCopyBehavior(), mapConfig.getInMemoryFormat())\n                .global(global)\n                .extractors(extractors)\n                .statsEnabled(mapConfig.isStatisticsEnabled())\n                .indexProvider(mapServiceContext.getIndexProvider(mapConfig))\n                .usesCachedQueryableEntries(mapConfig.getCacheDeserializedValues() != CacheDeserializedValues.NEVER)\n                .partitionCount(partitionCount)\n                .resultFilter(queryableEntry -> hasNotExpired(queryableEntry)).build();\n    }\n\nWith these changes, we are removing leaked map stuff to querying system, this will help to better isolate map and indexing.", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r535103881", "createdAt": "2020-12-03T11:01:37Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "diffHunk": "@@ -145,13 +145,6 @@ private Comparable sanitizeScalar(Object input) {\n         }\n     }\n \n-    void markIndexStoreExpirableIfNecessary(QueryableEntry record) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, "originalCommit": {"oid": "363350d26f61d1186dad831d737aa2426b40dd83"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5NzM0MQ==", "bodyText": "Thanks for the explanation!", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r535397341", "createdAt": "2020-12-03T16:43:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "diffHunk": "@@ -145,13 +145,6 @@ private Comparable sanitizeScalar(Object input) {\n         }\n     }\n \n-    void markIndexStoreExpirableIfNecessary(QueryableEntry record) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, "originalCommit": {"oid": "363350d26f61d1186dad831d737aa2426b40dd83"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 115, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}