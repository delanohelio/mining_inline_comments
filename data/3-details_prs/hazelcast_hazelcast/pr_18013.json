{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2MDUwMDQ3", "number": 18013, "title": "[IMDG-129] SQL: implementation of the ORDER BY clause", "bodyText": "Initial implementation of the SQL's ORDER BY clause. It supports\nthe ASC and DESC sortings, but there are some limitations.\nThe sorting is only supported only if there is a matching index that\nstores the key/value pairs already pre-sorted. Otherwise, an exception\nis thrown.\nThe nested sortings are supported, but again only if the supporting\ncomposite SORTED index is created.", "createdAt": "2020-12-28T11:12:59Z", "url": "https://github.com/hazelcast/hazelcast/pull/18013", "merged": true, "mergeCommit": {"oid": "0487981a6bab35e5b49435474bbe9cd3b118d79e"}, "closed": true, "closedAt": "2021-01-22T15:02:26Z", "author": {"login": "petrpleshachkov"}, "timelineItems": {"totalCount": 128, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdypbiVAH2gAyNTQ2MDUwMDQ3OjQ4NmM3ZWEyMTk3MDQ0MDc5NmI0YjI3N2UzYjk0ZWMzOWVmYmVkMjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdypgdwgBqjQyMzg2NTc0ODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "486c7ea21970440796b4b277e3b94ec39efbed23", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/486c7ea21970440796b4b277e3b94ec39efbed23", "committedDate": "2021-01-22T13:49:38Z", "message": "Implemented IdentifiedDataSerializable in ReceiveSortMergePlanNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "committedDate": "2021-01-22T13:49:38Z", "message": "Removed not used code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5099351140e5def76667f88aa80e69526404ac4b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/5099351140e5def76667f88aa80e69526404ac4b", "committedDate": "2021-01-22T13:49:38Z", "message": "Minor improvement: replaced List with array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e77bab6acf6932f8c4242462666e952bb7beb9f", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/7e77bab6acf6932f8c4242462666e952bb7beb9f", "committedDate": "2021-01-22T13:49:38Z", "message": "Fixed equals/hashCode methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9156f1430c44775973138f61025313350a41bb3", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/f9156f1430c44775973138f61025313350a41bb3", "committedDate": "2021-01-22T13:49:38Z", "message": "Simplified code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8c981fa1d72750010e38826a2b3b0330407475f", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/e8c981fa1d72750010e38826a2b3b0330407475f", "committedDate": "2021-01-22T13:49:38Z", "message": "Fixed index scan creation\n\n1. Generate full scans when a filter exists\n2. Exclude full scans covered by lookups with the same collation\n3. Unit testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde45cf36c81666db961d10651a1a0dc81b3bba0", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/cde45cf36c81666db961d10651a1a0dc81b3bba0", "committedDate": "2021-01-22T13:49:38Z", "message": "Simplified unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "committedDate": "2021-01-22T13:49:38Z", "message": "Removed a leftover"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78e65cf016255e59f4dbfe2c094c6d4198f59b89", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/78e65cf016255e59f4dbfe2c094c6d4198f59b89", "committedDate": "2021-01-22T13:49:38Z", "message": "Generalized fields collation\n\nUse List<Boolean> for fields collation instead of one boolean flag to\nprepare for [ASC, DESC] sortings in the future. The change is mostly\nneeded to keep the protocol unchanged in the future."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c8d3db3f49f67400f6a317d48fdbc1696d8401", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/64c8d3db3f49f67400f6a317d48fdbc1696d8401", "committedDate": "2021-01-22T13:49:38Z", "message": "Generalized a unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "committedDate": "2021-01-22T13:49:38Z", "message": "Use NoPartitioning partitioner for the sorting unicast send"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a62bd901143c8df6d78d004eef10e4aad0aa321b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/a62bd901143c8df6d78d004eef10e4aad0aa321b", "committedDate": "2021-01-22T13:49:38Z", "message": "Minor: make the field package-private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af00e7f418b414e154511aea1a7e05bd815eefea", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/af00e7f418b414e154511aea1a7e05bd815eefea", "committedDate": "2021-01-22T13:49:38Z", "message": "Assert SingleValuePartitioner is used"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "860c69cb99b3235cb53f3f36f47b411e601e7c2b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/860c69cb99b3235cb53f3f36f47b411e601e7c2b", "committedDate": "2021-01-22T13:49:38Z", "message": "NULL values handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c40ac7804296961cfcb0dc478698242d5d0b0b55", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/c40ac7804296961cfcb0dc478698242d5d0b0b55", "committedDate": "2021-01-22T13:49:38Z", "message": "Improved error message on not supported ORDER BY"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e01dfd54333b820ed48fd01a4b5767d17e940ef", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/4e01dfd54333b820ed48fd01a4b5767d17e940ef", "committedDate": "2021-01-22T13:49:38Z", "message": "More tests for the Exec components"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47cbf545dfa74f47b7f0d3e7914d073ac9e5d87b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/47cbf545dfa74f47b7f0d3e7914d073ac9e5d87b", "committedDate": "2021-01-22T13:49:38Z", "message": "Simplified code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a13bbf963766401020fa974cc68c8ed024c4c2b9", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/a13bbf963766401020fa974cc68c8ed024c4c2b9", "committedDate": "2021-01-22T13:49:38Z", "message": "Fixed typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "154514f77d99a5ec6a34d8be4bd96508a8d758d8", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/154514f77d99a5ec6a34d8be4bd96508a8d758d8", "committedDate": "2021-01-22T13:49:39Z", "message": "Fixed checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8807e668d4fa70a16702a04c3fa888c64a921632", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/8807e668d4fa70a16702a04c3fa888c64a921632", "committedDate": "2021-01-22T13:49:39Z", "message": "Remove unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6bddf682f05f5548007926e5256bc1ad311baaa", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/d6bddf682f05f5548007926e5256bc1ad311baaa", "committedDate": "2021-01-22T13:50:36Z", "message": "Renamed class to ZeroPartitioner and implemented IdentifiedDataSerializable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed52a50c75cb7462044d28fc7d8a32c94ad5736a", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/ed52a50c75cb7462044d28fc7d8a32c94ad5736a", "committedDate": "2021-01-22T13:50:36Z", "message": "Improved hashCode() calculation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c756faaeb719e02d612435d070932458c9bcebe3", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/c756faaeb719e02d612435d070932458c9bcebe3", "committedDate": "2021-01-22T13:50:36Z", "message": "Replicased List with int[]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d99e1140672b072630f81431f9fde8cf1cd2ee4", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/6d99e1140672b072630f81431f9fde8cf1cd2ee4", "committedDate": "2021-01-22T13:50:36Z", "message": "Simplified code a bit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f778cbea33ce14c86ac70c5be444ecb33000fb0a", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/f778cbea33ce14c86ac70c5be444ecb33000fb0a", "committedDate": "2021-01-22T13:50:36Z", "message": "Optimized code a bit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0f6249453e4ac55f5c59079ed014b8b31f80ced", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/e0f6249453e4ac55f5c59079ed014b8b31f80ced", "committedDate": "2021-01-22T13:50:36Z", "message": "Use singleton"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fc55b7c022c686d5128ee091dbf20d0e9c5a0ed", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/6fc55b7c022c686d5128ee091dbf20d0e9c5a0ed", "committedDate": "2021-01-22T13:50:36Z", "message": "Order NULL values before any other values in IndexInFilter and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e890835d91f1d04a2c6769e284743233a1a4a1c1", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/e890835d91f1d04a2c6769e284743233a1a4a1c1", "committedDate": "2021-01-22T13:50:36Z", "message": "Return back to the generic error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adf0d0524a0a8f993b3a0edc5345fb531a18a533", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/adf0d0524a0a8f993b3a0edc5345fb531a18a533", "committedDate": "2021-01-22T13:50:36Z", "message": "Cleanup unit tests on every run to avoid leftover indexes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c891b671af094f54d2a67296eaec5efa0c5cb0d2", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/c891b671af094f54d2a67296eaec5efa0c5cb0d2", "committedDate": "2021-01-22T13:50:36Z", "message": "Checkstyle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c33920249673a1a67456c8504ef2e095febdddb", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/1c33920249673a1a67456c8504ef2e095febdddb", "committedDate": "2021-01-22T13:50:36Z", "message": "Spotbugs fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06ffa2157ed2f6367e78777bc0291938c850349b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/06ffa2157ed2f6367e78777bc0291938c850349b", "committedDate": "2021-01-22T13:50:36Z", "message": "Fixed Calcite rules and a few tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f0a9d01797378c0394677bef981716abfe023fc", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/3f0a9d01797378c0394677bef981716abfe023fc", "committedDate": "2021-01-22T13:50:36Z", "message": "Fixed a test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92489a78f2f2fe2a10fec7cc4fd28af024d016c9", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/92489a78f2f2fe2a10fec7cc4fd28af024d016c9", "committedDate": "2021-01-22T13:53:39Z", "message": "Simplified code and revised getPhysicalRelsFromSubset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7ac2bad0ceea5286ae90749d3ecd56e46176ffc", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/f7ac2bad0ceea5286ae90749d3ecd56e46176ffc", "committedDate": "2021-01-22T13:53:39Z", "message": "Minor change for EE testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3899dabddb1f4890abeb15d43d1f8ff865920606", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/3899dabddb1f4890abeb15d43d1f8ff865920606", "committedDate": "2021-01-22T13:53:39Z", "message": "Added our own ExpandConversionRule to overcome Calcite's bug"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fbfa95261e032066e95016d51b2749228903074", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/1fbfa95261e032066e95016d51b2749228903074", "committedDate": "2021-01-22T11:30:04Z", "message": "Added our own ExpandConversionRule to overcome Calcite's bug"}, "afterCommit": {"oid": "3899dabddb1f4890abeb15d43d1f8ff865920606", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/3899dabddb1f4890abeb15d43d1f8ff865920606", "committedDate": "2021-01-22T13:53:39Z", "message": "Added our own ExpandConversionRule to overcome Calcite's bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDEzMTkz", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559413193", "createdAt": "2020-12-29T07:45:25Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo0NToyNVrOIMJHRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo0NToyNVrOIMJHRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzE0MQ==", "bodyText": "A single flag for the whole index means that we will not be able to support multi-direction scans in the future without breaking the backward compatibility. Perhaps it makes sense to use List<Boolean>, where every element is the direction of the scan of an individual component. Now they will be either all true, true, ... or false, false, ....\nBut in the future, we will be able to add the multidirectional scan by simply changing the relevant Exec class, and without breaking the protocol.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549603141", "createdAt": "2020-12-29T07:45:25Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/MapIndexScanPhysicalRel.java", "diffHunk": "@@ -45,6 +45,7 @@\n     private final List<QueryDataType> converterTypes;\n     private final RexNode indexExp;\n     private final RexNode remainderExp;\n+    private final boolean descending;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDEzODgy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559413882", "createdAt": "2020-12-29T07:47:50Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo0Nzo1MFrOIMJJ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo0Nzo1MFrOIMJJ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzgzMQ==", "bodyText": "Descending flag (or flags) should be added to explainTerms. Otherwise, Calcite will treat nodes with different flag values as equivalent nodes, and it is hard to predict the consequences of it. Also, the signature will be used for EXPLAIN in the future, and flag value would be useful there as well.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549603831", "createdAt": "2020-12-29T07:47:50Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/MapIndexScanPhysicalRel.java", "diffHunk": "@@ -103,9 +111,9 @@ public void visit(PhysicalRelVisitor visitor) {\n     @Override\n     public RelWriter explainTerms(RelWriter pw) {\n         return super.explainTerms(pw)\n-           .item(\"index\", index.getName())\n-           .item(\"indexExp\", indexExp)\n-           .item(\"remainderExp\", remainderExp);\n+            .item(\"index\", index.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDE0MzU4", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559414358", "createdAt": "2020-12-29T07:49:29Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo0OToyOVrOIMJLpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo0OToyOVrOIMJLpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNDI2Mg==", "bodyText": "Minor note: it seems that your IDEA adds indents automatically whenever the class is opened. It is better to disable this option because it makes PRs bigger and adds unnecessary entries to the file history.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549604262", "createdAt": "2020-12-29T07:49:29Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/MapScanPhysicalRule.java", "diffHunk": "@@ -40,8 +40,8 @@\n \n     private MapScanPhysicalRule() {\n         super(\n-            OptUtils.single(MapScanLogicalRel.class, HazelcastConventions.LOGICAL),\n-            MapScanPhysicalRule.class.getSimpleName()\n+                OptUtils.single(MapScanLogicalRel.class, HazelcastConventions.LOGICAL),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDE2MTcy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559416172", "createdAt": "2020-12-29T07:55:54Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo1NTo1NFrOIMJSJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo1NTo1NFrOIMJSJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNTkyNw==", "bodyText": "Perhaps we should add unit tests for the reverse direction in IndexEqualsFilterIterationTest, IndexInFilterIterationTest and IndexRangeFilterIterationTest. These are the isolated tests for iteration over entries for the given filter.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549605927", "createdAt": "2020-12-29T07:55:54Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/IndexEqualsFilterIterationTest.java", "diffHunk": "@@ -54,27 +54,27 @@ private void checkIteratorSimple(IndexType indexType) {\n         ExpressionEvalContext evalContext = SimpleExpressionEvalContext.create();\n \n         // Check missing value.\n-        checkIterator(new IndexEqualsFilter(intValue(1)).getEntries(index, evalContext));\n+        checkIterator(new IndexEqualsFilter(intValue(1)).getEntries(index, false, evalContext));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDE2NjAz", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559416603", "createdAt": "2020-12-29T07:57:16Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo1NzoxN1rOIMJTxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo1NzoxN1rOIMJTxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjM0Mg==", "bodyText": "Tests for \"descending=true\"?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549606342", "createdAt": "2020-12-29T07:57:17Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecTest.java", "diffHunk": "@@ -405,20 +405,21 @@ private void checkScan(\n         List<Integer> projects = Collections.singletonList(0);\n \n         MapIndexScanExec exec = new MapIndexScanExec(\n-            1,\n-            getMapContainer(map),\n-            partitions,\n-            GenericQueryTargetDescriptor.DEFAULT,\n-            GenericQueryTargetDescriptor.DEFAULT,\n-            fieldPaths,\n-            fieldTypes,\n-            projects,\n-            remainderFilter,\n-            getSerializationService(member),\n-            indexName,\n-            expectedComponentCount,\n-            indexFilter,\n-            converterTypes\n+                1,\n+                getMapContainer(map),\n+                partitions,\n+                GenericQueryTargetDescriptor.DEFAULT,\n+                GenericQueryTargetDescriptor.DEFAULT,\n+                fieldPaths,\n+                fieldTypes,\n+                projects,\n+                remainderFilter,\n+                getSerializationService(member),\n+                indexName,\n+                expectedComponentCount,\n+                indexFilter,\n+                converterTypes,\n+                false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 417}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDE3Mzc2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559417376", "createdAt": "2020-12-29T07:59:43Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo1OTo0M1rOIMJWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNzo1OTo0M1rOIMJWTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjk4OA==", "bodyText": "Why do we need AllFieldRowPartitioner for sorting that always sends data to a single member? Perhaps this class should not be part of the PR.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549606988", "createdAt": "2020-12-29T07:59:43Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/AllFieldsRowPartitioner.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Hash function which uses all row columns to calculate the hash.\n+ */\n+public class AllFieldsRowPartitioner extends AbstractFieldsRowPartitioner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDE4MjA3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559418207", "createdAt": "2020-12-29T08:02:37Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODowMjozN1rOIMJY2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODowMjozN1rOIMJY2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNzY0Mg==", "bodyText": "Same as AllFieldsRowPartitioner - this should not be needed for sorting that always send data to a single member AFAIU.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549607642", "createdAt": "2020-12-29T08:02:37Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/AbstractFieldsRowPartitioner.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.internal.util.HashUtil;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import static com.hazelcast.internal.serialization.impl.SerializationUtil.EMPTY_PARTITIONING_STRATEGY;\n+\n+/**\n+ * Partitioner that calculates row partition based on row field values.\n+ */\n+public abstract class AbstractFieldsRowPartitioner implements RowPartitioner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDE4NzU4", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559418758", "createdAt": "2020-12-29T08:04:24Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODowNDoyNFrOIMJatQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODowNDoyNFrOIMJatQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwODExNw==", "bodyText": "Do we support null values?\nAFAIK Calcite also supports NULL FIRST / NULLS LAST. Do we support it?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549608117", "createdAt": "2020-12-29T08:04:24Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKeyComparator.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * Comparator fot the sort key.\n+ */\n+@SuppressFBWarnings(value = \"SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\", justification = \"Never serialized\")\n+public class SortKeyComparator implements Comparator<SortKey> {\n+    /** List of ascending collations. */\n+    private final List<Boolean> ascs;\n+\n+    public SortKeyComparator(List<Boolean> ascs) {\n+        this.ascs = ascs;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public int compare(SortKey o1, SortKey o2) {\n+        for (int i = 0; i < ascs.size(); i++) {\n+            boolean asc = ascs.get(i);\n+\n+            Object item1 = o1.getKey().get(i);\n+            Object item2 = o2.getKey().get(i);\n+\n+            Comparable item1Comp = (Comparable) item1;\n+            Comparable item2Comp = (Comparable) item2;\n+\n+            int res = asc ? item1Comp.compareTo(item2Comp) : item2Comp.compareTo(item1Comp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDIzMzk0", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559423394", "createdAt": "2020-12-29T08:19:19Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoxOToxOVrOIMJrkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoxOToxOVrOIMJrkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMjQzNA==", "bodyText": "Why do we pass false here? Wouldn't it break the expected collation?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549612434", "createdAt": "2020-12-29T08:19:19Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexInFilter.java", "diffHunk": "@@ -168,7 +168,7 @@ private LazyIterator(InternalIndex index, ExpressionEvalContext evalContext, Col\n             while (filterIterator.hasNext()) {\n                 IndexFilter filter = filterIterator.next();\n \n-                Iterator<QueryableEntry> iterator = filter.getEntries(index, evalContext);\n+                Iterator<QueryableEntry> iterator = filter.getEntries(index, false, evalContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI0MjA1", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559424205", "createdAt": "2020-12-29T08:21:58Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMTo1OFrOIMJuHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMTo1OFrOIMJuHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzA4NQ==", "bodyText": "Perhaps the descending flag should be propagated to the index iterator, otherwise, we may lose the collation. Do we have tests that ensure that the values returned from different index lookups (equals, in, range) follow the expected collation?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549613085", "createdAt": "2020-12-29T08:21:58Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexEqualsFilter.java", "diffHunk": "@@ -49,7 +49,7 @@ public IndexFilterValue getValue() {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, boolean descending, ExpressionEvalContext evalContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI0Mzcy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559424372", "createdAt": "2020-12-29T08:22:28Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjoyOFrOIMJutA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjoyOFrOIMJutA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzIzNg==", "bodyText": "Do we need limit in this PR, provided that LIMIT/OFFSET is not supported yet?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549613236", "createdAt": "2020-12-29T08:22:28Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/MergeSort.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import com.hazelcast.sql.impl.row.Row;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+\n+/**\n+ * An utility class to perform merge sort with min-heap.\n+ */\n+public class MergeSort {\n+    /** Constant for unlimited number of rows. */\n+    public static final int UNLIMITED = 0;\n+\n+    /** Sources. */\n+    private final MergeSortSource[] sources;\n+\n+    /** Current items. */\n+    private final PriorityQueue<SortKey> heap;\n+\n+    /** Optional limit on the number of returned results. */\n+    private final int limit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI0NDg0", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559424484", "createdAt": "2020-12-29T08:22:48Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjo0OFrOIMJvCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjo0OFrOIMJvCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzMyMA==", "bodyText": "Minor: perhaps Object[] could be a slightly better choice here because there could be plenty of SortKey created leading to big memory consumption.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549613320", "createdAt": "2020-12-29T08:22:48Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKey.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import java.util.List;\n+\n+/**\n+ * Single sort key.\n+ */\n+public class SortKey {\n+    /** The key */\n+    private final List<Object> key;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI2MDk1", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559426095", "createdAt": "2020-12-29T08:27:43Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyNzo0M1rOIMJ1Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyNzo0M1rOIMJ1Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDg1NA==", "bodyText": "As mentioned in the other comment, it seems strange that the Iterator<QueryableEntry> getSqlRecordIterator(Comparable value) overload doesn't take descending as an argument. Or is it because EqualsFilter always has values for all index components, and it is guaranteed that returned entries will have the same values for all columns of the desired collation?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549614854", "createdAt": "2020-12-29T08:27:43Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexStore.java", "diffHunk": "@@ -127,9 +127,12 @@\n     Set<QueryableEntry> evaluate(Predicate predicate, TypeConverter converter);\n \n     /**\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.\n      * @return iterator over all index entries\n      */\n-    Iterator<QueryableEntry> getSqlRecordIterator();\n+    Iterator<QueryableEntry> getSqlRecordIterator(boolean descending);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI2NTg3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559426587", "createdAt": "2020-12-29T08:29:04Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyOTowNVrOIMJ2rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyOTowNVrOIMJ2rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTI3Ng==", "bodyText": "Perhaps we need tests for unsupported features (LIMIT/OFFSET, NULLS FIRST/LAST)", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549615276", "createdAt": "2020-12-29T08:29:05Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/calcite/parse/ParserOperationsTest.java", "diffHunk": "@@ -97,14 +106,6 @@ public void testUnsupportedWhereScalar() {\n         );\n     }\n \n-    @Test\n-    public void testUnsupportedOrderBy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI3MjA2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559427206", "createdAt": "2020-12-29T08:30:58Z", "commit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODozMDo1OFrOIMJ4hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODozMDo1OFrOIMJ4hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTc1MQ==", "bodyText": "Do we handle unsupported parts of the ORDER BY (LIMIT/OFFSET, NULLS FIRST/LAST)?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549615751", "createdAt": "2020-12-29T08:30:58Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -301,10 +305,6 @@ private void processCall(SqlCall call) {\n     }\n \n     private void processSelect(SqlSelect select) {\n-        if (select.hasOrderBy()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU1MDkz", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559555093", "createdAt": "2020-12-29T14:25:24Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyNToyNVrOIMQdQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyNToyNVrOIMQdQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMzQ1OQ==", "bodyText": "This change will not be needed if we remove AllFieldsRowPartitioner, which, in turn, should not be needed for this PR either.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549723459", "createdAt": "2020-12-29T14:25:25Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/SerializationUtil.java", "diffHunk": "@@ -54,7 +54,7 @@\n \n public final class SerializationUtil {\n \n-    static final PartitioningStrategy EMPTY_PARTITIONING_STRATEGY = new EmptyPartitioningStrategy();\n+    public static final PartitioningStrategy EMPTY_PARTITIONING_STRATEGY = new EmptyPartitioningStrategy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU2NTk3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559556597", "createdAt": "2020-12-29T14:28:57Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyODo1N1rOIMQiCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyODo1N1rOIMQiCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDY4Mg==", "bodyText": "Why do we use only index to check for equality? This violates the semantics of SortKeyComparator.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549724682", "createdAt": "2020-12-29T14:28:57Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKey.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+/**\n+ * Single sort key.\n+ */\n+public class SortKey {\n+    /** The key */\n+    private final Object[] key;\n+\n+    /** Index to make rows unique. */\n+    private final long index;\n+\n+    public SortKey(Object[] key, long index) {\n+        this.key = key;\n+        this.index = index;\n+    }\n+\n+    public Object[] getKey() {\n+        return key;\n+    }\n+\n+    public long getIndex() {\n+        return index;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Long.hashCode(index);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof SortKey) {\n+            SortKey other = (SortKey) obj;\n+\n+            return index == other.index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU2OTIy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559556922", "createdAt": "2020-12-29T14:29:46Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyOTo0NlrOIMQjGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDoyOTo0NlrOIMQjGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDk1Mw==", "bodyText": "boolean[] could be a better choice from the performance perspective since this is a pretty sensitive place.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549724953", "createdAt": "2020-12-29T14:29:46Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKeyComparator.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * Comparator fot the sort key.\n+ */\n+@SuppressFBWarnings(value = \"SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\", justification = \"Never serialized\")\n+public class SortKeyComparator implements Comparator<SortKey> {\n+    /** List of ascending collations. */\n+    private final List<Boolean> ascs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU3NzEw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559557710", "createdAt": "2020-12-29T14:31:45Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozMTo0NVrOIMQlkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozMTo0NVrOIMQlkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNTU4NQ==", "bodyText": "limit is not used.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549725585", "createdAt": "2020-12-29T14:31:45Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/MergeSort.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import com.hazelcast.sql.impl.row.Row;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+\n+/**\n+ * An utility class to perform merge sort with min-heap.\n+ */\n+public class MergeSort {\n+    /** Constant for unlimited number of rows. */\n+    public static final int UNLIMITED = 0;\n+\n+    /** Sources. */\n+    private final MergeSortSource[] sources;\n+\n+    /** Current items. */\n+    private final PriorityQueue<SortKey> heap;\n+\n+    /** Sources which are not in the heap yet. */\n+    private final Set<Integer> missingSourceIndexes = new HashSet<>();\n+\n+    /** Whether the sorting is finished. */\n+    private boolean done;\n+\n+    public MergeSort(MergeSortSource[] sources, SortKeyComparator comparator) {\n+        this(sources, comparator, UNLIMITED);\n+    }\n+\n+    @SuppressFBWarnings(value = \"EI_EXPOSE_REP2\", justification = \"This is an internal class\")\n+    public MergeSort(MergeSortSource[] sources, SortKeyComparator comparator, int limit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU4OTEx", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559558911", "createdAt": "2020-12-29T14:34:49Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozNDo0OVrOIMQpaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozNDo0OVrOIMQpaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjU3MQ==", "bodyText": "Class doesn't implement IdentifiedDataSerializable.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549726571", "createdAt": "2020-12-29T14:34:49Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/ReceiveSortMergePlanNode.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.plan.node.ZeroInputPlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Physical node which receives from remote stripes and performs sort-merge.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergePlanNode extends ZeroInputPlanNode implements EdgeAwarePlanNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU5MjAy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559559202", "createdAt": "2020-12-29T14:35:27Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozNToyN1rOIMQqUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozNToyN1rOIMQqUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjgwMg==", "bodyText": "Is it ok that fieldTypes are not used in equals/hashCode?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549726802", "createdAt": "2020-12-29T14:35:27Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/ReceiveSortMergePlanNode.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.plan.node.ZeroInputPlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Physical node which receives from remote stripes and performs sort-merge.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergePlanNode extends ZeroInputPlanNode implements EdgeAwarePlanNode {\n+    /** Edge iD. */\n+    private int edgeId;\n+\n+    /** Field types. */\n+    private List<QueryDataType> fieldTypes;\n+\n+    /** Expressions to be used for sorting. */\n+    private List<Expression> expressions;\n+\n+    /** Sort directions. */\n+    private List<Boolean> ascs;\n+\n+    public ReceiveSortMergePlanNode() {\n+        // No-op.\n+    }\n+\n+    public ReceiveSortMergePlanNode(\n+            int id,\n+            int edgeId,\n+            List<QueryDataType> fieldTypes,\n+            List<Expression> expressions,\n+            List<Boolean> ascs\n+    ) {\n+        super(id);\n+\n+        this.edgeId = edgeId;\n+        this.fieldTypes = fieldTypes;\n+        this.expressions = expressions;\n+        this.ascs = ascs;\n+    }\n+\n+    public List<Expression> getExpressions() {\n+        return expressions;\n+    }\n+\n+    public List<Boolean> getAscs() {\n+        return ascs;\n+    }\n+\n+    @Override\n+    public int getEdgeId() {\n+        return edgeId;\n+    }\n+\n+    @Override\n+    public boolean isSender() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void visit(PlanNodeVisitor visitor) {\n+        visitor.onReceiveSortMergeNode(this);\n+    }\n+\n+    @Override\n+    public PlanNodeSchema getSchema0() {\n+        return new PlanNodeSchema(fieldTypes);\n+    }\n+\n+    @Override\n+    public void writeData0(ObjectDataOutput out) throws IOException {\n+        out.writeInt(edgeId);\n+        SerializationUtil.writeList(fieldTypes, out);\n+        out.writeObject(expressions);\n+        out.writeObject(ascs);\n+    }\n+\n+    @Override\n+    public void readData0(ObjectDataInput in) throws IOException {\n+        edgeId = in.readInt();\n+        fieldTypes = SerializationUtil.readList(in);\n+        expressions = in.readObject();\n+        ascs = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id, edgeId, expressions, ascs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTU5Mzcw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559559370", "createdAt": "2020-12-29T14:35:48Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozNTo0OFrOIMQq6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozNTo0OFrOIMQq6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjk1NQ==", "bodyText": "Class doesn't implement IdentifiedDataSerializable.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549726955", "createdAt": "2020-12-29T14:35:48Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/UnicastSendPlanNode.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n+import com.hazelcast.sql.impl.partitioner.RowPartitioner;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Node which unicasts data to remote stripes.\n+ */\n+public class UnicastSendPlanNode extends UniInputPlanNode implements EdgeAwarePlanNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTYwNjky", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559560692", "createdAt": "2020-12-29T14:38:58Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozODo1OFrOIMQvfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDozODo1OFrOIMQvfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyODEyNg==", "bodyText": "The partitioner is not used, which indicates an incorrect implementation of the CreateExecPlanNodeVisitor.onUnicastSendNode.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549728126", "createdAt": "2020-12-29T14:38:58Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/UnicastSendPlanNode.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n+import com.hazelcast.sql.impl.partitioner.RowPartitioner;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Node which unicasts data to remote stripes.\n+ */\n+public class UnicastSendPlanNode extends UniInputPlanNode implements EdgeAwarePlanNode {\n+    /** Edge ID. */\n+    private int edgeId;\n+\n+    /** Partition hasher (get partition hash from row). */\n+    private RowPartitioner partitioner;\n+\n+    public UnicastSendPlanNode() {\n+        // No-op.\n+    }\n+\n+    public UnicastSendPlanNode(int id, PlanNode upstream, int edgeId, RowPartitioner partitioner) {\n+        super(id, upstream);\n+\n+        this.edgeId = edgeId;\n+        this.partitioner = partitioner;\n+    }\n+\n+    public RowPartitioner getPartitioner() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTYyMTI4", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559562128", "createdAt": "2020-12-29T14:42:21Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0MjoyMVrOIMQ0NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0MjoyMVrOIMQ0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTMzMg==", "bodyText": "Static code analysis indicates that while(true) actually never loops. We need isolated unit tests for all involved components (ReceiveSortMergeExec, MergeSort, MergeSortSource, SortKey, SortKeyComparator, StripedInbox). Otherwise, there is a high risk of bugs, since these classes are complex.\nExamples of isolated Exec tests could be found in the com.hazelcast.sql.impl.exec test package (e.g. FilterExecTest).", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549729332", "createdAt": "2020-12-29T14:42:21Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/ReceiveSortMergeExec.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.io;\n+\n+import com.hazelcast.sql.impl.exec.AbstractExec;\n+import com.hazelcast.sql.impl.exec.IterationResult;\n+import com.hazelcast.sql.impl.exec.sort.MergeSort;\n+import com.hazelcast.sql.impl.exec.sort.MergeSortSource;\n+import com.hazelcast.sql.impl.exec.sort.SortKey;\n+import com.hazelcast.sql.impl.exec.sort.SortKeyComparator;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.ListRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.List;\n+\n+/**\n+ * Executor which receives entries from multiple sources and merges them into a single sorted stream.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergeExec extends AbstractExec {\n+    /**\n+     * AbstractInbox to consume results from.\n+     */\n+    private final StripedInbox inbox;\n+\n+    /**\n+     * Expressions.\n+     */\n+    private final List<Expression> expressions;\n+\n+    /**\n+     * Sorter.\n+     */\n+    private final MergeSort sorter;\n+\n+    /**\n+     * Current batch.\n+     */\n+    private RowBatch curBatch;\n+\n+    public ReceiveSortMergeExec(\n+        int id,\n+        StripedInbox inbox,\n+        List<Expression> expressions,\n+        List<Boolean> ascs\n+    ) {\n+        super(id);\n+\n+        this.inbox = inbox;\n+        this.expressions = expressions;\n+\n+        MergeSortSource[] sources = new MergeSortSource[inbox.getStripeCount()];\n+\n+        for (int i = 0; i < inbox.getStripeCount(); i++) {\n+            sources[i] = new Source(i);\n+        }\n+\n+        sorter = new MergeSort(sources, new SortKeyComparator(ascs));\n+    }\n+\n+    @Override\n+    protected void setup0(QueryFragmentContext ctx) {\n+        inbox.setup();\n+    }\n+\n+    @Override\n+    public IterationResult advance0() {\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTYyNTc4", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559562578", "createdAt": "2020-12-29T14:43:31Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0MzozMVrOIMQ1kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0MzozMVrOIMQ1kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTY4MA==", "bodyText": "As mentioned before, the partitioner is simply ignored here. We need unit tests to ensure that the visitor produces the expected node. See CreateExecPlanNodeVisitorTest.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549729680", "createdAt": "2020-12-29T14:43:31Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -300,14 +362,24 @@ public void onMapIndexScanNode(MapIndexScanPlanNode node) {\n                     node.getIndexName(),\n                     node.getIndexComponentCount(),\n                     node.getIndexFilter(),\n-                    node.getConverterTypes()\n+                    node.getConverterTypes(),\n+                    node.getDescending()\n                 );\n             }\n         }\n \n         push(res);\n     }\n \n+    @Override\n+    public void onUnicastSendNode(UnicastSendPlanNode node) {\n+        Outbox[] outboxes = prepareOutboxes(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTYzMzY3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559563367", "createdAt": "2020-12-29T14:45:18Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0NToxOFrOIMQ4Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0NToxOFrOIMQ4Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMDM0Mg==", "bodyText": "This method is not used in the PR because CreateExecPlanNodeVisitor ignores the partitioner.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549730342", "createdAt": "2020-12-29T14:45:18Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/RowPartitioner.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+/**\n+ * Function which maps rows to partitions.\n+ */\n+public interface RowPartitioner extends DataSerializable {\n+    /**\n+     * Get partition for the row.\n+     *\n+     * @param row Row.\n+     * @param partitionCount Number of partitions.\n+     * @param serializationService Serialization service for partition calculation.\n+     * @return Partition, between 0 (inclusive) and .\n+     */\n+    int getPartition(Row row, int partitionCount, InternalSerializationService serializationService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTY0NjAw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559564600", "createdAt": "2020-12-29T14:48:03Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0ODowM1rOIMQ8dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0ODowM1rOIMQ8dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMTQ0NA==", "bodyText": "It would be nice to have isolated unit tests for this method to ensure the stability of the implementation.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549731444", "createdAt": "2020-12-29T14:48:03Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTrait.java", "diffHunk": "@@ -76,6 +76,32 @@ public boolean satisfies(RelTrait targetTrait) {\n         return this.equals(targetTrait);\n     }\n \n+    /**\n+     * Checks whtehr the result set of the node having this trait is guaranteed to exist on all members that will execute a\n+     * fragment with this node.\n+     *\n+     * @return {@code true} if the full result set exists on all participants of the fragment hosting this node.\n+     */\n+    public boolean isFullResultSetOnAllParticipants() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTY1MTQ0", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559565144", "createdAt": "2020-12-29T14:49:12Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0OToxMlrOIMQ-TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo0OToxMlrOIMQ-TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMTkxNw==", "bodyText": "We do not support offset/fetch, so it is better to disallow passing them for now.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549731917", "createdAt": "2020-12-29T14:49:12Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/SortLogicalRel.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rex.RexNode;\n+\n+/**\n+ * Logical sorting.\n+ */\n+public class SortLogicalRel extends Sort implements LogicalRel {\n+    public SortLogicalRel(\n+            RelOptCluster cluster,\n+            RelTraitSet traits,\n+            RelNode child,\n+            RelCollation collation,\n+            RexNode offset,\n+            RexNode fetch\n+    ) {\n+        super(cluster, traits, child, collation, offset, fetch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTY1NDk2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559565496", "createdAt": "2020-12-29T14:50:00Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo1MDowMFrOIMQ_ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo1MDowMFrOIMQ_ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMjIwMg==", "bodyText": "Since limit/offset are not supported, we'd better assert that they are null.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549732202", "createdAt": "2020-12-29T14:50:00Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/SortLogicalRule.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.HazelcastConventions;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.convert.ConverterRule;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.logical.LogicalSort;\n+\n+/**\n+ * Converts abstract sorting to logical sorting.\n+ */\n+public final class SortLogicalRule extends ConverterRule {\n+    public static final RelOptRule INSTANCE = new SortLogicalRule();\n+\n+    private SortLogicalRule() {\n+        super(\n+            LogicalSort.class,\n+            Convention.NONE,\n+            HazelcastConventions.LOGICAL,\n+            SortLogicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public RelNode convert(RelNode rel) {\n+        Sort sort = (Sort) rel;\n+        RelNode input = sort.getInput();\n+\n+        return new SortLogicalRel(\n+            sort.getCluster(),\n+            OptUtils.toLogicalConvention(sort.getTraitSet()),\n+            OptUtils.toLogicalInput(input),\n+            sort.getCollation(),\n+            sort.offset,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTY4OTky", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559568992", "createdAt": "2020-12-29T14:58:13Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo1ODoxNFrOIMRK-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNDo1ODoxNFrOIMRK-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNTE2Mg==", "bodyText": "The error message doesn't explain the problem properly:\n\nSorting could be located on top of any operator, and it could be impossible to add any index on it (imagine sorting on top of aggregation or join).\nIt is not clear what nested sorting means, is it a well-known term in the SQL world?\nIf the user needs to add an index, can we tell him which exact tables and columns are affected?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549735162", "createdAt": "2020-12-29T14:58:14Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "diffHunk": "@@ -253,6 +261,12 @@ public void onMapIndexScan(MapIndexScanPhysicalRel rel) {\n         mapNames.add(table.getMapName());\n     }\n \n+    @Override\n+    public void onSort(SortPhysicalRel rel) {\n+        throw QueryException.error(\"Cannot perform ORDER BY clause without matching index.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTcwMzkw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559570390", "createdAt": "2020-12-29T15:01:30Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTowMTozMVrOIMRPUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTowMTozMVrOIMRPUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNjI3NQ==", "bodyText": "It seems that the only expression that is ever passed to ReceiveSortMergePlanNode is ColumnExpression. Do we really need to serialize them? Perhaps just idx would be enough (i.e. List<Integer> instead of List<Expression>)", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549736275", "createdAt": "2020-12-29T15:01:31Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "diffHunk": "@@ -318,6 +332,49 @@ public void onFilter(FilterPhysicalRel rel) {\n         pushUpstream(filterNode);\n     }\n \n+    @Override\n+    public void onSortMergeExchange(SortMergeExchangePhysicalRel rel) {\n+        PlanNode upstreamNode = pollSingleUpstream();\n+        PlanNodeSchema upstreamNodeSchema = upstreamNode.getSchema();\n+\n+        // Create sender and push it as a fragment.\n+        int edge = nextEdge();\n+\n+        int id = pollId(rel);\n+\n+        UnicastSendPlanNode sendNode = new UnicastSendPlanNode(\n+            id,\n+            upstreamNode,\n+            edge,\n+            AllFieldsRowPartitioner.INSTANCE\n+        );\n+\n+        addFragment(sendNode, dataMemberMapping());\n+\n+        List<RelFieldCollation> collations = rel.getCollation().getFieldCollations();\n+        List<Expression> expressions = new ArrayList<>(collations.size());\n+        List<Boolean> ascs = new ArrayList<>(collations.size());\n+\n+        for (RelFieldCollation collation : collations) {\n+            RelFieldCollation.Direction direction = collation.getDirection();\n+            int idx = collation.getFieldIndex();\n+\n+            expressions.add(ColumnExpression.create(idx, upstreamNodeSchema.getType(idx)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTcxMzM0", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559571334", "createdAt": "2020-12-29T15:03:44Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTowMzo0NFrOIMRSYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTowMzo0NFrOIMRSYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNzA1OA==", "bodyText": "Since our current implementation always pass values to a single node (ROOT), we do not need AllFieldsRowPartitioner.INSTANCE, because there always be only one target member, and any partition will be assigned to that member. We may introduce a static partitioner, that assigns zero partition to every row.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549737058", "createdAt": "2020-12-29T15:03:44Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "diffHunk": "@@ -318,6 +332,49 @@ public void onFilter(FilterPhysicalRel rel) {\n         pushUpstream(filterNode);\n     }\n \n+    @Override\n+    public void onSortMergeExchange(SortMergeExchangePhysicalRel rel) {\n+        PlanNode upstreamNode = pollSingleUpstream();\n+        PlanNodeSchema upstreamNodeSchema = upstreamNode.getSchema();\n+\n+        // Create sender and push it as a fragment.\n+        int edge = nextEdge();\n+\n+        int id = pollId(rel);\n+\n+        UnicastSendPlanNode sendNode = new UnicastSendPlanNode(\n+            id,\n+            upstreamNode,\n+            edge,\n+            AllFieldsRowPartitioner.INSTANCE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTkwNDQz", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559590443", "createdAt": "2020-12-29T15:47:45Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTo0Nzo0NVrOIMSRCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTo0Nzo0NVrOIMSRCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1MzA5OA==", "bodyText": "I am not quite sure how we update the collation here. Consider we have a query SELECT a+b FROM table[a,b]. The plan will look like this:\nProjectRel[0:$0+$1]\n    ScanRel[0:a, 1:b]\n\nNow, if we execute the code below, we will get the following map:\n0 -> 0 // Column \"a\" mapped to \"a+b\"\n1 -> 0 // Column \"b\" mapped to \"a+b\"\n\nThen, if we had the original collation [a ASC], it would be converted to 0:ASC, which means a+b ASC, which is incorrect.\nAFAIU, instead it should work like this:\n\nCollect the list of top-level RexInputRef of the project\nRemap the input collation to these new refs accordingly\n\nAlso, we need extensive test coverage for trait propagation, because this is a complicated part of code, and if we have a single bug here, it may break many queries.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549753098", "createdAt": "2020-12-29T15:47:45Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/ProjectPhysicalRule.java", "diffHunk": "@@ -74,20 +83,77 @@ public void onMatch(RelOptRuleCall call) {\n      * @param convertedInput Input.\n      * @return Conversions (converted input + trait set).\n      */\n-    private static Collection<InputAndTraitSet> getTransforms(RelNode convertedInput) {\n+    private static Collection<InputAndTraitSet> getTransforms(List<RexNode> projects, RelNode convertedInput) {\n         List<InputAndTraitSet> res = new ArrayList<>(1);\n \n         Collection<RelNode> physicalInputs = OptUtils.getPhysicalRelsFromSubset(convertedInput);\n \n+        // Initialize a field index to the project index map\n+        Map<Integer, Integer> inputFieldIndex2ProjectIndexMap = new HashMap<>();\n+        for (int i = 0; i < projects.size(); ++i) {\n+            RexNode projectExp = projects.get(i);\n+            ProjectFieldVisitor projectFieldVisitor = new ProjectFieldVisitor(inputFieldIndex2ProjectIndexMap, i);\n+            projectExp.accept(projectFieldVisitor);\n+        }\n+\n         for (RelNode physicalInput : physicalInputs) {\n-            RelTraitSet finalTraitSet = createPhysicalTraitSet(physicalInput);\n+            RelTraitSet traitSet = createPhysicalTraitSet(physicalInput);\n+            RelCollation transformedCollation =\n+                convertCollation(inputFieldIndex2ProjectIndexMap, traitSet.getTrait(RelCollationTraitDef.INSTANCE));\n+            RelTraitSet finalTraitSet = OptUtils.traitPlus(traitSet, transformedCollation);\n \n             res.add(new InputAndTraitSet(physicalInput, finalTraitSet));\n         }\n \n         return res;\n     }\n \n+    /**\n+     * Transforms the collation remapping the collation fields in accordance with the\n+     * project fields.\n+     * @param inputFieldIndex2ProjectIndex a mapping from the input index field to the project index\n+     * @param collation an initial collation\n+     * @return the transformed collation\n+     */\n+    private static RelCollation convertCollation(Map<Integer, Integer> inputFieldIndex2ProjectIndex, RelCollation collation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTk1MTQx", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559595141", "createdAt": "2020-12-29T15:58:49Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTo1ODo1MFrOIMSgQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNTo1ODo1MFrOIMSgQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1Njk5NQ==", "bodyText": "Index resolution is a heavy operation. Instead of calling it twice, we may just create a copy of relAscending and change the collation.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549756995", "createdAt": "2020-12-29T15:58:50Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTk1OTc3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559595977", "createdAt": "2020-12-29T16:00:45Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjowMDo0NVrOIMSi1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjowMDo0NVrOIMSi1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1NzY1NQ==", "bodyText": "Even if there is a filter, we still should generate full scans for the non-involved indexes. Otherwise, some plans will not work. Do we have a test, where:\n\nThere is an index on column a\nCondition on the same column\nORDER BY on the other column?\n\nE.g. SELECT a, b FROM table(index(a)) WHERE a=1 ORDER BY b", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549757655", "createdAt": "2020-12-29T16:00:45Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -116,6 +118,28 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n+        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n+\n+        if (filter == null) {\n+            // There is no filter, still generate index scans for\n+            // possible ORDER BY clause on the upper level\n+            for (MapTableIndex index : supportedIndexes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTk4NTM5", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559598539", "createdAt": "2020-12-29T16:06:48Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjowNjo0OFrOIMSrTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjowNjo0OFrOIMSrTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1OTgyMg==", "bodyText": "What if there are two relations with the same collation? E.g. a user accidentally created two identical indexes.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549759822", "createdAt": "2020-12-29T16:06:48Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {\n+            // Compare the collations field by field\n+            int coll1Size = coll1.getFieldCollations().size();\n+            int coll2Size = coll2.getFieldCollations().size();\n+\n+            for (int i = 0; i < coll1Size; ++i) {\n+                if (i >= coll2Size) {\n+                    // The coll1 has more fields and the prefixes are equal\n+                    return 1;\n+                }\n+\n+                RelFieldCollation fieldColl1 = coll1.getFieldCollations().get(i);\n+                RelFieldCollation fieldColl2 = coll2.getFieldCollations().get(i);\n+                // First, compare directions\n+                int cmp = fieldColl1.getDirection().compareTo(fieldColl2.getDirection());\n+                if (cmp == 0) {\n+                    // Directions are the same\n+                    if (fieldColl1.getFieldIndex() == fieldColl2.getFieldIndex()) {\n+                        // And fieldIndex is the same, try the next field\n+                        continue;\n+                    } else {\n+                        return Integer.compare(fieldColl1.getFieldIndex(), fieldColl2.getFieldIndex());\n+                    }\n+                }\n+                return cmp;\n+            }\n+\n+            // All the fields from coll1 are equal to the fields from coll2, compare the size\n+            return Integer.compare(coll1Size, coll2Size);\n+        });\n+\n+        // Put the rels into the ordered TreeMap\n+        for (RelNode rel : rels) {\n+            relsTreeMap.put(rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE), rel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTk5NzY4", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559599768", "createdAt": "2020-12-29T16:09:44Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjowOTo0NFrOIMSvYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjowOTo0NFrOIMSvYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2MDg2NA==", "bodyText": "I would suggest moving the comparison logic into a separate class and tests it separatelyly. Otherwise, we cannot test it to a sufficient extent.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549760864", "createdAt": "2020-12-29T16:09:44Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjAzNDYy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559603462", "createdAt": "2020-12-29T16:18:30Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoxODozMVrOIMS7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoxODozMVrOIMS7pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDAwNw==", "bodyText": "Perhaps this method could be replaced with RelCollation.satisfies(RelCollation).", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549764007", "createdAt": "2020-12-29T16:18:31Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {\n+            // Compare the collations field by field\n+            int coll1Size = coll1.getFieldCollations().size();\n+            int coll2Size = coll2.getFieldCollations().size();\n+\n+            for (int i = 0; i < coll1Size; ++i) {\n+                if (i >= coll2Size) {\n+                    // The coll1 has more fields and the prefixes are equal\n+                    return 1;\n+                }\n+\n+                RelFieldCollation fieldColl1 = coll1.getFieldCollations().get(i);\n+                RelFieldCollation fieldColl2 = coll2.getFieldCollations().get(i);\n+                // First, compare directions\n+                int cmp = fieldColl1.getDirection().compareTo(fieldColl2.getDirection());\n+                if (cmp == 0) {\n+                    // Directions are the same\n+                    if (fieldColl1.getFieldIndex() == fieldColl2.getFieldIndex()) {\n+                        // And fieldIndex is the same, try the next field\n+                        continue;\n+                    } else {\n+                        return Integer.compare(fieldColl1.getFieldIndex(), fieldColl2.getFieldIndex());\n+                    }\n+                }\n+                return cmp;\n+            }\n+\n+            // All the fields from coll1 are equal to the fields from coll2, compare the size\n+            return Integer.compare(coll1Size, coll2Size);\n+        });\n+\n+        // Put the rels into the ordered TreeMap\n+        for (RelNode rel : rels) {\n+            relsTreeMap.put(rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE), rel);\n+        }\n+\n+        List<RelNode> resultRels = new ArrayList<>();\n+        Map.Entry<RelCollation, RelNode> prevEntry = null;\n+        // Go through the ordered collations and exclude covered ones\n+        for (Map.Entry<RelCollation, RelNode> entry : relsTreeMap.descendingMap().entrySet()) {\n+            RelCollation collation = entry.getKey();\n+            RelNode relNode = entry.getValue();\n+\n+            if (prevEntry == null) {\n+                resultRels.add(relNode);\n+                prevEntry = entry;\n+            } else {\n+                RelCollation prevCollation = prevEntry.getKey();\n+                if (!coveredCollation(prevCollation, collation)) {\n+                    prevEntry = entry;\n+                    resultRels.add(relNode);\n+                }\n+            }\n+        }\n+        return resultRels;\n+    }\n+\n+    /**\n+     * Tests whether collation1 covers (prefix based) collation2\n+     *\n+     * @param collation1 the collation\n+     * @param collation2 the collation\n+     * @return {@code true} if collation1 covers collation2, otherwise {@code false}\n+     */\n+    private static boolean coveredCollation(RelCollation collation1, RelCollation collation2) {\n+        if (collation1.getFieldCollations().size() < collation2.getFieldCollations().size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjA0NjYw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559604660", "createdAt": "2020-12-29T16:21:19Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyMToxOVrOIMS_Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyMToxOVrOIMS_Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDk2Nw==", "bodyText": "We cannot throw out covered collations if there is an index scan found. Consider that we resolved the following candidates:\n\n[a ASC, b ASC] -> index scan\n[an ASC] -> index lookup\nThe second relation is covered by the first one, but it has a filter, whilst the first one does the full scan. Therefore, we may loose a very good plan with a lookup.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549764967", "createdAt": "2020-12-29T16:21:19Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {\n+            // Compare the collations field by field\n+            int coll1Size = coll1.getFieldCollations().size();\n+            int coll2Size = coll2.getFieldCollations().size();\n+\n+            for (int i = 0; i < coll1Size; ++i) {\n+                if (i >= coll2Size) {\n+                    // The coll1 has more fields and the prefixes are equal\n+                    return 1;\n+                }\n+\n+                RelFieldCollation fieldColl1 = coll1.getFieldCollations().get(i);\n+                RelFieldCollation fieldColl2 = coll2.getFieldCollations().get(i);\n+                // First, compare directions\n+                int cmp = fieldColl1.getDirection().compareTo(fieldColl2.getDirection());\n+                if (cmp == 0) {\n+                    // Directions are the same\n+                    if (fieldColl1.getFieldIndex() == fieldColl2.getFieldIndex()) {\n+                        // And fieldIndex is the same, try the next field\n+                        continue;\n+                    } else {\n+                        return Integer.compare(fieldColl1.getFieldIndex(), fieldColl2.getFieldIndex());\n+                    }\n+                }\n+                return cmp;\n+            }\n+\n+            // All the fields from coll1 are equal to the fields from coll2, compare the size\n+            return Integer.compare(coll1Size, coll2Size);\n+        });\n+\n+        // Put the rels into the ordered TreeMap\n+        for (RelNode rel : rels) {\n+            relsTreeMap.put(rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE), rel);\n+        }\n+\n+        List<RelNode> resultRels = new ArrayList<>();\n+        Map.Entry<RelCollation, RelNode> prevEntry = null;\n+        // Go through the ordered collations and exclude covered ones\n+        for (Map.Entry<RelCollation, RelNode> entry : relsTreeMap.descendingMap().entrySet()) {\n+            RelCollation collation = entry.getKey();\n+            RelNode relNode = entry.getValue();\n+\n+            if (prevEntry == null) {\n+                resultRels.add(relNode);\n+                prevEntry = entry;\n+            } else {\n+                RelCollation prevCollation = prevEntry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjA2MDY2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559606066", "createdAt": "2020-12-29T16:24:55Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyNDo1NVrOIMTD8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyNDo1NVrOIMTD8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjEzMA==", "bodyText": "Looks like this method could be private.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549766130", "createdAt": "2020-12-29T16:24:55Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -691,41 +822,61 @@ private static MapIndexScanPhysicalRel createIndexScan(\n             filter,\n             converterTypes,\n             exp,\n-            remainderExp\n+            remainderExp,\n+            descending\n         );\n     }\n \n     /**\n-     * Create an index scan without any filter. Used by HD maps only.\n+     * Builds a collation with collation fields re-mapped according with the table projects\n      *\n-     * @param scan the original scan operator\n+     * @param scan       the logical map scan\n+     * @param index      the index\n+     * @param descending whether the collation is descending\n+     * @return the new collation trait\n+     */\n+    private static RelCollation buildCollationTrait(MapScanLogicalRel scan,\n+                                                    MapTableIndex index,\n+                                                    boolean descending) {\n+        List<RelFieldCollation> fields = new ArrayList<>(index.getFieldOrdinals().size());\n+        HazelcastTable table = scan.getTableUnwrapped();\n+        for (Integer indexFieldOrdinal : index.getFieldOrdinals()) {\n+            int remappedIndexFieldOrdinal = table.getProjects().indexOf(indexFieldOrdinal);\n+            if (remappedIndexFieldOrdinal == -1) {\n+                // The field is not used in the query\n+                break;\n+            }\n+            RelFieldCollation.Direction direction = descending ? RelFieldCollation.Direction.DESCENDING\n+                : RelFieldCollation.Direction.ASCENDING;\n+            RelFieldCollation fieldCollation = new RelFieldCollation(remappedIndexFieldOrdinal, direction);\n+            fields.add(fieldCollation);\n+        }\n+        return RelCollations.of(fields);\n+    }\n+\n+    /**\n+     * Creates an index scan without any filter.\n+     *\n+     * @param scan         the original scan operator\n      * @param distribution the original distribution\n-     * @param indexes available indexes\n+     * @param index        available indexes\n      * @return index scan or {@code null}\n      */\n     public static RelNode createFullIndexScan(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 380}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjA2Mjgx", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559606281", "createdAt": "2020-12-29T16:25:30Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyNTozMFrOIMTErA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyNTozMFrOIMTErA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjMxNg==", "bodyText": "Can we filter out the candidate index early if we realize that it has no collation?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549766316", "createdAt": "2020-12-29T16:25:30Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -665,6 +792,10 @@ private static MapIndexScanPhysicalRel createIndexScan(\n         // Prepare traits\n         RelTraitSet traitSet = OptUtils.toPhysicalConvention(scan.getTraitSet(), distribution);\n \n+        // Make a collation trait\n+        RelCollation relCollation = buildCollationTrait(scan, index, descending);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 326}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjA3NTc1", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559607575", "createdAt": "2020-12-29T16:28:35Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyODozNVrOIMTJIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoyODozNVrOIMTJIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NzQ1Nw==", "bodyText": "Looks like this is a leftover.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549767457", "createdAt": "2020-12-29T16:28:35Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/calcite/opt/physical/index/PhysicalIndexExpressionTest.java", "diffHunk": "@@ -189,4 +190,9 @@ private void checkNoIndexForCondition(String condition, String hdRemainderFilter\n             checkNoIndex(sql, INT, INT, INT, INT, INT);\n         }\n     }\n+\n+    @RunWith(HazelcastSerialClassRunner.class)\n+    @Category({QuickTest.class, ParallelJVMTest.class})\n+    public static class PhysicalSortIndexTest extends OptimizerTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjEwNTU2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559610556", "createdAt": "2020-12-29T16:36:16Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozNjoxNlrOIMTTGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozNjoxNlrOIMTTGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDAwOQ==", "bodyText": "We need more tests to handle typical cases here:\n\nTests when there is no merge phase\nTests when sorting is combined with index lookups\nNegative tests, e.g. for HASH indexes, missing indexes, lost collations", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549770009", "createdAt": "2020-12-29T16:36:16Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/calcite/opt/physical/index/PhysicalSortIndexTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapIndexScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.ProjectPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.RootPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.SortPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.exchange.SortMergeExchangePhysicalRel;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.schema.map.MapTableIndex;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.schema.Table;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class PhysicalSortIndexTest extends IndexOptimizerTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjExNjgz", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559611683", "createdAt": "2020-12-29T16:39:11Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozOToxMVrOIMTXBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozOToxMVrOIMTXBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTAxMw==", "bodyText": "I would recommend adding isolated unit tests for createIndexScans to ensure that all the logic works as expected. It is difficult to assess the correctness because currently, we have only integration tests that check the final plan, but not the alternatives generated in MEMO. It should be relatively simple to create [scan, distribution, indexes] by hand and check which alternatives are returned.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549771013", "createdAt": "2020-12-29T16:39:11Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -82,23 +89,18 @@ private IndexResolver() {\n      * Analyzes the filter of the input scan operator, and produces zero, one or more {@link MapIndexScanPhysicalRel}\n      * operators.\n      *\n-     * @param scan scan operator to be analyzed\n+     * @param scan         scan operator to be analyzed\n      * @param distribution distribution that will be passed to created index scan rels\n-     * @param indexes indexes available on the map being scanned\n+     * @param indexes      indexes available on the map being scanned\n      * @return zero, one or more index scan rels\n      */\n     public static List<RelNode> createIndexScans(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjEyMTky", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559612192", "createdAt": "2020-12-29T16:40:30Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0MDozMVrOIMTYoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0MDozMVrOIMTYoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTQyNQ==", "bodyText": "Do we really need to run the tests below with all the combinations of parameters?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549771425", "createdAt": "2020-12-29T16:40:31Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/SqlOrderByTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.IndexConfig;\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.test.HazelcastSerialParametersRunnerFactory;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojo;\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializationMode;\n+import static com.hazelcast.sql.SqlBasicTest.portableFieldName;\n+import static com.hazelcast.sql.SqlBasicTest.serializationConfig;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test that covers basic column read operations through SQL.\n+ */\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastSerialParametersRunnerFactory.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+@SuppressWarnings(\"checkstyle:RedundantModifier\")\n+public class SqlOrderByTest extends SqlTestSupport {\n+\n+    private static final String MAP_OBJECT = \"map_object\";\n+    private static final String MAP_BINARY = \"map_binary\";\n+\n+    private static final int[] PAGE_SIZES = {256};\n+    private static final int[] DATA_SET_SIZES = {4096};\n+    private static final SqlTestInstanceFactory FACTORY = SqlTestInstanceFactory.create();\n+\n+    private static TestHazelcastInstanceFactory factory;\n+    private static List<HazelcastInstance> members;\n+    private static HazelcastInstance member;\n+\n+    private static HazelcastInstance member1;\n+    private static HazelcastInstance member2;\n+\n+    @Parameter\n+    public int cursorBufferSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjEzNjIy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-559613622", "createdAt": "2020-12-29T16:44:26Z", "commit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NDoyNlrOIMTdMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NDoyNlrOIMTdMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MjU5Mw==", "bodyText": "I am not sure that this test covers sufficient number of cases. E.g.:\n\nAll supported types (e.g. these are no tests for float)\nHandling of null values\nHandling of the same values (e.g. 1, 2, 2)\nTesting index lookups and ORDER BY together\nSingle member (no merge) and multiple members (with merge)", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549772593", "createdAt": "2020-12-29T16:44:26Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/SqlOrderByTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.IndexConfig;\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.test.HazelcastSerialParametersRunnerFactory;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojo;\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializationMode;\n+import static com.hazelcast.sql.SqlBasicTest.portableFieldName;\n+import static com.hazelcast.sql.SqlBasicTest.serializationConfig;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test that covers basic column read operations through SQL.\n+ */\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastSerialParametersRunnerFactory.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+@SuppressWarnings(\"checkstyle:RedundantModifier\")\n+public class SqlOrderByTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c364ce930090559c002db51c124c8f048a22192c"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MTU1MTE0", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-565155114", "createdAt": "2021-01-11T08:51:31Z", "commit": {"oid": "351d44b171ac38d0c560ab2fac985c3007a19787"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwODo1MTozMVrOIRMHxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwODo1MTozMVrOIRMHxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg5NTMwMA==", "bodyText": "The override is here just to make it final, right?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r554895300", "createdAt": "2021-01-11T08:51:31Z", "author": {"login": "taburet"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/SortLogicalRel.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rex.RexNode;\n+\n+/**\n+ * Logical sorting.\n+ */\n+public class SortLogicalRel extends Sort implements LogicalRel {\n+    public SortLogicalRel(\n+            RelOptCluster cluster,\n+            RelTraitSet traits,\n+            RelNode child,\n+            RelCollation collation\n+    ) {\n+        super(cluster, traits, child, collation);\n+    }\n+\n+    @Override\n+    public final Sort copy(RelTraitSet traitSet, RelNode input, RelCollation collation, RexNode offset, RexNode fetch) {\n+        return new SortLogicalRel(getCluster(), traitSet, input, collation);\n+    }\n+\n+    @Override\n+    public final RelWriter explainTerms(RelWriter pw) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "351d44b171ac38d0c560ab2fac985c3007a19787"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MzI2NTU5", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-565326559", "createdAt": "2021-01-11T12:53:58Z", "commit": {"oid": "f3bd9c2e163ebac5b152856b719dcff43dd55850"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMjo1Mzo1OFrOIRUHjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMjo1NTowM1rOIRUJ0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjMxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.**\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026317", "createdAt": "2021-01-11T12:53:58Z", "author": {"login": "alex-dukhno"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -125,18 +128,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3bd9c2e163ebac5b152856b719dcff43dd55850"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjQzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.*\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026435", "createdAt": "2021-01-11T12:54:12Z", "author": {"login": "alex-dukhno"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -125,18 +128,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.**\n      * @return iterator over index entries that are matching the given comparions type and value\n      */\n-    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value);\n+    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value, boolean descending);\n \n     /**\n      * @param from lower bound\n      * @param fromInclusive lower bound inclusive flag\n      * @param to upper bound\n      * @param toInclusive upper bound inclusive flag\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3bd9c2e163ebac5b152856b719dcff43dd55850"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjgwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.*\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026804", "createdAt": "2021-01-11T12:54:51Z", "author": {"login": "alex-dukhno"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexStore.java", "diffHunk": "@@ -140,18 +143,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3bd9c2e163ebac5b152856b719dcff43dd55850"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjg5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.*\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026899", "createdAt": "2021-01-11T12:55:03Z", "author": {"login": "alex-dukhno"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexStore.java", "diffHunk": "@@ -140,18 +143,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*\n      * @return iterator over index entries that are matching the given comparions type and value\n      */\n-    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value);\n+    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value, boolean descending);\n \n     /**\n      * @param from lower bound\n      * @param fromInclusive lower bound inclusive flag\n      * @param to upper bound\n      * @param toInclusive upper bound inclusive flag\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3bd9c2e163ebac5b152856b719dcff43dd55850"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2MTk2NDU5", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-566196459", "createdAt": "2021-01-12T11:54:31Z", "commit": {"oid": "2f05ca9c96801041307fb61fd2a5e023a3faff18"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxMTo1NDozMlrOIR-NXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxMTo1NDozMlrOIR-NXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxNTkzNQ==", "bodyText": "With the new satisfies check, the upper equals check is no longer needed.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555715935", "createdAt": "2021-01-12T11:54:32Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTraitDef.java", "diffHunk": "@@ -97,6 +97,10 @@ public RelNode convert(\n             return rel;\n         }\n \n+        if (currentTrait.satisfies(targetTrait)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f05ca9c96801041307fb61fd2a5e023a3faff18"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2OTU2NDUy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-566956452", "createdAt": "2021-01-13T07:39:11Z", "commit": {"oid": "2f05ca9c96801041307fb61fd2a5e023a3faff18"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2OTk2MTY1", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-566996165", "createdAt": "2021-01-13T08:40:59Z", "commit": {"oid": "2f05ca9c96801041307fb61fd2a5e023a3faff18"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo0MDo1OVrOISk0rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo0MDo1OVrOISk0rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0ODU5MA==", "bodyText": "In IndexInFilter, we put NULLs last for ASC. But in SortKeyComparator we have the following code, which AFAIU puts NULLs first for ASC:\nif (o1 == null) {\n    return asc ? -1 : 1;\n}\n\nWhat is the canonical implementation that we would like to have? Do we have tests that cover all types of filters, as well as distributed vs non-distirubted case? Another question - does composite filters handle nulls in the same way as we expect?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556348590", "createdAt": "2021-01-13T08:40:59Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexInFilter.java", "diffHunk": "@@ -70,8 +72,21 @@ public IndexInFilter(List<IndexFilter> filters) {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n-        Map<Comparable, IndexFilter> canonicalFilters = new HashMap<>();\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, boolean descending, ExpressionEvalContext evalContext) {\n+\n+        // Sort the filter Comparables\n+        // NULLs are coming last if the sort is ASC\n+        // NULLs are coming first if the sort is DESC\n+        NavigableMap<Comparable, IndexFilter> canonicalFilters = new TreeMap<>((o1, o2) -> {\n+            if (o1 == NULL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f05ca9c96801041307fb61fd2a5e023a3faff18"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDAyMjc3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567002277", "createdAt": "2021-01-13T08:49:06Z", "commit": {"oid": "7d123a63b095335ec190e28d54c4bce3488a4a02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo0OTowNlrOISlHiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo0OTowNlrOISlHiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1MzQxNw==", "bodyText": "Objects.hash produces an array on every call. This is not very good for the hot code path. We'd better use manually created hashCode implementation.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556353417", "createdAt": "2021-01-13T08:49:06Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKey.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+/**\n+ * Single sort key.\n+ */\n+public class SortKey {\n+    /** The key */\n+    private final Object[] key;\n+\n+    /** Index to make rows unique. */\n+    private final long index;\n+\n+    public SortKey(Object[] key, long index) {\n+        this.key = key;\n+        this.index = index;\n+    }\n+\n+    public Object[] getKey() {\n+        return key;\n+    }\n+\n+    public long getIndex() {\n+        return index;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(index, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d123a63b095335ec190e28d54c4bce3488a4a02"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDA1MzU2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567005356", "createdAt": "2021-01-13T08:52:59Z", "commit": {"oid": "7d123a63b095335ec190e28d54c4bce3488a4a02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo1Mjo1OVrOISlQjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo1Mjo1OVrOISlQjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NTcyNw==", "bodyText": "SingleValuePartitioner is not a very correct name for this class, because there is no value. Maybe it should be something like ZeroPartitioner, SinglePartitionPartitioner or so, to better reflect the purpose.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556355727", "createdAt": "2021-01-13T08:52:59Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/SingleValuePartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Partitioner that is not making actual partitioning mapping all rows to the same partition.\n+ */\n+public final class SingleValuePartitioner implements RowPartitioner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d123a63b095335ec190e28d54c4bce3488a4a02"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDA1NzMy", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567005732", "createdAt": "2021-01-13T08:53:25Z", "commit": {"oid": "7d123a63b095335ec190e28d54c4bce3488a4a02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo1MzoyNVrOISlRsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo1MzoyNVrOISlRsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NjAxOA==", "bodyText": "Since this class is passed over the wire, it should implement IdentifiedDataSerializable.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556356018", "createdAt": "2021-01-13T08:53:25Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/SingleValuePartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Partitioner that is not making actual partitioning mapping all rows to the same partition.\n+ */\n+public final class SingleValuePartitioner implements RowPartitioner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d123a63b095335ec190e28d54c4bce3488a4a02"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDE4MTUx", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567018151", "createdAt": "2021-01-13T09:08:51Z", "commit": {"oid": "df15a9460ab87640faf70aaec530a8115cba9176"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTowODo1MlrOISl3Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTowODo1MlrOISl3Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2NTY2Nw==", "bodyText": "columnIndexes could be an int[], which will make the serialization slightly more efficient.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556365667", "createdAt": "2021-01-13T09:08:52Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/ReceiveSortMergePlanNode.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.ZeroInputPlanNode;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Physical node which receives from remote stripes and performs sort-merge.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergePlanNode extends ZeroInputPlanNode implements EdgeAwarePlanNode, IdentifiedDataSerializable {\n+    /**\n+     * Edge iD.\n+     */\n+    private int edgeId;\n+\n+    /**\n+     * Field types.\n+     */\n+    private List<QueryDataType> fieldTypes;\n+\n+    /**\n+     * Indexes of columns to be used for sorting.\n+     */\n+    private List<Integer> columnIndexes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df15a9460ab87640faf70aaec530a8115cba9176"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDQyMTcx", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567042171", "createdAt": "2021-01-13T09:37:37Z", "commit": {"oid": "8f8fcd84e7bf109643f84e61f121d2396db77322"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTozNzozOFrOISm_iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTozNzozOFrOISm_iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM4NDEzNw==", "bodyText": "Minor: probably we do not need this method at all.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556384137", "createdAt": "2021-01-13T09:37:38Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/SortPhysicalRule.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.HazelcastConventions;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.logical.SortLogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.exchange.SortMergeExchangePhysicalRel;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelCollationTraitDef;\n+import org.apache.calcite.rel.RelFieldCollation;\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * The rule that converts logical sort into its physical counterpart. In the current release\n+ * we support only a limited case that relies on the locally pre-sorted indexes to avoid local sorting.\n+ * <p>\n+ * However, if the input is located on a few nodes, and extra merge sort {@link SortMergeExchangePhysicalRel}\n+ * is created to sort locally pre-sorted entries.\n+ */\n+public final class SortPhysicalRule extends RelOptRule {\n+    public static final RelOptRule INSTANCE = new SortPhysicalRule();\n+\n+    private SortPhysicalRule() {\n+        super(\n+            OptUtils.parentChild(SortLogicalRel.class, RelNode.class, HazelcastConventions.LOGICAL),\n+            SortPhysicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+        SortLogicalRel sort = call.rel(0);\n+        RelNode input = sort.getInput();\n+\n+        RelNode convertedInput = OptUtils.toPhysicalInput(input);\n+\n+        Collection<RelNode> transforms = getTransforms(sort, convertedInput);\n+\n+        for (RelNode transform : transforms) {\n+            call.transformTo(transform);\n+        }\n+    }\n+\n+    /**\n+     * Get possible transformations for the given input.\n+     *\n+     * @param logicalSort    logical sort.\n+     * @param convertedInput Converted input.\n+     * @return Possible transforms.\n+     */\n+    private Collection<RelNode> getTransforms(SortLogicalRel logicalSort, RelNode convertedInput) {\n+        List<RelNode> requiresLocalSortRels = new ArrayList<>(1);\n+        List<RelNode> noLocalSortRels = new ArrayList<>(1);\n+\n+        for (RelNode physicalInput : OptUtils.getPhysicalRelsFromSubset(convertedInput)) {\n+            // Check whether local sorting is needed\n+            boolean requiresLocalSort = requiresLocalSort(\n+                logicalSort.getCollation(),\n+                physicalInput.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE)\n+            );\n+\n+            RelNode rel;\n+\n+            if (requiresLocalSort) {\n+                rel = createLocalSort(logicalSort, physicalInput);\n+            } else {\n+                rel = createLocalNoSort(physicalInput);\n+            }\n+\n+            // Add merge phase if needed.\n+            DistributionTrait physicalInputDist = OptUtils.getDistribution(physicalInput);\n+\n+            if (!physicalInputDist.isFullResultSetOnAllParticipants()) {\n+                rel = createMerge(rel, logicalSort);\n+            }\n+\n+            // Add to the list of transformations.\n+            if (requiresLocalSort) {\n+                requiresLocalSortRels.add(rel);\n+            } else {\n+                noLocalSortRels.add(rel);\n+            }\n+        }\n+\n+        // Pick up a plan that doesn't require local sorting,\n+        // otherwise an exception will be thrown when local sort\n+        // is touched in runtime.\n+        if (noLocalSortRels.size() > 0) {\n+            return noLocalSortRels;\n+        } else {\n+            return requiresLocalSortRels;\n+        }\n+    }\n+\n+    /**\n+     * Check if local sorting phase is needed. It could be avoided iff sort collation is a prefix of input collation.\n+     *\n+     * @return {@code true} if local sorting is needed, {@code false} otherwise.\n+     */\n+    private static boolean requiresLocalSort(RelCollation sortCollation, RelCollation inputCollation) {\n+        if (sortCollation.getFieldCollations().isEmpty()) {\n+            // No need for sorting\n+            return false;\n+        }\n+\n+        List<RelFieldCollation> sortFields = sortCollation.getFieldCollations();\n+        List<RelFieldCollation> inputFields = inputCollation.getFieldCollations();\n+\n+        if (sortFields.size() <= inputFields.size()) {\n+            for (int i = 0; i < sortFields.size(); i++) {\n+                RelFieldCollation sortField = sortFields.get(i);\n+                RelFieldCollation inputField = inputFields.get(i);\n+\n+                // Different collation, local sorting is needed.\n+                if (!sortField.equals(inputField)) {\n+                    return true;\n+                }\n+            }\n+\n+            // Prefix is confirmed, no local sorting is needed.\n+            return false;\n+        } else {\n+            // Input has less collated fields than sort. Definitely not a prefix => local sorting is needed.\n+            return true;\n+        }\n+    }\n+\n+    private static SortPhysicalRel createLocalSort(SortLogicalRel logicalSort, RelNode physicalInput) {\n+        // Input traits are propagated, but new collation is used.\n+        RelTraitSet traitSet = OptUtils.traitPlus(physicalInput.getTraitSet(),\n+            logicalSort.getCollation()\n+        );\n+\n+        return new SortPhysicalRel(\n+            logicalSort.getCluster(),\n+            traitSet,\n+            physicalInput,\n+            logicalSort.getCollation()\n+        );\n+    }\n+\n+    private RelNode createLocalNoSort(RelNode input) {\n+        return input;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f8fcd84e7bf109643f84e61f121d2396db77322"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDUwNDIz", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567050423", "createdAt": "2021-01-13T09:47:22Z", "commit": {"oid": "8f8fcd84e7bf109643f84e61f121d2396db77322"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTo0NzoyMlrOISnX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTo0NzoyMlrOISnX-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5MDM5Mw==", "bodyText": "A call to containsKey is not needed, since remove already does this check. Similarly for the other containsKey call below.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556390393", "createdAt": "2021-01-13T09:47:22Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -136,20 +174,101 @@ private IndexResolver() {\n         }\n \n         List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n-\n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+            List<Boolean> ascs = buildFieldDirections(index, true);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, ascs);\n+\n+            if (relAscending != null) {\n+                RelCollation relAscCollation = getCollation(relAscending);\n+                if (fullScanRelsMap.containsKey(relAscCollation)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f8fcd84e7bf109643f84e61f121d2396db77322"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDUyNjA1", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567052605", "createdAt": "2021-01-13T09:49:53Z", "commit": {"oid": "8f8fcd84e7bf109643f84e61f121d2396db77322"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTo0OTo1M1rOISneTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTo0OTo1M1rOISneTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5MjAxNA==", "bodyText": "RelCollationComparator could be a singleton.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556392014", "createdAt": "2021-01-13T09:49:53Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -136,20 +174,101 @@ private IndexResolver() {\n         }\n \n         List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n-\n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+            List<Boolean> ascs = buildFieldDirections(index, true);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, ascs);\n+\n+            if (relAscending != null) {\n+                RelCollation relAscCollation = getCollation(relAscending);\n+                if (fullScanRelsMap.containsKey(relAscCollation)) {\n+                    // The fulls scan has the same collation, exclude it\n+                    fullScanRelsMap.remove(relAscCollation);\n+                }\n+\n+                rels.add(relAscending);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+                if (relAscCollation.getFieldCollations().size() > 0) {\n+                    RelNode relDescending = replaceCollationDirection(relAscending, DESCENDING);\n+                    rels.add(relDescending);\n+\n+                    RelCollation relDescCollation = getCollation(relDescending);\n+                    if (fullScanRelsMap.containsKey(relDescCollation)) {\n+                        // The fulls scan has the same collation, exclude it\n+                        fullScanRelsMap.remove(relDescCollation);\n+                    }\n+                }\n             }\n         }\n \n+        rels.addAll(fullScanRelsMap.values());\n         return rels;\n     }\n \n+    private static RelCollation getCollation(RelNode rel) {\n+        return rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE);\n+    }\n+\n+    /**\n+     * Replaces a direction in the collation trait of the rel\n+     * @param rel       the rel\n+     * @param direction the collation\n+     * @return the rel with changed collation\n+     */\n+    private static RelNode replaceCollationDirection(RelNode rel, Direction direction) {\n+        RelCollation collation = rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE);\n+\n+        List<RelFieldCollation> newFields = new ArrayList<>(collation.getFieldCollations().size());\n+        for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n+            RelFieldCollation newFieldCollation = new RelFieldCollation(fieldCollation.getFieldIndex(), direction);\n+            newFields.add(newFieldCollation);\n+        }\n+\n+        RelCollation newCollation = RelCollations.of(newFields);\n+        RelTraitSet traitSet = rel.getTraitSet();\n+        traitSet = OptUtils.traitPlus(traitSet, newCollation);\n+\n+        return rel.copy(traitSet, rel.getInputs());\n+    }\n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return a filtered out map of collation to rel\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static Map<RelCollation, RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>(new RelCollationComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f8fcd84e7bf109643f84e61f121d2396db77322"}, "originalPosition": 193}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDY1MjU3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567065257", "createdAt": "2021-01-13T10:04:18Z", "commit": {"oid": "f9419cfe53b49156bfacd109deae81e73631f1c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDowNDoxOFrOISoEJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDowNDoxOFrOISoEJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwMTcwMQ==", "bodyText": "Here we have ASC NULLS FIRST and DESC NULLS LAST. Could you please confirm that it works the same way for :\n\nComposite indexes (e.g. [x, NULL] comes before [x, y] for ASC, and vice versa for DESC)\nMerge sorter\nIN filter", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556401701", "createdAt": "2021-01-13T10:04:18Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -115,11 +116,19 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getSqlRecordIterator() {\n-        Iterator<QueryableEntry> iterator = new IndexEntryFlatteningIterator(recordMap.values().iterator());\n-        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+    public Iterator<QueryableEntry> getSqlRecordIterator(boolean descending) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9419cfe53b49156bfacd109deae81e73631f1c5"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDY5Mjkw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-567069290", "createdAt": "2021-01-13T10:09:14Z", "commit": {"oid": "f9419cfe53b49156bfacd109deae81e73631f1c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDowOToxNFrOISoQOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDowOToxNFrOISoQOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNDc5Mw==", "bodyText": "Consider the we have LESS THAN EQUALS 2 operator and a collection of values [0, 1, 2, 3, 4].\nFor ASC we call headMap(2, true), and get [0, 1, 2]. For DESC we call tailMap(2, true), and get [2, 3, 4].\nLooks like we return completely wrong results here unless I am missing something. Do we have tests for these cases?", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556404793", "createdAt": "2021-01-13T10:09:14Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -138,21 +147,38 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable searchedValue) {\n+    public Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable searchedValue, boolean descending) {\n         Iterator<Map<Data, QueryableEntry>> iterator;\n \n+        ConcurrentNavigableMap navigableMap = descending ? recordMap.descendingMap() : recordMap;\n         switch (comparison) {\n             case LESS:\n-                iterator = recordMap.headMap(searchedValue, false).values().iterator();\n+                if (descending) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9419cfe53b49156bfacd109deae81e73631f1c5"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MDkwMzU0", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-569090354", "createdAt": "2021-01-15T09:23:22Z", "commit": {"oid": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOToyMzoyMlrOIUQf7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOToyMzoyMlrOIUQf7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODExMjc0OA==", "bodyText": "Minor: formally, we do not do any conversions here.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558112748", "createdAt": "2021-01-15T09:23:22Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/org/apache/calcite/plan/volcano/HazelcastRelSubsetUtil.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.calcite.plan.volcano;\n+\n+import com.hazelcast.sql.impl.calcite.opt.HazelcastConventions;\n+\n+/**\n+ * Utility class to access package-private Calcite internals.\n+ */\n+public final class HazelcastRelSubsetUtil {\n+\n+    private HazelcastRelSubsetUtil() {\n+    }\n+\n+    /**\n+     * Convert the given input into input with PHYSICAL convention.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MDk1NjQ3", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-569095647", "createdAt": "2021-01-15T09:30:11Z", "commit": {"oid": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTozMDoxMlrOIURHdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTozMDoxMlrOIURHdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMjg2OQ==", "bodyText": "Here we convert a physical subset to another physical rel traits. I do not know the exact consequences of it, but perhaps it would be better to do convert(rel, rel.getTraitSet()). In any case, let's double-check that this convert call doesn't lead to the creation of new converters.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558122869", "createdAt": "2021-01-15T09:30:12Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -172,31 +173,35 @@ public static boolean isPhysical(RelNode rel) {\n     /**\n      * Get possible physical rels from the given subset. Every returned input is guaranteed to have a unique trait set.\n      *\n-     * @param subset Subset.\n+     * @param input Subset.\n      * @return Physical rels.\n      */\n-    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode subset) {\n-        if (subset instanceof RelSubset) {\n-            RelSubset subset0 = (RelSubset) subset;\n+    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode input) {\n \n-            Set<RelTraitSet> traitSets = new HashSet<>();\n+        RelNode convertedInput = convert(input, input.getTraitSet());\n \n-            Set<RelNode> res = Collections.newSetFromMap(new IdentityHashMap<>());\n+        if (!(convertedInput instanceof RelSubset)) {\n+            return Collections.emptyList();\n+        }\n+\n+        RelSubset logicalSubset = (RelSubset) convertedInput;\n+        RelSubset physicalSubset = HazelcastRelSubsetUtil.getPhysicalSubSet(logicalSubset);\n+\n+        Set<RelTraitSet> traitSets = new HashSet<>();\n \n-            for (RelNode rel : subset0.getRelList()) {\n-                if (!isPhysical(rel)) {\n-                    continue;\n-                }\n+        Set<RelNode> res = Collections.newSetFromMap(new IdentityHashMap<>());\n \n-                if (traitSets.add(rel.getTraitSet())) {\n-                    res.add(convert(subset, rel.getTraitSet()));\n-                }\n+        for (RelNode rel : physicalSubset.getRelList()) {\n+            if (!isPhysical(rel)) {\n+                continue;\n             }\n \n-            return res;\n-        } else {\n-            return Collections.emptyList();\n+            if (traitSets.add(rel.getTraitSet())) {\n+                res.add(convert(physicalSubset, rel.getTraitSet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MDk2MTg2", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-569096186", "createdAt": "2021-01-15T09:30:54Z", "commit": {"oid": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTozMDo1NFrOIURLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTozMDo1NFrOIURLiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMzkxMw==", "bodyText": "Strictly speaking, logicalSubset is not necessarily logical. It could be physical as well. So I would rename this variable to avoid confusion.", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558123913", "createdAt": "2021-01-15T09:30:54Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -172,31 +173,35 @@ public static boolean isPhysical(RelNode rel) {\n     /**\n      * Get possible physical rels from the given subset. Every returned input is guaranteed to have a unique trait set.\n      *\n-     * @param subset Subset.\n+     * @param input Subset.\n      * @return Physical rels.\n      */\n-    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode subset) {\n-        if (subset instanceof RelSubset) {\n-            RelSubset subset0 = (RelSubset) subset;\n+    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode input) {\n \n-            Set<RelTraitSet> traitSets = new HashSet<>();\n+        RelNode convertedInput = convert(input, input.getTraitSet());\n \n-            Set<RelNode> res = Collections.newSetFromMap(new IdentityHashMap<>());\n+        if (!(convertedInput instanceof RelSubset)) {\n+            return Collections.emptyList();\n+        }\n+\n+        RelSubset logicalSubset = (RelSubset) convertedInput;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MzE4Nzkw", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-569318790", "createdAt": "2021-01-15T14:43:13Z", "commit": {"oid": "acd00285d0965a1aec6627707f3845c33a22d223"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46cf92f7bc553174750752a05bbd182e32701f68", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/46cf92f7bc553174750752a05bbd182e32701f68", "committedDate": "2021-01-22T13:43:19Z", "message": "SQL: implementation of the ORDER BY clause\n\nInitial implementation of the SQL's ORDER BY clause. It supports\nothe ASC and DESC sortings, but there are some limitations.\n\nThe sorting is only supported only if there is a matching index that\nstores the key/value pairs already pre-sorted. Otherwise, an exception\nis thrown.\n\nThe nested sortings are supported, but again only if the supporting\ncomposite SORTED index is created."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6ee1bc3ee471973b3f03c727939aad5dbff37c9", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/f6ee1bc3ee471973b3f03c727939aad5dbff37c9", "committedDate": "2021-01-22T13:43:19Z", "message": "Minor improvements, checkstyle, formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "689e5177dc7ef959df8a440887a118300a42de12", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/689e5177dc7ef959df8a440887a118300a42de12", "committedDate": "2021-01-22T13:43:19Z", "message": "Minor improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "127f290b0cf7b945a23ad0e04fa0740ad44eb131", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/127f290b0cf7b945a23ad0e04fa0740ad44eb131", "committedDate": "2021-01-22T13:43:19Z", "message": "Minors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "593b73d8b939d59a7d4aa7fa54e4927994b461e9", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/593b73d8b939d59a7d4aa7fa54e4927994b461e9", "committedDate": "2021-01-22T13:43:19Z", "message": "Propagate descending flag properly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c8edd2300073eb0150b6dfc68a47244f77c3fff", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/4c8edd2300073eb0150b6dfc68a47244f77c3fff", "committedDate": "2021-01-22T13:43:19Z", "message": "Removed a leftover"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d0a6ce4cf2c3fe41e9060051b86a4c821badd85", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/6d0a6ce4cf2c3fe41e9060051b86a4c821badd85", "committedDate": "2021-01-22T13:43:19Z", "message": "Addresses reviewer's comment\n\nReplace List<Object> with the Object[] in the SortKey.\nCheckstyle fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4784a3582c2bc7dd170af94ff294e248ec7def3", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/b4784a3582c2bc7dd170af94ff294e248ec7def3", "committedDate": "2021-01-22T13:43:19Z", "message": "Fixed formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21a6b05739456c8c48960bb31864b3adb9fa17c5", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/21a6b05739456c8c48960bb31864b3adb9fa17c5", "committedDate": "2021-01-22T13:43:19Z", "message": "Added descending flag to the explainTerms(...)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "999b1391fbbded3f721bbc73a7f23473d45ce706", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/999b1391fbbded3f721bbc73a7f23473d45ce706", "committedDate": "2021-01-22T13:43:19Z", "message": "Extended Filter tests with descending navigation support.\n\nFixed some issues in the filters."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92edccadde00f182d2c4a631941ab91c0bc94ecc", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/92edccadde00f182d2c4a631941ab91c0bc94ecc", "committedDate": "2021-01-22T13:43:19Z", "message": "Removed not used parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9d13966a66f23076cc6fbc4333e85b8d2fabfdb", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/d9d13966a66f23076cc6fbc4333e85b8d2fabfdb", "committedDate": "2021-01-22T13:43:19Z", "message": "Minor: added more asserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c703f2a539ded71f37dcaa85dc080c2045fe1c37", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/c703f2a539ded71f37dcaa85dc080c2045fe1c37", "committedDate": "2021-01-22T13:43:19Z", "message": "Removed unnecessary passing of column expressions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb2fb561a2960b5013f6ff39f6f37a3d2018a948", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/bb2fb561a2960b5013f6ff39f6f37a3d2018a948", "committedDate": "2021-01-22T13:43:19Z", "message": "Optimized full index scan generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8190a507dbad5b56f20645491431aa9b6c2b4e61", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/8190a507dbad5b56f20645491431aa9b6c2b4e61", "committedDate": "2021-01-22T13:43:19Z", "message": "Minor: made method private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "600741a4041fb305398d48e0015cf93f8141c170", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/600741a4041fb305398d48e0015cf93f8141c170", "committedDate": "2021-01-22T13:43:19Z", "message": "Filter out a full index scan if there is no collation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7360b8ff6ea67a7c0a848b6ed61087829ef669f0", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/7360b8ff6ea67a7c0a848b6ed61087829ef669f0", "committedDate": "2021-01-22T13:43:19Z", "message": "Removed unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4259dcdc0aa41dae304cec260b699ff2da2b406", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/e4259dcdc0aa41dae304cec260b699ff2da2b406", "committedDate": "2021-01-22T13:47:18Z", "message": "Implement IdentifiedDataSerializable in UnicastSendPlanNode"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0MjcyODc5", "url": "https://github.com/hazelcast/hazelcast/pull/18013#pullrequestreview-574272879", "createdAt": "2021-01-22T13:48:07Z", "commit": {"oid": "1fbfa95261e032066e95016d51b2749228903074"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "486c7ea21970440796b4b277e3b94ec39efbed23", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/486c7ea21970440796b4b277e3b94ec39efbed23", "committedDate": "2021-01-22T13:49:38Z", "message": "Implemented IdentifiedDataSerializable in ReceiveSortMergePlanNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "068da3eaecbca541a36329130fd9b20a4f0561a7", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/068da3eaecbca541a36329130fd9b20a4f0561a7", "committedDate": "2021-01-22T13:49:38Z", "message": "Fixed hashCode/equals method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "committedDate": "2021-01-22T13:49:38Z", "message": "Removed not used code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5099351140e5def76667f88aa80e69526404ac4b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/5099351140e5def76667f88aa80e69526404ac4b", "committedDate": "2021-01-22T13:49:38Z", "message": "Minor improvement: replaced List with array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e77bab6acf6932f8c4242462666e952bb7beb9f", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/7e77bab6acf6932f8c4242462666e952bb7beb9f", "committedDate": "2021-01-22T13:49:38Z", "message": "Fixed equals/hashCode methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9156f1430c44775973138f61025313350a41bb3", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/f9156f1430c44775973138f61025313350a41bb3", "committedDate": "2021-01-22T13:49:38Z", "message": "Simplified code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8c981fa1d72750010e38826a2b3b0330407475f", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/e8c981fa1d72750010e38826a2b3b0330407475f", "committedDate": "2021-01-22T13:49:38Z", "message": "Fixed index scan creation\n\n1. Generate full scans when a filter exists\n2. Exclude full scans covered by lookups with the same collation\n3. Unit testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde45cf36c81666db961d10651a1a0dc81b3bba0", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/cde45cf36c81666db961d10651a1a0dc81b3bba0", "committedDate": "2021-01-22T13:49:38Z", "message": "Simplified unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "committedDate": "2021-01-22T13:49:38Z", "message": "Removed a leftover"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20066dee21a60bf5296742bbc002d3694dd377c8", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/20066dee21a60bf5296742bbc002d3694dd377c8", "committedDate": "2021-01-22T13:49:38Z", "message": "More tests on the index plans with sorting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78e65cf016255e59f4dbfe2c094c6d4198f59b89", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/78e65cf016255e59f4dbfe2c094c6d4198f59b89", "committedDate": "2021-01-22T13:49:38Z", "message": "Generalized fields collation\n\nUse List<Boolean> for fields collation instead of one boolean flag to\nprepare for [ASC, DESC] sortings in the future. The change is mostly\nneeded to keep the protocol unchanged in the future."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c8d3db3f49f67400f6a317d48fdbc1696d8401", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/64c8d3db3f49f67400f6a317d48fdbc1696d8401", "committedDate": "2021-01-22T13:49:38Z", "message": "Generalized a unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "committedDate": "2021-01-22T13:49:38Z", "message": "Use NoPartitioning partitioner for the sorting unicast send"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a62bd901143c8df6d78d004eef10e4aad0aa321b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/a62bd901143c8df6d78d004eef10e4aad0aa321b", "committedDate": "2021-01-22T13:49:38Z", "message": "Minor: make the field package-private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af00e7f418b414e154511aea1a7e05bd815eefea", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/af00e7f418b414e154511aea1a7e05bd815eefea", "committedDate": "2021-01-22T13:49:38Z", "message": "Assert SingleValuePartitioner is used"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "860c69cb99b3235cb53f3f36f47b411e601e7c2b", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/860c69cb99b3235cb53f3f36f47b411e601e7c2b", "committedDate": "2021-01-22T13:49:38Z", "message": "NULL values handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e33e8042ad18dbe8ce7499c2732c12d1cad4832", "author": {"user": {"login": "petrpleshachkov", "name": null}}, "url": "https://github.com/hazelcast/hazelcast/commit/3e33e8042ad18dbe8ce7499c2732c12d1cad4832", "committedDate": "2021-01-22T13:49:38Z", "message": "Added tests for unsupported features"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3061, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}