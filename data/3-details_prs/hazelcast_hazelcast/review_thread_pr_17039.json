{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NTUxOTk0", "number": 17039, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyNToxN1rOECGBvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDowNzowNVrOEClDQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjMxMzU5OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyNToxN1rOGeVsuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyNToxN1rOGeVsuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTk3OQ==", "bodyText": "This comment looks irrelevant.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r434465979", "createdAt": "2020-06-03T10:25:17Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.List;\n+\n+/**\n+ * Base class for map scans.\n+ */\n+public abstract class AbstractMapScanRel extends AbstractScanRel {\n+    /** Filter. */\n+    protected final RexNode filter;\n+\n+    public AbstractMapScanRel(\n+        RelOptCluster cluster,\n+        RelTraitSet traitSet,\n+        RelOptTable table,\n+        List<Integer> projects,\n+        RexNode filter\n+    ) {\n+        super(cluster, traitSet, table, projects);\n+\n+        this.filter = filter;\n+    }\n+\n+    public List<Integer> getProjects() {\n+        return projects != null ? projects : identity();\n+    }\n+\n+    public RexNode getFilter() {\n+        return filter;\n+    }\n+\n+    public AbstractMapTable getMap() {\n+        return getTableUnwrapped().getTarget();\n+    }\n+\n+    @Override\n+    public RelWriter explainTerms(RelWriter pw) {\n+        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n+    }\n+\n+    @Override\n+    public final double estimateRowCount(RelMetadataQuery mq) {\n+        double rowCount = super.estimateRowCount(mq);\n+\n+        if (filter != null) {\n+            double selectivity = mq.getSelectivity(this, filter);\n+\n+            rowCount = rowCount * selectivity;\n+        }\n+\n+        return rowCount;\n+    }\n+\n+    @Override\n+    public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+        return computeSelfCost(\n+            planner,\n+            mq,\n+            table.getRowCount(),\n+            filter,\n+            getProjects().size(),\n+            CostUtils.TABLE_SCAN_CPU_MULTIPLIER\n+        );\n+    }\n+\n+    protected RelOptCost computeSelfCost(\n+        RelOptPlanner planner,\n+        RelMetadataQuery mq,\n+        double scanRowCount,\n+        RexNode filter,\n+        int projectCount,\n+        double costMultiplier\n+    ) {\n+        // 1. Get cost of the scan itself. For replicated map cost is multiplied by the number of nodes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fa70829fefe01f6f9b1a0cbfd3fb54690562f89"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDQ5OTkyOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDowNzo1MVrOGe-6Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjo0MDozNVrOGfDzew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTE1NA==", "bodyText": "CostUtil.adjustFilteredRowCount?", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435141154", "createdAt": "2020-06-04T10:07:51Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.List;\n+\n+/**\n+ * Base class for map scans.\n+ */\n+public abstract class AbstractMapScanRel extends AbstractScanRel {\n+    /** Filter. */\n+    protected final RexNode filter;\n+\n+    public AbstractMapScanRel(\n+        RelOptCluster cluster,\n+        RelTraitSet traitSet,\n+        RelOptTable table,\n+        List<Integer> projects,\n+        RexNode filter\n+    ) {\n+        super(cluster, traitSet, table, projects);\n+\n+        this.filter = filter;\n+    }\n+\n+    public List<Integer> getProjects() {\n+        return projects != null ? projects : identity();\n+    }\n+\n+    public RexNode getFilter() {\n+        return filter;\n+    }\n+\n+    public AbstractMapTable getMap() {\n+        return getTableUnwrapped().getTarget();\n+    }\n+\n+    @Override\n+    public RelWriter explainTerms(RelWriter pw) {\n+        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n+    }\n+\n+    @Override\n+    public final double estimateRowCount(RelMetadataQuery mq) {\n+        double rowCount = super.estimateRowCount(mq);\n+\n+        if (filter != null) {\n+            double selectivity = mq.getSelectivity(this, filter);\n+\n+            rowCount = rowCount * selectivity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyMTM3MQ==", "bodyText": "Yes, we may use this method. However, this piece of code will go away soon once we introduce project/filter-into-scan rules, so it is safe to keep it for now as is.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435221371", "createdAt": "2020-06-04T12:40:35Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.List;\n+\n+/**\n+ * Base class for map scans.\n+ */\n+public abstract class AbstractMapScanRel extends AbstractScanRel {\n+    /** Filter. */\n+    protected final RexNode filter;\n+\n+    public AbstractMapScanRel(\n+        RelOptCluster cluster,\n+        RelTraitSet traitSet,\n+        RelOptTable table,\n+        List<Integer> projects,\n+        RexNode filter\n+    ) {\n+        super(cluster, traitSet, table, projects);\n+\n+        this.filter = filter;\n+    }\n+\n+    public List<Integer> getProjects() {\n+        return projects != null ? projects : identity();\n+    }\n+\n+    public RexNode getFilter() {\n+        return filter;\n+    }\n+\n+    public AbstractMapTable getMap() {\n+        return getTableUnwrapped().getTarget();\n+    }\n+\n+    @Override\n+    public RelWriter explainTerms(RelWriter pw) {\n+        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n+    }\n+\n+    @Override\n+    public final double estimateRowCount(RelMetadataQuery mq) {\n+        double rowCount = super.estimateRowCount(mq);\n+\n+        if (filter != null) {\n+            double selectivity = mq.getSelectivity(this, filter);\n+\n+            rowCount = rowCount * selectivity;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTE1NA=="}, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDUxOTk1OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractRootRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoxNDoxMFrOGe_HXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjo0NzoyNVrOGfEDfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0NDU0Mg==", "bodyText": "shouldn't the class be abstract?", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435144542", "createdAt": "2020-06-04T10:14:10Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractRootRel.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.SingleRel;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+\n+/**\n+ * Base class for root operators.\n+ */\n+public class AbstractRootRel extends SingleRel implements HazelcastRelNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTQ3MA==", "bodyText": "Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225470", "createdAt": "2020-06-04T12:47:25Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractRootRel.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.SingleRel;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+\n+/**\n+ * Base class for root operators.\n+ */\n+public class AbstractRootRel extends SingleRel implements HazelcastRelNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0NDU0Mg=="}, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDU1MzM4OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/HazelcastConventions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyMzowOVrOGe_cMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjo0NzoyM1rOGfEDYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0OTg3NA==", "bodyText": "assert toConvention == LOGICAL?", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435149874", "createdAt": "2020-06-04T10:23:09Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/HazelcastConventions.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.logical.LogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.PhysicalRel;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelTraitSet;\n+\n+/**\n+ * Hazelcast conventions.\n+ */\n+public final class HazelcastConventions {\n+    /** Convention used during logical planning. */\n+    public static final Convention LOGICAL = new Convention.Impl(\"LOGICAL\", LogicalRel.class);\n+\n+    /** Convention used during physical planning. */\n+    public static final Convention PHYSICAL = new Convention.Impl(\"PHYSICAL\", PhysicalRel.class) {\n+        @Override\n+        public boolean canConvertConvention(Convention toConvention) {\n+            // Allows conversion between LOGICAL and PHYSICAL conventions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTQ0Mg==", "bodyText": "Done.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225442", "createdAt": "2020-06-04T12:47:23Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/HazelcastConventions.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.logical.LogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.PhysicalRel;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelTraitSet;\n+\n+/**\n+ * Hazelcast conventions.\n+ */\n+public final class HazelcastConventions {\n+    /** Convention used during logical planning. */\n+    public static final Convention LOGICAL = new Convention.Impl(\"LOGICAL\", LogicalRel.class);\n+\n+    /** Convention used during physical planning. */\n+    public static final Convention PHYSICAL = new Convention.Impl(\"PHYSICAL\", PhysicalRel.class) {\n+        @Override\n+        public boolean canConvertConvention(Convention toConvention) {\n+            // Allows conversion between LOGICAL and PHYSICAL conventions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0OTg3NA=="}, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDY2MDUzOnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTrait.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDo1NjoxN1rOGfAfXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjo0NzowOFrOGfEC0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NzA2OA==", "bodyText": "Suspicious that traitDef itself is not used for in equals and hashCode.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435167068", "createdAt": "2020-06-04T10:56:17Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTrait.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.distribution;\n+\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTrait;\n+import org.apache.calcite.plan.RelTraitDef;\n+\n+import static com.hazelcast.sql.impl.calcite.opt.distribution.DistributionType.ANY;\n+\n+/**\n+ * Defines how the given relation is distributed in the cluster.\n+ */\n+public class DistributionTrait implements RelTrait {\n+    /** Trait definition. */\n+    private final DistributionTraitDef traitDef;\n+\n+    /** Distribution type. */\n+    private final DistributionType type;\n+\n+    DistributionTrait(DistributionTraitDef traitDef, DistributionType type) {\n+        this.traitDef = traitDef;\n+        this.type = type;\n+    }\n+\n+    public DistributionType getType() {\n+        return type;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    @Override\n+    public RelTraitDef getTraitDef() {\n+        return traitDef;\n+    }\n+\n+    @Override\n+    public boolean satisfies(RelTrait targetTrait) {\n+        if (!(targetTrait instanceof DistributionTrait)) {\n+            return false;\n+        }\n+\n+        // For single-member deployments all distributions satisfy each other.\n+        if (traitDef.getMemberCount() == 1) {\n+            return true;\n+        }\n+\n+        DistributionType targetType = ((DistributionTrait) targetTrait).getType();\n+\n+        // Any type satisfies ANY.\n+        if (targetType == ANY) {\n+            return true;\n+        }\n+\n+        // Otherwise compare two distributions.\n+        return this.equals(targetTrait);\n+    }\n+\n+    @Override\n+    public void register(RelOptPlanner planner) {\n+        // No-op.\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTI5Ng==", "bodyText": "Nice catch! Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225296", "createdAt": "2020-06-04T12:47:08Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTrait.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.distribution;\n+\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTrait;\n+import org.apache.calcite.plan.RelTraitDef;\n+\n+import static com.hazelcast.sql.impl.calcite.opt.distribution.DistributionType.ANY;\n+\n+/**\n+ * Defines how the given relation is distributed in the cluster.\n+ */\n+public class DistributionTrait implements RelTrait {\n+    /** Trait definition. */\n+    private final DistributionTraitDef traitDef;\n+\n+    /** Distribution type. */\n+    private final DistributionType type;\n+\n+    DistributionTrait(DistributionTraitDef traitDef, DistributionType type) {\n+        this.traitDef = traitDef;\n+        this.type = type;\n+    }\n+\n+    public DistributionType getType() {\n+        return type;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    @Override\n+    public RelTraitDef getTraitDef() {\n+        return traitDef;\n+    }\n+\n+    @Override\n+    public boolean satisfies(RelTrait targetTrait) {\n+        if (!(targetTrait instanceof DistributionTrait)) {\n+            return false;\n+        }\n+\n+        // For single-member deployments all distributions satisfy each other.\n+        if (traitDef.getMemberCount() == 1) {\n+            return true;\n+        }\n+\n+        DistributionType targetType = ((DistributionTrait) targetTrait).getType();\n+\n+        // Any type satisfies ANY.\n+        if (targetType == ANY) {\n+            return true;\n+        }\n+\n+        // Otherwise compare two distributions.\n+        return this.equals(targetTrait);\n+    }\n+\n+    @Override\n+    public void register(RelOptPlanner planner) {\n+        // No-op.\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NzA2OA=="}, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDgyNTY1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/UniExpression.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTo0OToxM1rOGfCGog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjo0NzoyMFrOGfEDQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MzUwNg==", "bodyText": "Does the operand really can be null?", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435193506", "createdAt": "2020-06-04T11:49:13Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/UniExpression.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Expression with one operand.\n+ */\n+public abstract class UniExpression<T> implements Expression<T> {\n+\n+    protected Expression<?> operand;\n+\n+    protected UniExpression() {\n+        // No-op.\n+    }\n+\n+    protected UniExpression(Expression<?> operand) {\n+        this.operand = operand;\n+    }\n+\n+    public Expression<?> getOperand() {\n+        return operand;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeObject(operand);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        operand = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return operand != null ? operand.hashCode() : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTQwOQ==", "bodyText": "I think it can't, Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225409", "createdAt": "2020-06-04T12:47:20Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/UniExpression.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Expression with one operand.\n+ */\n+public abstract class UniExpression<T> implements Expression<T> {\n+\n+    protected Expression<?> operand;\n+\n+    protected UniExpression() {\n+        // No-op.\n+    }\n+\n+    protected UniExpression(Expression<?> operand) {\n+        this.operand = operand;\n+    }\n+\n+    public Expression<?> getOperand() {\n+        return operand;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeObject(operand);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        operand = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return operand != null ? operand.hashCode() : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MzUwNg=="}, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDg2MTE3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractObjectConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjowMDo0M1rOGfCdPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjozNzowN1rOGfDrfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5OTI5NA==", "bodyText": "It also makes sense to include changes to 01-type-system.md regarding BIT to BOOLEAN transition.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435199294", "createdAt": "2020-06-04T12:00:43Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractObjectConverter.java", "diffHunk": "@@ -33,8 +33,8 @@ protected AbstractObjectConverter(int id, QueryDataTypeFamily typeFamily) {\n     }\n \n     @Override\n-    public boolean asBit(Object val) {\n-        return resolveConverter(val, QueryDataTypeFamily.BOOLEAN).asBit(val);\n+    public boolean asBoolean(Object val) {\n+        return resolveConverter(val, QueryDataTypeFamily.BOOLEAN).asBoolean(val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxOTMyNg==", "bodyText": "Addressed.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435219326", "createdAt": "2020-06-04T12:37:07Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractObjectConverter.java", "diffHunk": "@@ -33,8 +33,8 @@ protected AbstractObjectConverter(int id, QueryDataTypeFamily typeFamily) {\n     }\n \n     @Override\n-    public boolean asBit(Object val) {\n-        return resolveConverter(val, QueryDataTypeFamily.BOOLEAN).asBit(val);\n+    public boolean asBoolean(Object val) {\n+        return resolveConverter(val, QueryDataTypeFamily.BOOLEAN).asBoolean(val);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5OTI5NA=="}, "originalCommit": {"oid": "5610da8026e323459e0697aba64830274d390787"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTM4Nzg2OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDowNToyOFrOGfHqZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjo0Mjo1MFrOGfiNWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDU4Mg==", "bodyText": "Minor: True -> true?", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435284582", "createdAt": "2020-06-04T14:05:28Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTraitDef;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.ConventionTraitDef;\n+import org.apache.calcite.plan.HazelcastRelOptCluster;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelTrait;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+\n+import static org.apache.calcite.plan.RelOptRule.convert;\n+\n+/**\n+ * Utility methods for rules.\n+ */\n+public final class OptUtils {\n+    private OptUtils() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Get operand matching a single node.\n+     *\n+     * @param cls Node class.\n+     * @param convention Convention.\n+     * @return Operand.\n+     */\n+    public static <R extends RelNode> RelOptRuleOperand single(Class<R> cls, Convention convention) {\n+        return RelOptRule.operand(cls, convention, RelOptRule.any());\n+    }\n+\n+    /**\n+     * Get operand matching a node with specific child node.\n+     *\n+     * @param cls Node class.\n+     * @param childCls Child node class.\n+     * @param convention Convention.\n+     * @return Operand.\n+     */\n+    public static <R1 extends RelNode, R2 extends RelNode> RelOptRuleOperand parentChild(Class<R1> cls,\n+        Class<R2> childCls, Convention convention) {\n+        RelOptRuleOperand childOperand = RelOptRule.operand(childCls, RelOptRule.any());\n+\n+        return RelOptRule.operand(cls, convention, RelOptRule.some(childOperand));\n+    }\n+\n+    /**\n+     * Add a single trait to the trait set.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param trait Trait to add.\n+     * @return Resulting trait set.\n+     */\n+    public static RelTraitSet traitPlus(RelTraitSet traitSet, RelTrait trait) {\n+        return traitSet.plus(trait).simplify();\n+    }\n+\n+    /**\n+     * Add two traits to the trait set.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param trait1 Trait to add.\n+     * @param trait2 Trait to add.\n+     * @return Resulting trait set.\n+     */\n+    public static RelTraitSet traitPlus(RelTraitSet traitSet, RelTrait trait1, RelTrait trait2) {\n+        return traitSet.plus(trait1).plus(trait2).simplify();\n+    }\n+\n+    /**\n+     * Convert the given trait set to logical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @return New trait set with logical convention.\n+     */\n+    public static RelTraitSet toLogicalConvention(RelTraitSet traitSet) {\n+        return traitPlus(traitSet, HazelcastConventions.LOGICAL);\n+    }\n+\n+    /**\n+     * Convert the given input into logical input.\n+     *\n+     * @param input Original input.\n+     * @return Logical input.\n+     */\n+    public static RelNode toLogicalInput(RelNode input) {\n+        return convert(input, toLogicalConvention(input.getTraitSet()));\n+    }\n+\n+    /**\n+     * Convert the given trait set to physical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @return New trait set with physical convention and provided distribution.\n+     */\n+    public static RelTraitSet toPhysicalConvention(RelTraitSet traitSet) {\n+        return traitPlus(traitSet, HazelcastConventions.PHYSICAL);\n+    }\n+\n+    /**\n+     * Convert the given trait set to physical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param distribution Distribution.\n+     * @return New trait set with physical convention and provided distribution.\n+     */\n+    public static RelTraitSet toPhysicalConvention(RelTraitSet traitSet, DistributionTrait distribution) {\n+        return traitPlus(traitSet, HazelcastConventions.PHYSICAL, distribution);\n+    }\n+\n+    /**\n+     * Convert the given input into physical input.\n+     *\n+     * @param input Original input.\n+     * @return Logical input.\n+     */\n+    public static RelNode toPhysicalInput(RelNode input) {\n+        return convert(input, toPhysicalConvention(input.getTraitSet()));\n+    }\n+\n+    /**\n+     * Convert the given input into physical input.\n+     *\n+     * @param input Original input.\n+     * @param distribution Distribution.\n+     * @return Logical input.\n+     */\n+    public static RelNode toPhysicalInput(RelNode input, DistributionTrait distribution) {\n+        return convert(input, toPhysicalConvention(input.getTraitSet(), distribution));\n+    }\n+\n+    /**\n+     * @param rel Node.\n+     * @return {@code True} if the given node is physical node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30af12c8de6320fae0134e780c62d5b8c294ab15"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxOTUxMw==", "bodyText": "Too late, it is merged. I'll fix it in the next PR. Bad habit from Apache Ignite days - we had such word as a requirement to code styling :-)", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435719513", "createdAt": "2020-06-05T06:42:50Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTraitDef;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.ConventionTraitDef;\n+import org.apache.calcite.plan.HazelcastRelOptCluster;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelTrait;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+\n+import static org.apache.calcite.plan.RelOptRule.convert;\n+\n+/**\n+ * Utility methods for rules.\n+ */\n+public final class OptUtils {\n+    private OptUtils() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Get operand matching a single node.\n+     *\n+     * @param cls Node class.\n+     * @param convention Convention.\n+     * @return Operand.\n+     */\n+    public static <R extends RelNode> RelOptRuleOperand single(Class<R> cls, Convention convention) {\n+        return RelOptRule.operand(cls, convention, RelOptRule.any());\n+    }\n+\n+    /**\n+     * Get operand matching a node with specific child node.\n+     *\n+     * @param cls Node class.\n+     * @param childCls Child node class.\n+     * @param convention Convention.\n+     * @return Operand.\n+     */\n+    public static <R1 extends RelNode, R2 extends RelNode> RelOptRuleOperand parentChild(Class<R1> cls,\n+        Class<R2> childCls, Convention convention) {\n+        RelOptRuleOperand childOperand = RelOptRule.operand(childCls, RelOptRule.any());\n+\n+        return RelOptRule.operand(cls, convention, RelOptRule.some(childOperand));\n+    }\n+\n+    /**\n+     * Add a single trait to the trait set.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param trait Trait to add.\n+     * @return Resulting trait set.\n+     */\n+    public static RelTraitSet traitPlus(RelTraitSet traitSet, RelTrait trait) {\n+        return traitSet.plus(trait).simplify();\n+    }\n+\n+    /**\n+     * Add two traits to the trait set.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param trait1 Trait to add.\n+     * @param trait2 Trait to add.\n+     * @return Resulting trait set.\n+     */\n+    public static RelTraitSet traitPlus(RelTraitSet traitSet, RelTrait trait1, RelTrait trait2) {\n+        return traitSet.plus(trait1).plus(trait2).simplify();\n+    }\n+\n+    /**\n+     * Convert the given trait set to logical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @return New trait set with logical convention.\n+     */\n+    public static RelTraitSet toLogicalConvention(RelTraitSet traitSet) {\n+        return traitPlus(traitSet, HazelcastConventions.LOGICAL);\n+    }\n+\n+    /**\n+     * Convert the given input into logical input.\n+     *\n+     * @param input Original input.\n+     * @return Logical input.\n+     */\n+    public static RelNode toLogicalInput(RelNode input) {\n+        return convert(input, toLogicalConvention(input.getTraitSet()));\n+    }\n+\n+    /**\n+     * Convert the given trait set to physical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @return New trait set with physical convention and provided distribution.\n+     */\n+    public static RelTraitSet toPhysicalConvention(RelTraitSet traitSet) {\n+        return traitPlus(traitSet, HazelcastConventions.PHYSICAL);\n+    }\n+\n+    /**\n+     * Convert the given trait set to physical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param distribution Distribution.\n+     * @return New trait set with physical convention and provided distribution.\n+     */\n+    public static RelTraitSet toPhysicalConvention(RelTraitSet traitSet, DistributionTrait distribution) {\n+        return traitPlus(traitSet, HazelcastConventions.PHYSICAL, distribution);\n+    }\n+\n+    /**\n+     * Convert the given input into physical input.\n+     *\n+     * @param input Original input.\n+     * @return Logical input.\n+     */\n+    public static RelNode toPhysicalInput(RelNode input) {\n+        return convert(input, toPhysicalConvention(input.getTraitSet()));\n+    }\n+\n+    /**\n+     * Convert the given input into physical input.\n+     *\n+     * @param input Original input.\n+     * @param distribution Distribution.\n+     * @return Logical input.\n+     */\n+    public static RelNode toPhysicalInput(RelNode input, DistributionTrait distribution) {\n+        return convert(input, toPhysicalConvention(input.getTraitSet(), distribution));\n+    }\n+\n+    /**\n+     * @param rel Node.\n+     * @return {@code True} if the given node is physical node.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDU4Mg=="}, "originalCommit": {"oid": "30af12c8de6320fae0134e780c62d5b8c294ab15"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTM5NjQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/Cost.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDowNzowNVrOGfHvrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjo0NDoxNlrOGfiPVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTkzNA==", "bodyText": "Maybe IllegalStateException is more appropriate here?", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435285934", "createdAt": "2020-06-04T14:07:05Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/Cost.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.cost;\n+\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptUtil;\n+\n+/**\n+ * Cost of relational operator.\n+ * <p>\n+ * We use our own implementation instead of the one provided by Apache Calcite. In Apache Calcite, the cost is a vector of\n+ * three values - row count, CPU and IO. First, it has some problems with comparison semantics [1]. Second, its comparison\n+ * depends mostly on row count, while in our case other factors, such as network, are more important. Last, it has a\n+ * number of methods and variables that are otherwise unused (or mostly unused).\n+ * <p>\n+ * Our implementation still tracks row count, CPU and network, but it doesn't implement unnecessary methods, has proper\n+ * comparison semantics, and use CPU and network for cost comparison instead row count.\n+ * <p>\n+ * [1] https://issues.apache.org/jira/browse/CALCITE-3956\n+ */\n+public class Cost implements RelOptCost {\n+\n+    public static final Cost ZERO = new Cost(0.0d, 0.0d, 0.0d);\n+    public static final Cost TINY = new Cost(1.0d, 1.0d, 0.0d);\n+    public static final Cost HUGE = new Cost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);\n+    public static final Cost INFINITY = new Cost(Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+    private final double rows;\n+    private final double cpu;\n+    private final double network;\n+\n+    Cost(double rows, double cpu, double network) {\n+        this.rows = rows;\n+        this.cpu = cpu;\n+        this.network = network;\n+    }\n+\n+    public double getRowsInternal() {\n+        return rows;\n+    }\n+\n+    public double getCpuInternal() {\n+        return cpu;\n+    }\n+\n+    public double getNetworkInternal() {\n+        return network;\n+    }\n+\n+    @Override\n+    public double getRows() {\n+        // Make sure that Calcite doesn't rely on our values.\n+        throw new UnsupportedOperationException(\"Should not be called.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30af12c8de6320fae0134e780c62d5b8c294ab15"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMDAyMg==", "bodyText": "Invocations of this method are located deep inside Apache Calcite internals, so a specific exception type should not make much difference.", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435720022", "createdAt": "2020-06-05T06:44:16Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/Cost.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.cost;\n+\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptUtil;\n+\n+/**\n+ * Cost of relational operator.\n+ * <p>\n+ * We use our own implementation instead of the one provided by Apache Calcite. In Apache Calcite, the cost is a vector of\n+ * three values - row count, CPU and IO. First, it has some problems with comparison semantics [1]. Second, its comparison\n+ * depends mostly on row count, while in our case other factors, such as network, are more important. Last, it has a\n+ * number of methods and variables that are otherwise unused (or mostly unused).\n+ * <p>\n+ * Our implementation still tracks row count, CPU and network, but it doesn't implement unnecessary methods, has proper\n+ * comparison semantics, and use CPU and network for cost comparison instead row count.\n+ * <p>\n+ * [1] https://issues.apache.org/jira/browse/CALCITE-3956\n+ */\n+public class Cost implements RelOptCost {\n+\n+    public static final Cost ZERO = new Cost(0.0d, 0.0d, 0.0d);\n+    public static final Cost TINY = new Cost(1.0d, 1.0d, 0.0d);\n+    public static final Cost HUGE = new Cost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);\n+    public static final Cost INFINITY = new Cost(Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+    private final double rows;\n+    private final double cpu;\n+    private final double network;\n+\n+    Cost(double rows, double cpu, double network) {\n+        this.rows = rows;\n+        this.cpu = cpu;\n+        this.network = network;\n+    }\n+\n+    public double getRowsInternal() {\n+        return rows;\n+    }\n+\n+    public double getCpuInternal() {\n+        return cpu;\n+    }\n+\n+    public double getNetworkInternal() {\n+        return network;\n+    }\n+\n+    @Override\n+    public double getRows() {\n+        // Make sure that Calcite doesn't rely on our values.\n+        throw new UnsupportedOperationException(\"Should not be called.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTkzNA=="}, "originalCommit": {"oid": "30af12c8de6320fae0134e780c62d5b8c294ab15"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 561, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}