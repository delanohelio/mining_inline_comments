{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NTA5MTM0", "number": 16963, "title": "SQL DDL prototype", "bodyText": "", "createdAt": "2020-05-07T07:27:30Z", "url": "https://github.com/hazelcast/hazelcast/pull/16963", "merged": true, "mergeCommit": {"oid": "fe5541220c0ba6fc03d3ebe665ea578fc822adfe"}, "closed": true, "closedAt": "2020-05-08T08:12:42Z", "author": {"login": "gierlachg"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcctSUfAH2gAyNDE0NTA5MTM0OjU5MjRiNjI4M2U2OTZlMjY1NTZkYTVhNmQ0ZDJlNTA4ZjlkNTE4MWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfNWedgFqTQwODA3NjIzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5924b6283e696e26556da5a6d4d2e508f9d5181b", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5924b6283e696e26556da5a6d4d2e508f9d5181b", "committedDate": "2020-04-30T13:41:42Z", "message": "Parse CREATE/DROP TABLE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48162e6580a9d39884e6779b4d7ac85fa5cc3b22", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/48162e6580a9d39884e6779b4d7ac85fa5cc3b22", "committedDate": "2020-05-04T06:39:37Z", "message": "Merge branch 'sql' into ddl\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/OptimizerContext.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a94d1e05af084b4ec5a71c954fe662fd4f5fafd", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2a94d1e05af084b4ec5a71c954fe662fd4f5fafd", "committedDate": "2020-05-04T08:02:42Z", "message": "Naming & update interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c88067ca66136354598ac3be5183d4c10647dab", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5c88067ca66136354598ac3be5183d4c10647dab", "committedDate": "2020-05-05T12:20:41Z", "message": "Add support for user defined tables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b519267aae7bf5d586d9e2c3e129d358daa6598b", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b519267aae7bf5d586d9e2c3e129d358daa6598b", "committedDate": "2020-05-05T12:57:10Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9e2610711eb56603ca9124b53e8c8b81c1244bb", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f9e2610711eb56603ca9124b53e8c8b81c1244bb", "committedDate": "2020-05-06T10:10:47Z", "message": "Create user defined tables under default schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "554b9f1e2abce00bc8f0d507391a707e0cd1b0fa", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/554b9f1e2abce00bc8f0d507391a707e0cd1b0fa", "committedDate": "2020-05-06T10:18:06Z", "message": "Merge branch 'sql' into ddl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2bc6afe604281abb35f445635e009028fdc066d", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a2bc6afe604281abb35f445635e009028fdc066d", "committedDate": "2020-05-06T10:24:52Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1d241f0a231dd03ad491057735b206e46b60179", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a1d241f0a231dd03ad491057735b206e46b60179", "committedDate": "2020-05-06T11:22:58Z", "message": "Evolving table schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89596c3b01fbcde1cee11c3e9ff57b77071b85ae", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/89596c3b01fbcde1cee11c3e9ff57b77071b85ae", "committedDate": "2020-05-06T12:03:19Z", "message": "Add schema dsitribution test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "814b8e52f7bc8c250b1520f2bdbed4d98cfbfe92", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/814b8e52f7bc8c250b1520f2bdbed4d98cfbfe92", "committedDate": "2020-05-06T12:05:32Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec79988d281f09830ae8c58db92b5b2211615421", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ec79988d281f09830ae8c58db92b5b2211615421", "committedDate": "2020-05-06T13:07:42Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03549967693f17ec359ab425fcd59cf2e6452e85", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/03549967693f17ec359ab425fcd59cf2e6452e85", "committedDate": "2020-05-06T14:10:42Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0843cdb221f550cd558c604770dde6e012eb4eac", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0843cdb221f550cd558c604770dde6e012eb4eac", "committedDate": "2020-05-07T07:22:02Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f2ce834e8c1e4da631031bf0261443d7a7e3830", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9f2ce834e8c1e4da631031bf0261443d7a7e3830", "committedDate": "2020-05-07T07:52:17Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MzAzMzU4", "url": "https://github.com/hazelcast/hazelcast/pull/16963#pullrequestreview-407303358", "createdAt": "2020-05-07T09:30:51Z", "commit": {"oid": "0843cdb221f550cd558c604770dde6e012eb4eac"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMDo1MVrOGR2UVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMzowN1rOGR2Z4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2ODkxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (variant == null) {\n          \n          \n            \n                                if (variant == null || \"OFFSET_DATE_TIME\".equals(variant.getSimple()) {", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421368916", "createdAt": "2020-05-07T09:30:51Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/codegen/includes/parserImpls.ftl", "diffHunk": "@@ -0,0 +1,312 @@\n+<#--\n+// Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+-->\n+\n+/**\n+* Parses CREATE EXTERNAL TABLE statement.\n+*/\n+SqlCreate SqlCreateTable(Span span, boolean replace) :\n+{\n+    SqlParserPos startPos = span.pos();\n+\n+    SqlIdentifier name;\n+    boolean ifNotExists = false;\n+    SqlNodeList columns = SqlNodeList.EMPTY;\n+    SqlIdentifier type;\n+    SqlNodeList sqlOptions = SqlNodeList.EMPTY;\n+}\n+{\n+    <EXTERNAL> <TABLE>\n+    [\n+        <IF> <NOT> <EXISTS> { ifNotExists = true; }\n+    ]\n+    name = SimpleIdentifier()\n+    columns = TableColumns()\n+    <TYPE>\n+    type = SimpleIdentifier()\n+    [\n+        <OPTIONS>\n+        sqlOptions = SqlOptions()\n+    ]\n+    {\n+        return new SqlCreateTable(\n+            name,\n+            columns,\n+            type,\n+            sqlOptions,\n+            replace,\n+            ifNotExists,\n+            startPos.plus(getPos())\n+        );\n+    }\n+}\n+\n+SqlNodeList TableColumns():\n+{\n+    Span span;\n+\n+    Map<String, SqlNode> columns = new LinkedHashMap<String, SqlNode>();\n+    SqlTableColumn column;\n+}\n+{\n+    <LPAREN> { span = span(); }\n+    column = TableColumn()\n+    {\n+        columns.put(column.name(), column);\n+    }\n+    (\n+        <COMMA> column = TableColumn()\n+        {\n+            if (columns.putIfAbsent(column.name(), column) != null) {\n+               throw SqlUtil.newContextException(getPos(),\n+                   ParserResource.RESOURCE.duplicateColumn(column.name()));\n+            }\n+        }\n+    )*\n+    <RPAREN>\n+    {\n+        return new SqlNodeList(columns.values(), span.end(this));\n+    }\n+}\n+\n+SqlTableColumn TableColumn() :\n+{\n+    Span span;\n+\n+    SqlIdentifier name;\n+    SqlDataType type;\n+}\n+{\n+    name = SimpleIdentifier() { span = span(); }\n+    type = SqlDataType()\n+    {\n+        return new SqlTableColumn(name, type, span.end(this));\n+    }\n+}\n+\n+SqlDataType SqlDataType() :\n+{\n+    Span span;\n+\n+    QueryDataType type;\n+}\n+{\n+    type = QueryDataType() { span = span(); }\n+    {\n+        return new SqlDataType(type, span.end(this));\n+    }\n+}\n+\n+QueryDataType QueryDataType() :\n+{\n+    QueryDataType type;\n+}\n+{\n+    (\n+        type = NumericType()\n+    |\n+        type = CharacterType()\n+    |\n+        type = DateTimeType()\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType NumericType() :\n+{\n+    QueryDataType type;\n+    int precision = -1;\n+    int scale = -1;\n+}\n+{\n+    (\n+        <BOOLEAN> { type = QueryDataType.BOOLEAN; }\n+    |\n+        <TINYINT> { type = QueryDataType.TINYINT; }\n+    |\n+        <SMALLINT> { type = QueryDataType.SMALLINT; }\n+    |\n+        (<INTEGER> | <INT>) { type = QueryDataType.INT; }\n+    |\n+        <BIGINT> { type = QueryDataType.BIGINT; }\n+    |\n+        (<REAL> | <FLOAT>) { type = QueryDataType.REAL; }\n+    |\n+        <DOUBLE> [ <PRECISION> ] { type = QueryDataType.DOUBLE; }\n+    |\n+        (<DECIMAL> | <DEC> | <NUMERIC>)\n+        [\n+            <LPAREN>\n+            precision = UnsignedIntLiteral()\n+            [\n+                <COMMA>\n+                scale = UnsignedIntLiteral()\n+            ]\n+            <RPAREN>\n+        ] { type = scale > 0 ? QueryDataType.DECIMAL : QueryDataType.DECIMAL_BIG_INTEGER; }\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType CharacterType() :\n+{\n+    QueryDataType type;\n+}\n+{\n+    (\n+        (<CHARACTER> | <CHAR>)\n+        (\n+            <VARYING> { type = QueryDataType.VARCHAR; }\n+        |\n+            { type = QueryDataType.VARCHAR_CHARACTER; }\n+        )\n+    |\n+        <VARCHAR> { type = QueryDataType.VARCHAR; }\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType DateTimeType() :\n+{\n+    QueryDataType type;\n+    SqlIdentifier variant = null;\n+}\n+{\n+    (\n+        <TIME> { type = QueryDataType.TIME; }\n+    |\n+        <DATE> { type = QueryDataType.DATE; }\n+    |\n+        <TIMESTAMP>\n+        (\n+            <WITH>\n+            (\n+                <TIME> <ZONE>\n+                [\n+                    <LPAREN> variant = SimpleIdentifier() <RPAREN>\n+                ]\n+                {\n+                    if (variant == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0843cdb221f550cd558c604770dde6e012eb4eac"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTM3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (variant == null) {\n          \n          \n            \n                                if (variant == null || \"INSTANT\".equals(variant.getSimple()) {", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421369370", "createdAt": "2020-05-07T09:31:35Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/codegen/includes/parserImpls.ftl", "diffHunk": "@@ -0,0 +1,312 @@\n+<#--\n+// Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+-->\n+\n+/**\n+* Parses CREATE EXTERNAL TABLE statement.\n+*/\n+SqlCreate SqlCreateTable(Span span, boolean replace) :\n+{\n+    SqlParserPos startPos = span.pos();\n+\n+    SqlIdentifier name;\n+    boolean ifNotExists = false;\n+    SqlNodeList columns = SqlNodeList.EMPTY;\n+    SqlIdentifier type;\n+    SqlNodeList sqlOptions = SqlNodeList.EMPTY;\n+}\n+{\n+    <EXTERNAL> <TABLE>\n+    [\n+        <IF> <NOT> <EXISTS> { ifNotExists = true; }\n+    ]\n+    name = SimpleIdentifier()\n+    columns = TableColumns()\n+    <TYPE>\n+    type = SimpleIdentifier()\n+    [\n+        <OPTIONS>\n+        sqlOptions = SqlOptions()\n+    ]\n+    {\n+        return new SqlCreateTable(\n+            name,\n+            columns,\n+            type,\n+            sqlOptions,\n+            replace,\n+            ifNotExists,\n+            startPos.plus(getPos())\n+        );\n+    }\n+}\n+\n+SqlNodeList TableColumns():\n+{\n+    Span span;\n+\n+    Map<String, SqlNode> columns = new LinkedHashMap<String, SqlNode>();\n+    SqlTableColumn column;\n+}\n+{\n+    <LPAREN> { span = span(); }\n+    column = TableColumn()\n+    {\n+        columns.put(column.name(), column);\n+    }\n+    (\n+        <COMMA> column = TableColumn()\n+        {\n+            if (columns.putIfAbsent(column.name(), column) != null) {\n+               throw SqlUtil.newContextException(getPos(),\n+                   ParserResource.RESOURCE.duplicateColumn(column.name()));\n+            }\n+        }\n+    )*\n+    <RPAREN>\n+    {\n+        return new SqlNodeList(columns.values(), span.end(this));\n+    }\n+}\n+\n+SqlTableColumn TableColumn() :\n+{\n+    Span span;\n+\n+    SqlIdentifier name;\n+    SqlDataType type;\n+}\n+{\n+    name = SimpleIdentifier() { span = span(); }\n+    type = SqlDataType()\n+    {\n+        return new SqlTableColumn(name, type, span.end(this));\n+    }\n+}\n+\n+SqlDataType SqlDataType() :\n+{\n+    Span span;\n+\n+    QueryDataType type;\n+}\n+{\n+    type = QueryDataType() { span = span(); }\n+    {\n+        return new SqlDataType(type, span.end(this));\n+    }\n+}\n+\n+QueryDataType QueryDataType() :\n+{\n+    QueryDataType type;\n+}\n+{\n+    (\n+        type = NumericType()\n+    |\n+        type = CharacterType()\n+    |\n+        type = DateTimeType()\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType NumericType() :\n+{\n+    QueryDataType type;\n+    int precision = -1;\n+    int scale = -1;\n+}\n+{\n+    (\n+        <BOOLEAN> { type = QueryDataType.BOOLEAN; }\n+    |\n+        <TINYINT> { type = QueryDataType.TINYINT; }\n+    |\n+        <SMALLINT> { type = QueryDataType.SMALLINT; }\n+    |\n+        (<INTEGER> | <INT>) { type = QueryDataType.INT; }\n+    |\n+        <BIGINT> { type = QueryDataType.BIGINT; }\n+    |\n+        (<REAL> | <FLOAT>) { type = QueryDataType.REAL; }\n+    |\n+        <DOUBLE> [ <PRECISION> ] { type = QueryDataType.DOUBLE; }\n+    |\n+        (<DECIMAL> | <DEC> | <NUMERIC>)\n+        [\n+            <LPAREN>\n+            precision = UnsignedIntLiteral()\n+            [\n+                <COMMA>\n+                scale = UnsignedIntLiteral()\n+            ]\n+            <RPAREN>\n+        ] { type = scale > 0 ? QueryDataType.DECIMAL : QueryDataType.DECIMAL_BIG_INTEGER; }\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType CharacterType() :\n+{\n+    QueryDataType type;\n+}\n+{\n+    (\n+        (<CHARACTER> | <CHAR>)\n+        (\n+            <VARYING> { type = QueryDataType.VARCHAR; }\n+        |\n+            { type = QueryDataType.VARCHAR_CHARACTER; }\n+        )\n+    |\n+        <VARCHAR> { type = QueryDataType.VARCHAR; }\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType DateTimeType() :\n+{\n+    QueryDataType type;\n+    SqlIdentifier variant = null;\n+}\n+{\n+    (\n+        <TIME> { type = QueryDataType.TIME; }\n+    |\n+        <DATE> { type = QueryDataType.DATE; }\n+    |\n+        <TIMESTAMP>\n+        (\n+            <WITH>\n+            (\n+                <TIME> <ZONE>\n+                [\n+                    <LPAREN> variant = SimpleIdentifier() <RPAREN>\n+                ]\n+                {\n+                    if (variant == null) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME;\n+                    } else if (\"ZONED_DATE_TIME\".equalsIgnoreCase(variant.getSimple())) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_ZONED_DATE_TIME;\n+                    } else if (\"CALENDAR\".equalsIgnoreCase(variant.getSimple())) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_CALENDAR;\n+                    } else {\n+                        throw SqlUtil.newContextException(getPos(),\n+                            ParserResource.RESOURCE.unknownTimestampVariant(variant.getSimple()));\n+                    }\n+                }\n+            |\n+                <LOCAL> <TIME> <ZONE>\n+                [\n+                    <LPAREN> variant = SimpleIdentifier() <RPAREN>\n+                ]\n+                {\n+                    if (variant == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0843cdb221f550cd558c604770dde6e012eb4eac"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MDMzOQ==", "bodyText": "This should be also the default when just TIMESTAMP is used without any TIME ZONE clause", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421370339", "createdAt": "2020-05-07T09:33:07Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/codegen/includes/parserImpls.ftl", "diffHunk": "@@ -0,0 +1,312 @@\n+<#--\n+// Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+-->\n+\n+/**\n+* Parses CREATE EXTERNAL TABLE statement.\n+*/\n+SqlCreate SqlCreateTable(Span span, boolean replace) :\n+{\n+    SqlParserPos startPos = span.pos();\n+\n+    SqlIdentifier name;\n+    boolean ifNotExists = false;\n+    SqlNodeList columns = SqlNodeList.EMPTY;\n+    SqlIdentifier type;\n+    SqlNodeList sqlOptions = SqlNodeList.EMPTY;\n+}\n+{\n+    <EXTERNAL> <TABLE>\n+    [\n+        <IF> <NOT> <EXISTS> { ifNotExists = true; }\n+    ]\n+    name = SimpleIdentifier()\n+    columns = TableColumns()\n+    <TYPE>\n+    type = SimpleIdentifier()\n+    [\n+        <OPTIONS>\n+        sqlOptions = SqlOptions()\n+    ]\n+    {\n+        return new SqlCreateTable(\n+            name,\n+            columns,\n+            type,\n+            sqlOptions,\n+            replace,\n+            ifNotExists,\n+            startPos.plus(getPos())\n+        );\n+    }\n+}\n+\n+SqlNodeList TableColumns():\n+{\n+    Span span;\n+\n+    Map<String, SqlNode> columns = new LinkedHashMap<String, SqlNode>();\n+    SqlTableColumn column;\n+}\n+{\n+    <LPAREN> { span = span(); }\n+    column = TableColumn()\n+    {\n+        columns.put(column.name(), column);\n+    }\n+    (\n+        <COMMA> column = TableColumn()\n+        {\n+            if (columns.putIfAbsent(column.name(), column) != null) {\n+               throw SqlUtil.newContextException(getPos(),\n+                   ParserResource.RESOURCE.duplicateColumn(column.name()));\n+            }\n+        }\n+    )*\n+    <RPAREN>\n+    {\n+        return new SqlNodeList(columns.values(), span.end(this));\n+    }\n+}\n+\n+SqlTableColumn TableColumn() :\n+{\n+    Span span;\n+\n+    SqlIdentifier name;\n+    SqlDataType type;\n+}\n+{\n+    name = SimpleIdentifier() { span = span(); }\n+    type = SqlDataType()\n+    {\n+        return new SqlTableColumn(name, type, span.end(this));\n+    }\n+}\n+\n+SqlDataType SqlDataType() :\n+{\n+    Span span;\n+\n+    QueryDataType type;\n+}\n+{\n+    type = QueryDataType() { span = span(); }\n+    {\n+        return new SqlDataType(type, span.end(this));\n+    }\n+}\n+\n+QueryDataType QueryDataType() :\n+{\n+    QueryDataType type;\n+}\n+{\n+    (\n+        type = NumericType()\n+    |\n+        type = CharacterType()\n+    |\n+        type = DateTimeType()\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType NumericType() :\n+{\n+    QueryDataType type;\n+    int precision = -1;\n+    int scale = -1;\n+}\n+{\n+    (\n+        <BOOLEAN> { type = QueryDataType.BOOLEAN; }\n+    |\n+        <TINYINT> { type = QueryDataType.TINYINT; }\n+    |\n+        <SMALLINT> { type = QueryDataType.SMALLINT; }\n+    |\n+        (<INTEGER> | <INT>) { type = QueryDataType.INT; }\n+    |\n+        <BIGINT> { type = QueryDataType.BIGINT; }\n+    |\n+        (<REAL> | <FLOAT>) { type = QueryDataType.REAL; }\n+    |\n+        <DOUBLE> [ <PRECISION> ] { type = QueryDataType.DOUBLE; }\n+    |\n+        (<DECIMAL> | <DEC> | <NUMERIC>)\n+        [\n+            <LPAREN>\n+            precision = UnsignedIntLiteral()\n+            [\n+                <COMMA>\n+                scale = UnsignedIntLiteral()\n+            ]\n+            <RPAREN>\n+        ] { type = scale > 0 ? QueryDataType.DECIMAL : QueryDataType.DECIMAL_BIG_INTEGER; }\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType CharacterType() :\n+{\n+    QueryDataType type;\n+}\n+{\n+    (\n+        (<CHARACTER> | <CHAR>)\n+        (\n+            <VARYING> { type = QueryDataType.VARCHAR; }\n+        |\n+            { type = QueryDataType.VARCHAR_CHARACTER; }\n+        )\n+    |\n+        <VARCHAR> { type = QueryDataType.VARCHAR; }\n+    )\n+    {\n+        return type;\n+    }\n+}\n+\n+QueryDataType DateTimeType() :\n+{\n+    QueryDataType type;\n+    SqlIdentifier variant = null;\n+}\n+{\n+    (\n+        <TIME> { type = QueryDataType.TIME; }\n+    |\n+        <DATE> { type = QueryDataType.DATE; }\n+    |\n+        <TIMESTAMP>\n+        (\n+            <WITH>\n+            (\n+                <TIME> <ZONE>\n+                [\n+                    <LPAREN> variant = SimpleIdentifier() <RPAREN>\n+                ]\n+                {\n+                    if (variant == null) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME;\n+                    } else if (\"ZONED_DATE_TIME\".equalsIgnoreCase(variant.getSimple())) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_ZONED_DATE_TIME;\n+                    } else if (\"CALENDAR\".equalsIgnoreCase(variant.getSimple())) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_CALENDAR;\n+                    } else {\n+                        throw SqlUtil.newContextException(getPos(),\n+                            ParserResource.RESOURCE.unknownTimestampVariant(variant.getSimple()));\n+                    }\n+                }\n+            |\n+                <LOCAL> <TIME> <ZONE>\n+                [\n+                    <LPAREN> variant = SimpleIdentifier() <RPAREN>\n+                ]\n+                {\n+                    if (variant == null) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_INSTANT;\n+                    } else if (\"DATE\".equalsIgnoreCase(variant.getSimple())) {\n+                        type = QueryDataType.TIMESTAMP_WITH_TZ_DATE;\n+                    } else {\n+                        throw SqlUtil.newContextException(getPos(),\n+                            ParserResource.RESOURCE.unknownTimestampVariant(variant.getSimple()));\n+                    }\n+                }\n+            )\n+        |\n+            <WITHOUT> <TIME> <ZONE> { type = QueryDataType.TIMESTAMP; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0843cdb221f550cd558c604770dde6e012eb4eac"}, "originalPosition": 235}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361d5ef9e06b039503635b7a50ed5d0a77e5623d", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/361d5ef9e06b039503635b7a50ed5d0a77e5623d", "committedDate": "2020-05-07T10:08:35Z", "message": "Merge branch 'sql' into ddl\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/ExecutionConfig.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/ExecutionContext.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/SqlOptimizer.java\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/optimizer/support/OptimizerTestSupport.java\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/tpch/TpcHTest.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/optimizer/NoOpSqlOptimizer.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/optimizer/NotImplementedSqlOptimizer.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/parser/NoOpSqlParser.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/SchemaUtils.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/ReplicatedMapTableResolver.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7724c7c6353744dfe83927a8ebcc402c0f8d8cab", "committedDate": "2020-05-07T10:13:00Z", "message": "Address type parsing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a53f6ab40870badb262c8fc65ae03a98f04d42a", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6a53f6ab40870badb262c8fc65ae03a98f04d42a", "committedDate": "2020-05-07T10:20:52Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "488ef52f954083be43d6b1711e2de2016cb2d467", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/488ef52f954083be43d6b1711e2de2016cb2d467", "committedDate": "2020-05-07T10:21:15Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MzM5MzUy", "url": "https://github.com/hazelcast/hazelcast/pull/16963#pullrequestreview-407339352", "createdAt": "2020-05-07T10:20:35Z", "commit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDoyMDozNlrOGR4HMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozNDozOFrOGR4ksA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5ODMyMg==", "bodyText": "I propose to avoid renames of the central classes unless there is a strong reason to. In this specific case, parsing is a part of optimization process, not vice versa.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421398322", "createdAt": "2020-05-07T10:20:36Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/optimizer/SqlOptimizer.java", "diffHunk": "@@ -14,77 +14,50 @@\n  * limitations under the License.\n  */\n \n-package com.hazelcast.sql.impl.calcite;\n+package com.hazelcast.sql.impl.calcite.optimizer;\n \n-import com.hazelcast.cluster.memberselector.MemberSelectors;\n import com.hazelcast.internal.util.collection.PartitionIdSet;\n import com.hazelcast.partition.Partition;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.calcite.ExecutionContext;\n import com.hazelcast.sql.impl.calcite.opt.logical.LogicalRel;\n import com.hazelcast.sql.impl.calcite.opt.physical.PhysicalRel;\n import com.hazelcast.sql.impl.calcite.opt.physical.visitor.NodeIdVisitor;\n import com.hazelcast.sql.impl.calcite.opt.physical.visitor.PlanCreateVisitor;\n import com.hazelcast.sql.impl.calcite.opt.physical.visitor.SqlToQueryType;\n import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n-import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n-import com.hazelcast.sql.impl.optimizer.SqlOptimizer;\n import com.hazelcast.sql.impl.plan.Plan;\n-import com.hazelcast.sql.impl.schema.TableResolver;\n-import com.hazelcast.sql.impl.schema.map.PartitionedMapTableResolver;\n-import com.hazelcast.sql.impl.schema.map.ReplicatedMapTableResolver;\n import com.hazelcast.sql.impl.type.QueryDataType;\n import org.apache.calcite.rel.RelNode;\n import org.apache.calcite.rel.type.RelDataType;\n \n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.UUID;\n \n-/**\n- * Calcite-based SQL optimizer.\n- */\n-@SuppressWarnings(\"checkstyle:ClassDataAbstractionCoupling\")\n-public class CalciteSqlOptimizer implements SqlOptimizer {\n+public class SqlOptimizer {\n     /** Node engine. */\n     private final NodeEngine nodeEngine;\n \n-    public CalciteSqlOptimizer(NodeEngine nodeEngine) {\n+    public SqlOptimizer(NodeEngine nodeEngine) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMDU4OQ==", "bodyText": "We cannot use empty schema names. A classical object hierarchy is catalog -> schema -> object. Every such an object should have a definitive name for several reasons:\n\nThey need to be displayed somehow in tools that will talk to us through JDBC\nIt should be possible to reach any object from any naming context. With empty schema name, some objects may become unreachable\n\nOther vendors typically have a default schema name PUBLIC or alike.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421400589", "createdAt": "2020-05-07T10:24:49Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastSchemaUtils.java", "diffHunk": "@@ -65,30 +68,33 @@ public static HazelcastSchema createRootSchema(List<TableResolver> tableResolver\n \n             for (Table table : tables) {\n                 HazelcastTable convertedTable = new HazelcastTable(\n-                    table,\n-                    createTableStatistic(table)\n+                        table,\n+                        createTableStatistic(table)\n                 );\n \n-                Map<String , HazelcastTable> schemaTableMap =\n-                    tableMap.computeIfAbsent(table.getSchemaName(), (k) -> new HashMap<>());\n+                if (table.getSchemaName() == null || table.getSchemaName().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMjQ2OA==", "bodyText": "I am not very keen on having such methods on public API because it increases complexity for users and we need a common method that handles all query types anyway, because otherwise, we will not be able to integrate JDBC.\nIs there a reason why the existing method or at least re-use of SqlQuery is not applicable for an update operation?", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421402468", "createdAt": "2020-05-07T10:28:24Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlService.java", "diffHunk": "@@ -49,4 +50,22 @@ default SqlCursor query(String sql, Object... params) {\n      * @return Cursor.\n      */\n     SqlCursor query(SqlQuery query);\n+\n+    /**\n+     * Execute update.\n+     *\n+     * @param sql SQL.\n+     */\n+    default void update(String sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNTAwNg==", "bodyText": "It is not clear why SELECT is wrapped into a DDL class", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421405006", "createdAt": "2020-05-07T10:33:07Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -156,84 +164,106 @@ private SqlCursor query0(String sql, List<Object> params, long timeout, int page\n         }\n \n         if (timeout < 0) {\n-            throw QueryException.error(\"Timeout cannot be negative: \" + pageSize);\n+            throw QueryException.error(\"Timeout cannot be negative: \" + timeout);\n         }\n \n         if (pageSize <= 0) {\n             throw QueryException.error(\"Page size must be positive: \" + pageSize);\n         }\n \n         // Execute.\n-        QueryState state;\n-\n         if (QueryUtils.isExplain(sql)) {\n             String unwrappedSql = QueryUtils.unwrapExplain(sql);\n \n             if (unwrappedSql.isEmpty()) {\n                 throw QueryException.error(\"SQL statement to be explained cannot be empty\");\n             }\n \n-            Plan plan = prepare(unwrappedSql);\n+            DqlStatement operation = prepareQuery(unwrappedSql);\n+            return operation.explain(internalService);\n+        } else {\n+            DqlStatement operation = prepareQuery(sql);\n+            return operation.execute(internalService, params0, timeout, pageSize);\n+        }\n+    }\n \n-            state = internalService.executeExplain(plan);\n+    private DqlStatement prepareQuery(String sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNTg3Mg==", "bodyText": "As mentioned before, the motivation of the rename is not obvious. This underlying implementation is optimizer, not parser.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421405872", "createdAt": "2020-05-07T10:34:38Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/parser/SqlParser.java", "diffHunk": "@@ -14,19 +14,18 @@\n  * limitations under the License.\n  */\n \n-package com.hazelcast.sql.impl.optimizer;\n-\n-import com.hazelcast.sql.impl.plan.Plan;\n+package com.hazelcast.sql.impl.parser;\n \n /**\n- * Optimizer responsible for conversion of SQL string to executable plan.\n+ * Parser responsible for conversion of SQL string to executable statement.\n  */\n-public interface SqlOptimizer {\n+public interface SqlParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7724c7c6353744dfe83927a8ebcc402c0f8d8cab"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea77ee8495ce48a3e31a2b0d559a2b111066e493", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ea77ee8495ce48a3e31a2b0d559a2b111066e493", "committedDate": "2020-05-07T10:37:50Z", "message": "Address type parsing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba22d0c75626bbeafcdc74c7f291590379e1f4ef", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ba22d0c75626bbeafcdc74c7f291590379e1f4ef", "committedDate": "2020-05-07T10:41:55Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a84810b4913aa437ec42caf6534babdd01fb7a", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b8a84810b4913aa437ec42caf6534babdd01fb7a", "committedDate": "2020-05-07T11:28:35Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40353b6a5ec48ca60f33b0a0f9f8591c6427fc38", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/40353b6a5ec48ca60f33b0a0f9f8591c6427fc38", "committedDate": "2020-05-07T12:28:59Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b47b6bfc794d4f2206c6c04f9083ad8c90eddc9b", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b47b6bfc794d4f2206c6c04f9083ad8c90eddc9b", "committedDate": "2020-05-07T12:51:48Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16b223994fa553228fb6f102470a0af3e1606abd", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/16b223994fa553228fb6f102470a0af3e1606abd", "committedDate": "2020-05-07T12:57:10Z", "message": "Merge branch 'sql' into ddl\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/CalciteSqlOptimizer.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/OptimizerContext.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "016bfa3a2c437880ce1074e8c326490486a7bee5", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/016bfa3a2c437880ce1074e8c326490486a7bee5", "committedDate": "2020-05-07T13:07:16Z", "message": "Merge origin/sql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6e3cb4f7f27c8608ee55493e3e8c951e4a5ba8d", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d6e3cb4f7f27c8608ee55493e3e8c951e4a5ba8d", "committedDate": "2020-05-07T13:24:18Z", "message": "Exclude generated sources from spotbugs examination"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/724a617b7a6218b0b7ca26c077cdf8e02e5ff10f", "committedDate": "2020-05-07T14:08:19Z", "message": "Exclude generated calcite sources from spotbugs examination"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NjY3MzM5", "url": "https://github.com/hazelcast/hazelcast/pull/16963#pullrequestreview-407667339", "createdAt": "2020-05-07T17:04:18Z", "commit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNzowNDoxOFrOGSH80g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTo0NToyNVrOGSZ1iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1NzgxMA==", "bodyText": "As you mentioned in the TODO, I also do not think that we need it at the moment, given that tables are already exposed.  Moreover, this is not an \"external\" object for the cluster. I would remove it for now and return back if we have any indication that it is needed.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421657810", "createdAt": "2020-05-07T17:04:18Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/connector/PartitionedMapConnector.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.connector;\n+\n+import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.TableSchema.Field;\n+import com.hazelcast.sql.impl.schema.map.MapTableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.hazelcast.sql.impl.schema.map.PartitionedMapTable.DISTRIBUTION_FIELD_ORDINAL_NONE;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+// TODO: do we want to keep it? maps are auto discovered...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODM4Mg==", "bodyText": "Minor: we may need table options here in the future, but for the sake of prototyping this is not relevant.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421658382", "createdAt": "2020-05-07T17:05:19Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/connector/SqlConnector.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.connector;\n+\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableSchema.Field;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface SqlConnector {\n+\n+    Table createTable(\n+            String schemaName,\n+            String name,\n+            List<Field> fields,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODkxNA==", "bodyText": "As far as I understand, we are supposed to call Jet via some sort of reflection or service discovery here, in order to install more connectors?", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421658914", "createdAt": "2020-05-07T17:06:13Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/connector/SqlConnectorFactory.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.connector;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public final class SqlConnectorFactory {\n+\n+    // TODO: replace it with connector class and its instantiation ???\n+    // (TableSchemaField, Table, TableField, QueryDataType etc. need to be public then?)\n+    private static final Map<String, SqlConnector> CONNECTORS_BY_TYPE = prepareConnectors();\n+\n+    private SqlConnectorFactory() {\n+    }\n+\n+    private static Map<String, SqlConnector> prepareConnectors() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2MTE4Nw==", "bodyText": "As far as I understand, if we remove local map connectors, these changes are no longer needed, since every map will reside in the predefined schema?\nNevertheless, in future, we may need to allow for certain maps to reside in specific schemas for the sake of convenience (e.g. in multi-tenant applications). But it is not very clear at the moment how to achieve this - through configuration, some DDL commands, an alias, or something else.\nGiven that we do not have concrete requirements to map maps into non-standard schemes for now, perhaps it is better to keep the implementation simple.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421661187", "createdAt": "2020-05-07T17:10:04Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java", "diffHunk": "@@ -41,7 +41,21 @@ public PartitionedMapTable(\n         List<MapTableIndex> indexes,\n         int distributionFieldOrdinal\n     ) {\n-        super(SCHEMA_NAME_PARTITIONED, name, fields, statistics, keyDescriptor, valueDescriptor);\n+        this(SCHEMA_NAME_PARTITIONED, name, fields, statistics, keyDescriptor, valueDescriptor, indexes,\n+                distributionFieldOrdinal);\n+    }\n+\n+    public PartitionedMapTable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2MTg4NA==", "bodyText": "This class defines an external source, so maybe it makes sense to add External to the name for clarity. ExternalTableSchema?", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421661884", "createdAt": "2020-05-07T17:11:21Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/TableSchema.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * User defined table schema definition.\n+ */\n+public class TableSchema implements DataSerializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2MzYyMw==", "bodyText": "We skip the system replicated map when resolving objects. I think we need to do the same for other system Jet maps created during job execution. I would propose to follow the same naming as other Jet maps do.\nIdeally, we would like to have some single namespace for all system maps that should not be displayed to the user. I am not sure whether it is possible to rename existing Jet maps due to compatibility constraints.\nIn any case, this is what we should keep in mind for production implementation. Not very important for the prototype.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421663623", "createdAt": "2020-05-07T17:14:24Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/Catalog.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.connector.SqlConnector;\n+import com.hazelcast.sql.impl.connector.SqlConnectorFactory;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.hazelcast.sql.impl.QueryUtils.CATALOG;\n+import static com.hazelcast.sql.impl.QueryUtils.SCHEMA_NAME_PUBLIC;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class Catalog implements TableResolver {\n+\n+    // TODO: is it the best/right name?\n+    public static final String CATALOG_MAP_NAME = \"__sql.catalog\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NDY2MQ==", "bodyText": "Likewise, I would add External here to explicitly denote that this is a resolver for external objects.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421664661", "createdAt": "2020-05-07T17:16:08Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/Catalog.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.connector.SqlConnector;\n+import com.hazelcast.sql.impl.connector.SqlConnectorFactory;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.hazelcast.sql.impl.QueryUtils.CATALOG;\n+import static com.hazelcast.sql.impl.QueryUtils.SCHEMA_NAME_PUBLIC;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class Catalog implements TableResolver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NTYzMg==", "bodyText": "Minor: it seems that some IDEA quirk kicks in here, adding automatic padding to the files when they are opened. It is better to turn off it to minimize PR scope.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421665632", "createdAt": "2020-05-07T17:17:51Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlService.java", "diffHunk": "@@ -26,7 +26,7 @@\n     /**\n      * Execute query.\n      *\n-     * @param sql SQL.\n+     * @param sql    SQL.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0Nzc2Ng==", "bodyText": "Minor thought for future: maybe it makes sense to add this \"unparsing\" to QueryDataType itself so that we do not miss something when a new type is added.\nNot relevant for prototyping.", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421947766", "createdAt": "2020-05-08T05:34:08Z", "author": {"login": "devozerov"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/SqlDataType.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.parse;\n+\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+\n+public class SqlDataType extends SqlIdentifier {\n+\n+    private final QueryDataType type;\n+\n+    public SqlDataType(QueryDataType type, SqlParserPos pos) {\n+        super(type.toString(), pos);\n+        this.type = type;\n+    }\n+\n+    public QueryDataType type() {\n+        return type;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {\n+        if (type == QueryDataType.BOOLEAN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MDg1Nw==", "bodyText": "Here we make the purpose of optimization stage fuzzy, because sometimes optimizer does optimization, sometimes it does parsing and execution. I would prefer to retain clear boundaries for component responsibilities so that the optimizer prepares the plan, and then in the SqlServiceImpl we decide how to execute the returned plan. This is needed to ensure that we can evolve the engine easily. For example, consider that in future we will need to implement SQL query statistics or asynchronous query cancellation for JDBC. With a centralized approach, it will be much easier than trying to hook into disparate execution points.\nI do not want to slow down the prototyping due to this comment, so I propose to do the following:\n\nGo on with the current approach for now\nSoon I will switch to API implementation, where I can try to decouple execution from planning in the following way:\n\n\nPlanner return a plan that could be SELECT plan, DDL plan, etc\nThen depending on the plan type, we feed it to a designated handler in the \"core\" module", "url": "https://github.com/hazelcast/hazelcast/pull/16963#discussion_r421950857", "createdAt": "2020-05-08T05:45:25Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -174,10 +174,16 @@ private SqlCursor query0(String sql, List<Object> params, long timeout, int page\n             }\n \n             Plan plan = prepare(unwrappedSql);\n+            if (plan == null) {\n+                return new SingleValueSqlCursor(0);\n+            }\n \n             state = internalService.executeExplain(plan);\n         } else {\n             Plan plan = prepare(sql);\n+            if (plan == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724a617b7a6218b0b7ca26c077cdf8e02e5ff10f"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8498319b50698b80dbc9bdf86d7089e54340cbd5", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8498319b50698b80dbc9bdf86d7089e54340cbd5", "committedDate": "2020-05-08T06:38:58Z", "message": "Naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a28d52bc61c05d881fd15e69942a548e09d202e", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9a28d52bc61c05d881fd15e69942a548e09d202e", "committedDate": "2020-05-08T06:44:04Z", "message": "Naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdf3a307bfd2fcf84cb7c151a505294a278e5cd6", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fdf3a307bfd2fcf84cb7c151a505294a278e5cd6", "committedDate": "2020-05-08T07:37:52Z", "message": "Cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDc2MjM4", "url": "https://github.com/hazelcast/hazelcast/pull/16963#pullrequestreview-408076238", "createdAt": "2020-05-08T08:11:03Z", "commit": {"oid": "fdf3a307bfd2fcf84cb7c151a505294a278e5cd6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3607, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}