{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMTY2MDM0", "number": 16946, "title": "#4233 Add ITopic.publishAll, ITopic.publishAllAsync and ITopic.publishAsync methods", "bodyText": "The publishAsync and publishAllAsync methods do what the methodnames say - they do the publish in an async manner.\nThe publishAll methods publishes the complete messages collection as one single message.\nI've created three separate new client messages (please see client protocol pull request).\nPlease have a more detailed look at the following classes:\nClientReliableTopicProxy.java and ReliableTopicProxy.java\nThe publish method is quite complex. It's possible that the publishAll, publishAllAsync and publishAsync methods need a complete rewrite.\nIf that's the case, I need some more help.\nthe pull request for the client protocoll changes is hazelcast/hazelcast-client-protocol#318\nSo please feel free - I'm happy for every comment.\nFixes: #4233", "createdAt": "2020-05-01T15:04:14Z", "url": "https://github.com/hazelcast/hazelcast/pull/16946", "merged": true, "mergeCommit": {"oid": "ddf62c39b90c5a723bb1f7256332d468215c8935"}, "closed": true, "closedAt": "2020-09-30T07:44:05Z", "author": {"login": "andrewoelfing"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce3YdHAFqTQwNzE4Mzg5OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNpGhegFqTQ5ODUzNTcwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTgzODk5", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-407183899", "createdAt": "2020-05-07T06:35:18Z", "commit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozNToxOFrOGRwSjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozNToxOFrOGRwSjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MDE1OA==", "bodyText": "@andrewoelfing It seems some files are deleted by mistake ? Can you revert these ?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421270158", "createdAt": "2020-05-07T06:35:18Z", "author": {"login": "sancar"}, "path": "src/main/resources/apache-v2-license.txt", "diffHunk": "@@ -1,202 +0,0 @@\n-\n-                                 Apache License\n-                           Version 2.0, January 2004\n-                        http://www.apache.org/licenses/\n-\n-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTg1OTMz", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-407185933", "createdAt": "2020-05-07T06:39:41Z", "commit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozOTo0MVrOGRwZUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozOTo0MVrOGRwZUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MTg4OQ==", "bodyText": "partition id is used by TotalOrderedTopicProxy to make sure the total order.\nThis one should not need it.\nSee https://docs.hazelcast.org/docs/4.0.1/manual/html-single/index.html#understanding-topic-behavior", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421271889", "createdAt": "2020-05-07T06:39:41Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +41,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final int partitionId;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTg4Mjkx", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-407188291", "createdAt": "2020-05-07T06:44:40Z", "commit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjo0NDo0MFrOGRwhSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjo0NDo0MFrOGRwhSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MzkzMQ==", "bodyText": "I believe this should be called with invokeOnPartition. Also async ones should have partitionId as the fourth parameter.\nI have got suspicious about this and deleted my comment. It seems, we are using partition id on ClientTopicProxy but not on ClientReliableTopicProxy. Order guarantees may not be given for Reliable one.  Can you still add tests for order guarantees for all of the new methods ?\nWe can add tests as following for new methods to verify the behaviour.\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java#L141\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java#L220\nIt seems tests are missing on the client side. Don't forget to add them for client side as well ?\nEasiest could be to make ClientTopicTest to extend TopicTest. We don't have to, but we are using this pattern to avoid writing tests twice when it fits. See if these tests are suitable. Here is an example:\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueueBasicLocalTest.java#L29", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421273931", "createdAt": "2020-05-07T06:44:40Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +138,21 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Data element = toData(message);\n+        ClientMessage request = TopicPublishCodec.encodeRequest(name, element);\n+        try {\n+            ClientInvocationFuture invocationFuture = new ClientInvocation(getClient(), request, getName()).invoke();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 62}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c736e79dc239feae5d03182174b35af0e605589d", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c736e79dc239feae5d03182174b35af0e605589d", "committedDate": "2020-05-10T22:10:36Z", "message": "Merge branch 'master' of github.com:hazelcast/hazelcast into issue/4233"}, "afterCommit": {"oid": "56fdd9732809f72e46508f75745e4517e07597c4", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/56fdd9732809f72e46508f75745e4517e07597c4", "committedDate": "2020-05-11T20:58:15Z", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56fdd9732809f72e46508f75745e4517e07597c4", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/56fdd9732809f72e46508f75745e4517e07597c4", "committedDate": "2020-05-11T20:58:15Z", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods"}, "afterCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "committedDate": "2020-05-12T12:54:25Z", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTY3Mzk1", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-423567395", "createdAt": "2020-06-03T13:45:01Z", "commit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo0NTowMlrOGeciCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1MToxNVrOGefk3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA==", "bodyText": "We have to distinguish between \"reliable topic\" and \"topic\" here. \"Reliable topic\" (meaning *ReliableTopicProxy classes, obtained through HazelcastInstance#getReliableTopic) use another user-facing structure under the covers - Ringbuffer<ReliableTopicMessage>. On the other hand, \"topic\" (meaning TopicProxy and ClientTopicProxy classes, obtained through HazelcastInstance#getTopic) don't use the ringbuffer but use the \"eventing system\" instead.\nWhat I'm trying to say is, the reliable topic proxies need to use the ringbuffer. Now, that will make your life both easier and harder :D I'm not sure how easy it will be but you should switch to using ringbuffer.addAllAsync() in the reliable topic proxies.\nAfter you try it out, you can let us know if you ran into some difficulties there and we'll continue from there on.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434577928", "createdAt": "2020-06-03T13:45:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4MzIzNQ==", "bodyText": "Since this task may be fired in a cluster which contains a 4.0 member which doesn't have this operation, we need to add a check for the cluster version somewhere here, just like the ones you've added in your previous PR I believe. Maybe something like this:\n        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\n                    \"Publish all is unavailable at cluster version \" + clusterVersion);\n        }\n        return new PublishAllOperation(parameters.name, items());", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434583235", "createdAt": "2020-06-03T13:52:09Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        return new PublishAllOperation(parameters.name, items());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ==", "bodyText": "It's a shame sync and async methods don't share the code and sync simply being async().get() I see there's an additional object created for the async case so maybe that's not possible. Or maybe you can extract at least some part.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434586709", "createdAt": "2020-06-03T13:56:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +95,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+\n+        ClientMessage request = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+        final ClientMessage clientMessage = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        return publishAsyncInternal(clientMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ==", "bodyText": "Another layer of complexity :) In addition to reliable topic vs topic, \"topic\" can be different if we're talking about \"totally-ordered\" topic and \"non-totally-ordered\" topic (determined by TopicConfig#isGlobalOrderingEnabled). The \"non-ordered\" is implemented in TopicProxy and ClientTopicProxy and here you avoid firing any partition operations since partition operations are ordered. On the other hand, in TotalOrderedTopicProxy you can override the method from TopicProxy and fire the PublishAllOperation (but remember to check for the cluster version first).\nLooks like clients don't have non-ordered topics, they send a message task which then sends a publish operation. Basically turning it into an ordered topic always.\nThis also means that the async member-side non-ordered implementation of TopicProxy#publishAllAsync is basically the same as the sync one, since the TopicProxySupport#publishInternal doesn't usually block. Usually meaning there's some silly rule that every 100000th event should block. This IMHO is a poor backpressure mechanism and I think we should remove it anyway.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434592341", "createdAt": "2020-06-03T14:04:12Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -47,6 +56,13 @@ public void publish(@Nonnull E message) {\n         publishInternal(message);\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ==", "bodyText": "Haven't looked at the tests too closely (will look after other comments are addressed) but as a general idea since all implementations share the same interface, I suggest that you write the test once and just parametrize it - either use the reliable topic or regular topic, the ordered or non-ordered topic.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434627805", "createdAt": "2020-06-03T14:51:15Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0bf91539c2bcf41e7ecfeb04edfb6a4fe868ea74", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0bf91539c2bcf41e7ecfeb04edfb6a4fe868ea74", "committedDate": "2020-07-12T07:55:15Z", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,"}, "afterCommit": {"oid": "1fceb14e25cc2237b2adcbfb2a7af3b989640de5", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1fceb14e25cc2237b2adcbfb2a7af3b989640de5", "committedDate": "2020-07-12T12:14:30Z", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f19e53074510f0ec3624e9642d620f0605ca023", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3f19e53074510f0ec3624e9642d620f0605ca023", "committedDate": "2020-08-01T06:08:26Z", "message": "#4233 Add ITopic.publishAll, ITopic.publishAllAsync and ITopic.publishAsync methods\nImplementing UnitTests\nCleanUp Code\npublishAll, publishAsync, publishAllAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bda213ae52a3fab1bc10d8f2703c5f8419ae0e06", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bda213ae52a3fab1bc10d8f2703c5f8419ae0e06", "committedDate": "2020-08-01T06:08:27Z", "message": "#4233 Fixed CodecHashTest issue\nalso implemented more unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f64be4c384ebbe5464549fe3213e969674129555", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f64be4c384ebbe5464549fe3213e969674129555", "committedDate": "2020-08-01T06:08:27Z", "message": "#4233 fixes after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a1ffb41918968abe5807804ccc993cb3cd697ca", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6a1ffb41918968abe5807804ccc993cb3cd697ca", "committedDate": "2020-08-01T06:08:27Z", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e9aec279487de2ce281fa58ae2d751c48e1367e", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8e9aec279487de2ce281fa58ae2d751c48e1367e", "committedDate": "2020-08-01T06:08:27Z", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2a63fb2076478f5922489b29a8f7cf74a01cf97", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f2a63fb2076478f5922489b29a8f7cf74a01cf97", "committedDate": "2020-08-01T06:08:28Z", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/06bf94d90dce7969f542325a4d0d2dab5475540d", "committedDate": "2020-08-25T21:50:19Z", "message": "#4233 WIP review-advised changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fceb14e25cc2237b2adcbfb2a7af3b989640de5", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1fceb14e25cc2237b2adcbfb2a7af3b989640de5", "committedDate": "2020-07-12T12:14:30Z", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,"}, "afterCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/06bf94d90dce7969f542325a4d0d2dab5475540d", "committedDate": "2020-08-25T21:50:19Z", "message": "#4233 WIP review-advised changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDQ2OTAy", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-476446902", "createdAt": "2020-08-27T07:17:01Z", "commit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNzowMVrOHIDdMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo1NToyOFrOHIEs8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzI4Mw==", "bodyText": "Do we actually throw it or do we complete the future with this exception?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478207283", "createdAt": "2020-08-27T07:17:01Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -63,6 +66,16 @@\n      */\n     void publish(@Nonnull E message);\n \n+    /**\n+     * Publishes the message to all subscribers of this topic.\n+     *\n+     * @param message the message to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzU5Ng==", "bodyText": "Same comment as on publishAsync", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478207596", "createdAt": "2020-08-27T07:17:40Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -95,4 +108,23 @@\n      * @return statistics about this topic\n      */\n     @Nonnull LocalTopicStats getLocalTopicStats();\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @throws TopicOverloadException if the consumer is too slow\n+     *                                (only works in combination with reliable topic)\n+     */\n+    void publishAll(@Nonnull Collection<? extends E> messages) throws ExecutionException, InterruptedException;\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg==", "bodyText": "Can you check if this statistic is per-message or per-operation?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478208042", "createdAt": "2020-08-27T07:18:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception {\n+        TopicService service = getService();\n+        service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxMDE5MQ==", "bodyText": "Since PublishAllOperation is a new operation and since this member might be running in a cluster with older members, we need to introduce the cluster version check:\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)){\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\nSame in other methods using this operation.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478210191", "createdAt": "2020-08-27T07:22:52Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNTM0OQ==", "bodyText": "Since none of the operations that are passed as arguments to this method actually have a Data result (or even have any kind of result), you can change it to InternalCompletableFuture<Void>. Also, then you don't need to wrap it in newDelegatingFuture(serializationService, publishInternalAsync(op)) as the serialization service doesn't have anything to deserialize.\nIn the end, we then get this:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        return publishInternalAsync(op);\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        return publishInternalAsync(op);\n    }\n\n    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n        topicStats.incrementPublishes();\n        try {\n            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);\n        } catch (Throwable t) {\n            throw rethrow(t);\n        }\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478215349", "createdAt": "2020-08-27T07:32:45Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    private InternalCompletableFuture<Data> publishInternalAsync(Operation operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzIxMA==", "bodyText": "Minor: add the // RU_COMPAT_4_0 comment here so we can easily find it and remove it in 4.2.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478217210", "createdAt": "2020-08-27T07:36:10Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.cluster.Versions;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+import com.hazelcast.version.Version;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxOTgyMQ==", "bodyText": "Minor: you can use Collections.singleton(payload).", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478219821", "createdAt": "2020-08-27T07:40:53Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +126,14 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Collection<E> messages = new ArrayList<>();\n+        messages.add(payload);\n+        return publishAllAsync(messages);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA==", "bodyText": "Just occurred to me - can you check if this addition is atomic - either all are added or none? Asking because then it's safe to retry but if we added some and not others, we might end up adding some items multiple times.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478222064", "createdAt": "2020-08-27T07:45:00Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA==", "bodyText": "Minor: this was previously in the try-catch block and was wrapped in case serialization failed (I think) so maybe we can follow the same approach here. Not sure if we should complete the future or throw it to the caller. Maybe fail-fast and throwing it directly is the better option here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478223308", "createdAt": "2020-08-27T07:47:15Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNDAxOA==", "bodyText": "Do you have a test where this is exercised? I'd like to see which threads are involved in this execution and if it works nicely.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478224018", "createdAt": "2020-08-27T07:48:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()\n+                .map(m -> new ReliableTopicMessage(toData(m), null))\n+                .collect(Collectors.toList());\n+        switch (overloadPolicy) {\n+            case ERROR:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            if (id == -1) {\n+                                returnFuture.completeExceptionally(new TopicOverloadException(\n+                                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+\n+                break;\n+            case DISCARD_OLDEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case DISCARD_NEWEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case BLOCK:\n+                addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ==", "bodyText": "Do we have to honor the overloadPolicy here? Seems like we do in publish and we also increment the stats (keep in mind that you need to check if we increment per-message or per-operation). Same comment for publishAll and publishAllAsync", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478226321", "createdAt": "2020-08-27T07:52:59Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -184,6 +194,22 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNzY5OQ==", "bodyText": "If you want, replace this with:\n        return collection.stream().map(item -> {\n            checkNotNull(item, \"collection can't contains null items\");\n            return toData(item);\n        }).toArray(Data[]::new);", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478227699", "createdAt": "2020-08-27T07:55:28Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -64,6 +79,33 @@ public boolean removeMessageListener(@Nonnull UUID registrationId) {\n     public LocalTopicStats getLocalTopicStats() {\n         return getLocalTopicStatsInternal();\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        messages.forEach(this::publishInternal);\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        publishAll(messages);\n+        return InternalCompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    protected Data[] toDataArray(Collection<? extends E> collection) {\n+        Data[] items = new Data[collection.size()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07ba970db2c3e893d5211520367764a628094703", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/07ba970db2c3e893d5211520367764a628094703", "committedDate": "2020-08-27T21:18:55Z", "message": "#4233 WIP - code beautification, changed some jdoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9e9a6da6c194a858ab8a2ad1b79c987c1d7ff7f", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e9e9a6da6c194a858ab8a2ad1b79c987c1d7ff7f", "committedDate": "2020-08-30T21:43:34Z", "message": "#4233 WIP - Fixed overloadpolicy, fixed try catch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87a91dce0aa4a4f6b7e62774006d817810c69f4a", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/87a91dce0aa4a4f6b7e62774006d817810c69f4a", "committedDate": "2020-09-01T05:29:24Z", "message": "#4233 WIP - clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "committedDate": "2020-09-06T14:33:28Z", "message": "#4233 extended ReliableTopic tests (block, 2x discard, error)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTE1NTU2", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-494515556", "createdAt": "2020-09-23T10:25:57Z", "commit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDoyNTo1N1rOHWkCIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTo1NToyMlrOHWo2Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyMTA5MQ==", "bodyText": "I think this is the wrong kind of NotNull, should probably use javax.annotation.Nonnull", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493421091", "createdAt": "2020-09-23T10:25:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -35,15 +36,22 @@\n import com.hazelcast.topic.impl.reliable.MessageRunner;\n import com.hazelcast.topic.impl.reliable.ReliableMessageListenerAdapter;\n import com.hazelcast.topic.impl.reliable.ReliableTopicMessage;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzMTY4NA==", "bodyText": "Why do we need this first catch block? Same in publishAllAsync.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493431684", "createdAt": "2020-09-23T10:37:19Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzODQxMA==", "bodyText": "I think it should be fine, but let's just avoid completing the same future several times and guard it with if-else-if statements. Same on other methods.\nAlso, don't complete it here in case we've scheduled another run because there was no room left for all items.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493438410", "createdAt": "2020-09-23T10:44:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0MzU1Mw==", "bodyText": "This looks odd. We schedule the task but also complete the future. I think we should probably not complete exceptionally here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493443553", "createdAt": "2020-09-23T10:50:29Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0NjMyNw==", "bodyText": "Not used.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493446327", "createdAt": "2020-09-23T10:53:38Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionSpecificClientProxy.java", "diffHunk": "@@ -87,4 +87,8 @@ protected ClientMessage invokeOnPartition(ClientMessage req) {\n             throw ExceptionUtil.rethrowAllowInterrupted(e);\n         }\n     }\n+\n+    public int getPartitionId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0OTI2OA==", "bodyText": "Same as in client proxy.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493449268", "createdAt": "2020-09-23T10:56:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -21,29 +21,39 @@\n import com.hazelcast.config.ReliableTopicConfig;\n import com.hazelcast.core.HazelcastException;\n import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.cluster.Versions;\n import com.hazelcast.internal.monitor.impl.LocalTopicStatsImpl;\n import com.hazelcast.internal.nio.ClassLoaderUtil;\n+import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.internal.util.ExceptionUtil;\n import com.hazelcast.internal.util.UuidUtil;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.ringbuffer.OverflowPolicy;\n import com.hazelcast.ringbuffer.Ringbuffer;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.topic.ITopic;\n import com.hazelcast.topic.LocalTopicStats;\n import com.hazelcast.topic.MessageListener;\n import com.hazelcast.topic.ReliableMessageListener;\n import com.hazelcast.topic.TopicOverloadException;\n import com.hazelcast.topic.TopicOverloadPolicy;\n+import com.hazelcast.version.Version;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1MTI5Nw==", "bodyText": "Since the stat says it is the number of published messages, we need to increment this by number of messages, and only in cases we successfully published. I guess the publish is wrong then and it should be fixed but I can do it in another PR.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493451297", "createdAt": "2020-09-23T10:59:17Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDk3OA==", "bodyText": "In the member-side we complete the future in the client-side we throw directly. We should probably have the same behaviour and between the two, I think I'd prefer the client-side one (throwing directly) as it's an early indicator of failure, like the instance already been shutdown, or the message not being serializable.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493454978", "createdAt": "2020-09-23T11:03:44Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTEyOA==", "bodyText": "Same as in client-side", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493455128", "createdAt": "2020-09-23T11:03:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName())));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@NotNull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,\n+                                  InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages,\n+                                  long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                nodeEngine.getExecutionService().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NzcxMA==", "bodyText": "It's actually interesting that the PublishOperation is also wrong here. We should increment after we successfully published, not before, as the stat says it is the number of successfully published messages. You can fix it here, I'll fix the rest in another PR.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493457710", "createdAt": "2020-09-23T11:06:51Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception { }\n+\n+    @Override\n+    public void run() throws Exception {\n+        TopicService service = getService();\n+        EventService eventService = getNodeEngine().getEventService();\n+        Collection<EventRegistration> registrations = eventService.getRegistrations(TopicService.SERVICE_NAME, name);\n+\n+        Lock lock = service.getOrderLock(name);\n+        lock.lock();\n+        try {\n+            for (Data item : messages) {\n+                TopicEvent topicEvent = new TopicEvent(name, item, getCallerAddress());\n+                service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODYwNA==", "bodyText": "I don't think we need the service anymore.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493458604", "createdAt": "2020-09-23T11:07:51Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +42,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final SerializationService serializationService;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.serializationService = nodeEngine.getSerializationService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODk2MA==", "bodyText": "Not used.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493458960", "createdAt": "2020-09-23T11:08:16Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxySupport.java", "diffHunk": "@@ -100,6 +112,16 @@ public void publishInternal(@Nonnull Object message) {\n         topicService.publishMessage(name, message, multithreaded);\n     }\n \n+    protected InternalCompletableFuture<Data> putAsyncInternal(Operation operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1OTQ4Mg==", "bodyText": "serializationService not used.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493459482", "createdAt": "2020-09-23T11:08:54Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,11 +40,18 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n+    private final SerializationService serializationService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTE0NQ==", "bodyText": "No need to set the partition ID if it'll be invoked on the partition by the helper method.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493461145", "createdAt": "2020-09-23T11:10:46Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTgyOA==", "bodyText": "You can just call publishAllAsync here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493461828", "createdAt": "2020-09-23T11:11:37Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ==", "bodyText": "Again, the issue with successfully published statistics. Maybe you can avoid it alltogether, and keep the current behaviour, and I'll fix it in another PR in all places.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493462439", "createdAt": "2020-09-23T11:12:20Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        topicStats.incrementPublishes();\n+        try {\n+            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NTMwMg==", "bodyText": "testPublishAll and testPublishAllAsync are the same. Can you fix that? I guess they can share a single helper method to avoid duplication.\nSame for other two tests when it comes to avoiding duplication.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493465302", "createdAt": "2020-09-23T11:15:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -93,4 +107,117 @@ public void testGetLocalTopicStats() throws Exception {\n \n         topic.getLocalTopicStats();\n     }\n+\n+    @Test\n+    public void testPublish() throws InterruptedException {\n+        String publishValue = \"message\";\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        topic.publish(publishValue);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertTrue(receivedValues.contains(publishValue));\n+            }\n+        });\n+    }\n+\n+\n+    @Test\n+    public void testPublishAsync() throws InterruptedException {\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final List<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        final String message = \"message\";\n+        topic.publishAsync(message);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertEquals(Arrays.asList(message), receivedValues);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testPublishAll() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2ODk0OQ==", "bodyText": "You can use assertCompletesEventually to avoid blocking the test forever in case it never completes, same in other test methods doing the same.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493468949", "createdAt": "2020-09-23T11:19:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java", "diffHunk": "@@ -136,6 +140,108 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testTopicPublishAsync() throws Exception {\n+        final String randomName = \"testTopicPublishAsync\" + generateRandomString(5);\n+        final AtomicInteger count = new AtomicInteger(0);\n+\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(1);\n+        HazelcastInstance instance = factory.newHazelcastInstance();\n+        ITopic<String> topic = instance.getTopic(randomName);\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+            }\n+        });\n+\n+        final CompletableFuture<Void> f = topic.publishAsync(\"TestMessage\").toCompletableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4MDYxNg==", "bodyText": "Since none of the methods in TopicTest use the client instance, I don't think it's worth extending it here. If you want to make the tests reusable, we need more involvement on different levels.\nFirst off, it should look like this:\n\nClientReliableTopicTest extends ClientTopicTest (client-side tests)\nReliableTopicAbstractTest extends TopicTest (member-side tests)\n\nThen, you'd need to go over all of the test methods and make sure they aren't calling something like instance.getTopic() or client.getReliableTopic() directly in the test. Instead, they would need to call something like getTopicImplementation().publish() where getTopicImplementation would be some abstract method which is overriden in different tests. For instance:\n\nClientReliableTopicTest would return client.getReliableTopic\nReliableTopicAbstractTest would return member.getReliableTopic\nClientTopicTest would return client.getTopic\nTopicTest would return member.getTopic\n\nPersonally, I think it's too much involvement for this PR and we can do it in a separate PR. Now, we might just add similar tests on client and member-side, and for both regular topic and ITopic.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493480616", "createdAt": "2020-09-23T11:33:53Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkzOA==", "bodyText": "I've also noticed we have no tests for BLOCK overload policy. So here's a suggestion, you can do analogous tests for topic, reliable topic, member and client side.\n    @Before\n    public void setup() {\n        Config config = smallInstanceConfig();\n        config.addRingBufferConfig(new RingbufferConfig(\"blockingReliableTopic*\")\n                .setCapacity(10)\n                .setTimeToLiveSeconds(60));\n        hazelcastFactory.newHazelcastInstance(config);\n\n        // for member-side ReliableTopicAbstractTest\n        config.addReliableTopicConfig(new ReliableTopicConfig(\"blockingReliableTopic*\")\n                .setReadBatchSize(10)\n                .setTopicOverloadPolicy(TopicOverloadPolicy.BLOCK));\n        \n        // for client-side ClientReliableTopicTest\n        ClientConfig clientConfig = new ClientConfig()\n                .addReliableTopicConfig(new ClientReliableTopicConfig(\"blockingReliableTopic*\")\n                        .setReadBatchSize(10)\n                        .setTopicOverloadPolicy(TopicOverloadPolicy.BLOCK));\n        \n        client = hazelcastFactory.newHazelcastClient(clientConfig);\n    }\n    \n    @Test\n    public void testBlockingAsync() {\n        String randomName = \"blockingReliableTopic\" + generateRandomString(5);\n        AtomicInteger count = new AtomicInteger(0);\n\n        ITopic<Object> topic = client.getReliableTopic(randomName);\n        topic.addMessageListener(message -> count.incrementAndGet());\n\n\n        for (int i = 0; i < 10; i++) {\n            topic.publish(\"message\");\n        }\n        assertTrueEventually(() -> assertEquals(10, count.get()));\n        assertCompletesEventually(topic.publishAllAsync(asList(\"msg 1\", \"msg 2\", \"msg 3\", \"msg 4\", \"msg 5\")).toCompletableFuture());\n        assertTrueEventually(() -> assertEquals(15, count.get()));\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493499938", "createdAt": "2020-09-23T11:55:22Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a215bdfa1b797ebe33535000eba9dbb690dd3ba", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0a215bdfa1b797ebe33535000eba9dbb690dd3ba", "committedDate": "2020-09-24T20:07:20Z", "message": "#4233 code review\nremoved unused code, corrected imports, better exception handling, changed task scheduling, added some tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/acbc348e59a3308a6a869b2a9ca324db8ec6d392", "committedDate": "2020-09-24T21:37:52Z", "message": "#4233 code review\nFixed unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MjM4NzI4", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-496238728", "createdAt": "2020-09-25T09:01:02Z", "commit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOTowMTowMlrOHX7NtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOTowNDo0MlrOHX7VSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0OTQ2MA==", "bodyText": "Move this to the else block so we don't complete or increment when there's an exception. Same on client side.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494849460", "createdAt": "2020-09-25T09:01:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +277,139 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+                messages.forEach(p -> localTopicStats.incrementPublishes());\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MDM0NA==", "bodyText": "Here it's not that critical as on member-side (because of statistics) but move this to an else block.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494850344", "createdAt": "2020-09-25T09:02:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,114 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MTQwMg==", "bodyText": "Looks like stats are incremented in the operation so you can remove it from here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494851402", "createdAt": "2020-09-25T09:04:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,19 +40,68 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n     private final int partitionId;\n+    private final LocalTopicStatsImpl topicStats;\n \n     public TotalOrderedTopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n-        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());\n+        this.partitionId = nodeEngine.getPartitionService()\n+                .getPartitionId(getNameAsPartitionAwareData());\n+        this.operationService = nodeEngine.getOperationService();\n+        this.topicStats = service.getLocalTopicStats(name);\n     }\n \n     @Override\n     public void publish(@Nonnull  E message) {\n         checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n-        Operation operation = new PublishOperation(getName(), toData(message))\n-                .setPartitionId(partitionId);\n+        Operation operation = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message));\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        publishAllAsync(messages).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        try {\n+            final InvocationFuture<Void> invocationFuture = operationService.invokeOnPartition(\n+                    OperationService.SERVICE_NAME, operation, partitionId);\n+            topicStats.incrementPublishes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MzU3MzE5", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-496357319", "createdAt": "2020-09-25T12:03:54Z", "commit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMjowMzo1NFrOHYAzSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMjowMzo1NFrOHYAzSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MTAwMw==", "bodyText": "ClientMessageDecoder can not be null.\nIf you add completionStage.toCompletableFuture().join(); in your tests you will get NullPointerException. Please add this version to tests as well.\nYou can pass  clientMessage -> null instead of null to fix the problem easily.\nPlease check publishAsync method as well for the same.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494941003", "createdAt": "2020-09-25T12:03:54Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +91,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        ClientMessage request = getClientMessage(messages);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        final ClientMessage clientMessage = getClientMessage(messages);\n+        return invokeOnPartitionAsync(clientMessage, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "committedDate": "2020-09-26T20:16:45Z", "message": "#4233 code review\ncorrected conditions, add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDM4MTQz", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-497438143", "createdAt": "2020-09-28T11:56:08Z", "commit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NjowOVrOHY6TeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NjowOVrOHY6TeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzEyOQ==", "bodyText": "The test name is confusing. I know what you mean but only because I know the background.\nCan you rename it to something like testPublishAllAsync_thenJoin ?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495883129", "createdAt": "2020-09-28T11:56:09Z", "author": {"login": "sancar"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDM4MzAz", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-497438303", "createdAt": "2020-09-28T11:56:23Z", "commit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NjoyM1rOHY6T7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NjoyM1rOHY6T7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzI0NA==", "bodyText": "This is unused.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495883244", "createdAt": "2020-09-28T11:56:23Z", "author": {"login": "sancar"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+        ITopic<String> topic = createTopic(count, receivedValues);\n+\n+        final List<String> messages = Arrays.asList(\"message 1\", \"message 2\", \"messgae 3\");\n+        final CompletionStage<Void> completionStage = topic.publishAllAsync(messages);\n+        completionStage.toCompletableFuture().join();\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(messages.size(), count.get());\n+                assertTrue(messages.containsAll(receivedValues));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testBlockingAsync() {\n+        AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDQxNjc0", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-497441674", "createdAt": "2020-09-28T12:01:23Z", "commit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowMToyM1rOHY6d3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowMToyM1rOHY6d3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NTc4OQ==", "bodyText": "This payload parameter is unused. It can be removed. Please check the member side proxy as well.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495885789", "createdAt": "2020-09-28T12:01:23Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,115 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDQzMDYw", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-497443060", "createdAt": "2020-09-28T12:03:24Z", "commit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e11e4c5a08f82c8fd22595c097d049251e2e02e", "author": {"user": {"login": "andrewoelfing", "name": "Andr\u00e9 W\u00f6lfing"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3e11e4c5a08f82c8fd22595c097d049251e2e02e", "committedDate": "2020-09-28T12:29:21Z", "message": "#4233 code review\nmethod renaming, removed unused code, removed unused parameter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTM1NzAy", "url": "https://github.com/hazelcast/hazelcast/pull/16946#pullrequestreview-498535702", "createdAt": "2020-09-29T14:31:29Z", "commit": {"oid": "3e11e4c5a08f82c8fd22595c097d049251e2e02e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3814, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}