{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NTQ5NTQw", "number": 17086, "title": "Initial support for Portable and INSERTs", "bodyText": "Added support for direct Portable fields reading and writing.\nAdded support for IMap/ReplicatedMap (+ Kafka) INSERTS.\nThe main logic is contained within com.hazelcast.sql.impl.inject - the idea is quite similar to QueryTargetDescriptor et al. and if it's right it might be worth merging extraction and injection descriptors & targets into one.\nThe logic responsible for resolving metadata is contained within com.hazelcast.sql.impl.schema.map.options - again, the idea is quite similar to MapSampleMetadataResolver et al.\nAbove are used in LocalPartitionedMapConnector & LocalReplicatedMapConnector as well as in KafkaSqlConnector in Jet.\nThere is fair amount of duplicated code and TODOs right now, I was trying to affect existing interfaces as little as possible but if it turns out this is the right direction some refactoring, cleanup & unification would be needed.", "createdAt": "2020-06-15T13:42:05Z", "url": "https://github.com/hazelcast/hazelcast/pull/17086", "merged": true, "mergeCommit": {"oid": "02d5574de973a3fb956bc330e719d247661dd7d9"}, "closed": true, "closedAt": "2020-06-25T13:00:13Z", "author": {"login": "gierlachg"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcrggDgAH2gAyNDM0NTQ5NTQwOmU1OWI0OGQxZTM5MjBhNjNiZWU3NTRjZmU2NjY4M2ViYmFmZmQzMWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuuGJqgFqTQzNzQ1ODAxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e59b48d1e3920a63bee754cfe66683ebbaffd31a", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e59b48d1e3920a63bee754cfe66683ebbaffd31a", "committedDate": "2020-06-15T13:16:48Z", "message": "Initial support for Portable and INSERTs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ac3d3090f711bc7445ebec99f7702a3027a01f6", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1ac3d3090f711bc7445ebec99f7702a3027a01f6", "committedDate": "2020-06-15T13:55:53Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fed5f10f547dacc19f13c6cc4cb3282facfaada8", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fed5f10f547dacc19f13c6cc4cb3282facfaada8", "committedDate": "2020-06-15T14:02:47Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5870bbfe8500bc3d9fbbf91252df404a5faacd23", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5870bbfe8500bc3d9fbbf91252df404a5faacd23", "committedDate": "2020-06-15T14:14:31Z", "message": "Make checkstyle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee672ba8ace75fc08b00fb3286d34f2a3203a9fc", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ee672ba8ace75fc08b00fb3286d34f2a3203a9fc", "committedDate": "2020-06-17T06:46:12Z", "message": "Add support for POJO field injection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "196c567479d35777c994837342da6fc96f5594d7", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/196c567479d35777c994837342da6fc96f5594d7", "committedDate": "2020-06-17T07:20:36Z", "message": "Proper declared table type resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48001d80f5ada939bad083bdf29a6c8832eda971", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/48001d80f5ada939bad083bdf29a6c8832eda971", "committedDate": "2020-06-17T11:21:34Z", "message": "Simplify resolvers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6b18861a8372be0883c2fd1aa0d500aaf72babb", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d6b18861a8372be0883c2fd1aa0d500aaf72babb", "committedDate": "2020-06-17T12:36:48Z", "message": "Add DML design doc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95c59e175fc26605e5596cb10bc113d995d0e83a", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/95c59e175fc26605e5596cb10bc113d995d0e83a", "committedDate": "2020-06-17T12:39:47Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "committedDate": "2020-06-17T12:55:00Z", "message": "Wording"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTY3MjMx", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-432967231", "createdAt": "2020-06-18T06:11:59Z", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjoxMTo1OVrOGlg5fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjoxMTo1OVrOGlg5fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw==", "bodyText": "There is one problematic case that can be seen pretty frequently in IMDG with SQL - when the same field is present in both key and value. The common motivation for this is data co-location for joins. E.g.:\nPersonKey {\n    Long id;\n    Long deptId;\n}\nPersonValue {\n    ...\n    Long deptId;\n}\n\nIs there a way to write to both fields in our case?", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441989503", "createdAt": "2020-06-18T06:11:59Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTcxMjk5", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-432971299", "createdAt": "2020-06-18T06:21:02Z", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjoyMTowMlrOGlhGEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjoyMTowMlrOGlhGEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5MjcyMQ==", "bodyText": "One thing that concerns me is the usage of CREATE EXTERNAL TABLE for internal cluster objects because the whole command context is misleading:\n\nNothing is really created because the map already exists. Likewise, when we call \"DROP\" the map is not destroyed\nThe map is internal to the system, not external\n\nWhat if rethink completely how treat maps? Consider that in future we may want to create and drop distributed objects declaratively, @cangencer has some ideas about it. In this case, we will do something like CREATE MAP myMap ... or DROP MAP myMap ....\nNow, what we may want to do with an existing IMap is to add some metadata, like these class names. This could be done with the ALTER statement. E.g.:\nALTER MAP myMap KEY_CLASS com.PersonKey VALUE_CLASS com.Person TABLE_NAME my_map_table\nWDYT?", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441992721", "createdAt": "2020-06-18T06:21:02Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTczOTMz", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-432973933", "createdAt": "2020-06-18T06:26:25Z", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjoyNjoyNVrOGlhOLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjoyNjoyNVrOGlhOLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NDc5OQ==", "bodyText": "Here we basically duplicate the definition of columns. First, they are defined explicitly. Second, they could be derived from the class. The idea with CREATE MAP / ALTER MAP addresses this - you just provide class definitions (in the form of a class name, or portable class IDs), and columns are extracted from there.\nIs there any important use cases for us where explicit column definition might be needed? E.g. to define an alias for the column, or to mark it non-nullable, etc?", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441994799", "createdAt": "2020-06-18T06:26:25Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+```\n+\n+Given:\n+```\n+class PersonId {\n+    public int id;\n+}\n+\n+class Person {\n+    public String name;\n+}\n+```\n+To define a table where both key and value are POJOs and respectively of `PersonId` & `Person` class, `keyClass` &\n+`valueClass` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTc2MjMz", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-432976233", "createdAt": "2020-06-18T06:30:47Z", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjozMDo0N1rOGlhU-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjozMDo0N1rOGlhU-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NjUzOA==", "bodyText": "Type specification in the form of fully-qualified class name is pretty verbose. Can it be reduced to a simple name? E.g. kafka, jms, etc.", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441996538", "createdAt": "2020-06-18T06:30:47Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+```\n+\n+Given:\n+```\n+class PersonId {\n+    public int id;\n+}\n+\n+class Person {\n+    public String name;\n+}\n+```\n+To define a table where both key and value are POJOs and respectively of `PersonId` & `Person` class, `keyClass` &\n+`valueClass` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  id INT,\n+  name VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+OPTIONS (keyClass 'PersonId', valueClass 'Person')\n+```\n+\n+Given:\n+```\n+ClassDefinition keyClassDefinition = new ClassDefinitionBuilder(1, 2, 3)\n+    .addIntField(\"id\")\n+    .build();\n+\n+ClassDefinition valueClassDefinition = new ClassDefinitionBuilder(4, 5, 6)\n+    .addUTFField(\"name\")\n+    .build();\n+```\n+To define a table where both key and value are Portables and map to respective `ClassDefinition`s, `keyFactoryId` +\n+`keyClassId` + `KeyClassVersion` & `valueFactoryId` + `valueClassId` + `valueClassVersion` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  id INT,\n+  name VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTc2ODQ0", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-432976844", "createdAt": "2020-06-18T06:31:56Z", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjozMTo1NlrOGlhW1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjozMTo1NlrOGlhW1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NzAxMw==", "bodyText": "Can we have an explicit list of commands that are going to be supported in 4.1?", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441997013", "createdAt": "2020-06-18T06:31:56Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTc3MjEx", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-432977211", "createdAt": "2020-06-18T06:32:40Z", "commit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjozMjo0MFrOGlhX5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjozMjo0MFrOGlhX5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NzI4Nw==", "bodyText": "We should define in the document in which schema the object will be created.", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441997287", "createdAt": "2020-06-18T06:32:40Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+```\n+\n+Given:\n+```\n+class PersonId {\n+    public int id;\n+}\n+\n+class Person {\n+    public String name;\n+}\n+```\n+To define a table where both key and value are POJOs and respectively of `PersonId` & `Person` class, `keyClass` &\n+`valueClass` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  id INT,\n+  name VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+OPTIONS (keyClass 'PersonId', valueClass 'Person')\n+```\n+\n+Given:\n+```\n+ClassDefinition keyClassDefinition = new ClassDefinitionBuilder(1, 2, 3)\n+    .addIntField(\"id\")\n+    .build();\n+\n+ClassDefinition valueClassDefinition = new ClassDefinitionBuilder(4, 5, 6)\n+    .addUTFField(\"name\")\n+    .build();\n+```\n+To define a table where both key and value are Portables and map to respective `ClassDefinition`s, `keyFactoryId` +\n+`keyClassId` + `KeyClassVersion` & `valueFactoryId` + `valueClassId` + `valueClassVersion` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b92ea7f9871eac2bb480e3ac4f169d0ba96f952e", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b92ea7f9871eac2bb480e3ac4f169d0ba96f952e", "committedDate": "2020-06-18T12:05:03Z", "message": "Improving DML design document"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a2607eafff710ba28f7374889a1da75a39f99f0", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3a2607eafff710ba28f7374889a1da75a39f99f0", "committedDate": "2020-06-18T12:40:03Z", "message": "Merge branch 'sql' into portable_and_inserts\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "932ce39408273933944211cb2b1e1529cd1f63a5", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/932ce39408273933944211cb2b1e1529cd1f63a5", "committedDate": "2020-06-18T16:51:58Z", "message": "Add TODOs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b3223730e8fca1f573760cfa2d334e616524ff5", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0b3223730e8fca1f573760cfa2d334e616524ff5", "committedDate": "2020-06-19T13:38:14Z", "message": "Merge branch 'sql' into portable_and_inserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caa372da9d589ba830dddd5565130d63cc9955ff", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/caa372da9d589ba830dddd5565130d63cc9955ff", "committedDate": "2020-06-23T10:27:27Z", "message": "Merge branch 'sql' into portable_and_inserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09b6e82fb38eb211b983978f07473f2bb461ab2f", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/09b6e82fb38eb211b983978f07473f2bb461ab2f", "committedDate": "2020-06-23T14:51:40Z", "message": "Add JSON support for SQL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cafa572f971848c0fd070baaa96bc506042a034", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0cafa572f971848c0fd070baaa96bc506042a034", "committedDate": "2020-06-24T09:46:09Z", "message": "Derive schema from POJO & Portable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "122a9dbded4a4849f265375ff2c616f387829ff6", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/122a9dbded4a4849f265375ff2c616f387829ff6", "committedDate": "2020-06-24T10:12:18Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "529b53dd729ba598853a45ce8a39c68a6e3a76a9", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/529b53dd729ba598853a45ce8a39c68a6e3a76a9", "committedDate": "2020-06-24T11:16:28Z", "message": "Refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60ced877dc12a4e04ffa129e38125474cec7120c", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/60ced877dc12a4e04ffa129e38125474cec7120c", "committedDate": "2020-06-24T12:42:27Z", "message": "Refactor UpsertTargets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78ec920259853fb7cab6fcfa88c1c5f581221318", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/78ec920259853fb7cab6fcfa88c1c5f581221318", "committedDate": "2020-06-24T13:06:51Z", "message": "Refactor JsonUpsertTarget"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "370e3c052a12a74edb522d1e7bf77cebf12e7057", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/370e3c052a12a74edb522d1e7bf77cebf12e7057", "committedDate": "2020-06-25T06:47:11Z", "message": "Support sample json metadata resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9692dbac6b5411acd86ab17926293d6c13a8ca30", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9692dbac6b5411acd86ab17926293d6c13a8ca30", "committedDate": "2020-06-25T07:15:17Z", "message": "Better error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "140f7a4a8604cf9e03de1531aaa884b8c22fdf1d", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/140f7a4a8604cf9e03de1531aaa884b8c22fdf1d", "committedDate": "2020-06-25T08:55:02Z", "message": "Avoid json deserialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6011802292d1b364528aae2dfadaa9619eaf4c6", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a6011802292d1b364528aae2dfadaa9619eaf4c6", "committedDate": "2020-06-25T09:56:51Z", "message": "Add table validation on creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a90e43ab4b61808e62150344081665b01d12d5f8", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a90e43ab4b61808e62150344081665b01d12d5f8", "committedDate": "2020-06-25T10:01:31Z", "message": "Naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "119cb405c296bee799ffc499267375603da345c6", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/119cb405c296bee799ffc499267375603da345c6", "committedDate": "2020-06-25T12:15:54Z", "message": "Make checkstyle happier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76caa8316efde8fae9f9f15c6fdd57b0f58c13fb", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/76caa8316efde8fae9f9f15c6fdd57b0f58c13fb", "committedDate": "2020-06-25T12:39:37Z", "message": "Merge branch 'sql' into portable_and_inserts\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/extract/GenericQueryTarget.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/ReplicatedMapTableResolver.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/schema/map/sample/MapSampleMetadataResolverTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc66420c1270b1a27496b712bd42a973f49c6ae4", "author": {"user": {"login": "gierlachg", "name": "Grzegorz Gierlach"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fc66420c1270b1a27496b712bd42a973f49c6ae4", "committedDate": "2020-06-25T12:45:16Z", "message": "Formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NDU4MDEy", "url": "https://github.com/hazelcast/hazelcast/pull/17086#pullrequestreview-437458012", "createdAt": "2020-06-25T12:48:57Z", "commit": {"oid": "fc66420c1270b1a27496b712bd42a973f49c6ae4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3693, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}