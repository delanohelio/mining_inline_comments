{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NDM1ODE0", "number": 17646, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMToxNjo1MFrOEpbYpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTo0MTowOFrOEpb3EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODc1NzUxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMToxNjo1MFrOHbFshA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMToxNjo1MFrOHbFshA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE2NjkxNg==", "bodyText": "nit: should be has failed for address instead of has failed to address", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498166916", "createdAt": "2020-10-01T11:16:50Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {\n+                logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n+                        + \" has failed to address \" + subscriber.getRemoteAddress(), throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODc2ODQxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMToxOTo1OVrOHbFy8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMToxOTo1OVrOHbFy8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE2ODU2MQ==", "bodyText": "Question: what if the underlying connections gets closed due to missed heartbeats or the client shuts down? Shouldn't we avoid log messages in this case (i.e. filter out HazelcastClientNotActiveException and TargetDisconnectedException)?", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498168561", "createdAt": "2020-10-01T11:19:59Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {\n+                logger.warning(\"Deregistration of listener with ID \" + userRegistrationId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODgxMjgzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTozNDozMlrOHbGORg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzoxOTo0NFrOHbKAtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTU1OA==", "bodyText": "nit: there is one small problem related with this async remote deregistration. Namely, users might see some No eventHandler for callId... warnings in the log for a period of time until remote calls succeeds. Same thing could happen with the old code, but the time frame increases with the async approach. We could reduce log level to fine, but I'm not sure if that's a good idea.", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498175558", "createdAt": "2020-10-01T11:34:32Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNzYyMQ==", "bodyText": "I think log level fine is fine. I will change that.", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498237621", "createdAt": "2020-10-01T13:19:44Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTU1OA=="}, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODgzNTM2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTo0MTowOFrOHbGbtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo0NjowNFrOHbN77w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODk5Ng==", "bodyText": "nit: in the old code subscriber.removeEventHandler call made only if listenerMessageCodec.encodeRemoveRequest returns a non-null. Do we need to keep this logic?", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498178996", "createdAt": "2020-10-01T11:41:08Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzOTQzNw==", "bodyText": "if (request != null)  this check for only remote request in the old code as well.", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498239437", "createdAt": "2020-10-01T13:22:16Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODk5Ng=="}, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwMTkzNQ==", "bodyText": "Yes, you're right.", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498301935", "createdAt": "2020-10-01T14:46:04Z", "author": {"login": "puzpuzpuz"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODk5Ng=="}, "originalCommit": {"oid": "b7169be8935c023540cdde606524688fa52f2274"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 134, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}