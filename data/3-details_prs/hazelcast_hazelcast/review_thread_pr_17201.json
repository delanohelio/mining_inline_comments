{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MjU5NTYw", "number": 17201, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMDo1NVrOENPTLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToyMzozOVrOEdLO7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE3NjEyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMDo1NVrOGvzthg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzo1NDoyMVrOGxIeMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA==", "bodyText": "This doesn't seem very intuitive. Because a comparator is set, it becomes a priority queue.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452783494", "createdAt": "2020-07-10T11:20:55Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE3MjIwMA==", "bodyText": "It's how we avoid yet another config class and another interface and another method on HazelcastInstance. I don't mind, as long as the documentation is clear. Any other suggestions for exposing a priority queue?", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453172200", "createdAt": "2020-07-11T08:31:06Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NDIzMw==", "bodyText": "I do mind because it isn't intuitive. I think having an explicit property on it like 'boolean priorityQueue' makes more sense en have a default comparator implementation be in place that makes use of the Comparable interface. So the only thin someone should need to do is 'queueConfig.setPriorityQueue(true)....' This way it is explicit.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453454233", "createdAt": "2020-07-13T06:12:41Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUxODU4MQ==", "bodyText": "@pveentjer\nI agree that API should be intuitive for usage. What's your take on below suggestions?\n<!-- Current implementation -->\n<queue name=\"myQueue\">\n        <comparator-class-name>com.mycompany.MyQueueItemSpecificComparator</comparator-class-name>\n        <duplicate-allowed>false</duplicate-allowed>\n</queue>\n\n<!-- Alternative 1  priority-queue element with a cardinality min = 0 and max = 1 -->\n<queue name=\"myQueue\">\n\t\t<priority-queue>\n\t\t\t<comparator-class-name>com.mycompany.MyQueueItemSpecificComparator</comparator-class-name>\n\t\t\t<duplicate-allowed>false</duplicate-allowed>\n\t\t</priority-queue>\n</queue>\n\n<!-- Alternative 2: This is my favorite: when one of comparator-class-name or duplicate-allowed is not null, then kind is always a priority-queue -->\n<queue name=\"myQueue\" kind=\"priority-queue\" comparator-class-name=\"com.mycompany.MyQueueItemSpecificComparator\" duplicate-allowed=false>\n</queue>", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453518581", "createdAt": "2020-07-13T09:30:23Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3MjIwOA==", "bodyText": "Following suggestions done above, I finally went for this to configure a priority based queue\n<queue name=\"myQueue\" queue-type=\"PRIORITY_QUEUE\" comparator-class-name=\"com.mycompany.MyQueueItemSpecificComparator\" duplicate-allowed=false></queue>", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r454172208", "createdAt": "2020-07-14T07:54:21Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE3ODQ1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMTo1M1rOGvzu-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMjozMDoyNlrOG2tisw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ==", "bodyText": "This seems to be very use case specific. I'm not sure we want to have this in the codebase.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452783865", "createdAt": "2020-07-10T11:21:53Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2MzA5Ng==", "bodyText": "Hi Peter,\nThanks for your kind feedback so far.\nYou are right. This is really use case specific. I would have like to provide a solution without altering internal of Queue implementation.\nI am open for alternative solution.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453463096", "createdAt": "2020-07-13T06:40:35Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3MDk4MA==", "bodyText": "I don't think there is an alternative solution. But there is no queue implementation that has duplicate detection and I have never had the need for it. So I don't see a good reason why it should be in here; this is a general-purpose data-structure and we should prevent add use case-specific additions. It makes the code complex to maintain and use.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459370980", "createdAt": "2020-07-23T11:03:33Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5ODY0MA==", "bodyText": "What happens when a regular queue is created and duplicate allowed is set to false? Afaik there is no duplicate checking in the regular queue (would be undesirable due to complexity). So is there an exception if you set the duplicates allowed to false, but don't create a priority queue? Or is the setting ignored?", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459498640", "createdAt": "2020-07-23T14:37:07Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzNTMzMQ==", "bodyText": "Attribute duplicate-allowed in the config holds only for priority queue. This setting is completely ignored for regular queue.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459935331", "createdAt": "2020-07-24T09:03:54Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMjQ1MQ==", "bodyText": "I don't think there is an alternative solution. But there is no queue implementation that has duplicate detection and I have never had the need for it. So I don't see a good reason why it should be in here; this is a general-purpose data-structure and we should prevent add use case-specific additions. It makes the code complex to maintain and use.\n\nI can understand your concerns about providing use case specific additions on general data structure. In the current case the addition is transparent for API user and the default works for standard data structure as in previous release.\nYes, real usecase can be rare to find. In our case we are currently using this in production with HC V.3.12 (we have our own queue implementation) and we would want to keep the functionality. I am not sure it is something we would want to handle at the application level without trying to build the same distribution already supported in HC.\nYou are right about the complexity that this could add to the codebase. For this enhancement, it just turns out that it was rather limited in my opinion.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r460022451", "createdAt": "2020-07-24T12:30:26Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE4MzY1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueItem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyNDowMlrOGvzyDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjo0MTo1MFrOGwdN4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDY1Mw==", "bodyText": "What is the advantage of using a getter here?", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452784653", "createdAt": "2020-07-10T11:24:02Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueItem.java", "diffHunk": "@@ -96,10 +96,10 @@ public void readData(ObjectDataInput in) throws IOException {\n     }\n \n     @Override\n-    public int compareTo(QueueItem o) {\n-        if (itemId < o.getItemId()) {\n+    public int compareTo(QueueItem other) {\n+        if (getItemId() < other.getItemId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2MzUyMA==", "bodyText": "Nope. Will revert back.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453463520", "createdAt": "2020-07-13T06:41:50Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueItem.java", "diffHunk": "@@ -96,10 +96,10 @@ public void readData(ObjectDataInput in) throws IOException {\n     }\n \n     @Override\n-    public int compareTo(QueueItem o) {\n-        if (itemId < o.getItemId()) {\n+    public int compareTo(QueueItem other) {\n+        if (getItemId() < other.getItemId()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDY1Mw=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE5MjI2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyNzowOFrOGvz3Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNzoxMDoyMVrOGwdk7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTk3MA==", "bodyText": "The NoDuplicatePriorityQueue is stored in a single partition and as a consequence will not be accessed concurrently. There should not be any need to synchronize.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452785970", "createdAt": "2020-07-10T11:27:08Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.Data;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+    private Set<Data> dataSet = new HashSet();\r\n+    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\r\n+\r\n+    /**\r\n+     * Constructs an instance of {@code NoDuplicatePriorityQueue}\r\n+     *\r\n+     * @param comparator supplied comparator to be used by this priority queue\r\n+     */\r\n+    public NoDuplicatePriorityQueue(Comparator<QueueItem> comparator) {\r\n+        super(comparator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean offer(QueueItem e) {\r\n+        Lock lock = this.readWriteLock.writeLock();\r\n+        Data otherData = e.getData();\r\n+        if (dataSet.contains(otherData)) {\r\n+            return false;\r\n+        }\r\n+        lock.lock();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2OTQyMA==", "bodyText": "Ok", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453469420", "createdAt": "2020-07-13T07:10:21Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.Data;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+    private Set<Data> dataSet = new HashSet();\r\n+    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\r\n+\r\n+    /**\r\n+     * Constructs an instance of {@code NoDuplicatePriorityQueue}\r\n+     *\r\n+     * @param comparator supplied comparator to be used by this priority queue\r\n+     */\r\n+    public NoDuplicatePriorityQueue(Comparator<QueueItem> comparator) {\r\n+        super(comparator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean offer(QueueItem e) {\r\n+        Lock lock = this.readWriteLock.writeLock();\r\n+        Data otherData = e.getData();\r\n+        if (dataSet.contains(otherData)) {\r\n+            return false;\r\n+        }\r\n+        lock.lock();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTk3MA=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE5Njg3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyODo0NlrOGvz52g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOToxMDozOVrOG2od0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NjY1MA==", "bodyText": "This add a constant memory overhead per item stored. I can't say I'm too excited about that.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452786650", "createdAt": "2020-07-10T11:28:46Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.Data;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+    private Set<Data> dataSet = new HashSet();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzOTI4Mw==", "bodyText": "Right. This is a comparable implementation of something we are using in production with HC 3.12 where IQueue SPI allowed creation of specialized queue.\nAny suggestion on how to improve this?", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459939283", "createdAt": "2020-07-24T09:10:39Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.Data;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+    private Set<Data> dataSet = new HashSet();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NjY1MA=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzIyMTUyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/ForwardingQueueItemComparator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTozODowMFrOGv0IUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzowMDo1NlrOHC4Qrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDM1Mg==", "bodyText": "The complexity to add an item to the priority is O(Log(N)) because the priority queue is based on a binary heap.\nBut now the value that is added, is deserialized very every value it needs to be compared with.\nSo with N items, the total number of deserializations is 2Log(N)). If there are many items in the priority queue or when the items take a long time to deserialize, this can be a serious performance problem. So I would at least optimize is so that Log(N)+1 deserialization are needed instead of 2Log(N))", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452790352", "createdAt": "2020-07-10T11:38:00Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/ForwardingQueueItemComparator.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.SerializationService;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.Objects;\r\n+\r\n+/**\r\n+ * A comparator which forwards its {@link Comparator#compare(Object, Object)} to another supplied comparator.\r\n+ * If {@code comparator} is {@code null}, then {@link Comparator#compare(Object, Object)}\r\n+ * uses {@link QueueItem#compareTo(QueueItem)}\r\n+ *\r\n+ * @param <T> the type of objects that may be compared by the delegated comparator\r\n+ *           as defined by the supplied comparator instance in {QueueConfig}\r\n+ */\r\n+public final class ForwardingQueueItemComparator<T> implements Comparator<QueueItem> {\r\n+\r\n+    private final Comparator<T> customComparator;\r\n+    private final SerializationService serializationService;\r\n+\r\n+    public ForwardingQueueItemComparator(final Comparator<T> customComparator,\r\n+                                         final SerializationService serializationService) {\r\n+        Objects.requireNonNull(customComparator, \"Custom comparator cannot be null.\");\r\n+        this.customComparator = customComparator;\r\n+        this.serializationService = serializationService;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compare(QueueItem o1, QueueItem o2) {\r\n+        T object1 = (T) serializationService.toObject(o1.getData());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NTE0MA==", "bodyText": "You could cache the value in the comparator but be very careful with caching a value indefinably. I'm not sure if a new comparator is created or an existing one is recycled.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453455140", "createdAt": "2020-07-13T06:15:43Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/ForwardingQueueItemComparator.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.SerializationService;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.Objects;\r\n+\r\n+/**\r\n+ * A comparator which forwards its {@link Comparator#compare(Object, Object)} to another supplied comparator.\r\n+ * If {@code comparator} is {@code null}, then {@link Comparator#compare(Object, Object)}\r\n+ * uses {@link QueueItem#compareTo(QueueItem)}\r\n+ *\r\n+ * @param <T> the type of objects that may be compared by the delegated comparator\r\n+ *           as defined by the supplied comparator instance in {QueueConfig}\r\n+ */\r\n+public final class ForwardingQueueItemComparator<T> implements Comparator<QueueItem> {\r\n+\r\n+    private final Comparator<T> customComparator;\r\n+    private final SerializationService serializationService;\r\n+\r\n+    public ForwardingQueueItemComparator(final Comparator<T> customComparator,\r\n+                                         final SerializationService serializationService) {\r\n+        Objects.requireNonNull(customComparator, \"Custom comparator cannot be null.\");\r\n+        this.customComparator = customComparator;\r\n+        this.serializationService = serializationService;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compare(QueueItem o1, QueueItem o2) {\r\n+        T object1 = (T) serializationService.toObject(o1.getData());\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDM1Mg=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc4MDk3NQ==", "bodyText": "Added deserialized value caching in QueueItem, it will only be used in case of priority queue.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r472780975", "createdAt": "2020-08-19T07:00:56Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/ForwardingQueueItemComparator.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.SerializationService;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.Objects;\r\n+\r\n+/**\r\n+ * A comparator which forwards its {@link Comparator#compare(Object, Object)} to another supplied comparator.\r\n+ * If {@code comparator} is {@code null}, then {@link Comparator#compare(Object, Object)}\r\n+ * uses {@link QueueItem#compareTo(QueueItem)}\r\n+ *\r\n+ * @param <T> the type of objects that may be compared by the delegated comparator\r\n+ *           as defined by the supplied comparator instance in {QueueConfig}\r\n+ */\r\n+public final class ForwardingQueueItemComparator<T> implements Comparator<QueueItem> {\r\n+\r\n+    private final Comparator<T> customComparator;\r\n+    private final SerializationService serializationService;\r\n+\r\n+    public ForwardingQueueItemComparator(final Comparator<T> customComparator,\r\n+                                         final SerializationService serializationService) {\r\n+        Objects.requireNonNull(customComparator, \"Custom comparator cannot be null.\");\r\n+        this.customComparator = customComparator;\r\n+        this.serializationService = serializationService;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compare(QueueItem o1, QueueItem o2) {\r\n+        T object1 = (T) serializationService.toObject(o1.getData());\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDM1Mg=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzI2MTU4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueDataSerializerHook.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo1NDowNFrOGv0g8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjo0NDoxNlrOGwdQ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjY1Ng==", "bodyText": "I don't see any change in the 'constructors' array", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452796656", "createdAt": "2020-07-10T11:54:04Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueDataSerializerHook.java", "diffHunk": "@@ -127,6 +127,8 @@\n     public static final int MERGE = 44;\n     public static final int MERGE_BACKUP = 45;\n \n+    public static final int PRIORITY_QUEUE_COMPARATOR = 46;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NzE0Nw==", "bodyText": "I don't believe we need an explicit serializer for this logic. It can just piggyback on whatever kind of serialization is in place. So let it implement the appropriate serialization interface.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452797147", "createdAt": "2020-07-10T11:55:19Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueDataSerializerHook.java", "diffHunk": "@@ -127,6 +127,8 @@\n     public static final int MERGE = 44;\n     public static final int MERGE_BACKUP = 45;\n \n+    public static final int PRIORITY_QUEUE_COMPARATOR = 46;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjY1Ng=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2NDMxNA==", "bodyText": "Ups! This just a tryout which slips into commit. Will revert it.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453464314", "createdAt": "2020-07-13T06:44:16Z", "author": {"login": "wangumer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueDataSerializerHook.java", "diffHunk": "@@ -127,6 +127,8 @@\n     public static final int MERGE = 44;\n     public static final int MERGE_BACKUP = 45;\n \n+    public static final int PRIORITY_QUEUE_COMPARATOR = 46;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjY1Ng=="}, "originalCommit": {"oid": "58af35720bb7aa554539c48c8fad696bf74f6619"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzYwMzg5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozMDowOFrOG2NQMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzowMTozNlrOHC4SkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzQyNQ==", "bodyText": "This is not going to work. The issue is that the same data might be serialized differently from time to time; so the same instance is not guaranteed to give the same Data.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459493425", "createdAt": "2020-07-23T14:30:08Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.BinaryInterface;\r\n+import com.hazelcast.internal.serialization.Data;\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+@BinaryInterface\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+\r\n+    private Set<Data> dataSet = new HashSet();\r\n+\r\n+    /**\r\n+     * Constructs an instance of {@code NoDuplicatePriorityQueue}\r\n+     *\r\n+     * @param comparator supplied comparator to be used by this priority queue\r\n+     */\r\n+    public NoDuplicatePriorityQueue(Comparator<QueueItem> comparator) {\r\n+        super(comparator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean offer(QueueItem e) {\r\n+        Data otherData = e.getData();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb78280dd0b5f3224a038329ce47809dde1e5ddc"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc4MTQ1Ng==", "bodyText": "Can you elaborate how the same instance serializes as different Data instances?", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r472781456", "createdAt": "2020-08-19T07:01:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.BinaryInterface;\r\n+import com.hazelcast.internal.serialization.Data;\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+@BinaryInterface\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+\r\n+    private Set<Data> dataSet = new HashSet();\r\n+\r\n+    /**\r\n+     * Constructs an instance of {@code NoDuplicatePriorityQueue}\r\n+     *\r\n+     * @param comparator supplied comparator to be used by this priority queue\r\n+     */\r\n+    public NoDuplicatePriorityQueue(Comparator<QueueItem> comparator) {\r\n+        super(comparator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean offer(QueueItem e) {\r\n+        Data otherData = e.getData();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzQyNQ=="}, "originalCommit": {"oid": "bb78280dd0b5f3224a038329ce47809dde1e5ddc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mzc0MDQ2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjoyOToyNFrOHHJvEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTozMDo1OFrOHIMAuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2MTU4Nw==", "bodyText": "I would consider caching config.isPriorityQueue() in a final field. If the config changes - that is shouldn't, but still - for any reason, we get a funky behavior.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477261587", "createdAt": "2020-08-26T12:29:24Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueContainer.java", "diffHunk": "@@ -430,22 +446,32 @@ public QueueItem txnPeek(long offerId, UUID transactionId) {\n     // TX Methods Ends\n \n     public long offer(Data data) {\n-        QueueItem item = new QueueItem(this, nextId(), null);\n+        Data itemData = shouldKeepItemData() ? data : null;\n+        QueueItem item = new QueueItem(this, nextId(), itemData);\n         if (store.isEnabled()) {\n             try {\n                 store.store(item.getItemId(), data);\n             } catch (Exception e) {\n                 throw new HazelcastException(e);\n             }\n         }\n-        if (!store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()) {\n-            item.setData(data);\n-        }\n         getItemQueue().offer(item);\n         cancelEvictionIfExists();\n         return item.getItemId();\n     }\n \n+    /**\n+     * Returns {@code true} if we should keep queue item data in-memory. This is\n+     * the case if the queue store is disabled, we have not yet hit the in-memory\n+     * limit or we are using a priority queue which needs item values to sort the\n+     * queue items.\n+     */\n+    private boolean shouldKeepItemData() {\n+        return !store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()\n+                || config.isPriorityQueue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NzQ0OA==", "bodyText": "Cached. I see we have other calls to config in various methods but I'll keep that for another PR.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478347448", "createdAt": "2020-08-27T11:30:58Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueContainer.java", "diffHunk": "@@ -430,22 +446,32 @@ public QueueItem txnPeek(long offerId, UUID transactionId) {\n     // TX Methods Ends\n \n     public long offer(Data data) {\n-        QueueItem item = new QueueItem(this, nextId(), null);\n+        Data itemData = shouldKeepItemData() ? data : null;\n+        QueueItem item = new QueueItem(this, nextId(), itemData);\n         if (store.isEnabled()) {\n             try {\n                 store.store(item.getItemId(), data);\n             } catch (Exception e) {\n                 throw new HazelcastException(e);\n             }\n         }\n-        if (!store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()) {\n-            item.setData(data);\n-        }\n         getItemQueue().offer(item);\n         cancelEvictionIfExists();\n         return item.getItemId();\n     }\n \n+    /**\n+     * Returns {@code true} if we should keep queue item data in-memory. This is\n+     * the case if the queue store is disabled, we have not yet hit the in-memory\n+     * limit or we are using a priority queue which needs item values to sort the\n+     * queue items.\n+     */\n+    private boolean shouldKeepItemData() {\n+        return !store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()\n+                || config.isPriorityQueue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2MTU4Nw=="}, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzgwNjI0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueStoreWrapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo0NTo1MlrOHHKW0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo0NTo1MlrOHHKW0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3MTc2Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477271762", "createdAt": "2020-08-26T12:45:52Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueStoreWrapper.java", "diffHunk": "@@ -78,24 +66,29 @@ private QueueStoreWrapper(String name) {\n      * @param serializationService serialization service.\n      * @return returns a new instance of {@link QueueStoreWrapper}\n      */\n-    public static QueueStoreWrapper create(String name, QueueStoreConfig storeConfig\n-            , SerializationService serializationService, ClassLoader classLoader) {\n+    public static QueueStoreWrapper create(@Nonnull String name,\n+                                           @Nullable QueueStoreConfig storeConfig,\n+                                           @Nonnull SerializationService serializationService,\n+                                           @Nullable ClassLoader classLoader) {\n         checkNotNull(name, \"name should not be null\");\n         checkNotNull(serializationService, \"serializationService should not be null\");\n \n-        final QueueStoreWrapper storeWrapper = new QueueStoreWrapper(name);\n+        QueueStoreWrapper storeWrapper = new QueueStoreWrapper(name);\n         storeWrapper.setSerializationService(serializationService);\n         if (storeConfig == null || !storeConfig.isEnabled()) {\n             return storeWrapper;\n         }\n         // create queue store.\n-        final QueueStore queueStore = createQueueStore(name, storeConfig, classLoader);\n+        QueueStore queueStore = createQueueStore(name, storeConfig, classLoader);\n         if (queueStore != null) {\n-            storeWrapper.setEnabled(storeConfig.isEnabled());\n-            storeWrapper.setBinary(Boolean.parseBoolean(storeConfig.getProperty(STORE_BINARY)));\n-            storeWrapper.setMemoryLimit(parseInt(STORE_MEMORY_LIMIT, DEFAULT_MEMORY_LIMIT, storeConfig));\n-            storeWrapper.setBulkLoad(parseInt(STORE_BULK_LOAD, DEFAULT_BULK_LOAD, storeConfig));\n-            storeWrapper.setStore(queueStore);\n+            boolean isBinary = Boolean.parseBoolean(storeConfig.getProperty(QueueStoreConfig.STORE_BINARY));\n+            int memoryLimit = parseInt(QueueStoreConfig.STORE_MEMORY_LIMIT, DEFAULT_MEMORY_LIMIT, storeConfig);\n+            int bulkLoad = parseInt(QueueStoreConfig.STORE_BULK_LOAD, DEFAULT_BULK_LOAD, storeConfig);\n+            storeWrapper.setEnabled(storeConfig.isEnabled())\n+                        .setBinary(isBinary)\n+                        .setMemoryLimit(memoryLimit)\n+                        .setBulkLoad(bulkLoad)\n+                        .setStore(queueStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzgzMjgzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo1MjozNlrOHHKnIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTozMDozMlrOHIL_0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NTkzNg==", "bodyText": "I'd consider adding a check here that warns if queueStoreConfig#memoryLimit is set together with comparatorClassName. I'd even consider treating this situation an invalid configuration since we ignore memoryLimit in the implementation, which is against the user's intention.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477275936", "createdAt": "2020-08-26T12:52:36Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -207,7 +217,7 @@ public QueueStoreConfig getQueueStoreConfig() {\n      * @param queueStoreConfig set the QueueStore configuration to this configuration\n      * @return the QueueStore configuration\n      */\n-    public QueueConfig setQueueStoreConfig(QueueStoreConfig queueStoreConfig) {\n+    public QueueConfig setQueueStoreConfig(@Nullable QueueStoreConfig queueStoreConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NzIxOQ==", "bodyText": "As agreed, added warning on queue container startup because of two reasons:\n\nthere is a limit set by default and the only way to disable it is to set it to Integer.MAX_VALUE\nI prefer not to do validation while the config is still being created, maybe the user is in the process of making it valid.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478347219", "createdAt": "2020-08-27T11:30:32Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -207,7 +217,7 @@ public QueueStoreConfig getQueueStoreConfig() {\n      * @param queueStoreConfig set the QueueStore configuration to this configuration\n      * @return the QueueStore configuration\n      */\n-    public QueueConfig setQueueStoreConfig(QueueStoreConfig queueStoreConfig) {\n+    public QueueConfig setQueueStoreConfig(@Nullable QueueStoreConfig queueStoreConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NTkzNg=="}, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzgzNzI3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo1Mzo1NlrOHHKqJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToyOToyNVrOHIL9hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NjcxMQ==", "bodyText": "I would add that setting this to non-null also makes the store's memory limit setting ignored.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477276711", "createdAt": "2020-08-26T12:53:56Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -318,11 +328,44 @@ public MergePolicyConfig getMergePolicyConfig() {\n      *\n      * @return the updated queue configuration\n      */\n-    public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n+    public QueueConfig setMergePolicyConfig(@Nonnull MergePolicyConfig mergePolicyConfig) {\n         this.mergePolicyConfig = checkNotNull(mergePolicyConfig, \"mergePolicyConfig cannot be null\");\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise\n+     * it is a FIFO queue.\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false}\n+     * otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return !StringUtil.isNullOrEmptyAfterTrim(priorityComparatorClassName);\n+    }\n+\n+    /**\n+     * Returns the class name that will be used to compare queue items.\n+     * If the returned class name is non-empty, the queue will behave as a priority\n+     * queue, otherwise it behaves as a FIFO queue.\n+     */\n+    public @Nullable String getPriorityComparatorClassName() {\n+        return priorityComparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name that will be used to compare queue items.\n+     * If the provided class name is non-empty, the queue will behave as a priority\n+     * queue, otherwise it behaves as a FIFO queue.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjYzMQ==", "bodyText": "Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346631", "createdAt": "2020-08-27T11:29:25Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -318,11 +328,44 @@ public MergePolicyConfig getMergePolicyConfig() {\n      *\n      * @return the updated queue configuration\n      */\n-    public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n+    public QueueConfig setMergePolicyConfig(@Nonnull MergePolicyConfig mergePolicyConfig) {\n         this.mergePolicyConfig = checkNotNull(mergePolicyConfig, \"mergePolicyConfig cannot be null\");\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise\n+     * it is a FIFO queue.\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false}\n+     * otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return !StringUtil.isNullOrEmptyAfterTrim(priorityComparatorClassName);\n+    }\n+\n+    /**\n+     * Returns the class name that will be used to compare queue items.\n+     * If the returned class name is non-empty, the queue will behave as a priority\n+     * queue, otherwise it behaves as a FIFO queue.\n+     */\n+    public @Nullable String getPriorityComparatorClassName() {\n+        return priorityComparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name that will be used to compare queue items.\n+     * If the provided class name is non-empty, the queue will behave as a priority\n+     * queue, otherwise it behaves as a FIFO queue.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NjcxMQ=="}, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mzg1NDQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjo1ODoxMVrOHHK01Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToyOToxOVrOHIL9TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3OTQ0NQ==", "bodyText": "I would add it here as well that setting this makes the store's memory limit ignored.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477279445", "createdAt": "2020-08-26T12:58:11Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "diffHunk": "@@ -556,6 +556,14 @@\n \n     <xs:complexType name=\"queue\">\n         <xs:all>\n+        \t<xs:element name=\"priority-comparator-class-name\" type=\"non-space-string\" minOccurs=\"0\" maxOccurs=\"1\" >\n+\t            <xs:annotation>\n+\t                <xs:documentation>\n+\t                    Fully-qualified comparator's class name to be used for the priority queue.\n+\t                    If nothing is provided, then queue behaves as a FIFO queue.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjU3Mg==", "bodyText": "Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346572", "createdAt": "2020-08-27T11:29:19Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "diffHunk": "@@ -556,6 +556,14 @@\n \n     <xs:complexType name=\"queue\">\n         <xs:all>\n+        \t<xs:element name=\"priority-comparator-class-name\" type=\"non-space-string\" minOccurs=\"0\" maxOccurs=\"1\" >\n+\t            <xs:annotation>\n+\t                <xs:documentation>\n+\t                    Fully-qualified comparator's class name to be used for the priority queue.\n+\t                    If nothing is provided, then queue behaves as a FIFO queue.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3OTQ0NQ=="}, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mzg5MzkzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityWithDuplicateCheckTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzowODowM1rOHHLNXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToyOToxMlrOHIL9Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTcyNw==", "bodyText": "Already queueTriple \ud83d\ude04", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477285727", "createdAt": "2020-08-26T13:08:03Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityWithDuplicateCheckTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.collection.IQueue;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\r\n+import com.hazelcast.config.Config;\r\n+import com.hazelcast.core.HazelcastInstance;\r\n+import com.hazelcast.logging.ILogger;\r\n+import com.hazelcast.logging.Logger;\r\n+import com.hazelcast.map.IMap;\r\n+import com.hazelcast.test.HazelcastParallelClassRunner;\r\n+import com.hazelcast.test.HazelcastTestSupport;\r\n+import com.hazelcast.test.annotation.ParallelJVMTest;\r\n+import com.hazelcast.test.annotation.QuickTest;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+import org.junit.experimental.categories.Category;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import java.util.concurrent.ConcurrentSkipListSet;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.atomic.AtomicInteger;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertNull;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+@RunWith(HazelcastParallelClassRunner.class)\r\n+@Category({QuickTest.class, ParallelJVMTest.class})\r\n+public class QueuePriorityWithDuplicateCheckTest extends HazelcastTestSupport {\r\n+\r\n+    private static final ILogger LOG = Logger.getLogger(QueuePriorityWithDuplicateCheckTest.class);\r\n+    private PriorityElementTaskQueueImpl queue;\r\n+\r\n+    @Before\r\n+    public void before() {\r\n+        Config config = smallInstanceConfig();\r\n+        String queueName = randomName();\r\n+        String mapName = randomName();\r\n+\r\n+        config.getQueueConfig(queueName)\r\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\r\n+        HazelcastInstance hz = createHazelcastInstance(config);\r\n+        queue = new PriorityElementTaskQueueImpl(hz.getQueue(queueName), hz.getMap(mapName));\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queue() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        assertEquals(element, queue.dequeue());\r\n+        assertNull(queue.dequeue());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queueDouble() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjIyMg==", "bodyText": "Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346222", "createdAt": "2020-08-27T11:28:40Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityWithDuplicateCheckTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.collection.IQueue;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\r\n+import com.hazelcast.config.Config;\r\n+import com.hazelcast.core.HazelcastInstance;\r\n+import com.hazelcast.logging.ILogger;\r\n+import com.hazelcast.logging.Logger;\r\n+import com.hazelcast.map.IMap;\r\n+import com.hazelcast.test.HazelcastParallelClassRunner;\r\n+import com.hazelcast.test.HazelcastTestSupport;\r\n+import com.hazelcast.test.annotation.ParallelJVMTest;\r\n+import com.hazelcast.test.annotation.QuickTest;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+import org.junit.experimental.categories.Category;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import java.util.concurrent.ConcurrentSkipListSet;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.atomic.AtomicInteger;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertNull;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+@RunWith(HazelcastParallelClassRunner.class)\r\n+@Category({QuickTest.class, ParallelJVMTest.class})\r\n+public class QueuePriorityWithDuplicateCheckTest extends HazelcastTestSupport {\r\n+\r\n+    private static final ILogger LOG = Logger.getLogger(QueuePriorityWithDuplicateCheckTest.class);\r\n+    private PriorityElementTaskQueueImpl queue;\r\n+\r\n+    @Before\r\n+    public void before() {\r\n+        Config config = smallInstanceConfig();\r\n+        String queueName = randomName();\r\n+        String mapName = randomName();\r\n+\r\n+        config.getQueueConfig(queueName)\r\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\r\n+        HazelcastInstance hz = createHazelcastInstance(config);\r\n+        queue = new PriorityElementTaskQueueImpl(hz.getQueue(queueName), hz.getMap(mapName));\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queue() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        assertEquals(element, queue.dequeue());\r\n+        assertNull(queue.dequeue());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queueDouble() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTcyNw=="}, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjUwMg==", "bodyText": "Also changed the Semaphores with negative initial values to CountDownLatch.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346502", "createdAt": "2020-08-27T11:29:12Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityWithDuplicateCheckTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.collection.IQueue;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\r\n+import com.hazelcast.config.Config;\r\n+import com.hazelcast.core.HazelcastInstance;\r\n+import com.hazelcast.logging.ILogger;\r\n+import com.hazelcast.logging.Logger;\r\n+import com.hazelcast.map.IMap;\r\n+import com.hazelcast.test.HazelcastParallelClassRunner;\r\n+import com.hazelcast.test.HazelcastTestSupport;\r\n+import com.hazelcast.test.annotation.ParallelJVMTest;\r\n+import com.hazelcast.test.annotation.QuickTest;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+import org.junit.experimental.categories.Category;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import java.util.concurrent.ConcurrentSkipListSet;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.atomic.AtomicInteger;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertNull;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+@RunWith(HazelcastParallelClassRunner.class)\r\n+@Category({QuickTest.class, ParallelJVMTest.class})\r\n+public class QueuePriorityWithDuplicateCheckTest extends HazelcastTestSupport {\r\n+\r\n+    private static final ILogger LOG = Logger.getLogger(QueuePriorityWithDuplicateCheckTest.class);\r\n+    private PriorityElementTaskQueueImpl queue;\r\n+\r\n+    @Before\r\n+    public void before() {\r\n+        Config config = smallInstanceConfig();\r\n+        String queueName = randomName();\r\n+        String mapName = randomName();\r\n+\r\n+        config.getQueueConfig(queueName)\r\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\r\n+        HazelcastInstance hz = createHazelcastInstance(config);\r\n+        queue = new PriorityElementTaskQueueImpl(hz.getQueue(queueName), hz.getMap(mapName));\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queue() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        assertEquals(element, queue.dequeue());\r\n+        assertNull(queue.dequeue());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queueDouble() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTcyNw=="}, "originalCommit": {"oid": "edbdf8c06041a210c4b9636f6b740ba8167683ed"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDI4MjA1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToyMzozOVrOHILySA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTozMToyNVrOHIMBpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0Mzc1Mg==", "bodyText": "Shall we shutdown the executor in the end of the test to avoid leak?", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478343752", "createdAt": "2020-08-27T11:23:39Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.collection.impl.queue;\n+\n+import com.hazelcast.collection.IQueue;\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class QueuePriorityTest extends HazelcastTestSupport {\n+    private IQueue<PriorityElement> queue;\n+\n+    @Before\n+    public void before() {\n+        Config config = smallInstanceConfig();\n+        config.getQueueConfig(\"default\")\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n+        HazelcastInstance[] instances = factory.newInstances(config);\n+        queue = instances[0].getQueue(generateKeyOwnedBy(instances[1]));\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenHighestOfferedSecond_thenTakeHighest() {\n+\n+        PriorityElement elementLow = new PriorityElement(false, 1);\n+        PriorityElement elementHigh = new PriorityElement(true, 1);\n+\n+        assertTrue(queue.offer(elementLow));\n+        assertTrue(queue.offer(elementHigh));\n+        assertEquals(2, queue.size());\n+        assertTrue(queue.poll().isHighPriority());\n+        assertFalse(queue.poll().isHighPriority());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenHighestOfferedFirst_thenTakeHighest() {\n+\n+        PriorityElement elementLow = new PriorityElement(false, 1);\n+        PriorityElement elementHigh = new PriorityElement(true, 1);\n+\n+        assertTrue(queue.offer(elementHigh));\n+        assertTrue(queue.offer(elementLow));\n+        assertEquals(2, queue.size());\n+        assertTrue(queue.poll().isHighPriority());\n+        assertFalse(queue.poll().isHighPriority());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenTwoHighest_thenTakeFirstVersion() {\n+        PriorityElement elementHigh1 = new PriorityElement(true, 1);\n+        PriorityElement elementHigh2 = new PriorityElement(true, 2);\n+\n+        assertTrue(queue.offer(elementHigh1));\n+        assertTrue(queue.offer(elementHigh2));\n+        assertEquals(2, queue.size());\n+        assertEquals(1, queue.poll().getVersion());\n+        assertEquals(2, queue.poll().getVersion());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenTwoHighest_thenTakeFirstVersionAgain() {\n+\n+        PriorityElement elementHigh1 = new PriorityElement(true, 1);\n+        PriorityElement elementHigh2 = new PriorityElement(true, 2);\n+\n+        assertTrue(queue.offer(elementHigh2));\n+        assertTrue(queue.offer(elementHigh1));\n+        assertEquals(2, queue.size());\n+        assertEquals(1, queue.poll().getVersion());\n+        assertEquals(2, queue.poll().getVersion());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void queue() {\n+        PriorityElement element = new PriorityElement(false, 1);\n+        queue.offer(element);\n+        assertEquals(element, queue.poll());\n+        assertNull(queue.poll());\n+    }\n+\n+    @Test\n+    public void queuePrioritizing() {\n+        int count = 0;\n+        int elementCount = 100;\n+        for (int i = 0; i < elementCount; i++) {\n+            queue.offer(new PriorityElement(false, count));\n+            queue.offer(new PriorityElement(true, count));\n+            count++;\n+        }\n+\n+        for (int i = 0; i < elementCount; i++) {\n+            PriorityElement dequeue = queue.poll();\n+            assertTrue(\"High priority first\", dequeue.isHighPriority());\n+            assertEquals(i, dequeue.getVersion());\n+        }\n+        for (int i = 0; i < elementCount; i++) {\n+            PriorityElement dequeue = queue.poll();\n+            assertFalse(\"Low priority afterwards\", dequeue.isHighPriority());\n+            assertEquals(i, dequeue.getVersion());\n+        }\n+        assertNull(queue.poll());\n+    }\n+\n+    @Test\n+    public void queueConsistency() throws InterruptedException {\n+        int count = 0;\n+        for (int i = 0; i < 500; i++) {\n+            queue.offer(new PriorityElement(false, count));\n+            queue.offer(new PriorityElement(true, count));\n+            count++;\n+        }\n+        ExecutorService threadPool = Executors.newCachedThreadPool();\n+        ConcurrentSkipListSet<PriorityElement> tasks = new ConcurrentSkipListSet<>(new PriorityElementComparator());\n+        Semaphore sem = new Semaphore(-99);\n+        for (int i = 0; i < 100; i++) {\n+            threadPool.execute(() -> {\n+                PriorityElement task;\n+                while ((task = queue.poll()) != null) {\n+                    tasks.add(task);\n+                }\n+                sem.release();\n+            });\n+        }\n+        sem.acquire();\n+        assertEquals(500 * 2, tasks.size());\n+        assertNull(queue.poll());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d90fb075a7d66efb647c05f7b754176a74fd81e"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NzY4NA==", "bodyText": "Nice catch! Added creation and destruction in Before and After blocks.", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478347684", "createdAt": "2020-08-27T11:31:25Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.collection.impl.queue;\n+\n+import com.hazelcast.collection.IQueue;\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class QueuePriorityTest extends HazelcastTestSupport {\n+    private IQueue<PriorityElement> queue;\n+\n+    @Before\n+    public void before() {\n+        Config config = smallInstanceConfig();\n+        config.getQueueConfig(\"default\")\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n+        HazelcastInstance[] instances = factory.newInstances(config);\n+        queue = instances[0].getQueue(generateKeyOwnedBy(instances[1]));\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenHighestOfferedSecond_thenTakeHighest() {\n+\n+        PriorityElement elementLow = new PriorityElement(false, 1);\n+        PriorityElement elementHigh = new PriorityElement(true, 1);\n+\n+        assertTrue(queue.offer(elementLow));\n+        assertTrue(queue.offer(elementHigh));\n+        assertEquals(2, queue.size());\n+        assertTrue(queue.poll().isHighPriority());\n+        assertFalse(queue.poll().isHighPriority());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenHighestOfferedFirst_thenTakeHighest() {\n+\n+        PriorityElement elementLow = new PriorityElement(false, 1);\n+        PriorityElement elementHigh = new PriorityElement(true, 1);\n+\n+        assertTrue(queue.offer(elementHigh));\n+        assertTrue(queue.offer(elementLow));\n+        assertEquals(2, queue.size());\n+        assertTrue(queue.poll().isHighPriority());\n+        assertFalse(queue.poll().isHighPriority());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenTwoHighest_thenTakeFirstVersion() {\n+        PriorityElement elementHigh1 = new PriorityElement(true, 1);\n+        PriorityElement elementHigh2 = new PriorityElement(true, 2);\n+\n+        assertTrue(queue.offer(elementHigh1));\n+        assertTrue(queue.offer(elementHigh2));\n+        assertEquals(2, queue.size());\n+        assertEquals(1, queue.poll().getVersion());\n+        assertEquals(2, queue.poll().getVersion());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenTwoHighest_thenTakeFirstVersionAgain() {\n+\n+        PriorityElement elementHigh1 = new PriorityElement(true, 1);\n+        PriorityElement elementHigh2 = new PriorityElement(true, 2);\n+\n+        assertTrue(queue.offer(elementHigh2));\n+        assertTrue(queue.offer(elementHigh1));\n+        assertEquals(2, queue.size());\n+        assertEquals(1, queue.poll().getVersion());\n+        assertEquals(2, queue.poll().getVersion());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void queue() {\n+        PriorityElement element = new PriorityElement(false, 1);\n+        queue.offer(element);\n+        assertEquals(element, queue.poll());\n+        assertNull(queue.poll());\n+    }\n+\n+    @Test\n+    public void queuePrioritizing() {\n+        int count = 0;\n+        int elementCount = 100;\n+        for (int i = 0; i < elementCount; i++) {\n+            queue.offer(new PriorityElement(false, count));\n+            queue.offer(new PriorityElement(true, count));\n+            count++;\n+        }\n+\n+        for (int i = 0; i < elementCount; i++) {\n+            PriorityElement dequeue = queue.poll();\n+            assertTrue(\"High priority first\", dequeue.isHighPriority());\n+            assertEquals(i, dequeue.getVersion());\n+        }\n+        for (int i = 0; i < elementCount; i++) {\n+            PriorityElement dequeue = queue.poll();\n+            assertFalse(\"Low priority afterwards\", dequeue.isHighPriority());\n+            assertEquals(i, dequeue.getVersion());\n+        }\n+        assertNull(queue.poll());\n+    }\n+\n+    @Test\n+    public void queueConsistency() throws InterruptedException {\n+        int count = 0;\n+        for (int i = 0; i < 500; i++) {\n+            queue.offer(new PriorityElement(false, count));\n+            queue.offer(new PriorityElement(true, count));\n+            count++;\n+        }\n+        ExecutorService threadPool = Executors.newCachedThreadPool();\n+        ConcurrentSkipListSet<PriorityElement> tasks = new ConcurrentSkipListSet<>(new PriorityElementComparator());\n+        Semaphore sem = new Semaphore(-99);\n+        for (int i = 0; i < 100; i++) {\n+            threadPool.execute(() -> {\n+                PriorityElement task;\n+                while ((task = queue.poll()) != null) {\n+                    tasks.add(task);\n+                }\n+                sem.release();\n+            });\n+        }\n+        sem.acquire();\n+        assertEquals(500 * 2, tasks.size());\n+        assertNull(queue.poll());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0Mzc1Mg=="}, "originalCommit": {"oid": "0d90fb075a7d66efb647c05f7b754176a74fd81e"}, "originalPosition": 169}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 472, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}