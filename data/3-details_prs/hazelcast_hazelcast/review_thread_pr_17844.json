{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NDk0NjA3", "number": 17844, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzoxMTo1MlrOE8Nc6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoxNzoyNVrOE8PE8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTcwNDEwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzoxMTo1MlrOH4M0ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDo0ODowOVrOH4Qr5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5MjQxOQ==", "bodyText": "can tryConnectToAllClusterMembers  be called multiple times? if so, multiple scheduled tasks?", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528692419", "createdAt": "2020-11-23T13:11:52Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -299,23 +300,24 @@ public synchronized void start() {\n \n         heartbeat.start();\n         connectToCluster();\n-        if (isSmartRoutingEnabled) {\n-            executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);\n-        }\n     }\n \n-    public void connectToAllClusterMembers() {\n+    public void tryConnectToAllClusterMembers(boolean sync) {\n         if (!isSmartRoutingEnabled) {\n             return;\n         }\n \n-        for (Member member : client.getClientClusterService().getMemberList()) {\n-            try {\n-                getOrConnect(member.getAddress());\n-            } catch (Exception e) {\n-                EmptyStatement.ignore(e);\n+        if (sync) {\n+            for (Member member : client.getClientClusterService().getMemberList()) {\n+                try {\n+                    getOrConnectToMember(member);\n+                } catch (Exception e) {\n+                    EmptyStatement.ignore(e);\n+                }\n             }\n         }\n+\n+        executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc1NTY4Nw==", "bodyText": "No, it can not. We are calling it only once at the beginning of an instance.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528755687", "createdAt": "2020-11-23T14:48:09Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -299,23 +300,24 @@ public synchronized void start() {\n \n         heartbeat.start();\n         connectToCluster();\n-        if (isSmartRoutingEnabled) {\n-            executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);\n-        }\n     }\n \n-    public void connectToAllClusterMembers() {\n+    public void tryConnectToAllClusterMembers(boolean sync) {\n         if (!isSmartRoutingEnabled) {\n             return;\n         }\n \n-        for (Member member : client.getClientClusterService().getMemberList()) {\n-            try {\n-                getOrConnect(member.getAddress());\n-            } catch (Exception e) {\n-                EmptyStatement.ignore(e);\n+        if (sync) {\n+            for (Member member : client.getClientClusterService().getMemberList()) {\n+                try {\n+                    getOrConnectToMember(member);\n+                } catch (Exception e) {\n+                    EmptyStatement.ignore(e);\n+                }\n             }\n         }\n+\n+        executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5MjQxOQ=="}, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTc0ODc3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzoyMzoyM1rOH4NPtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNTo0NTo0NlrOH4TYmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ==", "bodyText": "you gave extra responsibility to the method authenticateOnCluster, rather than simply just authentication. Hence, you needed to put this explanation for the implicit returned connection. I would prefer this method to just do authentication and do existing connection check at getOrConnectToAddress. you also can close the connection at the same method rather than at handleSuccessfulAuth . This is more understandable to me, separation of concerns.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528699319", "createdAt": "2020-11-23T13:23:23Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -808,10 +807,17 @@ private ClientConnection getConnectionFromLoadBalancer(boolean dataMember) {\n             return null;\n         }\n \n-        return getConnection(member.getUuid());\n+        return activeConnections.get(member.getUuid());\n     }\n \n-    private void authenticateOnCluster(TcpClientConnection connection) {\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2NTQ3OQ==", "bodyText": "We are getting a lock at handleSuccessfulAuth. The check if the connection already exists should happen under that lock together with adding to activeConnections map if the connection did not exist. Not sure if I can refactor any further.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528765479", "createdAt": "2020-11-23T15:00:50Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -808,10 +807,17 @@ private ClientConnection getConnectionFromLoadBalancer(boolean dataMember) {\n             return null;\n         }\n \n-        return getConnection(member.getUuid());\n+        return activeConnections.get(member.getUuid());\n     }\n \n-    private void authenticateOnCluster(TcpClientConnection connection) {\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ=="}, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc5OTg5Ng==", "bodyText": "you can still do the check there at line https://github.com/hazelcast/hazelcast/pull/17844/files#diff-27e248511ddd6e03d414477f847d9c1b05ab33c329e40d318345cb2ed0d0ead2L874  where you can do putIfAbsent and if put fails, it can throw exception meaning that the connection auth failed due to an already existing connection and you do not even need a second check again.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528799896", "createdAt": "2020-11-23T15:45:46Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -808,10 +807,17 @@ private ClientConnection getConnectionFromLoadBalancer(boolean dataMember) {\n             return null;\n         }\n \n-        return getConnection(member.getUuid());\n+        return activeConnections.get(member.getUuid());\n     }\n \n-    private void authenticateOnCluster(TcpClientConnection connection) {\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ=="}, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTc2NzczOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzoyNzo1OVrOH4Na5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDo1NTozMFrOH4RByA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwMjE4MQ==", "bodyText": "I hate to keep an extra state connectingAddresses  when i already have activeConnections . How important an optimization is it to prevent multiple connection opening attempts when we can not avoid it 100% of the time. For code simplicity, I would chose not to add this extra state.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528702181", "createdAt": "2020-11-23T13:27:59Z", "author": {"login": "ihsandemir"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -1018,36 +1031,40 @@ public void onError(Channel channel, Throwable cause) {\n \n     private class ConnectToAllClusterMembersTask implements Runnable {\n \n-        private Set<Address> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+        private Set<UUID> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n \n         @Override\n         public void run() {\n+\n             if (!client.getLifecycleService().isRunning()) {\n                 return;\n             }\n \n             for (Member member : client.getClientClusterService().getMemberList()) {\n-                Address address = member.getAddress();\n-\n-                if (client.getLifecycleService().isRunning() && getConnection(address) == null\n-                        && connectingAddresses.add(address)) {\n-                    // submit a task for this address only if there is no\n-                    // another connection attempt for it\n-                    executor.submit(() -> {\n-                        try {\n-                            if (!client.getLifecycleService().isRunning()) {\n-                                return;\n-                            }\n-                            if (getConnection(member.getUuid()) == null) {\n-                                getOrConnect(address);\n-                            }\n-                        } catch (Exception e) {\n-                            EmptyStatement.ignore(e);\n-                        } finally {\n-                            connectingAddresses.remove(address);\n-                        }\n-                    });\n+                UUID uuid = member.getUuid();\n+\n+                if (activeConnections.get(uuid) != null) {\n+                    continue;\n                 }\n+\n+                if (!connectingAddresses.add(uuid)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2MTI4OA==", "bodyText": "The place that we can not avoid happens rarely.\nThis code happens periodically and more likely to occur.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528761288", "createdAt": "2020-11-23T14:55:30Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -1018,36 +1031,40 @@ public void onError(Channel channel, Throwable cause) {\n \n     private class ConnectToAllClusterMembersTask implements Runnable {\n \n-        private Set<Address> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+        private Set<UUID> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n \n         @Override\n         public void run() {\n+\n             if (!client.getLifecycleService().isRunning()) {\n                 return;\n             }\n \n             for (Member member : client.getClientClusterService().getMemberList()) {\n-                Address address = member.getAddress();\n-\n-                if (client.getLifecycleService().isRunning() && getConnection(address) == null\n-                        && connectingAddresses.add(address)) {\n-                    // submit a task for this address only if there is no\n-                    // another connection attempt for it\n-                    executor.submit(() -> {\n-                        try {\n-                            if (!client.getLifecycleService().isRunning()) {\n-                                return;\n-                            }\n-                            if (getConnection(member.getUuid()) == null) {\n-                                getOrConnect(address);\n-                            }\n-                        } catch (Exception e) {\n-                            EmptyStatement.ignore(e);\n-                        } finally {\n-                            connectingAddresses.remove(address);\n-                        }\n-                    });\n+                UUID uuid = member.getUuid();\n+\n+                if (activeConnections.get(uuid) != null) {\n+                    continue;\n                 }\n+\n+                if (!connectingAddresses.add(uuid)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwMjE4MQ=="}, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTk3MDQzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoxNzoyNVrOH4PV1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzo0MDoxNFrOH4veWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMzY1NQ==", "bodyText": "There is a slight behavior change here but I think this is not big a problem. If some of the member addresses are the same as the addresses configured, then we were not trying to connect the same address twice, but we are doing it right now.\nTo get the same behavior, maybe we could store the member addresses on the triedTargets, and while iterating over the configured addresses, check the contents of it to see whether we tried to connect or not.", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528733655", "createdAt": "2020-11-23T14:17:25Z", "author": {"login": "mdumandag"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -444,16 +446,30 @@ private void fireLifecycleEvent(LifecycleState state) {\n     }\n \n     private boolean doConnectToCandidateCluster(CandidateClusterContext context) {\n-        Set<Address> triedAddresses = new HashSet<>();\n+        Set<Object> triedTargets = new HashSet<>();\n         try {\n             waitStrategy.reset();\n             do {\n-                Collection<Address> addresses = getPossibleMemberAddresses(context.getAddressProvider());\n-                for (Address address : addresses) {\n+                List<Member> memberList = new ArrayList<>(client.getClientClusterService().getMemberList());\n+                if (shuffleMemberList) {\n+                    Collections.shuffle(memberList);\n+                }\n+                //try to connect to a member in the member list first\n+                for (Member member : memberList) {\n                     checkClientActive();\n-                    triedAddresses.add(address);\n+                    triedTargets.add(member);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MDEyMA==", "bodyText": "I missed that there is a loop here, the proposed change causes the configured addresses to not tried more than once in case of a failure, that is probably the cause of the test failures", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r529260120", "createdAt": "2020-11-24T07:40:14Z", "author": {"login": "mdumandag"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -444,16 +446,30 @@ private void fireLifecycleEvent(LifecycleState state) {\n     }\n \n     private boolean doConnectToCandidateCluster(CandidateClusterContext context) {\n-        Set<Address> triedAddresses = new HashSet<>();\n+        Set<Object> triedTargets = new HashSet<>();\n         try {\n             waitStrategy.reset();\n             do {\n-                Collection<Address> addresses = getPossibleMemberAddresses(context.getAddressProvider());\n-                for (Address address : addresses) {\n+                List<Member> memberList = new ArrayList<>(client.getClientClusterService().getMemberList());\n+                if (shuffleMemberList) {\n+                    Collections.shuffle(memberList);\n+                }\n+                //try to connect to a member in the member list first\n+                for (Member member : memberList) {\n                     checkClientActive();\n-                    triedAddresses.add(address);\n+                    triedTargets.add(member);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMzY1NQ=="}, "originalCommit": {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f"}, "originalPosition": 102}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 91, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}