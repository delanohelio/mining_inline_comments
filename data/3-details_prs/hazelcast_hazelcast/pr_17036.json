{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDY3NDkx", "number": 17036, "title": "Clean up TimedMemberState - remove all metric related fields", "bodyText": "Implements https://github.com/hazelcast/management-center/issues/3334 by removing all metrics (probes) related fields from JSON representation of TimedMemberState\nKeeps the overall structure of JSON representation of TMS compatible with IMDG 4.0, as MC 4.1 will have to be compatible with both IMDG 4.0 and 4.1\nAlso removes WanSyncState from MemberState as it was replaced with WAN events and not consumed anymore on MC side\n\nMC counterpart PR: https://github.com/hazelcast/management-center/pull/3302\nPotential next step: https://github.com/hazelcast/management-center/issues/3339", "createdAt": "2020-06-02T09:35:13Z", "url": "https://github.com/hazelcast/hazelcast/pull/17036", "merged": true, "mergeCommit": {"oid": "91b23b324e80fba1a378d4451b979b05d119db40"}, "closed": true, "closedAt": "2020-06-04T07:33:52Z", "author": {"login": "puzpuzpuz"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnS-wbABqjMzOTcxNTA2MTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnp10KgFqTQyMzU3NjMzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "196f3aa9f02c675670dad62d1428d27a6a1e23df", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/196f3aa9f02c675670dad62d1428d27a6a1e23df", "committedDate": "2020-06-02T09:49:33Z", "message": "Remove unused fields from MemberStateImpl"}, "afterCommit": {"oid": "76996b30f7422a60eb91ee4f97038ab55eb1c1f9", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/76996b30f7422a60eb91ee4f97038ab55eb1c1f9", "committedDate": "2020-06-02T11:15:46Z", "message": "Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNzMxMjI1", "url": "https://github.com/hazelcast/hazelcast/pull/17036#pullrequestreview-422731225", "createdAt": "2020-06-02T14:22:54Z", "commit": {"oid": "b7c3b183f58dbdaf2247c8d5a86914308618e36a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoyMjo1NFrOGd0K_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoyMjo1NFrOGd0K_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjY2OQ==", "bodyText": "Why is it deprecated instead of removed?", "url": "https://github.com/hazelcast/hazelcast/pull/17036#discussion_r433916669", "createdAt": "2020-06-02T14:22:54Z", "author": {"login": "emre-aydin"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/monitor/impl/MemberPartitionStateImpl.java", "diffHunk": "@@ -37,6 +37,7 @@\n \n     List<Integer> partitions = new ArrayList<Integer>(DEFAULT_PARTITION_COUNT);\n     boolean memberStateSafe;\n+    @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7c3b183f58dbdaf2247c8d5a86914308618e36a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNzMzMTQ5", "url": "https://github.com/hazelcast/hazelcast/pull/17036#pullrequestreview-422733149", "createdAt": "2020-06-02T14:24:53Z", "commit": {"oid": "be0c0bd1e6d7d4a207c55d92793ca8f8a0a6e601"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11272889136f75d1adc5108ec5154f4cecf20da7", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/11272889136f75d1adc5108ec5154f4cecf20da7", "committedDate": "2020-06-03T07:45:49Z", "message": "Remove certain MemberStateImpl fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c927a8bf0e14a631daf637c11e188955db4464e2", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c927a8bf0e14a631daf637c11e188955db4464e2", "committedDate": "2020-06-03T07:45:49Z", "message": "Remove unused fields from MemberStateImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b7c6dd6a24ea555df23fa37f7482a26d7e6316c", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3b7c6dd6a24ea555df23fa37f7482a26d7e6316c", "committedDate": "2020-06-03T07:45:49Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f01477054efae84471917ed187068b06a258be6f", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f01477054efae84471917ed187068b06a258be6f", "committedDate": "2020-06-03T07:45:49Z", "message": "Remove DS metrics from MemberStateImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18d90ec873061495c49df3a80eb0c409e1b79565", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/18d90ec873061495c49df3a80eb0c409e1b79565", "committedDate": "2020-06-03T07:45:49Z", "message": "Remove redundant JsonSerializable from *StatsImpl classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03", "committedDate": "2020-06-03T07:45:49Z", "message": "Remove redundant probe field from MemberPartitionStateImpl"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be0c0bd1e6d7d4a207c55d92793ca8f8a0a6e601", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/be0c0bd1e6d7d4a207c55d92793ca8f8a0a6e601", "committedDate": "2020-06-02T14:22:50Z", "message": "Remove redundant probe field from MemberPartitionStateImpl"}, "afterCommit": {"oid": "b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03", "committedDate": "2020-06-03T07:45:49Z", "message": "Remove redundant probe field from MemberPartitionStateImpl"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTQ3NDk3", "url": "https://github.com/hazelcast/hazelcast/pull/17036#pullrequestreview-423547497", "createdAt": "2020-06-03T13:24:27Z", "commit": {"oid": "b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyNDoyN1rOGeboGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzozMjoyNVrOGeb9aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MzA5OQ==", "bodyText": "Minor: maps -> queue", "url": "https://github.com/hazelcast/hazelcast/pull/17036#discussion_r434563099", "createdAt": "2020-06-03T13:24:27Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/management/TimedMemberStateFactory.java", "diffHunk": "@@ -244,195 +222,153 @@ protected void createNodeState(MemberStateImpl memberState) {\n         memberState.setNodeState(nodeState);\n     }\n \n-    private void createWanSyncState(MemberStateImpl memberState) {\n-        WanReplicationService wanReplicationService = instance.node.nodeEngine.getWanReplicationService();\n-        WanSyncState wanSyncState = wanReplicationService.getWanSyncState();\n-        if (wanSyncState != null) {\n-            memberState.setWanSyncState(wanSyncState);\n-        }\n-    }\n-\n     private void createMemState(MemberStateImpl memberState,\n                                 Collection<StatisticsAwareService> services) {\n-        int count = 0;\n         Config config = instance.getConfig();\n         for (StatisticsAwareService service : services) {\n             if (service instanceof MapService) {\n-                count = handleMap(memberState, count, config, ((MapService) service).getStats());\n+                handleMap(memberState, config, ((MapService) service).getStats());\n             } else if (service instanceof MultiMapService) {\n-                count = handleMultimap(memberState, count, config, ((MultiMapService) service).getStats());\n+                handleMultiMap(memberState, config, ((MultiMapService) service).getStats());\n             } else if (service instanceof QueueService) {\n-                count = handleQueue(memberState, count, config, ((QueueService) service).getStats());\n+                handleQueue(memberState, config, ((QueueService) service).getStats());\n             } else if (service instanceof TopicService) {\n-                count = handleTopic(memberState, count, config, ((TopicService) service).getStats());\n+                handleTopic(memberState, config, ((TopicService) service).getStats());\n             } else if (service instanceof ReliableTopicService) {\n-                count = handleReliableTopic(memberState, count, config,\n-                        ((ReliableTopicService) service).getStats());\n+                handleReliableTopic(memberState, config, ((ReliableTopicService) service).getStats());\n             } else if (service instanceof DistributedExecutorService) {\n-                count = handleExecutorService(memberState, count, config,\n-                        ((DistributedExecutorService) service).getStats());\n+                handleExecutorService(memberState, config, ((DistributedExecutorService) service).getStats());\n             } else if (service instanceof ReplicatedMapService) {\n-                count = handleReplicatedMap(memberState, count, config, ((ReplicatedMapService) service).getStats());\n+                handleReplicatedMap(memberState, config, ((ReplicatedMapService) service).getStats());\n             } else if (service instanceof PNCounterService) {\n-                count = handlePNCounter(memberState, count, config, ((PNCounterService) service).getStats());\n+                handlePNCounter(memberState, config, ((PNCounterService) service).getStats());\n             } else if (service instanceof FlakeIdGeneratorService) {\n-                count = handleFlakeIdGenerator(memberState, count, config,\n-                        ((FlakeIdGeneratorService) service).getStats());\n+                handleFlakeIdGenerator(memberState, config, ((FlakeIdGeneratorService) service).getStats());\n             } else if (service instanceof CacheService) {\n-                count = handleCache(memberState, count, (CacheService) service);\n+                handleCache(memberState, (CacheService) service);\n             }\n         }\n \n         WanReplicationService wanReplicationService = instance.node.nodeEngine.getWanReplicationService();\n         Map<String, LocalWanStats> wanStats = wanReplicationService.getStats();\n         if (wanStats != null) {\n-            count = handleWan(memberState, count, wanStats);\n+            handleWan(memberState, wanStats);\n         }\n     }\n \n-    private int handleFlakeIdGenerator(MemberStateImpl memberState, int count, Config config,\n-                                       Map<String, LocalFlakeIdGeneratorStats> flakeIdstats) {\n-        for (Map.Entry<String, LocalFlakeIdGeneratorStats> entry : flakeIdstats.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleFlakeIdGenerator(MemberStateImpl memberState, Config config,\n+                                        Map<String, LocalFlakeIdGeneratorStats> flakeIdStats) {\n+        Set<String> flakeIdGeneratorsWithStats = createHashSet(flakeIdStats.size());\n+        for (String name : flakeIdStats.keySet()) {\n             if (config.findFlakeIdGeneratorConfig(name).isStatisticsEnabled()) {\n-                LocalFlakeIdGeneratorStats stats = entry.getValue();\n-                memberState.putLocalFlakeIdStats(name, stats);\n-                ++count;\n+                flakeIdGeneratorsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setFlakeIdGeneratorsWithStats(flakeIdGeneratorsWithStats);\n     }\n \n-    private int handleExecutorService(MemberStateImpl memberState, int count, Config config,\n-                                      Map<String, LocalExecutorStats> executorServices) {\n-\n-        for (Map.Entry<String, LocalExecutorStats> entry : executorServices.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleExecutorService(MemberStateImpl memberState, Config config,\n+                                       Map<String, LocalExecutorStats> executorServices) {\n+        Set<String> executorsWithStats = createHashSet(executorServices.size());\n+        for (String name : executorServices.keySet()) {\n             if (config.findExecutorConfig(name).isStatisticsEnabled()) {\n-                LocalExecutorStats stats = entry.getValue();\n-                memberState.putLocalExecutorStats(name, stats);\n-                ++count;\n+                executorsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setExecutorsWithStats(executorsWithStats);\n     }\n \n-    private int handleMultimap(MemberStateImpl memberState, int count, Config config, Map<String, LocalMultiMapStats> multiMaps) {\n-        for (Map.Entry<String, LocalMultiMapStats> entry : multiMaps.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleMultiMap(MemberStateImpl memberState, Config config,\n+                                Map<String, LocalMultiMapStats> multiMaps) {\n+        Set<String> mapsWithStats = createHashSet(multiMaps.size());\n+        for (String name : multiMaps.keySet()) {\n             if (config.findMultiMapConfig(name).isStatisticsEnabled()) {\n-                LocalMultiMapStats stats = entry.getValue();\n-                memberState.putLocalMultiMapStats(name, stats);\n-                ++count;\n+                mapsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setMultiMapsWithStats(mapsWithStats);\n     }\n \n-    private int handleReplicatedMap(MemberStateImpl memberState, int count, Config\n-            config, Map<String, LocalReplicatedMapStats> replicatedMaps) {\n-        for (Map.Entry<String, LocalReplicatedMapStats> entry : replicatedMaps.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleReplicatedMap(MemberStateImpl memberState, Config config,\n+                                     Map<String, LocalReplicatedMapStats> replicatedMaps) {\n+        Set<String> mapsWithStats = createHashSet(replicatedMaps.size());\n+        for (String name : replicatedMaps.keySet()) {\n             if (config.findReplicatedMapConfig(name).isStatisticsEnabled()) {\n-                LocalReplicatedMapStats stats = entry.getValue();\n-                memberState.putLocalReplicatedMapStats(name, stats);\n-                ++count;\n+                mapsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setReplicatedMapsWithStats(mapsWithStats);\n     }\n \n-    private int handlePNCounter(MemberStateImpl memberState, int count, Config config,\n-                                Map<String, LocalPNCounterStats> counters) {\n-        for (Map.Entry<String, LocalPNCounterStats> entry : counters.entrySet()) {\n-            String name = entry.getKey();\n+    private void handlePNCounter(MemberStateImpl memberState, Config config,\n+                                 Map<String, LocalPNCounterStats> counters) {\n+        Set<String> countersWithStats = createHashSet(counters.size());\n+        for (String name : counters.keySet()) {\n             if (config.findPNCounterConfig(name).isStatisticsEnabled()) {\n-                LocalPNCounterStats stats = entry.getValue();\n-                memberState.putLocalPNCounterStats(name, stats);\n-                ++count;\n+                countersWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setPNCountersWithStats(countersWithStats);\n     }\n \n-    private int handleReliableTopic(MemberStateImpl memberState, int count, Config config, Map<String, LocalTopicStats> topics) {\n-        for (Map.Entry<String, LocalTopicStats> entry : topics.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleReliableTopic(MemberStateImpl memberState, Config config,\n+                                     Map<String, LocalTopicStats> topics) {\n+        Set<String> topicsWithStats = createHashSet(topics.size());\n+        for (String name : topics.keySet()) {\n             if (config.findReliableTopicConfig(name).isStatisticsEnabled()) {\n-                LocalTopicStats stats = entry.getValue();\n-                memberState.putLocalReliableTopicStats(name, stats);\n-                ++count;\n+                topicsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setReliableTopicsWithStats(topicsWithStats);\n     }\n \n-    private int handleTopic(MemberStateImpl memberState, int count, Config config, Map<String, LocalTopicStats> topics) {\n-        for (Map.Entry<String, LocalTopicStats> entry : topics.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleTopic(MemberStateImpl memberState, Config config, Map<String, LocalTopicStats> topics) {\n+        Set<String> topicsWithStats = createHashSet(topics.size());\n+        for (String name : topics.keySet()) {\n             if (config.findTopicConfig(name).isStatisticsEnabled()) {\n-                LocalTopicStats stats = entry.getValue();\n-                memberState.putLocalTopicStats(name, stats);\n-                ++count;\n+                topicsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setTopicsWithStats(topicsWithStats);\n     }\n \n-    private int handleQueue(MemberStateImpl memberState, int count, Config config, Map<String, LocalQueueStats> queues) {\n-        for (Map.Entry<String, LocalQueueStats> entry : queues.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleQueue(MemberStateImpl memberState, Config config, Map<String, LocalQueueStats> queues) {\n+        Set<String> mapsWithStats = createHashSet(queues.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MzIwOQ==", "bodyText": "Minor: queues -> maps", "url": "https://github.com/hazelcast/hazelcast/pull/17036#discussion_r434563209", "createdAt": "2020-06-03T13:24:38Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/management/TimedMemberStateFactory.java", "diffHunk": "@@ -244,195 +222,153 @@ protected void createNodeState(MemberStateImpl memberState) {\n         memberState.setNodeState(nodeState);\n     }\n \n-    private void createWanSyncState(MemberStateImpl memberState) {\n-        WanReplicationService wanReplicationService = instance.node.nodeEngine.getWanReplicationService();\n-        WanSyncState wanSyncState = wanReplicationService.getWanSyncState();\n-        if (wanSyncState != null) {\n-            memberState.setWanSyncState(wanSyncState);\n-        }\n-    }\n-\n     private void createMemState(MemberStateImpl memberState,\n                                 Collection<StatisticsAwareService> services) {\n-        int count = 0;\n         Config config = instance.getConfig();\n         for (StatisticsAwareService service : services) {\n             if (service instanceof MapService) {\n-                count = handleMap(memberState, count, config, ((MapService) service).getStats());\n+                handleMap(memberState, config, ((MapService) service).getStats());\n             } else if (service instanceof MultiMapService) {\n-                count = handleMultimap(memberState, count, config, ((MultiMapService) service).getStats());\n+                handleMultiMap(memberState, config, ((MultiMapService) service).getStats());\n             } else if (service instanceof QueueService) {\n-                count = handleQueue(memberState, count, config, ((QueueService) service).getStats());\n+                handleQueue(memberState, config, ((QueueService) service).getStats());\n             } else if (service instanceof TopicService) {\n-                count = handleTopic(memberState, count, config, ((TopicService) service).getStats());\n+                handleTopic(memberState, config, ((TopicService) service).getStats());\n             } else if (service instanceof ReliableTopicService) {\n-                count = handleReliableTopic(memberState, count, config,\n-                        ((ReliableTopicService) service).getStats());\n+                handleReliableTopic(memberState, config, ((ReliableTopicService) service).getStats());\n             } else if (service instanceof DistributedExecutorService) {\n-                count = handleExecutorService(memberState, count, config,\n-                        ((DistributedExecutorService) service).getStats());\n+                handleExecutorService(memberState, config, ((DistributedExecutorService) service).getStats());\n             } else if (service instanceof ReplicatedMapService) {\n-                count = handleReplicatedMap(memberState, count, config, ((ReplicatedMapService) service).getStats());\n+                handleReplicatedMap(memberState, config, ((ReplicatedMapService) service).getStats());\n             } else if (service instanceof PNCounterService) {\n-                count = handlePNCounter(memberState, count, config, ((PNCounterService) service).getStats());\n+                handlePNCounter(memberState, config, ((PNCounterService) service).getStats());\n             } else if (service instanceof FlakeIdGeneratorService) {\n-                count = handleFlakeIdGenerator(memberState, count, config,\n-                        ((FlakeIdGeneratorService) service).getStats());\n+                handleFlakeIdGenerator(memberState, config, ((FlakeIdGeneratorService) service).getStats());\n             } else if (service instanceof CacheService) {\n-                count = handleCache(memberState, count, (CacheService) service);\n+                handleCache(memberState, (CacheService) service);\n             }\n         }\n \n         WanReplicationService wanReplicationService = instance.node.nodeEngine.getWanReplicationService();\n         Map<String, LocalWanStats> wanStats = wanReplicationService.getStats();\n         if (wanStats != null) {\n-            count = handleWan(memberState, count, wanStats);\n+            handleWan(memberState, wanStats);\n         }\n     }\n \n-    private int handleFlakeIdGenerator(MemberStateImpl memberState, int count, Config config,\n-                                       Map<String, LocalFlakeIdGeneratorStats> flakeIdstats) {\n-        for (Map.Entry<String, LocalFlakeIdGeneratorStats> entry : flakeIdstats.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleFlakeIdGenerator(MemberStateImpl memberState, Config config,\n+                                        Map<String, LocalFlakeIdGeneratorStats> flakeIdStats) {\n+        Set<String> flakeIdGeneratorsWithStats = createHashSet(flakeIdStats.size());\n+        for (String name : flakeIdStats.keySet()) {\n             if (config.findFlakeIdGeneratorConfig(name).isStatisticsEnabled()) {\n-                LocalFlakeIdGeneratorStats stats = entry.getValue();\n-                memberState.putLocalFlakeIdStats(name, stats);\n-                ++count;\n+                flakeIdGeneratorsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setFlakeIdGeneratorsWithStats(flakeIdGeneratorsWithStats);\n     }\n \n-    private int handleExecutorService(MemberStateImpl memberState, int count, Config config,\n-                                      Map<String, LocalExecutorStats> executorServices) {\n-\n-        for (Map.Entry<String, LocalExecutorStats> entry : executorServices.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleExecutorService(MemberStateImpl memberState, Config config,\n+                                       Map<String, LocalExecutorStats> executorServices) {\n+        Set<String> executorsWithStats = createHashSet(executorServices.size());\n+        for (String name : executorServices.keySet()) {\n             if (config.findExecutorConfig(name).isStatisticsEnabled()) {\n-                LocalExecutorStats stats = entry.getValue();\n-                memberState.putLocalExecutorStats(name, stats);\n-                ++count;\n+                executorsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setExecutorsWithStats(executorsWithStats);\n     }\n \n-    private int handleMultimap(MemberStateImpl memberState, int count, Config config, Map<String, LocalMultiMapStats> multiMaps) {\n-        for (Map.Entry<String, LocalMultiMapStats> entry : multiMaps.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleMultiMap(MemberStateImpl memberState, Config config,\n+                                Map<String, LocalMultiMapStats> multiMaps) {\n+        Set<String> mapsWithStats = createHashSet(multiMaps.size());\n+        for (String name : multiMaps.keySet()) {\n             if (config.findMultiMapConfig(name).isStatisticsEnabled()) {\n-                LocalMultiMapStats stats = entry.getValue();\n-                memberState.putLocalMultiMapStats(name, stats);\n-                ++count;\n+                mapsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setMultiMapsWithStats(mapsWithStats);\n     }\n \n-    private int handleReplicatedMap(MemberStateImpl memberState, int count, Config\n-            config, Map<String, LocalReplicatedMapStats> replicatedMaps) {\n-        for (Map.Entry<String, LocalReplicatedMapStats> entry : replicatedMaps.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleReplicatedMap(MemberStateImpl memberState, Config config,\n+                                     Map<String, LocalReplicatedMapStats> replicatedMaps) {\n+        Set<String> mapsWithStats = createHashSet(replicatedMaps.size());\n+        for (String name : replicatedMaps.keySet()) {\n             if (config.findReplicatedMapConfig(name).isStatisticsEnabled()) {\n-                LocalReplicatedMapStats stats = entry.getValue();\n-                memberState.putLocalReplicatedMapStats(name, stats);\n-                ++count;\n+                mapsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setReplicatedMapsWithStats(mapsWithStats);\n     }\n \n-    private int handlePNCounter(MemberStateImpl memberState, int count, Config config,\n-                                Map<String, LocalPNCounterStats> counters) {\n-        for (Map.Entry<String, LocalPNCounterStats> entry : counters.entrySet()) {\n-            String name = entry.getKey();\n+    private void handlePNCounter(MemberStateImpl memberState, Config config,\n+                                 Map<String, LocalPNCounterStats> counters) {\n+        Set<String> countersWithStats = createHashSet(counters.size());\n+        for (String name : counters.keySet()) {\n             if (config.findPNCounterConfig(name).isStatisticsEnabled()) {\n-                LocalPNCounterStats stats = entry.getValue();\n-                memberState.putLocalPNCounterStats(name, stats);\n-                ++count;\n+                countersWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setPNCountersWithStats(countersWithStats);\n     }\n \n-    private int handleReliableTopic(MemberStateImpl memberState, int count, Config config, Map<String, LocalTopicStats> topics) {\n-        for (Map.Entry<String, LocalTopicStats> entry : topics.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleReliableTopic(MemberStateImpl memberState, Config config,\n+                                     Map<String, LocalTopicStats> topics) {\n+        Set<String> topicsWithStats = createHashSet(topics.size());\n+        for (String name : topics.keySet()) {\n             if (config.findReliableTopicConfig(name).isStatisticsEnabled()) {\n-                LocalTopicStats stats = entry.getValue();\n-                memberState.putLocalReliableTopicStats(name, stats);\n-                ++count;\n+                topicsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setReliableTopicsWithStats(topicsWithStats);\n     }\n \n-    private int handleTopic(MemberStateImpl memberState, int count, Config config, Map<String, LocalTopicStats> topics) {\n-        for (Map.Entry<String, LocalTopicStats> entry : topics.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleTopic(MemberStateImpl memberState, Config config, Map<String, LocalTopicStats> topics) {\n+        Set<String> topicsWithStats = createHashSet(topics.size());\n+        for (String name : topics.keySet()) {\n             if (config.findTopicConfig(name).isStatisticsEnabled()) {\n-                LocalTopicStats stats = entry.getValue();\n-                memberState.putLocalTopicStats(name, stats);\n-                ++count;\n+                topicsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setTopicsWithStats(topicsWithStats);\n     }\n \n-    private int handleQueue(MemberStateImpl memberState, int count, Config config, Map<String, LocalQueueStats> queues) {\n-        for (Map.Entry<String, LocalQueueStats> entry : queues.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleQueue(MemberStateImpl memberState, Config config, Map<String, LocalQueueStats> queues) {\n+        Set<String> mapsWithStats = createHashSet(queues.size());\n+        for (String name : queues.keySet()) {\n             if (config.findQueueConfig(name).isStatisticsEnabled()) {\n-                LocalQueueStats stats = entry.getValue();\n-                memberState.putLocalQueueStats(name, stats);\n-                ++count;\n+                mapsWithStats.add(name);\n             }\n         }\n-        return count;\n+        memberState.setQueuesWithStats(mapsWithStats);\n     }\n \n-    private int handleMap(MemberStateImpl memberState, int count, Config config, Map<String, LocalMapStats> maps) {\n-        for (Map.Entry<String, LocalMapStats> entry : maps.entrySet()) {\n-            String name = entry.getKey();\n+    private void handleMap(MemberStateImpl memberState, Config config, Map<String, LocalMapStats> maps) {\n+        Set<String> queuesWithStats = createHashSet(maps.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2ODU1Mg==", "bodyText": "It seems this method is not called.", "url": "https://github.com/hazelcast/hazelcast/pull/17036#discussion_r434568552", "createdAt": "2020-06-03T13:32:25Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/monitor/MemberState.java", "diffHunk": "@@ -58,34 +51,10 @@\n      */\n     String getName();\n \n-    Map<String, Long> getRuntimeProps();\n-\n-    LocalMapStats getLocalMapStats(String mapName);\n-\n-    LocalMultiMapStats getLocalMultiMapStats(String mapName);\n-\n-    LocalQueueStats getLocalQueueStats(String queueName);\n-\n-    LocalTopicStats getLocalTopicStats(String topicName);\n-\n-    LocalTopicStats getReliableLocalTopicStats(String reliableTopicName);\n-\n-    LocalPNCounterStats getLocalPNCounterStats(String pnCounterName);\n-\n-    LocalReplicatedMapStats getLocalReplicatedMapStats(String replicatedMapName);\n-\n-    LocalExecutorStats getLocalExecutorStats(String executorName);\n-\n-    LocalCacheStats getLocalCacheStats(String cacheName);\n-\n     LocalWanStats getLocalWanStats(String schemeName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b831c1f7b821a8b1c795dfb9f962ec6f16a0bd03"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bae9fb45929a28d57d909a33aa7192c11018b94", "author": {"user": {"login": "puzpuzpuz", "name": "Andrey Pechkurov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3bae9fb45929a28d57d909a33aa7192c11018b94", "committedDate": "2020-06-03T13:50:42Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTc2MzMy", "url": "https://github.com/hazelcast/hazelcast/pull/17036#pullrequestreview-423576332", "createdAt": "2020-06-03T13:54:01Z", "commit": {"oid": "3bae9fb45929a28d57d909a33aa7192c11018b94"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3656, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}