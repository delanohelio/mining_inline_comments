{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMTY2MDM0", "number": 16946, "reviewThreads": {"totalCount": 47, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozNToxOFrOD6G_nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowMToyM1rOEoC-KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjU4NTkxOnYy", "diffSide": "LEFT", "path": "src/main/resources/apache-v2-license.txt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozNToxOFrOGRwSjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDoyNzo1NlrOGR4WdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MDE1OA==", "bodyText": "@andrewoelfing It seems some files are deleted by mistake ? Can you revert these ?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421270158", "createdAt": "2020-05-07T06:35:18Z", "author": {"login": "sancar"}, "path": "src/main/resources/apache-v2-license.txt", "diffHunk": "@@ -1,202 +0,0 @@\n-\n-                                 Apache License\n-                           Version 2.0, January 2004\n-                        http://www.apache.org/licenses/\n-\n-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMjIyOQ==", "bodyText": "Hello @sancar, I'm not aware of deleting these files. But I will revert these changes.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421402229", "createdAt": "2020-05-07T10:27:56Z", "author": {"login": "andrewoelfing"}, "path": "src/main/resources/apache-v2-license.txt", "diffHunk": "@@ -1,202 +0,0 @@\n-\n-                                 Apache License\n-                           Version 2.0, January 2004\n-                        http://www.apache.org/licenses/\n-\n-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MDE1OA=="}, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjU5NzM1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozOTo0MVrOGRwZUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozOTo0MVrOGRwZUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MTg4OQ==", "bodyText": "partition id is used by TotalOrderedTopicProxy to make sure the total order.\nThis one should not need it.\nSee https://docs.hazelcast.org/docs/4.0.1/manual/html-single/index.html#understanding-topic-behavior", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421271889", "createdAt": "2020-05-07T06:39:41Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +41,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final int partitionId;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjYxMDgyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjo0NDo0MFrOGRwhSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjo0NDo0MFrOGRwhSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MzkzMQ==", "bodyText": "I believe this should be called with invokeOnPartition. Also async ones should have partitionId as the fourth parameter.\nI have got suspicious about this and deleted my comment. It seems, we are using partition id on ClientTopicProxy but not on ClientReliableTopicProxy. Order guarantees may not be given for Reliable one.  Can you still add tests for order guarantees for all of the new methods ?\nWe can add tests as following for new methods to verify the behaviour.\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java#L141\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java#L220\nIt seems tests are missing on the client side. Don't forget to add them for client side as well ?\nEasiest could be to make ClientTopicTest to extend TopicTest. We don't have to, but we are using this pattern to avoid writing tests twice when it fits. See if these tests are suitable. Here is an example:\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueueBasicLocalTest.java#L29", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421273931", "createdAt": "2020-05-07T06:44:40Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +138,21 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Data element = toData(message);\n+        ClientMessage request = TopicPublishCodec.encodeRequest(name, element);\n+        try {\n+            ClientInvocationFuture invocationFuture = new ClientInvocation(getClient(), request, getName()).invoke();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzAwMzcyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo0NTowMlrOGeciCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjoyMTo1NlrOHAJC5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA==", "bodyText": "We have to distinguish between \"reliable topic\" and \"topic\" here. \"Reliable topic\" (meaning *ReliableTopicProxy classes, obtained through HazelcastInstance#getReliableTopic) use another user-facing structure under the covers - Ringbuffer<ReliableTopicMessage>. On the other hand, \"topic\" (meaning TopicProxy and ClientTopicProxy classes, obtained through HazelcastInstance#getTopic) don't use the ringbuffer but use the \"eventing system\" instead.\nWhat I'm trying to say is, the reliable topic proxies need to use the ringbuffer. Now, that will make your life both easier and harder :D I'm not sure how easy it will be but you should switch to using ringbuffer.addAllAsync() in the reliable topic proxies.\nAfter you try it out, you can let us know if you ran into some difficulties there and we'll continue from there on.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434577928", "createdAt": "2020-06-03T13:45:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTI4Mg==", "bodyText": "Hello @mmedenjak, sorry, but I fail with the ClientReliableTopicProxy#addWithBackoff Method. This is a synchronous method and I actually have no idea how to implement an asynchronous one. Do you have an idea?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443831282", "createdAt": "2020-06-22T21:16:38Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5MTU5NA==", "bodyText": "That one is problematic, true. I guess BLOCK is not really a good name for the policy but maybe you can create a future and a self-scheduling task which will reschedule itself if it cannot add the item. Once it manages to add the item, it completes the task. So calling get() on such a future would yield the same behaviour as the sync variant. Not sure if it makes sense and let me know if you need help with an example of how I see it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r448991594", "createdAt": "2020-07-02T13:13:09Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMwODUzMA==", "bodyText": "Hello @mmedenjak, I know what you mean, but do you have an example of such a self-scheduling task?\nAlso RingBuffer#addAllAsync returns a CompletionStage with a Long generic type. This collides with the expected generic type E.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r453308530", "createdAt": "2020-07-12T12:09:33Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzODgwNw==", "bodyText": "Hey, I was off for three weeks, I'll try to figure out an example and send it to you.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r464238807", "createdAt": "2020-08-03T07:27:31Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNDA3OQ==", "bodyText": "Hey Matko! I can give you a little bit more information about the generics problem..\nThe problem is, that every RingBuffer method returns a CompletableFuture<Long> and not a CompletableFuture<E>.\n    @Override\n    public CompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> payloads) {\n        checkNotNull(payloads, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(payloads, NULL_MESSAGE_IS_NOT_ALLOWED);\n        CompletableFuture<Long> completableFuture = null;\n        try {\n            Collection<ReliableTopicMessage> messages = new ArrayList<>(payloads.size());\n            payloads.forEach(payload -> messages.add(new ReliableTopicMessage(toData(payload), null)));\n            switch (overloadPolicy) {\n                case ERROR:\n                case DISCARD_NEWEST:\n                    completableFuture = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture();\n                    break;\n                case DISCARD_OLDEST:\n                    completableFuture = ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture();\n                    break;\n                case BLOCK:\n                    completableFuture = addWithBackoffAsync(messages);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n            }\n        } catch (Exception e) {\n            throw (RuntimeException) peel(e, null,\n                    \"Failed to publish message: \" + payloads + \" to topic:\" + getName());\n        }\n        return new completableFuture;\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r465324079", "createdAt": "2020-08-04T20:53:56Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwOTIyMw==", "bodyText": "Hey, not sure if you might still be willing to work on this issue but I managed to take a look and here are my conclusions. I believe we should change all return types for publishAsync and publishAllAsync to these:\nCompletionStage<Void> publishAsync(@Nonnull E message);\nCompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages);\nThe reasons are:\n\nall other async methods on our public API return CompletionStage and none return InternalCompletableFuture since it's an internal implementation\nthe generic type should probably be Void since different implementations of ITopic use different backing structures and since ITopic#publish returns void anyway and not the ID or the message. Of course, we could return the messages themselves and I'm sure each implementation may create a new future which will be completed with the provided messages but I don't think that's necessary. The messages were provided as a parameter to the async methods which means the user already has references to them. What matters is the future itself and being able to react to the completion and not the messages themselves.\n\nThis also means you will have to adapt some methods to return a newly created future which will be completed when some operation completes. For instance, in ReliableTopicProxy#publishAsync:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Data data = toData(message);\n        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n        invokeOnPartition(new PublishOperation(name, data))\n                .whenCompleteAsync((o, t) -> {\n                    if (t != null) {\n                        returnFuture.completeExceptionally(t);\n                    } else {\n                        returnFuture.complete(null);\n                    }\n                });\n        return returnFuture;\n    }\nNote: I haven't tested this but I believe it works correctly, you'll need to verify this.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r469909223", "createdAt": "2020-08-13T12:20:07Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMDI0Ng==", "bodyText": "As for the self-scheduling and other details of the ReliableTopicProxy implementation, here's what I came up with:\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> payload) {\n        checkNotNull(payload, NULL_MESSAGES_IS_NOT_ALLOWED);\n        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n\n        try {\n            List<ReliableTopicMessage> messages = payload.stream()\n                                                         .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n                                                         .collect(Collectors.toList());\n            switch (overloadPolicy) {\n                case ERROR:\n                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n                    if (sequenceId == -1) {\n                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n                    }\n                    break;\n                case DISCARD_OLDEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n                    break;\n                case DISCARD_NEWEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n                    break;\n                case BLOCK:\n                    long timeoutMs = INITIAL_BACKOFF_MS;\n                    for (; ; ) {\n                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n                        if (result != -1) {\n                            break;\n                        }\n\n                        MILLISECONDS.sleep(timeoutMs);\n                        timeoutMs *= 2;\n                        if (timeoutMs > MAX_BACKOFF) {\n                            timeoutMs = MAX_BACKOFF;\n                        }\n                    }\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n            }\n\n            localTopicStats.incrementPublishes();\n        } catch (Exception e) {\n            throw (RuntimeException) peel(e, null, \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n        }\n    }\n\n    @Override\n    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n        checkNotNull(payload, NULL_MESSAGES_IS_NOT_ALLOWED);\n        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n\n        try {\n            List<ReliableTopicMessage> messages = payload.stream()\n                                                         .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n                                                         .collect(Collectors.toList());\n            switch (overloadPolicy) {\n                case ERROR:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n                              .whenCompleteAsync((id, t) -> {\n                                  if (t != null) {\n                                      returnFuture.completeExceptionally(t);\n                                  }\n                                  if (id == -1) {\n                                      returnFuture.completeExceptionally(new TopicOverloadException(\n                                              \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n                                  }\n                                  localTopicStats.incrementPublishes(payload.size());\n                                  returnFuture.complete(null);\n                              });\n\n                    break;\n                case DISCARD_OLDEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE)\n                              .whenCompleteAsync((id, t) -> {\n                                  if (t != null) {\n                                      returnFuture.completeExceptionally(t);\n                                  }\n                                  localTopicStats.incrementPublishes(payload.size());\n                                  returnFuture.complete(null);\n                              });\n                    break;\n                case DISCARD_NEWEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n                              .whenCompleteAsync((id, t) -> {\n                                  if (t != null) {\n                                      returnFuture.completeExceptionally(t);\n                                  }\n                                  localTopicStats.incrementPublishes(payload.size());\n                                  returnFuture.complete(null);\n                              });\n                    break;\n                case BLOCK:\n                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n            }\n        } catch (Exception e) {\n            returnFuture.completeExceptionally(peel(e, null, \"Failed to publish messages: \" + payload + \" to topic:\" + getName()));\n        }\n\n        return returnFuture;\n    }\n\n    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,\n                                  InternalCompletableFuture<Void> returnFuture,\n                                  List<ReliableTopicMessage> messages,\n                                  long pauseMillis) {\n        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n            if (t != null) {\n                returnFuture.completeExceptionally(t);\n            }\n            if (id == -1) {\n                nodeEngine.getExecutionService().schedule(\n                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n                        pauseMillis, MILLISECONDS);\n                returnFuture.completeExceptionally(new TopicOverloadException(\n                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n            }\n            localTopicStats.incrementPublishes(payload.size());\n            returnFuture.complete(null);\n        });\n    }\nI'm sure it can be cleaned up a bit and it definitely needs to be tested but that's what I was thinking about.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r469910246", "createdAt": "2020-08-13T12:21:56Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzAzNTY3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo1MjowOVrOGec2ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1OTozM1rOGm709Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4MzIzNQ==", "bodyText": "Since this task may be fired in a cluster which contains a 4.0 member which doesn't have this operation, we need to add a check for the cluster version somewhere here, just like the ones you've added in your previous PR I believe. Maybe something like this:\n        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\n                    \"Publish all is unavailable at cluster version \" + clusterVersion);\n        }\n        return new PublishAllOperation(parameters.name, items());", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434583235", "createdAt": "2020-06-03T13:52:09Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        return new PublishAllOperation(parameters.name, items());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3OTI4NQ==", "bodyText": "Easy to fix - done.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443479285", "createdAt": "2020-06-22T10:59:33Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        return new PublishAllOperation(parameters.name, items());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4MzIzNQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzA1NzEwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo1Njo0MlrOGedEVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjoyNToyMlrOHAJKmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ==", "bodyText": "It's a shame sync and async methods don't share the code and sync simply being async().get() I see there's an additional object created for the async case so maybe that's not possible. Or maybe you can extract at least some part.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434586709", "createdAt": "2020-06-03T13:56:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +95,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+\n+        ClientMessage request = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+        final ClientMessage clientMessage = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        return publishAsyncInternal(clientMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3OTQ1NA==", "bodyText": "Also done. :)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443479454", "createdAt": "2020-06-22T10:59:51Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +95,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+\n+        ClientMessage request = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+        final ClientMessage clientMessage = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        return publishAsyncInternal(clientMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjIxOQ==", "bodyText": "With the latest iteration of changes, this would become:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n\n        Data data = toData(message);\n        final ClientMessage clientMessage = TopicPublishCodec.encodeRequest(name, data);\n        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n        publishAsyncInternal(clientMessage).whenCompleteAsync((o, t) -> {\n            if (t != null) {\n                returnFuture.completeExceptionally(t);\n            } else {\n                returnFuture.complete(null);\n            }\n        });\n        return returnFuture;\n    }\n\n    protected ClientInvocationFuture publishAsyncInternal(ClientMessage clientMessage) {\n        try {\n            return new ClientInvocation(getClient(), clientMessage, getName(), getPartitionId()).invoke();\n        } catch (Exception e) {\n            throw rethrow(e);\n        }\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r469912219", "createdAt": "2020-08-13T12:25:22Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +95,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+\n+        ClientMessage request = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+        final ClientMessage clientMessage = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        return publishAsyncInternal(clientMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzA5MzAyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNDoxMlrOGedaVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNDo0MDozMVrOGsyXHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ==", "bodyText": "Another layer of complexity :) In addition to reliable topic vs topic, \"topic\" can be different if we're talking about \"totally-ordered\" topic and \"non-totally-ordered\" topic (determined by TopicConfig#isGlobalOrderingEnabled). The \"non-ordered\" is implemented in TopicProxy and ClientTopicProxy and here you avoid firing any partition operations since partition operations are ordered. On the other hand, in TotalOrderedTopicProxy you can override the method from TopicProxy and fire the PublishAllOperation (but remember to check for the cluster version first).\nLooks like clients don't have non-ordered topics, they send a message task which then sends a publish operation. Basically turning it into an ordered topic always.\nThis also means that the async member-side non-ordered implementation of TopicProxy#publishAllAsync is basically the same as the sync one, since the TopicProxySupport#publishInternal doesn't usually block. Usually meaning there's some silly rule that every 100000th event should block. This IMHO is a poor backpressure mechanism and I think we should remove it anyway.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434592341", "createdAt": "2020-06-03T14:04:12Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -47,6 +56,13 @@ public void publish(@Nonnull E message) {\n         publishInternal(message);\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNDY4Ng==", "bodyText": "Ok, here I'm lost... Do you mean, that I should implement the missing methods in the class TotalOrderedTopicProxy? And which clients do you think of?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443834686", "createdAt": "2020-06-22T21:24:03Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -47,6 +56,13 @@ public void publish(@Nonnull E message) {\n         publishInternal(message);\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMDAzMw==", "bodyText": "When talking about ITopic implementations, there are several:\n\nTopicProxy - member side implementation, no ordering guarantees, events are published through EventService#publishEvent which means every member can notify every other member\nTotalOrderedTopicProxy - member side implementation, an extension of TopicProxy which is used when TopicConfig#isGlobalOrderingEnabled, doesn't publish events locally through EventService#publishEvent but sends partition operations to the same partition so events published on all members are ordered\nClientTopicProxy - client side implementation, invokes operations on the partition owner for the topic name, which means the events are ordered. That member, on the other hand, calls the EventService#publishEvent in PublishOperation#run\nReliableTopicProxy, ClientReliableTopicProxy - use ringbuffer instead of EventService#publishEvent, all implementations order messages because they use a single ringbuffer as a backing structure. Since it doesn't use EventService, it's not supposed to be lossy\n\nIf I remember correctly, what I meant to say is - don't invoke partition operations then in TopicProxy, use the EventService#publishEvent. It is already async so probably your sync and async implementation in TopicProxy will be the same. On the other hand, you should invoke partition operations in TotalOrderedTopicProxy since there events published from different members will then be serialized and published through a single partition owner.\nIf it still doesn't make sense, please tell me, I'll take a closer look and provide some code snippets, I just didn't want to keep you waiting for months :)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r449000033", "createdAt": "2020-07-02T13:26:10Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -47,6 +56,13 @@ public void publish(@Nonnull E message) {\n         publishInternal(message);\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTY0NA==", "bodyText": "Something like this:\npublic abstract class TopicProxySupport extends AbstractDistributedObject<TopicService> implements InitializingObject {\n\n    protected final LocalTopicStatsImpl topicStats;\n    \n    private final String name;\n    private final ClassLoader configClassLoader;\n    private final TopicService topicService;\n    private boolean multithreaded;\n\n    public TopicProxySupport(String name, NodeEngine nodeEngine, TopicService service) {\n        super(nodeEngine, service);\n        this.name = name;\n        this.configClassLoader = nodeEngine.getConfigClassLoader();\n        this.topicService = service;\n        this.topicStats = topicService.getLocalTopicStats(name);\n    }\n\n    @Override\n    public void initialize() {\n        NodeEngine nodeEngine = getNodeEngine();\n        TopicConfig config = nodeEngine.getConfig().findTopicConfig(name);\n        multithreaded = config.isMultiThreadingEnabled();\n        for (ListenerConfig listenerConfig : config.getMessageListenerConfigs()) {\n            initialize(listenerConfig);\n        }\n    }\n\n    private void initialize(ListenerConfig listenerConfig) {\n        NodeEngine nodeEngine = getNodeEngine();\n\n        MessageListener listener = loadListener(listenerConfig);\n\n        if (listener == null) {\n            return;\n        }\n\n        if (listener instanceof HazelcastInstanceAware) {\n            HazelcastInstanceAware hazelcastInstanceAware = (HazelcastInstanceAware) listener;\n            hazelcastInstanceAware.setHazelcastInstance(nodeEngine.getHazelcastInstance());\n        }\n        addMessageListenerInternal(listener);\n    }\n\n    private MessageListener loadListener(ListenerConfig listenerConfig) {\n        try {\n            MessageListener listener = (MessageListener) listenerConfig.getImplementation();\n            if (listener == null && listenerConfig.getClassName() != null) {\n                listener = ClassLoaderUtil.newInstance(configClassLoader, listenerConfig.getClassName());\n            }\n            return listener;\n        } catch (Exception e) {\n            throw ExceptionUtil.rethrow(e);\n        }\n    }\n\n    public LocalTopicStats getLocalTopicStatsInternal() {\n        return topicService.getLocalTopicStats(name);\n    }\n\n    /**\n     * Publishes the message and increases the local statistics\n     * for the number of published messages.\n     *\n     * @param message the message to be published\n     */\n    public void publishInternal(@Nonnull Object message) {\n        topicStats.incrementPublishes();\n        topicService.publishMessage(name, message, multithreaded);\n    }\n\n    public @Nonnull\n    UUID addMessageListenerInternal(@Nonnull MessageListener listener) {\n        return topicService.addMessageListener(name, listener);\n    }\n\n    public boolean removeMessageListenerInternal(@Nonnull UUID registrationId) {\n        return topicService.removeMessageListener(name, registrationId);\n    }\n\n    @Override\n    public String getServiceName() {\n        return TopicService.SERVICE_NAME;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n}\npublic class TopicProxy<E> extends TopicProxySupport implements ITopic<E> {\n\n    protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n    protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n\n    public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n        super(name, nodeEngine, service);\n    }\n\n    @Override\n    public void publish(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        publishInternal(message);\n    }\n\n    @Override\n    public CompletionStage<E> publishAsync(@Nonnull E message) {\n        publish(message);\n        return InternalCompletableFuture.completedFuture(null);\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        messages.forEach(this::publishInternal);\n    }\n\n    @Override\n    public CompletionStage<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        publishAll(messages);\n        return InternalCompletableFuture.completedFuture(null);\n    }\n\n    @Nonnull\n    @Override\n    public UUID addMessageListener(@Nonnull MessageListener<E> listener) {\n        checkNotNull(listener, NULL_LISTENER_IS_NOT_ALLOWED);\n        return addMessageListenerInternal(listener);\n    }\n\n    @Override\n    public boolean removeMessageListener(@Nonnull UUID registrationId) {\n        return removeMessageListenerInternal(registrationId);\n    }\n\n    @Nonnull\n    @Override\n    public LocalTopicStats getLocalTopicStats() {\n        return getLocalTopicStatsInternal();\n    }\n}\npublic class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n\n    private final OperationService operationService;\n    private final SerializationService serializationService;\n    private final int partitionId;\n\n    public TotalOrderedTopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n        super(name, nodeEngine, service);\n        this.partitionId = nodeEngine.getPartitionService()\n                                     .getPartitionId(getNameAsPartitionAwareData());\n        this.operationService = nodeEngine.getOperationService();\n        this.serializationService = nodeEngine.getSerializationService();\n    }\n\n    @Override\n    public void publish(@Nonnull  E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public CompletionStage<E> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public CompletionStage<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        \n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n    }\n\n    private Data[] toDataArray(Collection<? extends E> collection) {\n        Data[] items = new Data[collection.size()];\n        int k = 0;\n        for (E item : collection) {\n            checkNotNull(item, \"collection mustn't contains null items\");\n            items[k] = toData(item);\n            k++;\n        }\n        return items;\n    }\n\n    private InternalCompletableFuture<Data> publishInternalAsync(Operation operation) {\n        topicStats.incrementPublishes();\n        try {\n            InvocationFuture<Data> future = operationService.invokeOnPartition(SERVICE_NAME, operation, partitionId);\n            return future;\n        } catch (Throwable t) {\n            throw rethrow(t);\n        }\n    }\n}", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r449615644", "createdAt": "2020-07-03T14:40:31Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -47,6 +56,13 @@ public void publish(@Nonnull E message) {\n         publishInternal(message);\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzMxMDgxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1MToxNVrOGefk3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyOTowNFrOGsM5hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ==", "bodyText": "Haven't looked at the tests too closely (will look after other comments are addressed) but as a general idea since all implementations share the same interface, I suggest that you write the test once and just parametrize it - either use the reliable topic or regular topic, the ordered or non-ordered topic.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434627805", "createdAt": "2020-06-03T14:51:15Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NTQyMA==", "bodyText": "As @sancar mentioned, it is the easiest way to extend this class.\n#16946 (comment)\nOr do you have any other problem in mind?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443485420", "createdAt": "2020-06-22T11:12:22Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMTg2Mg==", "bodyText": "Yeah, that'll work too. Parametrized tests are good if you stick to a single instance type (member or client) and then want to test different implementations - ordered vs non-ordered, reliable topic vs non-reliable topic.\nAnd then, once you have such a parametrized test using a member as the test instance, you override it as you say and call the same methods on the client.\nAnyway, if you see yourself copying the same tests for testing different topic implementations, think about parametrizing tests.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r449001862", "createdAt": "2020-07-02T13:29:04Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ=="}, "originalCommit": {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQxNDc5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNzowMVrOHIDdMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNjoxNFrOHIefVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzI4Mw==", "bodyText": "Do we actually throw it or do we complete the future with this exception?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478207283", "createdAt": "2020-08-27T07:17:01Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -63,6 +66,16 @@\n      */\n     void publish(@Nonnull E message);\n \n+    /**\n+     * Publishes the message to all subscribers of this topic.\n+     *\n+     * @param message the message to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDE5OQ==", "bodyText": "Ok, you are right. The future is completed with this exception returnFuture.completeExceptionally(t);\nI removed the @throws.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478650199", "createdAt": "2020-08-27T19:36:14Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -63,6 +66,16 @@\n      */\n     void publish(@Nonnull E message);\n \n+    /**\n+     * Publishes the message to all subscribers of this topic.\n+     *\n+     * @param message the message to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzI4Mw=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQxNjY5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNzo0MFrOHIDebA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNjozMlrOHIef9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzU5Ng==", "bodyText": "Same comment as on publishAsync", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478207596", "createdAt": "2020-08-27T07:17:40Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -95,4 +108,23 @@\n      * @return statistics about this topic\n      */\n     @Nonnull LocalTopicStats getLocalTopicStats();\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @throws TopicOverloadException if the consumer is too slow\n+     *                                (only works in combination with reliable topic)\n+     */\n+    void publishAll(@Nonnull Collection<? extends E> messages) throws ExecutionException, InterruptedException;\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDM1OQ==", "bodyText": "Same answer. ;)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478650359", "createdAt": "2020-08-27T19:36:32Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -95,4 +108,23 @@\n      * @return statistics about this topic\n      */\n     @Nonnull LocalTopicStats getLocalTopicStats();\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @throws TopicOverloadException if the consumer is too slow\n+     *                                (only works in combination with reliable topic)\n+     */\n+    void publishAll(@Nonnull Collection<? extends E> messages) throws ExecutionException, InterruptedException;\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzU5Ng=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQxOTY0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxODozNlrOHIDgKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzo1Njo0OFrOHJHHPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg==", "bodyText": "Can you check if this statistic is per-message or per-operation?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478208042", "createdAt": "2020-08-27T07:18:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception {\n+        TopicService service = getService();\n+        service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1Nzg5Ng==", "bodyText": "It seems that the statistics are calculated per-message (com.hazelcast.topic.impl.TopicService#dispatchEvent).\nBecause of this, I have to move this method call inside the com.hazelcast.topic.impl.PublishAllOperation#run method where all the messages are published? Correct?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478657896", "createdAt": "2020-08-27T19:51:06Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception {\n+        TopicService service = getService();\n+        service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMxNTc3NA==", "bodyText": "Yes, right, looks good.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479315774", "createdAt": "2020-08-28T13:56:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception {\n+        TopicService service = getService();\n+        service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQzMzQ0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoyMjo1MlrOHIDojw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozOToyNVrOHIelbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxMDE5MQ==", "bodyText": "Since PublishAllOperation is a new operation and since this member might be running in a cluster with older members, we need to introduce the cluster version check:\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)){\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\nSame in other methods using this operation.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478210191", "createdAt": "2020-08-27T07:22:52Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTc1OQ==", "bodyText": "Got it - changed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478651759", "createdAt": "2020-08-27T19:39:25Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxMDE5MQ=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQ2NTMxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzozMjo0NVrOHID8tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowNToyMVrOHIhO5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNTM0OQ==", "bodyText": "Since none of the operations that are passed as arguments to this method actually have a Data result (or even have any kind of result), you can change it to InternalCompletableFuture<Void>. Also, then you don't need to wrap it in newDelegatingFuture(serializationService, publishInternalAsync(op)) as the serialization service doesn't have anything to deserialize.\nIn the end, we then get this:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        return publishInternalAsync(op);\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        return publishInternalAsync(op);\n    }\n\n    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n        topicStats.incrementPublishes();\n        try {\n            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);\n        } catch (Throwable t) {\n            throw rethrow(t);\n        }\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478215349", "createdAt": "2020-08-27T07:32:45Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    private InternalCompletableFuture<Data> publishInternalAsync(Operation operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5NTE0MA==", "bodyText": "Ok, makes sense. Changed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478695140", "createdAt": "2020-08-27T21:05:21Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    private InternalCompletableFuture<Data> publishInternalAsync(Operation operation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNTM0OQ=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQ3Njk4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzozNjoxMFrOHIED-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDo0NTo1NFrOHIgpCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzIxMA==", "bodyText": "Minor: add the // RU_COMPAT_4_0 comment here so we can easily find it and remove it in 4.2.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478217210", "createdAt": "2020-08-27T07:36:10Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.cluster.Versions;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+import com.hazelcast.version.Version;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4NTQ1MA==", "bodyText": "Fixed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478685450", "createdAt": "2020-08-27T20:45:54Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.cluster.Versions;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+import com.hazelcast.version.Version;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzIxMA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQ5MzY1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo0MDo1M1rOHIEOLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo1Nzo1MlrOHIfLVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxOTgyMQ==", "bodyText": "Minor: you can use Collections.singleton(payload).", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478219821", "createdAt": "2020-08-27T07:40:53Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +126,14 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Collection<E> messages = new ArrayList<>();\n+        messages.add(payload);\n+        return publishAllAsync(messages);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2MTQ2Mw==", "bodyText": "Fixed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478661463", "createdAt": "2020-08-27T19:57:52Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +126,14 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Collection<E> messages = new ArrayList<>();\n+        messages.add(payload);\n+        return publishAllAsync(messages);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxOTgyMQ=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTUwNzM3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo0NTowMFrOHIEW8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMzo1OTozNlrOHJHR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA==", "bodyText": "Just occurred to me - can you check if this addition is atomic - either all are added or none? Asking because then it's safe to retry but if we added some and not others, we might end up adding some items multiple times.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478222064", "createdAt": "2020-08-27T07:45:00Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5MjQ4OQ==", "bodyText": "Ok, I investigated this. The com.hazelcast.ringbuffer.impl.RingbufferProxy#addAllAsync method uses the com.hazelcast.ringbuffer.impl.operations.AddAllOperation class for adding messages. In this operation (please see the run method), a check about the remaining capacity is accomplished. So either every item is added to the ringbuffer or none.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478692489", "createdAt": "2020-08-27T20:59:45Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMxODUwOQ==", "bodyText": "Great, thanks!", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479318509", "createdAt": "2020-08-28T13:59:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTUxNTI2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo0NzoxNVrOHIEbzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMTo1NDoyN1rOHJl7Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA==", "bodyText": "Minor: this was previously in the try-catch block and was wrapped in case serialization failed (I think) so maybe we can follow the same approach here. Not sure if we should complete the future or throw it to the caller. Maybe fail-fast and throwing it directly is the better option here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478223308", "createdAt": "2020-08-27T07:47:15Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg1MTE1Ng==", "bodyText": "I've changed the code in the same way like publishAll", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478851156", "createdAt": "2020-08-28T06:11:23Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMyMTg3Mg==", "bodyText": "I don't see the change, have you pushed it?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479321872", "createdAt": "2020-08-28T14:03:05Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgyMDU0Ng==", "bodyText": "Now it's pushed.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479820546", "createdAt": "2020-08-30T21:54:27Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTUxOTk4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo0ODozNlrOHIEekg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxNDozNTo1NlrOHNpw1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNDAxOA==", "bodyText": "Do you have a test where this is exercised? I'd like to see which threads are involved in this execution and if it works nicely.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478224018", "createdAt": "2020-08-27T07:48:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()\n+                .map(m -> new ReliableTopicMessage(toData(m), null))\n+                .collect(Collectors.toList());\n+        switch (overloadPolicy) {\n+            case ERROR:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            if (id == -1) {\n+                                returnFuture.completeExceptionally(new TopicOverloadException(\n+                                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+\n+                break;\n+            case DISCARD_OLDEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case DISCARD_NEWEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case BLOCK:\n+                addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA3Nzc4MA==", "bodyText": "Hello @mmedenjak, I've finished implementing some extended tests. Please see com.hazelcast.client.topic.ClientReliableTopicOverloadTest (and in special the extended abstract class com.hazelcast.topic.impl.reliable.TopicOverloadAbstractTest)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r484077780", "createdAt": "2020-09-06T14:35:56Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()\n+                .map(m -> new ReliableTopicMessage(toData(m), null))\n+                .collect(Collectors.toList());\n+        switch (overloadPolicy) {\n+            case ERROR:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            if (id == -1) {\n+                                returnFuture.completeExceptionally(new TopicOverloadException(\n+                                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+\n+                break;\n+            case DISCARD_OLDEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case DISCARD_NEWEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case BLOCK:\n+                addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNDAxOA=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTUzNDQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo1Mjo1OVrOHIEnkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMDoyNzowM1rOHLozyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ==", "bodyText": "Do we have to honor the overloadPolicy here? Seems like we do in publish and we also increment the stats (keep in mind that you need to check if we increment per-message or per-operation). Same comment for publishAll and publishAllAsync", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478226321", "createdAt": "2020-08-27T07:52:59Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -184,6 +194,22 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgyMTcyNA==", "bodyText": "Ok, I've changed (and pushed) it but the class with all its methods looks like a big mess.\nI will try to cleanup some things tomorrow.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479821724", "createdAt": "2020-08-30T22:06:34Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -184,6 +194,22 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NTAwMw==", "bodyText": "Ok, I've fixed and cleaned it up a little bit. The only thing actually missing is the dedicated test for addAsyncAndBlock.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r481965003", "createdAt": "2020-09-02T10:27:03Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -184,6 +194,22 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTU0MzAzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzo1NToyOFrOHIEs8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozODo1NFrOHIekdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNzY5OQ==", "bodyText": "If you want, replace this with:\n        return collection.stream().map(item -> {\n            checkNotNull(item, \"collection can't contains null items\");\n            return toData(item);\n        }).toArray(Data[]::new);", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478227699", "createdAt": "2020-08-27T07:55:28Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -64,6 +79,33 @@ public boolean removeMessageListener(@Nonnull UUID registrationId) {\n     public LocalTopicStats getLocalTopicStats() {\n         return getLocalTopicStatsInternal();\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        messages.forEach(this::publishInternal);\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        publishAll(messages);\n+        return InternalCompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    protected Data[] toDataArray(Collection<? extends E> collection) {\n+        Data[] items = new Data[collection.size()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTUwOA==", "bodyText": "Much more beautiful. :)\nI've changed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478651508", "createdAt": "2020-08-27T19:38:54Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -64,6 +79,33 @@ public boolean removeMessageListener(@Nonnull UUID registrationId) {\n     public LocalTopicStats getLocalTopicStats() {\n         return getLocalTopicStatsInternal();\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        messages.forEach(this::publishInternal);\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        publishAll(messages);\n+        return InternalCompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    protected Data[] toDataArray(Collection<? extends E> collection) {\n+        Data[] items = new Data[collection.size()];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNzY5OQ=="}, "originalCommit": {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODA3NzI1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDoyNTo1N1rOHWkCIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoxNzoyN1rOHXrHcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyMTA5MQ==", "bodyText": "I think this is the wrong kind of NotNull, should probably use javax.annotation.Nonnull", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493421091", "createdAt": "2020-09-23T10:25:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -35,15 +36,22 @@\n import com.hazelcast.topic.impl.reliable.MessageRunner;\n import com.hazelcast.topic.impl.reliable.ReliableMessageListenerAdapter;\n import com.hazelcast.topic.impl.reliable.ReliableTopicMessage;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NTcxNA==", "bodyText": "Fixed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494585714", "createdAt": "2020-09-24T20:17:27Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -35,15 +36,22 @@\n import com.hazelcast.topic.impl.reliable.MessageRunner;\n import com.hazelcast.topic.impl.reliable.ReliableMessageListenerAdapter;\n import com.hazelcast.topic.impl.reliable.ReliableTopicMessage;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyMTA5MQ=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODE0MTA0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDozNzoxOVrOHWkrhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoxNzo1MlrOHXrITA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzMTY4NA==", "bodyText": "Why do we need this first catch block? Same in publishAllAsync.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493431684", "createdAt": "2020-09-23T10:37:19Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NTkzMg==", "bodyText": "Removed the catch block (both)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494585932", "createdAt": "2020-09-24T20:17:52Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzMTY4NA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODE4MTAwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDo0NDo0OFrOHWlFyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoxOTowMlrOHXrKYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzODQxMA==", "bodyText": "I think it should be fine, but let's just avoid completing the same future several times and guard it with if-else-if statements. Same on other methods.\nAlso, don't complete it here in case we've scheduled another run because there was no room left for all items.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493438410", "createdAt": "2020-09-23T10:44:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjQ2NQ==", "bodyText": "Ok, I hope I understand it correctly. Fixed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586465", "createdAt": "2020-09-24T20:19:02Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzODQxMA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODIxMTE2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDo1MDoyOVrOHWlZ4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoxOToyM1rOHXrLHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0MzU1Mw==", "bodyText": "This looks odd. We schedule the task but also complete the future. I think we should probably not complete exceptionally here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493443553", "createdAt": "2020-09-23T10:50:29Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjY1NA==", "bodyText": "Fixed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586654", "createdAt": "2020-09-24T20:19:23Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0MzU1Mw=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODIyNzE0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionSpecificClientProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDo1MzozOFrOHWlktw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoxOTozMFrOHXrLVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0NjMyNw==", "bodyText": "Not used.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493446327", "createdAt": "2020-09-23T10:53:38Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionSpecificClientProxy.java", "diffHunk": "@@ -87,4 +87,8 @@ protected ClientMessage invokeOnPartition(ClientMessage req) {\n             throw ExceptionUtil.rethrowAllowInterrupted(e);\n         }\n     }\n+\n+    public int getPartitionId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjcxMA==", "bodyText": "removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586710", "createdAt": "2020-09-24T20:19:30Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionSpecificClientProxy.java", "diffHunk": "@@ -87,4 +87,8 @@ protected ClientMessage invokeOnPartition(ClientMessage req) {\n             throw ExceptionUtil.rethrowAllowInterrupted(e);\n         }\n     }\n+\n+    public int getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0NjMyNw=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODI0NDA2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDo1Njo1N1rOHWlwNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoxOTo0MFrOHXrLvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0OTI2OA==", "bodyText": "Same as in client proxy.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493449268", "createdAt": "2020-09-23T10:56:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -21,29 +21,39 @@\n import com.hazelcast.config.ReliableTopicConfig;\n import com.hazelcast.core.HazelcastException;\n import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.cluster.Versions;\n import com.hazelcast.internal.monitor.impl.LocalTopicStatsImpl;\n import com.hazelcast.internal.nio.ClassLoaderUtil;\n+import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.internal.util.ExceptionUtil;\n import com.hazelcast.internal.util.UuidUtil;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.ringbuffer.OverflowPolicy;\n import com.hazelcast.ringbuffer.Ringbuffer;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.topic.ITopic;\n import com.hazelcast.topic.LocalTopicStats;\n import com.hazelcast.topic.MessageListener;\n import com.hazelcast.topic.ReliableMessageListener;\n import com.hazelcast.topic.TopicOverloadException;\n import com.hazelcast.topic.TopicOverloadPolicy;\n+import com.hazelcast.version.Version;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjgxMw==", "bodyText": "fixed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586813", "createdAt": "2020-09-24T20:19:40Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -21,29 +21,39 @@\n import com.hazelcast.config.ReliableTopicConfig;\n import com.hazelcast.core.HazelcastException;\n import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.cluster.Versions;\n import com.hazelcast.internal.monitor.impl.LocalTopicStatsImpl;\n import com.hazelcast.internal.nio.ClassLoaderUtil;\n+import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.internal.util.ExceptionUtil;\n import com.hazelcast.internal.util.UuidUtil;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.ringbuffer.OverflowPolicy;\n import com.hazelcast.ringbuffer.Ringbuffer;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.topic.ITopic;\n import com.hazelcast.topic.LocalTopicStats;\n import com.hazelcast.topic.MessageListener;\n import com.hazelcast.topic.ReliableMessageListener;\n import com.hazelcast.topic.TopicOverloadException;\n import com.hazelcast.topic.TopicOverloadPolicy;\n+import com.hazelcast.version.Version;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0OTI2OA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODI1NjIzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDo1OToxN1rOHWl4IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyMDoyM1rOHXrNTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1MTI5Nw==", "bodyText": "Since the stat says it is the number of published messages, we need to increment this by number of messages, and only in cases we successfully published. I guess the publish is wrong then and it should be fixed but I can do it in another PR.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493451297", "createdAt": "2020-09-23T10:59:17Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NzIxMw==", "bodyText": "Ok, I think I've found every line where the stats are incremented.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494587213", "createdAt": "2020-09-24T20:20:23Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1MTI5Nw=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODI3ODA4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowMzo0NFrOHWmGgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyMTowM1rOHXrOjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDk3OA==", "bodyText": "In the member-side we complete the future in the client-side we throw directly. We should probably have the same behaviour and between the two, I think I'd prefer the client-side one (throwing directly) as it's an early indicator of failure, like the instance already been shutdown, or the message not being serializable.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493454978", "createdAt": "2020-09-23T11:03:44Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NzUzNA==", "bodyText": "Fixed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494587534", "createdAt": "2020-09-24T20:21:03Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDk3OA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODI3ODk3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowMzo1N1rOHWmHGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyMToxNFrOHXrO5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTEyOA==", "bodyText": "Same as in client-side", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493455128", "createdAt": "2020-09-23T11:03:57Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName())));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@NotNull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,\n+                                  InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages,\n+                                  long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                nodeEngine.getExecutionService().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NzYyMw==", "bodyText": "fixed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494587623", "createdAt": "2020-09-24T20:21:14Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName())));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@NotNull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,\n+                                  InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages,\n+                                  long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                nodeEngine.getExecutionService().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTEyOA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODI5Mzc2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowNjo1MVrOHWmRLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyMzowMVrOHXrSvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NzcxMA==", "bodyText": "It's actually interesting that the PublishOperation is also wrong here. We should increment after we successfully published, not before, as the stat says it is the number of successfully published messages. You can fix it here, I'll fix the rest in another PR.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493457710", "createdAt": "2020-09-23T11:06:51Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception { }\n+\n+    @Override\n+    public void run() throws Exception {\n+        TopicService service = getService();\n+        EventService eventService = getNodeEngine().getEventService();\n+        Collection<EventRegistration> registrations = eventService.getRegistrations(TopicService.SERVICE_NAME, name);\n+\n+        Lock lock = service.getOrderLock(name);\n+        lock.lock();\n+        try {\n+            for (Data item : messages) {\n+                TopicEvent topicEvent = new TopicEvent(name, item, getCallerAddress());\n+                service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODYwNQ==", "bodyText": "I also fixed the wrong PublishOperation code (changed beforeRune to afterRun)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494588605", "createdAt": "2020-09-24T20:23:01Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception { }\n+\n+    @Override\n+    public void run() throws Exception {\n+        TopicService service = getService();\n+        EventService eventService = getNodeEngine().getEventService();\n+        Collection<EventRegistration> registrations = eventService.getRegistrations(TopicService.SERVICE_NAME, name);\n+\n+        Lock lock = service.getOrderLock(name);\n+        lock.lock();\n+        try {\n+            for (Data item : messages) {\n+                TopicEvent topicEvent = new TopicEvent(name, item, getCallerAddress());\n+                service.incrementPublishes(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NzcxMA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODI5OTI0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowNzo1MVrOHWmUrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyMzoxMVrOHXrTBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODYwNA==", "bodyText": "I don't think we need the service anymore.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493458604", "createdAt": "2020-09-23T11:07:51Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +42,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final SerializationService serializationService;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.serializationService = nodeEngine.getSerializationService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODY3Nw==", "bodyText": "Removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494588677", "createdAt": "2020-09-24T20:23:11Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +42,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final SerializationService serializationService;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.serializationService = nodeEngine.getSerializationService();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODYwNA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODMwMTM0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxySupport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowODoxNlrOHWmWEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyMzoxN1rOHXrTNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODk2MA==", "bodyText": "Not used.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493458960", "createdAt": "2020-09-23T11:08:16Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxySupport.java", "diffHunk": "@@ -100,6 +112,16 @@ public void publishInternal(@Nonnull Object message) {\n         topicService.publishMessage(name, message, multithreaded);\n     }\n \n+    protected InternalCompletableFuture<Data> putAsyncInternal(Operation operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODcyNw==", "bodyText": "removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494588727", "createdAt": "2020-09-24T20:23:17Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxySupport.java", "diffHunk": "@@ -100,6 +112,16 @@ public void publishInternal(@Nonnull Object message) {\n         topicService.publishMessage(name, message, multithreaded);\n     }\n \n+    protected InternalCompletableFuture<Data> putAsyncInternal(Operation operation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODk2MA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODMwNDQ1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowODo1NFrOHWmYGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyNjowMVrOHXrYaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1OTQ4Mg==", "bodyText": "serializationService not used.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493459482", "createdAt": "2020-09-23T11:08:54Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,11 +40,18 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n+    private final SerializationService serializationService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDA1OQ==", "bodyText": "removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590059", "createdAt": "2020-09-24T20:26:01Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,11 +40,18 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n+    private final SerializationService serializationService;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1OTQ4Mg=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODMxNDAzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToxMDo0NlrOHWmemQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyNjowOVrOHXrYoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTE0NQ==", "bodyText": "No need to set the partition ID if it'll be invoked on the partition by the helper method.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493461145", "createdAt": "2020-09-23T11:10:46Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDExMg==", "bodyText": "removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590112", "createdAt": "2020-09-24T20:26:09Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTE0NQ=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODMxNzkwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToxMTozN1rOHWmhRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyNjoxNlrOHXrY1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTgyOA==", "bodyText": "You can just call publishAllAsync here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493461828", "createdAt": "2020-09-23T11:11:37Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDE2NA==", "bodyText": "changed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590164", "createdAt": "2020-09-24T20:26:16Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTgyOA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODMyMTczOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToxMjoyMFrOHWmjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNzo0NDoxMVrOHX4oMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ==", "bodyText": "Again, the issue with successfully published statistics. Maybe you can avoid it alltogether, and keep the current behaviour, and I'll fix it in another PR in all places.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493462439", "createdAt": "2020-09-23T11:12:20Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        topicStats.incrementPublishes();\n+        try {\n+            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDY2Nw==", "bodyText": "As mentioned earlier, I think I've found every call of incrementPublishes", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590667", "createdAt": "2020-09-24T20:27:13Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        topicStats.incrementPublishes();\n+        try {\n+            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwNzA5MA==", "bodyText": "Ideally, we should increment once the future is done, but let's not nitpick now, I'll do it later.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494807090", "createdAt": "2020-09-25T07:44:11Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        topicStats.incrementPublishes();\n+        try {\n+            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODMzODIyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToxNTo0MlrOHWmu1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDoyNzo1NFrOHXrcQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NTMwMg==", "bodyText": "testPublishAll and testPublishAllAsync are the same. Can you fix that? I guess they can share a single helper method to avoid duplication.\nSame for other two tests when it comes to avoiding duplication.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493465302", "createdAt": "2020-09-23T11:15:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -93,4 +107,117 @@ public void testGetLocalTopicStats() throws Exception {\n \n         topic.getLocalTopicStats();\n     }\n+\n+    @Test\n+    public void testPublish() throws InterruptedException {\n+        String publishValue = \"message\";\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        topic.publish(publishValue);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertTrue(receivedValues.contains(publishValue));\n+            }\n+        });\n+    }\n+\n+\n+    @Test\n+    public void testPublishAsync() throws InterruptedException {\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final List<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        final String message = \"message\";\n+        topic.publishAsync(message);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertEquals(Arrays.asList(message), receivedValues);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testPublishAll() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTA0MA==", "bodyText": "Oh no, this was a bad copy paste error. -_-", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494591040", "createdAt": "2020-09-24T20:27:54Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -93,4 +107,117 @@ public void testGetLocalTopicStats() throws Exception {\n \n         topic.getLocalTopicStats();\n     }\n+\n+    @Test\n+    public void testPublish() throws InterruptedException {\n+        String publishValue = \"message\";\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        topic.publish(publishValue);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertTrue(receivedValues.contains(publishValue));\n+            }\n+        });\n+    }\n+\n+\n+    @Test\n+    public void testPublishAsync() throws InterruptedException {\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final List<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        final String message = \"message\";\n+        topic.publishAsync(message);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertEquals(Arrays.asList(message), receivedValues);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testPublishAll() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NTMwMg=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODM2MDI0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToxOTo0OFrOHWm9FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToxMzo1MVrOHXs2Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2ODk0OQ==", "bodyText": "You can use assertCompletesEventually to avoid blocking the test forever in case it never completes, same in other test methods doing the same.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493468949", "createdAt": "2020-09-23T11:19:48Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java", "diffHunk": "@@ -136,6 +140,108 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testTopicPublishAsync() throws Exception {\n+        final String randomName = \"testTopicPublishAsync\" + generateRandomString(5);\n+        final AtomicInteger count = new AtomicInteger(0);\n+\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(1);\n+        HazelcastInstance instance = factory.newHazelcastInstance();\n+        ITopic<String> topic = instance.getTopic(randomName);\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+            }\n+        });\n+\n+        final CompletableFuture<Void> f = topic.publishAsync(\"TestMessage\").toCompletableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDA5NQ==", "bodyText": "Done", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494614095", "createdAt": "2020-09-24T21:13:51Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java", "diffHunk": "@@ -136,6 +140,108 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testTopicPublishAsync() throws Exception {\n+        final String randomName = \"testTopicPublishAsync\" + generateRandomString(5);\n+        final AtomicInteger count = new AtomicInteger(0);\n+\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(1);\n+        HazelcastInstance instance = factory.newHazelcastInstance();\n+        ITopic<String> topic = instance.getTopic(randomName);\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+            }\n+        });\n+\n+        final CompletableFuture<Void> f = topic.publishAsync(\"TestMessage\").toCompletableFuture();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2ODk0OQ=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODQzMjExOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTozMzo1M1rOHWnqqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToxNTowMlrOHXs4oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4MDYxNg==", "bodyText": "Since none of the methods in TopicTest use the client instance, I don't think it's worth extending it here. If you want to make the tests reusable, we need more involvement on different levels.\nFirst off, it should look like this:\n\nClientReliableTopicTest extends ClientTopicTest (client-side tests)\nReliableTopicAbstractTest extends TopicTest (member-side tests)\n\nThen, you'd need to go over all of the test methods and make sure they aren't calling something like instance.getTopic() or client.getReliableTopic() directly in the test. Instead, they would need to call something like getTopicImplementation().publish() where getTopicImplementation would be some abstract method which is overriden in different tests. For instance:\n\nClientReliableTopicTest would return client.getReliableTopic\nReliableTopicAbstractTest would return member.getReliableTopic\nClientTopicTest would return client.getTopic\nTopicTest would return member.getTopic\n\nPersonally, I think it's too much involvement for this PR and we can do it in a separate PR. Now, we might just add similar tests on client and member-side, and for both regular topic and ITopic.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493480616", "createdAt": "2020-09-23T11:33:53Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDY4OA==", "bodyText": "I've changed it back to HazelcastTestSupport.\nI can have a deeper look into when this PR is finished. :)", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494614688", "createdAt": "2020-09-24T21:15:02Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4MDYxNg=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODU1MTI2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTo1NToyMlrOHWo2Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoyMToxNFrOHYibfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkzOA==", "bodyText": "I've also noticed we have no tests for BLOCK overload policy. So here's a suggestion, you can do analogous tests for topic, reliable topic, member and client side.\n    @Before\n    public void setup() {\n        Config config = smallInstanceConfig();\n        config.addRingBufferConfig(new RingbufferConfig(\"blockingReliableTopic*\")\n                .setCapacity(10)\n                .setTimeToLiveSeconds(60));\n        hazelcastFactory.newHazelcastInstance(config);\n\n        // for member-side ReliableTopicAbstractTest\n        config.addReliableTopicConfig(new ReliableTopicConfig(\"blockingReliableTopic*\")\n                .setReadBatchSize(10)\n                .setTopicOverloadPolicy(TopicOverloadPolicy.BLOCK));\n        \n        // for client-side ClientReliableTopicTest\n        ClientConfig clientConfig = new ClientConfig()\n                .addReliableTopicConfig(new ClientReliableTopicConfig(\"blockingReliableTopic*\")\n                        .setReadBatchSize(10)\n                        .setTopicOverloadPolicy(TopicOverloadPolicy.BLOCK));\n        \n        client = hazelcastFactory.newHazelcastClient(clientConfig);\n    }\n    \n    @Test\n    public void testBlockingAsync() {\n        String randomName = \"blockingReliableTopic\" + generateRandomString(5);\n        AtomicInteger count = new AtomicInteger(0);\n\n        ITopic<Object> topic = client.getReliableTopic(randomName);\n        topic.addMessageListener(message -> count.incrementAndGet());\n\n\n        for (int i = 0; i < 10; i++) {\n            topic.publish(\"message\");\n        }\n        assertTrueEventually(() -> assertEquals(10, count.get()));\n        assertCompletesEventually(topic.publishAllAsync(asList(\"msg 1\", \"msg 2\", \"msg 3\", \"msg 4\", \"msg 5\")).toCompletableFuture());\n        assertTrueEventually(() -> assertEquals(15, count.get()));\n    }", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493499938", "createdAt": "2020-09-23T11:55:22Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTk2Ng==", "bodyText": "I've created more tests (and extended the existing ones).", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491966", "createdAt": "2020-09-26T20:21:14Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkzOA=="}, "originalCommit": {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzE4ODI1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOTowMTowMlrOHX7NtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoyMDoyNVrOHYibRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0OTQ2MA==", "bodyText": "Move this to the else block so we don't complete or increment when there's an exception. Same on client side.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494849460", "createdAt": "2020-09-25T09:01:02Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +277,139 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+                messages.forEach(p -> localTopicStats.incrementPublishes());\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTkxMA==", "bodyText": "Done", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491910", "createdAt": "2020-09-26T20:20:25Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +277,139 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+                messages.forEach(p -> localTopicStats.incrementPublishes());\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0OTQ2MA=="}, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzE5MzcxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOTowMjozNlrOHX7RKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoyMDozMVrOHYibUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MDM0NA==", "bodyText": "Here it's not that critical as on member-side (because of statistics) but move this to an else block.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494850344", "createdAt": "2020-09-25T09:02:36Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,114 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTkyMg==", "bodyText": "Done", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491922", "createdAt": "2020-09-26T20:20:31Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,114 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MDM0NA=="}, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzIwMDIyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOTowNDo0MlrOHX7VSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoyMDozNlrOHYibVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MTQwMg==", "bodyText": "Looks like stats are incremented in the operation so you can remove it from here.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494851402", "createdAt": "2020-09-25T09:04:42Z", "author": {"login": "mmedenjak"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,19 +40,68 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n     private final int partitionId;\n+    private final LocalTopicStatsImpl topicStats;\n \n     public TotalOrderedTopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n-        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());\n+        this.partitionId = nodeEngine.getPartitionService()\n+                .getPartitionId(getNameAsPartitionAwareData());\n+        this.operationService = nodeEngine.getOperationService();\n+        this.topicStats = service.getLocalTopicStats(name);\n     }\n \n     @Override\n     public void publish(@Nonnull  E message) {\n         checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n-        Operation operation = new PublishOperation(getName(), toData(message))\n-                .setPartitionId(partitionId);\n+        Operation operation = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message));\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        publishAllAsync(messages).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        try {\n+            final InvocationFuture<Void> invocationFuture = operationService.invokeOnPartition(\n+                    OperationService.SERVICE_NAME, operation, partitionId);\n+            topicStats.incrementPublishes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTkyNw==", "bodyText": "Done", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491927", "createdAt": "2020-09-26T20:20:36Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,19 +40,68 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n     private final int partitionId;\n+    private final LocalTopicStatsImpl topicStats;\n \n     public TotalOrderedTopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n-        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());\n+        this.partitionId = nodeEngine.getPartitionService()\n+                .getPartitionId(getNameAsPartitionAwareData());\n+        this.operationService = nodeEngine.getOperationService();\n+        this.topicStats = service.getLocalTopicStats(name);\n     }\n \n     @Override\n     public void publish(@Nonnull  E message) {\n         checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n-        Operation operation = new PublishOperation(getName(), toData(message))\n-                .setPartitionId(partitionId);\n+        Operation operation = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message));\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        publishAllAsync(messages).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        try {\n+            final InvocationFuture<Void> invocationFuture = operationService.invokeOnPartition(\n+                    OperationService.SERVICE_NAME, operation, partitionId);\n+            topicStats.incrementPublishes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MTQwMg=="}, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5Nzc4MDU0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMjowMzo1NFrOHYAzSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoyMTo1M1rOHYibtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MTAwMw==", "bodyText": "ClientMessageDecoder can not be null.\nIf you add completionStage.toCompletableFuture().join(); in your tests you will get NullPointerException. Please add this version to tests as well.\nYou can pass  clientMessage -> null instead of null to fix the problem easily.\nPlease check publishAsync method as well for the same.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494941003", "createdAt": "2020-09-25T12:03:54Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +91,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        ClientMessage request = getClientMessage(messages);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        final ClientMessage clientMessage = getClientMessage(messages);\n+        return invokeOnPartitionAsync(clientMessage, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MjAyMw==", "bodyText": "Hello @sancar, I've fixed this and created one more test.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495492023", "createdAt": "2020-09-26T20:21:53Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +91,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        ClientMessage request = getClientMessage(messages);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        final ClientMessage clientMessage = getClientMessage(messages);\n+        return invokeOnPartitionAsync(clientMessage, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MTAwMw=="}, "originalCommit": {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI1NDkwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NjowOVrOHY6TeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjoyOTozOFrOHY7YNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzEyOQ==", "bodyText": "The test name is confusing. I know what you mean but only because I know the background.\nCan you rename it to something like testPublishAllAsync_thenJoin ?", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495883129", "createdAt": "2020-09-28T11:56:09Z", "author": {"login": "sancar"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDcyNA==", "bodyText": "Renamed it.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495900724", "createdAt": "2020-09-28T12:29:38Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzEyOQ=="}, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI1NTc1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NjoyM1rOHY6T7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjoyOTo0NVrOHY7YZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzI0NA==", "bodyText": "This is unused.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495883244", "createdAt": "2020-09-28T11:56:23Z", "author": {"login": "sancar"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+        ITopic<String> topic = createTopic(count, receivedValues);\n+\n+        final List<String> messages = Arrays.asList(\"message 1\", \"message 2\", \"messgae 3\");\n+        final CompletionStage<Void> completionStage = topic.publishAllAsync(messages);\n+        completionStage.toCompletableFuture().join();\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(messages.size(), count.get());\n+                assertTrue(messages.containsAll(receivedValues));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testBlockingAsync() {\n+        AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDc3NQ==", "bodyText": "Removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495900775", "createdAt": "2020-09-28T12:29:45Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+        ITopic<String> topic = createTopic(count, receivedValues);\n+\n+        final List<String> messages = Arrays.asList(\"message 1\", \"message 2\", \"messgae 3\");\n+        final CompletionStage<Void> completionStage = topic.publishAllAsync(messages);\n+        completionStage.toCompletableFuture().join();\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(messages.size(), count.get());\n+                assertTrue(messages.containsAll(receivedValues));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testBlockingAsync() {\n+        AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzI0NA=="}, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI3MTc2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowMToyM1rOHY6d3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjoyOTo1M1rOHY7YsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NTc4OQ==", "bodyText": "This payload parameter is unused. It can be removed. Please check the member side proxy as well.", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495885789", "createdAt": "2020-09-28T12:01:23Z", "author": {"login": "sancar"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,115 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDg0OQ==", "bodyText": "Removed", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495900849", "createdAt": "2020-09-28T12:29:53Z", "author": {"login": "andrewoelfing"}, "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,115 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NTc4OQ=="}, "originalCommit": {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 697, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}