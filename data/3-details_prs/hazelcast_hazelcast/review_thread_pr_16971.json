{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1ODk0NjI5", "number": 16971, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozMjowNVrOD9t2PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoyNDoxMVrOD9vCNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQwODkzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozMjowNVrOGXX_Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozMjowNVrOGXX_Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2MzQ1NQ==", "bodyText": "Extra line", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427163455", "createdAt": "2020-05-19T09:32:05Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java", "diffHunk": "@@ -501,6 +510,7 @@ public Context() {\n             }\n         }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQyNjI3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNjozM1rOGXYKJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNjozM1rOGXYKJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjI0Nw==", "bodyText": "Shouldn't we use logging instead? Our logging should have already been initialized when we get here.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427166247", "createdAt": "2020-05-19T09:36:33Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import net.openhft.affinity.Affinity;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class is threadsafe.\n+ */\n+public class ThreadAffinity {\n+    public static final ThreadAffinity DISABLED = new ThreadAffinity(null);\n+\n+    final List<BitSet> allowedCpusList;\n+    final AtomicInteger threadIndex = new AtomicInteger();\n+\n+    public ThreadAffinity(String affinity) {\n+        allowedCpusList = parse(affinity);\n+\n+        if (allowedCpusList.isEmpty()) {\n+            return;\n+        }\n+\n+        if (!isAffinityAvailable()) {\n+            throw new RuntimeException(\"Can't use affinity '\" + affinity + \"'. Thread affinity support is not available.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a new ThreadAffinity based on a system property.\n+     *\n+     * If no property is set, then affinity is disabled.\n+     *\n+     * @param property the name of the system property.\n+     * @return the created ThreadAffinity.\n+     * @throws InvalidAffinitySyntaxException if there is a problem with the value.\n+     */\n+    public static ThreadAffinity newSystemThreadAffinity(String property) {\n+        String value = System.getProperty(property);\n+        try {\n+            return new ThreadAffinity(value);\n+        } catch (InvalidAffinitySyntaxException e) {\n+            throw new InvalidAffinitySyntaxException(\"Invalid affinity syntax for System property '\" + property + \"'.\"\n+                    + \" Value '\" + value + \"'. \"\n+                    + \" Errormessage '\" + e.getMessage() + \"'\");\n+        }\n+    }\n+\n+    public int getThreadCount() {\n+        return allowedCpusList.size();\n+    }\n+\n+\n+    public BitSet nextAllowedCpus() {\n+        if (allowedCpusList.isEmpty()) {\n+            return null;\n+        }\n+\n+        int index = threadIndex.getAndIncrement() % allowedCpusList.size();\n+        return allowedCpusList.get(index);\n+    }\n+\n+    public boolean isEnabled() {\n+        return !allowedCpusList.isEmpty();\n+    }\n+\n+    private static boolean isAffinityAvailable() {\n+        try {\n+            boolean jnaAvailable = Affinity.isJNAAvailable();\n+            if (!jnaAvailable) {\n+                System.err.println(\"jna is not available\");\n+            }\n+            return jnaAvailable;\n+        } catch (NoClassDefFoundError e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDUzNzY4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowNjoxMVrOGXZPzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowNjoxMVrOGXZPzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NDA3Nw==", "bodyText": "Missing \"be\".", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427184077", "createdAt": "2020-05-19T10:06:11Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import net.openhft.affinity.Affinity;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class is threadsafe.\n+ */\n+public class ThreadAffinity {\n+    public static final ThreadAffinity DISABLED = new ThreadAffinity(null);\n+\n+    final List<BitSet> allowedCpusList;\n+    final AtomicInteger threadIndex = new AtomicInteger();\n+\n+    public ThreadAffinity(String affinity) {\n+        allowedCpusList = parse(affinity);\n+\n+        if (allowedCpusList.isEmpty()) {\n+            return;\n+        }\n+\n+        if (!isAffinityAvailable()) {\n+            throw new RuntimeException(\"Can't use affinity '\" + affinity + \"'. Thread affinity support is not available.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a new ThreadAffinity based on a system property.\n+     *\n+     * If no property is set, then affinity is disabled.\n+     *\n+     * @param property the name of the system property.\n+     * @return the created ThreadAffinity.\n+     * @throws InvalidAffinitySyntaxException if there is a problem with the value.\n+     */\n+    public static ThreadAffinity newSystemThreadAffinity(String property) {\n+        String value = System.getProperty(property);\n+        try {\n+            return new ThreadAffinity(value);\n+        } catch (InvalidAffinitySyntaxException e) {\n+            throw new InvalidAffinitySyntaxException(\"Invalid affinity syntax for System property '\" + property + \"'.\"\n+                    + \" Value '\" + value + \"'. \"\n+                    + \" Errormessage '\" + e.getMessage() + \"'\");\n+        }\n+    }\n+\n+    public int getThreadCount() {\n+        return allowedCpusList.size();\n+    }\n+\n+\n+    public BitSet nextAllowedCpus() {\n+        if (allowedCpusList.isEmpty()) {\n+            return null;\n+        }\n+\n+        int index = threadIndex.getAndIncrement() % allowedCpusList.size();\n+        return allowedCpusList.get(index);\n+    }\n+\n+    public boolean isEnabled() {\n+        return !allowedCpusList.isEmpty();\n+    }\n+\n+    private static boolean isAffinityAvailable() {\n+        try {\n+            boolean jnaAvailable = Affinity.isJNAAvailable();\n+            if (!jnaAvailable) {\n+                System.err.println(\"jna is not available\");\n+            }\n+            return jnaAvailable;\n+        } catch (NoClassDefFoundError e) {\n+            e.printStackTrace();\n+            System.err.println(\"Affinity jar isn't available\");\n+            return false;\n+        }\n+    }\n+\n+    static List<BitSet> parse(String affinity) {\n+        List<BitSet> cpus = new ArrayList<>();\n+        if (affinity == null) {\n+            return cpus;\n+        }\n+\n+        affinity = affinity.trim();\n+        if (affinity.isEmpty()) {\n+            return cpus;\n+        }\n+\n+        List<CpuGroup> groups = new AffinityParser(affinity).parse();\n+        for (CpuGroup group : groups) {\n+            BitSet allowedCpus = new BitSet();\n+\n+            for (Integer cpu : group.cpus) {\n+                allowedCpus.set(cpu);\n+            }\n+            for (int k = 0; k < group.threadCount; k++) {\n+                cpus.add(allowedCpus);\n+            }\n+        }\n+\n+        return cpus;\n+    }\n+\n+    static class AffinityParser {\n+        private final String string;\n+        private final List<CpuGroup> groups = new ArrayList<>();\n+        private int index;\n+        private int digit;\n+        private int integer;\n+        private int fromRange;\n+        private int toRange;\n+\n+        AffinityParser(String string) {\n+            this.string = string;\n+        }\n+\n+        List<CpuGroup> parse() {\n+            if (!expression() || index < string.length()) {\n+                throw new InvalidAffinitySyntaxException(\"Syntax Error at \" + index);\n+            }\n+\n+            // verification that we have no duplicate cpus.\n+            BitSet usedCpus = new BitSet();\n+            for (CpuGroup group : groups) {\n+                for (Integer cpu : group.cpus) {\n+                    if (usedCpus.get(cpu)) {\n+                        throw new InvalidAffinitySyntaxException(\"Duplicate CPU found, offending CPU=\" + cpu);\n+                    }\n+                    usedCpus.set(cpu);\n+                }\n+            }\n+\n+            return groups;\n+        }\n+\n+        boolean expression() {\n+            if (!item()) {\n+                return false;\n+            }\n+\n+            while (character(',')) {\n+                if (!item()) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        boolean item() {\n+            if (range()) {\n+                for (int cpu = fromRange; cpu <= toRange; cpu++) {\n+                    CpuGroup group = new CpuGroup();\n+                    group.cpus.add(cpu);\n+                    group.threadCount = 1;\n+                    groups.add(group);\n+                }\n+                return true;\n+            } else {\n+                return group();\n+            }\n+        }\n+\n+        boolean range() {\n+            if (!integer()) {\n+                return false;\n+            }\n+            fromRange = integer;\n+            toRange = integer;\n+            if (character('-')) {\n+                if (!integer()) {\n+                    return false;\n+                }\n+                toRange = integer;\n+                if (toRange < fromRange) {\n+                    error(\"ToRange can't smaller than fromRange, toRange=\" + toRange + \" fromRange=\" + fromRange + \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDU0OTcyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowOToxMVrOGXZXOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowOToxMVrOGXZXOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTk3Nw==", "bodyText": "Missing \"cannot\".", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427185977", "createdAt": "2020-05-19T10:09:11Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import net.openhft.affinity.Affinity;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class is threadsafe.\n+ */\n+public class ThreadAffinity {\n+    public static final ThreadAffinity DISABLED = new ThreadAffinity(null);\n+\n+    final List<BitSet> allowedCpusList;\n+    final AtomicInteger threadIndex = new AtomicInteger();\n+\n+    public ThreadAffinity(String affinity) {\n+        allowedCpusList = parse(affinity);\n+\n+        if (allowedCpusList.isEmpty()) {\n+            return;\n+        }\n+\n+        if (!isAffinityAvailable()) {\n+            throw new RuntimeException(\"Can't use affinity '\" + affinity + \"'. Thread affinity support is not available.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a new ThreadAffinity based on a system property.\n+     *\n+     * If no property is set, then affinity is disabled.\n+     *\n+     * @param property the name of the system property.\n+     * @return the created ThreadAffinity.\n+     * @throws InvalidAffinitySyntaxException if there is a problem with the value.\n+     */\n+    public static ThreadAffinity newSystemThreadAffinity(String property) {\n+        String value = System.getProperty(property);\n+        try {\n+            return new ThreadAffinity(value);\n+        } catch (InvalidAffinitySyntaxException e) {\n+            throw new InvalidAffinitySyntaxException(\"Invalid affinity syntax for System property '\" + property + \"'.\"\n+                    + \" Value '\" + value + \"'. \"\n+                    + \" Errormessage '\" + e.getMessage() + \"'\");\n+        }\n+    }\n+\n+    public int getThreadCount() {\n+        return allowedCpusList.size();\n+    }\n+\n+\n+    public BitSet nextAllowedCpus() {\n+        if (allowedCpusList.isEmpty()) {\n+            return null;\n+        }\n+\n+        int index = threadIndex.getAndIncrement() % allowedCpusList.size();\n+        return allowedCpusList.get(index);\n+    }\n+\n+    public boolean isEnabled() {\n+        return !allowedCpusList.isEmpty();\n+    }\n+\n+    private static boolean isAffinityAvailable() {\n+        try {\n+            boolean jnaAvailable = Affinity.isJNAAvailable();\n+            if (!jnaAvailable) {\n+                System.err.println(\"jna is not available\");\n+            }\n+            return jnaAvailable;\n+        } catch (NoClassDefFoundError e) {\n+            e.printStackTrace();\n+            System.err.println(\"Affinity jar isn't available\");\n+            return false;\n+        }\n+    }\n+\n+    static List<BitSet> parse(String affinity) {\n+        List<BitSet> cpus = new ArrayList<>();\n+        if (affinity == null) {\n+            return cpus;\n+        }\n+\n+        affinity = affinity.trim();\n+        if (affinity.isEmpty()) {\n+            return cpus;\n+        }\n+\n+        List<CpuGroup> groups = new AffinityParser(affinity).parse();\n+        for (CpuGroup group : groups) {\n+            BitSet allowedCpus = new BitSet();\n+\n+            for (Integer cpu : group.cpus) {\n+                allowedCpus.set(cpu);\n+            }\n+            for (int k = 0; k < group.threadCount; k++) {\n+                cpus.add(allowedCpus);\n+            }\n+        }\n+\n+        return cpus;\n+    }\n+\n+    static class AffinityParser {\n+        private final String string;\n+        private final List<CpuGroup> groups = new ArrayList<>();\n+        private int index;\n+        private int digit;\n+        private int integer;\n+        private int fromRange;\n+        private int toRange;\n+\n+        AffinityParser(String string) {\n+            this.string = string;\n+        }\n+\n+        List<CpuGroup> parse() {\n+            if (!expression() || index < string.length()) {\n+                throw new InvalidAffinitySyntaxException(\"Syntax Error at \" + index);\n+            }\n+\n+            // verification that we have no duplicate cpus.\n+            BitSet usedCpus = new BitSet();\n+            for (CpuGroup group : groups) {\n+                for (Integer cpu : group.cpus) {\n+                    if (usedCpus.get(cpu)) {\n+                        throw new InvalidAffinitySyntaxException(\"Duplicate CPU found, offending CPU=\" + cpu);\n+                    }\n+                    usedCpus.set(cpu);\n+                }\n+            }\n+\n+            return groups;\n+        }\n+\n+        boolean expression() {\n+            if (!item()) {\n+                return false;\n+            }\n+\n+            while (character(',')) {\n+                if (!item()) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        boolean item() {\n+            if (range()) {\n+                for (int cpu = fromRange; cpu <= toRange; cpu++) {\n+                    CpuGroup group = new CpuGroup();\n+                    group.cpus.add(cpu);\n+                    group.threadCount = 1;\n+                    groups.add(group);\n+                }\n+                return true;\n+            } else {\n+                return group();\n+            }\n+        }\n+\n+        boolean range() {\n+            if (!integer()) {\n+                return false;\n+            }\n+            fromRange = integer;\n+            toRange = integer;\n+            if (character('-')) {\n+                if (!integer()) {\n+                    return false;\n+                }\n+                toRange = integer;\n+                if (toRange < fromRange) {\n+                    error(\"ToRange can't smaller than fromRange, toRange=\" + toRange + \" fromRange=\" + fromRange + \".\");\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        private void error(String error) {\n+            throw new InvalidAffinitySyntaxException(error + \" at index:\" + index);\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+        boolean group() {\n+            if (!character('[')) {\n+                return false;\n+            }\n+\n+            if (!range()) {\n+                return false;\n+            }\n+\n+            CpuGroup group = new CpuGroup();\n+            addCpuRangeToGroup(group);\n+\n+            while (character(',')) {\n+                if (!range()) {\n+                    return false;\n+                }\n+\n+                addCpuRangeToGroup(group);\n+            }\n+\n+            if (!character(']')) {\n+                return false;\n+            }\n+\n+            if (character(':')) {\n+                if (!integer()) {\n+                    return false;\n+                }\n+                group.threadCount = integer;\n+                if (group.threadCount == 0) {\n+                    error(\"Thread count can't be 0.\");\n+                } else if (group.threadCount > group.cpus.size()) {\n+                    error(\"Thread count be larger than number of cpu's in the group. \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDU2NDUzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxMjo1M1rOGXZgVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxMjo1M1rOGXZgVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4ODMxMA==", "bodyText": "Should be logging here and below.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427188310", "createdAt": "2020-05-19T10:12:53Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java", "diffHunk": "@@ -71,10 +81,19 @@ protected void afterRun() {\n \n     }\n \n-    /**\n-     * Manages the thread lifecycle and can be overridden to customize if needed.\n-     */\n-    public void run() {\n+    @Override\n+    public final void run() {\n+        if (allowedCpus != null) {\n+            Affinity.setAffinity(allowedCpus);\n+            BitSet actualCpus = Affinity.getAffinity();\n+            if (!actualCpus.equals(allowedCpus)) {\n+                System.out.println(getName() + \" affinity was not applied successfully. \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDU3MjE1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxNTowNVrOGXZlFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzoxODo0NVrOGX54oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA==", "bodyText": "Would make sense to add a test for negative numbers too. Both for groups and thread count.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427189524", "createdAt": "2020-05-19T10:15:05Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.BitSet;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ThreadAffinityTest {\n+\n+    @Test\n+    public void whenNull() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(null);\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test\n+    public void whenEmptyString() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(\"\");\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenSyntaxError() {\n+        new ThreadAffinity(\"abc\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenTrailingComma() {\n+        new ThreadAffinity(\"10,\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxMDc3OA==", "bodyText": "Negative integers are not parsed by the parser.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427210778", "createdAt": "2020-05-19T10:54:40Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.BitSet;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ThreadAffinityTest {\n+\n+    @Test\n+    public void whenNull() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(null);\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test\n+    public void whenEmptyString() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(\"\");\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenSyntaxError() {\n+        new ThreadAffinity(\"abc\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenTrailingComma() {\n+        new ThreadAffinity(\"10,\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA=="}, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNTg4MA==", "bodyText": "Shouldn't we get an InvalidAffinitySyntaxException for such a setting?", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427315880", "createdAt": "2020-05-19T13:47:46Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.BitSet;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ThreadAffinityTest {\n+\n+    @Test\n+    public void whenNull() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(null);\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test\n+    public void whenEmptyString() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(\"\");\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenSyntaxError() {\n+        new ThreadAffinity(\"abc\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenTrailingComma() {\n+        new ThreadAffinity(\"10,\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA=="}, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxODgxNw==", "bodyText": "You will. Check the syntax for an integer. it will expect 1 digit followed by zero or more digits. If it sees a '-', it won't recognize it and you get a syntax error.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427718817", "createdAt": "2020-05-20T03:18:45Z", "author": {"login": "pveentjer"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.BitSet;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ThreadAffinityTest {\n+\n+    @Test\n+    public void whenNull() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(null);\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test\n+    public void whenEmptyString() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(\"\");\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenSyntaxError() {\n+        new ThreadAffinity(\"abc\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenTrailingComma() {\n+        new ThreadAffinity(\"10,\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA=="}, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDYwMzQxOnYy", "diffSide": "RIGHT", "path": "hazelcast/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoyNDoxMVrOGXZ4YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDo1NDo1OFrOGXa4nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5NDQ2NA==", "bodyText": "I think later for a product feature we should get rid of these dependencies. Ideally, we should have no added dependency if thread affinity becomes a prod feature. We can bundle a statically linked native lib in our jar - just like in EE - that only provides the glue code between the underlying syscalls and our Java code. If it would be done against libnuma - that also supports setting affinity -, we would gain additional features such as discovering the NUMA layout of the machine.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427194464", "createdAt": "2020-05-19T10:24:11Z", "author": {"login": "blazember"}, "path": "hazelcast/pom.xml", "diffHunk": "@@ -315,6 +315,29 @@\n     </build>\n \n     <dependencies>\n+        <!-- needed for thread affinity -->\n+        <dependency>\n+            <groupId>net.openhft</groupId>\n+            <artifactId>affinity</artifactId>\n+            <version>3.2.2</version>\n+            <scope>provided</scope>\n+            <optional>true</optional>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.7.25</version>\n+            <scope>provided</scope>\n+            <optional>true</optional>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-simple</artifactId>\n+            <version>1.5.8</version>\n+            <scope>provided</scope>\n+            <optional>true</optional>\n+        </dependency>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxMDkxMQ==", "bodyText": "Agree. I already added this to the TDD.", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427210911", "createdAt": "2020-05-19T10:54:58Z", "author": {"login": "pveentjer"}, "path": "hazelcast/pom.xml", "diffHunk": "@@ -315,6 +315,29 @@\n     </build>\n \n     <dependencies>\n+        <!-- needed for thread affinity -->\n+        <dependency>\n+            <groupId>net.openhft</groupId>\n+            <artifactId>affinity</artifactId>\n+            <version>3.2.2</version>\n+            <scope>provided</scope>\n+            <optional>true</optional>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.7.25</version>\n+            <scope>provided</scope>\n+            <optional>true</optional>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-simple</artifactId>\n+            <version>1.5.8</version>\n+            <scope>provided</scope>\n+            <optional>true</optional>\n+        </dependency>\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5NDQ2NA=="}, "originalCommit": {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 514, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}