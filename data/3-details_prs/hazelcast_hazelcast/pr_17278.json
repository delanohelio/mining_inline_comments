{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MjY4NDQz", "number": 17278, "title": "SQL plan cache implementation (#17277)", "bodyText": "This PR introduces the plan cache for the SQL subsystem.\nThe design is described in the https://github.com/devozerov/hazelcast/blob/issues/17277/docs/design/sql/06-plan-caching.md\nCloses #17277", "createdAt": "2020-07-29T08:07:56Z", "url": "https://github.com/hazelcast/hazelcast/pull/17278", "merged": true, "mergeCommit": {"oid": "5e43956b337470f77a3b14303e997db2ab4045e3"}, "closed": true, "closedAt": "2020-08-13T15:23:54Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5mYNWAH2gAyNDU4MjY4NDQzOjExYmRlMzE5MzNhMTMwOGIxYzNhOTM1MzU4NjAzNmRiNjlkOTMwNzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-gE2ngFqTQ2Njc2MzM3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "11bde31933a1308b1c3a9353586036db69d93075", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/11bde31933a1308b1c3a9353586036db69d93075", "committedDate": "2020-07-29T08:02:36Z", "message": "SQL plan cache implementation (#17277)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3fbe0e2e417b4d19e7bbca346b5a9d0c14d32b8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f3fbe0e2e417b4d19e7bbca346b5a9d0c14d32b8", "committedDate": "2020-07-29T09:27:08Z", "message": "Minors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34432c71454da9e0f2cb42afd95233810f63a327", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/34432c71454da9e0f2cb42afd95233810f63a327", "committedDate": "2020-08-04T13:05:13Z", "message": "Merge branch 'master' into issues/17277"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/27f2595a576b35d2084c05b1c96f0a55db2dc468", "committedDate": "2020-08-04T13:08:57Z", "message": "Fixes after merge from master."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDkyNzA1", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-461492705", "createdAt": "2020-08-05T09:26:53Z", "commit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwOTozMDoyMlrOG8Bxxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDozMDowM1rOG8MVTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU5Njg3MA==", "bodyText": "\"cache plans\" -> \"cached plans\"", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465596870", "createdAt": "2020-08-05T09:30:22Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/06-plan-caching.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Plan Caching\n+\n+## Overview\n+\n+Optimization of a query may take considerable time. In many applications, the set of queries is fixed. Therefore, the result of \n+query optimization could be cached and reused. This document explains the design of the plan cache in the Hazelcast Mustang SQL\n+engine.\n+\n+In section 1 we discuss the high-level requirements to the plan cache. In section 2 we describe the design. \n+\n+## 1. Requirements\n+\n+We assume that the result of query optimization is deterministic. That is, the same query plan is produced for the same set of \n+inputs. The inputs of the query optimizer are:\n+1. Catalog (schemas, tables, indexes)\n+1. The original query: query string, current schema, and parameters \n+1. Metadata\n+\n+### 1.1 Catalog\n+\n+A  catalog is a set of objects that may participate in query execution. The catalog is often referred to as \"schema\" in \n+the literature. We use the term \"catalog\" to disambiguate from the logical object containers, which are also called \"schemas\".\n+ \n+The catalog has three types of objects. *Schema* is a logical container for other objects. *Table* is a relation backed\n+by some physical storage, such as an `IMap`. *Index* is an additional data structure of a table that speeds up the execution \n+of queries. The catalog is used to resolve objects mentioned in the query and choose the proper access method. \n+\n+If the catalog is changed, the plan created earlier might become invalid. For example, if the table is dropped, the execution \n+of the plan will produce an error. If a new index is added, the optimizer may pick a better access path.\n+\n+The plan cache must be able to find and remove plans that have become invalid after changing the catalog. \n+\n+### 1.2 Query\n+\n+The query consists of the query string, the current schema, and parameters. Each of them may influence the optimization result.\n+\n+The current schema affects object resolution. For example, the query `SELECT * FROM map` may refer to `IMap` or `ReplicatedMap`\n+depending on the current schema (`partitioned` or `replicated`). \n+\n+Parameter values may alter statistics derivation and access path selection. For example, `SELECT ... FROM sales WHERE region=?`\n+may have different optimal plans for regions `EMEA` and `APAC`.  \n+ \n+The plan cache must use query content properly to ensure the correctness and efficiency of the query execution.  \n+ \n+### 1.3 Metadata\n+ \n+In the query optimization theory, metadata is external information that is used for optimization. Examples are \n+statistics, column uniqueness, data distribution, etc.\n+\n+In this document, we consider only partition distribution because this is the only metadata we use in our optimizer, \n+that is not part of the catalog, and that could change across query runs.\n+\n+Every plan is built for the specific partition distribution. That is, the distribution and participating members are saved \n+in the plan.\n+\n+The plan cache must be able to find and remove plans with obsolete partition distribution. \n+ \n+## 2. Design\n+\n+### 2.1 Plan Key\n+\n+The plan key is a key used to locate the cache plan. It should be possible to derive the key from the query before the \n+optimization phase. \n+\n+We use the following key:\n+```\n+PlanKey {\n+    List<List<String>> searchPaths;\n+    String sql;\n+}\n+```\n+`searchPaths` is the list of schemas that are used to resolve non-fully qualified objects during query parsing. Search paths\n+are created based on configured table resolvers, and the current schema. `sql` is a query string.   \n+\n+For the same catalog, two queries with the same search paths, and the same query string will always resolve the same objects. \n+On the contrary, the same query string may resolve different objects for different search paths, as shown in section 1.2. \n+Therefore, search paths must be part of the key.  \n+\n+### 2.2 Data Structure\n+\n+We use `ConcurrentHashMap` to store cache plans. `PlanKey` is a key, the plan is a value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4MzQ2MA==", "bodyText": "Isn't the issue also with parameter types? For example consider this query:\nSELECT * FROM my_may WHERE field=?\nThe field type is a VARCHAR. If the parameter type is also varchar, we can use an index for field. If parameter type is numeric, field will be implicitly cast to a number and index cannot be used.", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465683460", "createdAt": "2020-08-05T12:16:36Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/06-plan-caching.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Plan Caching\n+\n+## Overview\n+\n+Optimization of a query may take considerable time. In many applications, the set of queries is fixed. Therefore, the result of \n+query optimization could be cached and reused. This document explains the design of the plan cache in the Hazelcast Mustang SQL\n+engine.\n+\n+In section 1 we discuss the high-level requirements to the plan cache. In section 2 we describe the design. \n+\n+## 1. Requirements\n+\n+We assume that the result of query optimization is deterministic. That is, the same query plan is produced for the same set of \n+inputs. The inputs of the query optimizer are:\n+1. Catalog (schemas, tables, indexes)\n+1. The original query: query string, current schema, and parameters \n+1. Metadata\n+\n+### 1.1 Catalog\n+\n+A  catalog is a set of objects that may participate in query execution. The catalog is often referred to as \"schema\" in \n+the literature. We use the term \"catalog\" to disambiguate from the logical object containers, which are also called \"schemas\".\n+ \n+The catalog has three types of objects. *Schema* is a logical container for other objects. *Table* is a relation backed\n+by some physical storage, such as an `IMap`. *Index* is an additional data structure of a table that speeds up the execution \n+of queries. The catalog is used to resolve objects mentioned in the query and choose the proper access method. \n+\n+If the catalog is changed, the plan created earlier might become invalid. For example, if the table is dropped, the execution \n+of the plan will produce an error. If a new index is added, the optimizer may pick a better access path.\n+\n+The plan cache must be able to find and remove plans that have become invalid after changing the catalog. \n+\n+### 1.2 Query\n+\n+The query consists of the query string, the current schema, and parameters. Each of them may influence the optimization result.\n+\n+The current schema affects object resolution. For example, the query `SELECT * FROM map` may refer to `IMap` or `ReplicatedMap`\n+depending on the current schema (`partitioned` or `replicated`). \n+\n+Parameter values may alter statistics derivation and access path selection. For example, `SELECT ... FROM sales WHERE region=?`\n+may have different optimal plans for regions `EMEA` and `APAC`.  \n+ \n+The plan cache must use query content properly to ensure the correctness and efficiency of the query execution.  \n+ \n+### 1.3 Metadata\n+ \n+In the query optimization theory, metadata is external information that is used for optimization. Examples are \n+statistics, column uniqueness, data distribution, etc.\n+\n+In this document, we consider only partition distribution because this is the only metadata we use in our optimizer, \n+that is not part of the catalog, and that could change across query runs.\n+\n+Every plan is built for the specific partition distribution. That is, the distribution and participating members are saved \n+in the plan.\n+\n+The plan cache must be able to find and remove plans with obsolete partition distribution. \n+ \n+## 2. Design\n+\n+### 2.1 Plan Key\n+\n+The plan key is a key used to locate the cache plan. It should be possible to derive the key from the query before the \n+optimization phase. \n+\n+We use the following key:\n+```\n+PlanKey {\n+    List<List<String>> searchPaths;\n+    String sql;\n+}\n+```\n+`searchPaths` is the list of schemas that are used to resolve non-fully qualified objects during query parsing. Search paths\n+are created based on configured table resolvers, and the current schema. `sql` is a query string.   \n+\n+For the same catalog, two queries with the same search paths, and the same query string will always resolve the same objects. \n+On the contrary, the same query string may resolve different objects for different search paths, as shown in section 1.2. \n+Therefore, search paths must be part of the key.  \n+\n+### 2.2 Data Structure\n+\n+We use `ConcurrentHashMap` to store cache plans. `PlanKey` is a key, the plan is a value.\n+ \n+### 2.3 Maximum Size and Plan Eviction\n+\n+The maximum size of the cache is required to prevent out-of-memory if too many distinct queries are submitted.\n+\n+When a plan is added to the map, the map size is checked. If the map size is greater than the maximum size, some plans are \n+evicted. \n+\n+Eviction is synchronous because the asynchronous variant is prone to out-of-memory. We assume that for the most workloads \n+evictions should be rare. \n+\n+We use the LRU (least recently used) approach to find the plans to evict. Whenever a plan is accessed, it's `lastUsed` field is \n+updated with the current time. During the eviction, plans are sorted by their `lastUsed` values, and the least recently used\n+plans are removed.   \n+\n+### 2.4 Reacting to Catalog and Partition Distribution Changes\n+\n+If a catalog or partition distribution is changed, some plans must be invalidated. There are two different ways to achieve \n+this: `push` and `pull`.\n+\n+With the `push` approach, the plan cache is notified about a change, from the relevant component. E.g., if an index is created,\n+then the map service notifies the plan cache about the change. The advantage of this solution is that any change is reflected \n+in the plan cache immediately. However, this approach increases coupling, because many components (map service, \n+replicated map service, partition service) now have to be aware of the SQL subsystem. This approach also requires complex\n+synchronization between query optimizer, plan cache, and dependent components, to ensure that no stale plan is ever cached.\n+\n+With the `pull` approach, the SQL subsystem queries other components periodically, collects the changes, and invalidates \n+affected plans. The advantage of this approach is simplicity. No synchronization or changes to other components are needed. \n+Invalid plans are guaranteed to be removed eventually. The downside is that invalid plans might be active for some time after\n+the change has occurred.\n+\n+We choose the `pull` approach due to simplicity and sufficient guarantees. The background worker reconstructs the catalog \n+periodically, and verifies that existing plans are compatible with the current catalog and partition distribution. \n+\n+To counter the problem with outdated plans, we add a special `invalidatePlan` flag to `QueryException`. If an invalid plan\n+is used, an exception with this flag will be thrown at some point. When the initiator member receives an exception with \n+this flag, the plan is invalidated. \n+\n+Note that currently, users will have to re-execute the query in this case. In future versions, we will add a transparent\n+query retry, so that invalid plans will not be visible to users.    \n+\n+### 2.5 No Use of Parameters\n+\n+In other databases, parameters are used for plan caching, because the same queries with different parameters may have different \n+optimal plans.\n+\n+We do not use parameters at the moment, because we do not have statistics. We may change this decision in the future when \n+statistics are available.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4NDc4MA==", "bodyText": "This file should not be here.", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465684780", "createdAt": "2020-08-05T12:19:17Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/.gitignore", "diffHunk": "@@ -0,0 +1 @@\n+tpch/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Njg3MA==", "bodyText": "We should use searchPaths to be consistent", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465696870", "createdAt": "2020-08-05T12:41:22Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/OptimizerContext.java", "diffHunk": "@@ -165,6 +161,8 @@ public RelNode optimize(RelNode node, RuleSet rules, RelTraitSet traitSet) {\n         HazelcastSchema rootSchema,\n         List<List<String>> schemaPaths\n     ) {\n+        assert schemaPaths != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTM5NQ==", "bodyText": "TableField doesn't have equals method implemented. It's not strictly necessary for imdg because it never uses it, but it's necessary for Jet because we use it for some connectors.", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465701395", "createdAt": "2020-08-05T12:48:51Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/PartitionedMapPlanObjectId.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.schema.TableField;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class PartitionedMapPlanObjectId implements PlanObjectId {\n+\n+    private final String schemaName;\n+    private final String name;\n+    private final List<TableField> fields;\n+    private final QueryTargetDescriptor keyDescriptor;\n+    private final QueryTargetDescriptor valueDescriptor;\n+    private final Set<String> conflictingSchemas;\n+\n+    public PartitionedMapPlanObjectId(\n+        String schemaName,\n+        String name,\n+        List<TableField> fields,\n+        Set<String> conflictingSchemas,\n+        QueryTargetDescriptor keyDescriptor,\n+        QueryTargetDescriptor valueDescriptor\n+    ) {\n+        this.schemaName = schemaName;\n+        this.name = name;\n+        this.fields = fields;\n+        this.keyDescriptor = keyDescriptor;\n+        this.valueDescriptor = valueDescriptor;\n+        this.conflictingSchemas = conflictingSchemas;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        PartitionedMapPlanObjectId that = (PartitionedMapPlanObjectId) o;\n+\n+        return schemaName.equals(that.schemaName)\n+            && name.equals(that.name)\n+            && fields.equals(that.fields)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0NjIwNg==", "bodyText": "We can add this test to understand the logic here:\n@RunWith(HazelcastSerialClassRunner.class)\n@Category({QuickTest.class, ParallelJVMTest.class})\npublic class SqlCatalogTest {\n\n    @Test\n    public void when_sameNameInTwoSchemas_then_conflict() {\n        // When\n        Table s1t1 = new MockTable(\"s1\", \"t1\");\n        Table s1t2 = new MockTable(\"s1\", \"t2\");\n        Table s2t2 = new MockTable(\"s2\", \"t2\");\n\n        TableResolver tr1 = new MockTableResolver(s1t1, s1t2, s2t2);\n        new SqlCatalog(singletonList(tr1));\n\n        // Then\n        assertEquals(emptySet(), s1t1.getConflictingSchemas());\n        assertEquals(new HashSet<>(asList(\"s1\", \"s2\")), s1t2.getConflictingSchemas());\n        assertEquals(new HashSet<>(asList(\"s1\", \"s2\")), s2t2.getConflictingSchemas());\n    }\n\n    @Test\n    public void when_sameFqn_then_noConflict() {\n        Table s1t1_1 = new MockTable(\"s1\", \"t1\");\n        Table s1t1_2 = new MockTable(\"s1\", \"t1\");\n\n        // When\n        TableResolver tr1 = new MockTableResolver(s1t1_1, s1t1_2);\n        new SqlCatalog(singletonList(tr1));\n\n        // Then\n        assertEquals(emptySet(), s1t1_1.getConflictingSchemas());\n        assertEquals(emptySet(), s1t1_2.getConflictingSchemas());\n    }\n\n    @Test\n    public void when_sameFqnAndConflict_then_conflict() {\n        Table s1t1_1 = new MockTable(\"s1\", \"t1\");\n        Table s1t1_2 = new MockTable(\"s1\", \"t1\");\n        Table s2t1 = new MockTable(\"s2\", \"t1\");\n\n        // When\n        TableResolver tr1 = new MockTableResolver(s1t1_1);\n        TableResolver tr2 = new MockTableResolver(s1t1_2, s2t1);\n        new SqlCatalog(asList(tr1, tr2));\n\n        // Then\n        Set<String> bothSchemas = new HashSet<>(asList(\"s1\", \"s2\"));\n        assertEquals(bothSchemas, s1t1_1.getConflictingSchemas());\n        // the second occurrence of s1t1 doesn't have the conflicts set\n        assertEquals(emptySet(), s1t1_2.getConflictingSchemas());\n        assertEquals(bothSchemas, s2t1.getConflictingSchemas());\n    }\n\n    private static class MockTableResolver implements TableResolver {\n        private final List<Table> tables;\n\n        private MockTableResolver(Table ... tables) {\n            this.tables = asList(tables);\n        }\n\n        @Override\n        public List<List<String>> getDefaultSearchPaths() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Nonnull\n        @Override\n        public List<Table> getTables() {\n            return tables;\n        }\n\n    }\n\n    private static class MockTable extends Table {\n        MockTable(String schema, String tableName) {\n            super(schema, tableName, emptyList(), null);\n        }\n\n        @Override\n        public PlanObjectId getObjectId() {\n            return null;\n        }\n    }\n}", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465746206", "createdAt": "2020-08-05T13:58:03Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/SqlCatalog.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Schema that is used for the duration of query.\n+ */\n+public class SqlCatalog {\n+\n+    private final Map<String, Map<String, Table>> schemas;\n+\n+    public SqlCatalog(List<TableResolver> tableResolvers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0NzA2OQ==", "bodyText": "Is it guaranteed that if there are two objects with the same FQN, the second one will never be resolved, given the table resolver list isn't changed? We rely on it.", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465747069", "createdAt": "2020-08-05T13:59:13Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/SqlCatalog.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Schema that is used for the duration of query.\n+ */\n+public class SqlCatalog {\n+\n+    private final Map<String, Map<String, Table>> schemas;\n+\n+    public SqlCatalog(List<TableResolver> tableResolvers) {\n+        // Populate schemas and tables.\n+        schemas = new HashMap<>();\n+\n+        Map<String, Set<Table>> tableConflicts = new HashMap<>();\n+\n+        for (TableResolver tableResolver : tableResolvers) {\n+            Collection<Table> tables = tableResolver.getTables();\n+\n+            for (Table table : tables) {\n+                String schemaName = table.getSchemaName();\n+                String tableName = table.getName();\n+\n+                Table oldTable = schemas.computeIfAbsent(schemaName, key -> new HashMap<>()).putIfAbsent(tableName, table);\n+\n+                if (oldTable == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MzIyMg==", "bodyText": "We can use Map<String, org.apache.calcite.schema.Table> here and remove the @SuppressWarnings", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465753222", "createdAt": "2020-08-05T14:07:48Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastSchemaUtils.java", "diffHunk": "@@ -57,38 +55,33 @@ public static HazelcastSchema createCatalog(Schema schema) {\n      * objects such as IMap and ReplicatedMap as well as external tables created by Jet. This approach will not work well\n      * should we need a relaxed/dynamic object resolution at some point in future.\n      *\n-     * @param tableResolvers Table resolver to be used to get the list of existing tables.\n      * @return Top-level schema.\n      */\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public static HazelcastSchema createRootSchema(List<TableResolver> tableResolvers) {\n-        // Create tables.\n-        Map<String, Map<String, HazelcastTable>> tableMap = new HashMap<>();\n+    public static HazelcastSchema createRootSchema(SqlCatalog catalog) {\n+        // Create schemas.\n+        Map<String, Schema> schemaMap = new HashMap<>();\n+\n+        for (Map.Entry<String, Map<String, Table>> currentSchemaEntry : catalog.getSchemas().entrySet()) {\n+            String schemaName = currentSchemaEntry.getKey();\n+\n+            Map schemaTables = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2OTgwNg==", "bodyText": "A better name would be CacheablePlan", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465769806", "createdAt": "2020-08-05T14:30:03Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/CachedPlan.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+\n+/**\n+ * Plan that could be cached.\n+ */\n+public interface CachedPlan extends SqlPlan {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNzQwMDg4", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-461740088", "createdAt": "2020-08-05T14:49:12Z", "commit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDo0OToxM1rOG8NMFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDo0OToxM1rOG8NMFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4MzgyOQ==", "bodyText": "Bad import", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465783829", "createdAt": "2020-08-05T14:49:13Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/calcite/TestMapTable.java", "diffHunk": "@@ -17,11 +17,13 @@\n package com.hazelcast.sql.impl.calcite;\n \n import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.plan.cache.PlanObjectId;\n import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n import com.hazelcast.sql.impl.schema.TableField;\n import com.hazelcast.sql.impl.schema.TableStatistics;\n import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.sun.corba.se.spi.ior.ObjectId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35aa44836a6b033f03234fd9804ccbbf0b72a54e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/35aa44836a6b033f03234fd9804ccbbf0b72a54e", "committedDate": "2020-08-06T10:39:32Z", "message": "Fix bad import."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea315ab28125fd68ac6f5592b3f45499e7241c65", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ea315ab28125fd68ac6f5592b3f45499e7241c65", "committedDate": "2020-08-06T10:40:37Z", "message": "CachedPlan -> CacheablePlan"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f777f92be7323f5651c6dfbe9d517181fcc2f8a3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f777f92be7323f5651c6dfbe9d517181fcc2f8a3", "committedDate": "2020-08-06T10:41:38Z", "message": "Remove unnecessary suppression."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d97ba396693d17ca3468665478da2363bf63c2ed", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d97ba396693d17ca3468665478da2363bf63c2ed", "committedDate": "2020-08-06T10:48:56Z", "message": "Minor rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61d595af05ff3dbcb641bec8f945086cab737707", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/61d595af05ff3dbcb641bec8f945086cab737707", "committedDate": "2020-08-06T10:49:16Z", "message": "Remove unrelated .gitignore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7bf9540969dbeb94ea6a4254e9f2311ac1ce6d6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d7bf9540969dbeb94ea6a4254e9f2311ac1ce6d6", "committedDate": "2020-08-06T10:50:05Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac274daf6161e2a597e3544345caa9b6361ef651", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ac274daf6161e2a597e3544345caa9b6361ef651", "committedDate": "2020-08-06T10:54:47Z", "message": "Added equals to TableField"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e560f89a36d2d63729eb6b930de148ac62a4a93a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e560f89a36d2d63729eb6b930de148ac62a4a93a", "committedDate": "2020-08-06T10:57:42Z", "message": "Unit tests for SqlCatalog from Viliam."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNTM5MjU4", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-462539258", "createdAt": "2020-08-06T13:52:01Z", "commit": {"oid": "e560f89a36d2d63729eb6b930de148ac62a4a93a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMzo1MjowMVrOG80gBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMzo1MjowMVrOG80gBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyNzkwOA==", "bodyText": "\"Object ID\" sounds too generic to me. ID implies that it's stable, but it changes with any property change. Maybe \"comparison key\" would be better. Or \"object key\", for brevity. Also should contain \"plan\", because the key is tailored for plan. What about this?:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public PlanObjectId getObjectId() {\n          \n          \n            \n                public PlanObjectKey getPlanObjectKey() {", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466427908", "createdAt": "2020-08-06T13:52:01Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java", "diffHunk": "@@ -39,4 +41,20 @@ public PartitionedMapTable(\n     public PartitionedMapTable(String name, QueryException exception) {\n         super(SCHEMA_NAME_PARTITIONED, name, exception);\n     }\n+\n+    @Override\n+    public PlanObjectId getObjectId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e560f89a36d2d63729eb6b930de148ac62a4a93a"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d1e5df9a208bfa6ad07eec638546a37376abc4dc", "committedDate": "2020-08-06T13:58:37Z", "message": "ObjectKey -> ObjectId"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MTAzNDMx", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-464103431", "createdAt": "2020-08-10T10:08:10Z", "commit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzI2Nzg2", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-465726786", "createdAt": "2020-08-12T09:03:38Z", "commit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTowMzozOFrOG_YdGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTowMzozOFrOG_YdGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNDEzOQ==", "bodyText": "Is it going to be documented anywhere? How the users can detect that the exception indicates an invalid plan?", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469114139", "createdAt": "2020-08-12T09:03:38Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/sql/06-plan-caching.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Plan Caching\n+\n+## Overview\n+\n+Optimization of a query may take considerable time. In many applications, the set of queries is fixed. Therefore, the result of \n+query optimization could be cached and reused. This document explains the design of the plan cache in the Hazelcast Mustang SQL\n+engine.\n+\n+In section 1 we discuss the high-level requirements to the plan cache. In section 2 we describe the design. \n+\n+## 1. Requirements\n+\n+We assume that the result of query optimization is deterministic. That is, the same query plan is produced for the same set of \n+inputs. The inputs of the query optimizer are:\n+1. Catalog (schemas, tables, indexes)\n+1. The original query: query string, current schema, and parameters \n+1. Metadata\n+\n+### 1.1 Catalog\n+\n+A  catalog is a set of objects that may participate in query execution. The catalog is often referred to as \"schema\" in \n+the literature. We use the term \"catalog\" to disambiguate from the logical object containers, which are also called \"schemas\".\n+ \n+The catalog has three types of objects. *Schema* is a logical container for other objects. *Table* is a relation backed\n+by some physical storage, such as an `IMap`. *Index* is an additional data structure of a table that speeds up the execution \n+of queries. The catalog is used to resolve objects mentioned in the query and choose the proper access method. \n+\n+If the catalog is changed, the plan created earlier might become invalid. For example, if the table is dropped, the execution \n+of the plan will produce an error. If a new index is added, the optimizer may pick a better access path.\n+\n+The plan cache must be able to find and remove plans that have become invalid after changing the catalog. \n+\n+### 1.2 Query\n+\n+The query consists of the query string, the current schema, and parameters. Each of them may influence the optimization result.\n+\n+The current schema affects object resolution. For example, the query `SELECT * FROM map` may refer to `IMap` or `ReplicatedMap`\n+depending on the current schema (`partitioned` or `replicated`). \n+\n+Parameter values may alter statistics derivation and access path selection. For example, `SELECT ... FROM sales WHERE region=?`\n+may have different optimal plans for regions `EMEA` and `APAC`.  \n+ \n+The plan cache must use query content properly to ensure the correctness and efficiency of the query execution.  \n+ \n+### 1.3 Metadata\n+ \n+In the query optimization theory, metadata is external information that is used for optimization. Examples are \n+statistics, column uniqueness, data distribution, etc.\n+\n+In this document, we consider only partition distribution because this is the only metadata we use in our optimizer, \n+that is not part of the catalog, and that could change across query runs.\n+\n+Every plan is built for the specific partition distribution. That is, the distribution and participating members are saved \n+in the plan.\n+\n+The plan cache must be able to find and remove plans with obsolete partition distribution. \n+ \n+## 2. Design\n+\n+### 2.1 Plan Key\n+\n+The plan key is a key used to locate the cache plan. It should be possible to derive the key from the query before the \n+optimization phase. \n+\n+We use the following key:\n+```\n+PlanKey {\n+    List<List<String>> searchPaths;\n+    String sql;\n+}\n+```\n+`searchPaths` is the list of schemas that are used to resolve non-fully qualified objects during query parsing. Search paths\n+are created based on configured table resolvers, and the current schema. `sql` is a query string.   \n+\n+For the same catalog, two queries with the same search paths, and the same query string will always resolve the same objects. \n+On the contrary, the same query string may resolve different objects for different search paths, as shown in section 1.2. \n+Therefore, search paths must be part of the key.  \n+\n+### 2.2 Data Structure\n+\n+We use `ConcurrentHashMap` to store cached plans. `PlanKey` is a key, the plan is a value.\n+ \n+### 2.3 Maximum Size and Plan Eviction\n+\n+The maximum size of the cache is required to prevent out-of-memory if too many distinct queries are submitted.\n+\n+When a plan is added to the map, the map size is checked. If the map size is greater than the maximum size, some plans are \n+evicted. \n+\n+Eviction is synchronous because the asynchronous variant is prone to out-of-memory. We assume that for the most workloads \n+evictions should be rare. \n+\n+We use the LRU (least recently used) approach to find the plans to evict. Whenever a plan is accessed, it's `lastUsed` field is \n+updated with the current time. During the eviction, plans are sorted by their `lastUsed` values, and the least recently used\n+plans are removed.   \n+\n+### 2.4 Reacting to Catalog and Partition Distribution Changes\n+\n+If a catalog or partition distribution is changed, some plans must be invalidated. There are two different ways to achieve \n+this: `push` and `pull`.\n+\n+With the `push` approach, the plan cache is notified about a change, from the relevant component. E.g., if an index is created,\n+then the map service notifies the plan cache about the change. The advantage of this solution is that any change is reflected \n+in the plan cache immediately. However, this approach increases coupling, because many components (map service, \n+replicated map service, partition service) now have to be aware of the SQL subsystem. This approach also requires complex\n+synchronization between query optimizer, plan cache, and dependent components, to ensure that no stale plan is ever cached.\n+\n+With the `pull` approach, the SQL subsystem queries other components periodically, collects the changes, and invalidates \n+affected plans. The advantage of this approach is simplicity. No synchronization or changes to other components are needed. \n+Invalid plans are guaranteed to be removed eventually. The downside is that invalid plans might be active for some time after\n+the change has occurred.\n+\n+We choose the `pull` approach due to simplicity and sufficient guarantees. The background worker reconstructs the catalog \n+periodically, and verifies that existing plans are compatible with the current catalog and partition distribution. \n+\n+To counter the problem with outdated plans, we add a special `invalidatePlan` flag to `QueryException`. If an invalid plan\n+is used, an exception with this flag will be thrown at some point. When the initiator member receives an exception with \n+this flag, the plan is invalidated. \n+\n+Note that currently, users will have to re-execute the query in this case. In future versions, we will add a transparent\n+query retry, so that invalid plans will not be visible to users.    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzYxNTE4", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-465761518", "createdAt": "2020-08-12T09:50:35Z", "commit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo1MDozNVrOG_aJ6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDoyNjowOVrOG_bTGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTk5NQ==", "bodyText": "What is a reasoning behind this default?", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469141995", "createdAt": "2020-08-12T09:50:35Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -51,6 +59,8 @@\n     /** Default state check frequency. */\n     private static final long STATE_CHECK_FREQUENCY = 1_000L;\n \n+    private static final int PLAN_CACHE_SIZE = 10_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NDI3NA==", "bodyText": "What is the reasoning behind magic number 3 ?", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469144274", "createdAt": "2020-08-12T09:54:35Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -242,4 +291,12 @@ private SqlOptimizer createOptimizer(NodeEngine nodeEngine) {\n             throw new HazelcastException(\"Failed to instantiate the optimizer class \" + className + \": \" + e.getMessage(), e);\n         }\n     }\n+\n+    private static List<TableResolver> createTableResolvers(NodeEngine nodeEngine) {\n+        List<TableResolver> res = new ArrayList<>(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0ODQ5NA==", "bodyText": "Javadoc of the interface methods would be helpful.", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469148494", "createdAt": "2020-08-12T10:02:15Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/KeyValueIterator.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+/**\n+ * Iterator over key/value pairs.\n+ */\n+public interface KeyValueIterator {\n+    boolean tryAdvance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NTk4Ng==", "bodyText": "Javadoc", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469155986", "createdAt": "2020-08-12T10:16:53Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/CachedPlanInvalidationCallback.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MDczMA==", "bodyText": "Sorting on every put might be very expensive, have you considered to use ordered concurrent data structure (e.g. ConcurrentSkipListMap) for the cache to avoid this intermediate step?", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469160730", "createdAt": "2020-08-12T10:26:09Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/PlanCache.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Cache for plans.\n+ */\n+public class PlanCache implements CachedPlanInvalidationCallback {\n+\n+    private final int maxSize;\n+    private final ConcurrentHashMap<PlanCacheKey, CacheablePlan> plans = new ConcurrentHashMap<>();\n+\n+    public PlanCache(int maxSize) {\n+        assert maxSize > 0;\n+\n+        this.maxSize = maxSize;\n+    }\n+\n+    public CacheablePlan get(PlanCacheKey key) {\n+        CacheablePlan plan = plans.get(key);\n+\n+        if (plan != null) {\n+            plan.onPlanUsed();\n+\n+            return plan;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public void put(PlanCacheKey key, CacheablePlan plan) {\n+        plans.put(key, plan);\n+\n+        plan.onPlanUsed();\n+\n+        shrinkIfNeeded();\n+    }\n+\n+    public void invalidate(CacheablePlan plan) {\n+        remove(plan);\n+    }\n+\n+    public void clear() {\n+        plans.clear();\n+    }\n+\n+    public int size() {\n+        return plans.size();\n+    }\n+\n+    public void check(PlanCheckContext context) {\n+        plans.values().removeIf(plan -> !plan.isPlanValid(context));\n+    }\n+\n+    private void shrinkIfNeeded() {\n+        int oversize = plans.size() - maxSize;\n+\n+        if (oversize <= 0) {\n+            return;\n+        }\n+\n+        // Sort plans according to their last used timestamps\n+        TreeMap<Long, CacheablePlan> sorted = new TreeMap<>();\n+\n+        for (CacheablePlan plan : plans.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0552acff9adf466547f8961e0ae4c8b53801e7f1", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0552acff9adf466547f8961e0ae4c8b53801e7f1", "committedDate": "2020-08-12T15:33:54Z", "message": "Removed unnecessary magic number."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b1c0712dd7d52f92d1b24e65085a4b6b9e09be5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8b1c0712dd7d52f92d1b24e65085a4b6b9e09be5", "committedDate": "2020-08-12T16:02:09Z", "message": "JavaDoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "906c50142e3e93bf1b84f3c8c9fff7a05d7f5d25", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/906c50142e3e93bf1b84f3c8c9fff7a05d7f5d25", "committedDate": "2020-08-12T16:11:54Z", "message": "Merge branch 'master' into issues/17277\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/CalciteSqlOptimizer.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/OptimizerContext.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/AbstractMapScanExec.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/extract/AbstractGenericExtractor.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/extract/GenericQueryTarget.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/plan/Plan.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlResultImplTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/client/SqlClientResultTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryExecuteOperationFactoryTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/plan/PlanTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/state/QueryInitiatorStateTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be5f78b8654839186e97c07ff8b3c35c7042b18e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/be5f78b8654839186e97c07ff8b3c35c7042b18e", "committedDate": "2020-08-12T16:24:09Z", "message": "Merge with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MTI2NDgy", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-466126482", "createdAt": "2020-08-12T17:29:15Z", "commit": {"oid": "be5f78b8654839186e97c07ff8b3c35c7042b18e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzoyOToxNVrOG_rXeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzoyOToxNVrOG_rXeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQyMzk5Mg==", "bodyText": "A leftover?", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469423992", "createdAt": "2020-08-12T17:29:15Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/KeyValueIterator.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+/**\n+ * Iterator over key/value pairs.\n+ */\n+public interface KeyValueIterator {\n+    /**\n+     * Advances the iterator to the next available record.\n+     * <p>\n+     * If the method has returned {@code true}, the key and the value could be accessed through\n+     * {@link #getKey()} and {@link #getValue()} respectively.\n+     *\n+     * @return {@code} t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be5f78b8654839186e97c07ff8b3c35c7042b18e"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eedc2f63d9d5ce8f0b7402e4dc3644aec4834143", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/eedc2f63d9d5ce8f0b7402e4dc3644aec4834143", "committedDate": "2020-08-13T04:58:39Z", "message": "Do no update read schema if there are no plans."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NTI0OTgz", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-466524983", "createdAt": "2020-08-13T07:53:40Z", "commit": {"oid": "eedc2f63d9d5ce8f0b7402e4dc3644aec4834143"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "132959ef5ffad3e7a225d958ea18759cbdb45054", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/132959ef5ffad3e7a225d958ea18759cbdb45054", "committedDate": "2020-08-13T07:56:20Z", "message": "Minor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzYzMzcy", "url": "https://github.com/hazelcast/hazelcast/pull/17278#pullrequestreview-466763372", "createdAt": "2020-08-13T13:31:39Z", "commit": {"oid": "132959ef5ffad3e7a225d958ea18759cbdb45054"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3469, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}