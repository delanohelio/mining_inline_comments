{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODU1NTg5", "number": 16680, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyNTozNFrODipUbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjoyMjowM1rODirlbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU1MTUwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/graph/BronKerboschCliqueFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyNTozNVrOFuAmyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyNTozNVrOFuAmyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4ODc0Nw==", "bodyText": "Leftover.", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383788747", "createdAt": "2020-02-25T10:25:35Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/graph/BronKerboschCliqueFinder.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+*  Original work Copyright (c) 2005-2020, by Ewgenij Proschak and Contributors.\n+ * Modified work Copyright (c) 2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+public class BronKerboschCliqueFinder<V> {\n+\n+    private final Graph<V> graph;\n+    private final long nanos;\n+    private boolean timeLimitReached;\n+    private List<Set<V>> maximumCliques;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param graph   the input graph; must be simple\n+     * @param timeout the maximum time to wait, if zero no timeout\n+     * @param unit    the time unit of the timeout argument\n+     */\n+    public BronKerboschCliqueFinder(Graph<V> graph, long timeout, TimeUnit unit) {\n+        this.graph = Objects.requireNonNull(graph, \"Graph cannot be null\");\n+        if (timeout == 0L) {\n+            this.nanos = Long.MAX_VALUE;\n+        } else {\n+            this.nanos = unit.toNanos(timeout);\n+        }\n+        if (this.nanos < 1L) {\n+            throw new IllegalArgumentException(\"Invalid timeout, must be positive\");\n+        }\n+        this.timeLimitReached = false;\n+    }\n+\n+    /**\n+     * Constructs a new clique finder.\n+     *\n+     * @param graph the input graph; must be \"simple\".\n+     */\n+    public BronKerboschCliqueFinder(Graph<V> graph) {\n+        this(graph, 0L, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Computes and returns the maximum cliques of the given graph.\n+     *\n+     * @return the maximum cliques of the given graph.\n+     */\n+    public Collection<Set<V>> computeMaxCliques() {\n+        lazyRun();\n+        return maximumCliques;\n+    }\n+\n+    /**\n+     * Check the computation has stopped due to a time limit or due to computing all maximal\n+     * cliques.\n+     *\n+     * @return true if the computation has stopped due to a time limit, false otherwise\n+     */\n+    public boolean isTimeLimitReached() {\n+        return timeLimitReached;\n+    }\n+\n+    /**\n+     * Lazily execute the enumeration algorithm.\n+     */\n+    private void lazyRun() {\n+        if (maximumCliques != null) {\n+            return;\n+        }\n+\n+        maximumCliques = new ArrayList<>();\n+\n+        // [basri] Our Graph impl is already a simple graph.\n+        //            if (!GraphTests.isSimple(graph)) {\n+        //                throw new IllegalArgumentException(\"Graph must be simple\");\n+        //            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU2ODE4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyOTo0OFrOFuAwlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyOTo0OFrOFuAwlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MTI1Mg==", "bodyText": "Can you please add a few comments/javadoc on the class and update(), resolve() methods?", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383791252", "createdAt": "2020-02-25T10:29:48Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.cluster.impl;\n+\n+import com.hazelcast.cluster.impl.MemberImpl;\n+import com.hazelcast.internal.util.graph.BronKerboschCliqueFinder;\n+import com.hazelcast.internal.util.graph.Graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+class PartialDisconnectionHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU3MzgyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozMToyNlrOFuA0Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozMToyNlrOFuA0Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MjEzOQ==", "bodyText": "better to move lock() to outside of try { block...", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383792139", "createdAt": "2020-02-25T10:31:26Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -1200,12 +1242,87 @@ public boolean verifySplitBrainMergeMemberListVersion(SplitBrainJoinMessage join\n         }\n     }\n \n+    void handleReceivedSuspectedMembers(MemberImpl sender, long timestamp, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!validateReceivedSuspectedMembers(sender, suspectedMemberInfos)) {\n+            return;\n+        }\n+\n+        MemberMap memberMap = getMemberMap();\n+        List<MemberImpl> suspectedMembers = suspectedMemberInfos.stream()\n+                                                                .map(m -> memberMap.getMember(m.getAddress(), m.getUuid()))\n+                                                                .filter(Objects::nonNull)\n+                                                                .collect(toList());\n+\n+        if (partialDisconnectionHandler.update(sender, timestamp, suspectedMembers)) {\n+            logger.warning(\"Received suspected members: \" + suspectedMembers + \" from \" + sender);\n+            if (logger.isFineEnabled()) {\n+                for (Entry<MemberImpl, Set<MemberImpl>> e : partialDisconnectionHandler.getDisconnections().entrySet()) {\n+                    logger.fine(e.getKey() + \" is disconnected to: \" + e.getValue());\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean validateReceivedSuspectedMembers(MemberImpl sender, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!partialDisconnectionDetectionEnabled) {\n+            return false;\n+        } else if (!clusterService.isMaster()) {\n+            if (suspectedMemberInfos.size() > 0) {\n+                logger.severe(\"This not is not master but received suspected members: \" + suspectedMemberInfos + \" from \"\n+                        + sender);\n+            }\n+            return false;\n+        } else if (getLocalMember().equals(sender)) {\n+            logger.severe(\"Received suspected members: \" + suspectedMemberInfos + \" from itself.\");\n+            return false;\n+        } else if (suspectedMemberInfos.contains(new MemberInfo(getLocalMember()))) {\n+            logger.severe(\"Received suspected members: \" + suspectedMemberInfos + \" from \" + sender + \" contains this member!\");\n+            return false;\n+        } else if (clusterService.getClusterJoinManager().isMastershipClaimInProgress()) {\n+            if (suspectedMemberInfos.size() > 0 && logger.isFineEnabled()) {\n+                logger.warning(\"Ignoring received suspected members: \" + suspectedMemberInfos + \" from \" + sender\n+                        + \" because mastership claim is in progress...\");\n+            }\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    void checkPartialDisconnectivity(long timestamp) {\n+        if (!partialDisconnectionDetectionEnabled) {\n+            return;\n+        } else if (!clusterService.isMaster()) {\n+            logger.severe(\"Cannot check disconnected members since I am not the master.\");\n+            return;\n+        }\n+\n+        try {\n+            clusterServiceLock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU3OTM5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozMjo0OFrOFuA3Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozMjo0OFrOFuA3Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5Mjk0Mg==", "bodyText": "Are these really severe logs, or can we log them as warning?", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383792942", "createdAt": "2020-02-25T10:32:48Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -1200,12 +1242,87 @@ public boolean verifySplitBrainMergeMemberListVersion(SplitBrainJoinMessage join\n         }\n     }\n \n+    void handleReceivedSuspectedMembers(MemberImpl sender, long timestamp, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!validateReceivedSuspectedMembers(sender, suspectedMemberInfos)) {\n+            return;\n+        }\n+\n+        MemberMap memberMap = getMemberMap();\n+        List<MemberImpl> suspectedMembers = suspectedMemberInfos.stream()\n+                                                                .map(m -> memberMap.getMember(m.getAddress(), m.getUuid()))\n+                                                                .filter(Objects::nonNull)\n+                                                                .collect(toList());\n+\n+        if (partialDisconnectionHandler.update(sender, timestamp, suspectedMembers)) {\n+            logger.warning(\"Received suspected members: \" + suspectedMembers + \" from \" + sender);\n+            if (logger.isFineEnabled()) {\n+                for (Entry<MemberImpl, Set<MemberImpl>> e : partialDisconnectionHandler.getDisconnections().entrySet()) {\n+                    logger.fine(e.getKey() + \" is disconnected to: \" + e.getValue());\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean validateReceivedSuspectedMembers(MemberImpl sender, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!partialDisconnectionDetectionEnabled) {\n+            return false;\n+        } else if (!clusterService.isMaster()) {\n+            if (suspectedMemberInfos.size() > 0) {\n+                logger.severe(\"This not is not master but received suspected members: \" + suspectedMemberInfos + \" from \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 438}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU4NTAwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozNDoyM1rOFuA6jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozNDoyM1rOFuA6jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MzgwNA==", "bodyText": "Can't we make just use Member as parameter, instead of Address and UUID pair?\nclearMemberSuspicion(MemberImpl member, String reason)", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383793804", "createdAt": "2020-02-25T10:34:23Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -456,27 +487,37 @@ void setMembers(MemberMap memberMap) {\n \n     // called under cluster service lock\n     private void retainSuspectedMembers(MemberMap memberMap) {\n-        Iterator<Address> it = suspectedMembers.iterator();\n+        Iterator<MemberImpl> it = suspectedMembers.iterator();\n         while (it.hasNext()) {\n-            Address suspectedAddress = it.next();\n-            if (!memberMap.contains(suspectedAddress)) {\n+            Member suspectedMember = it.next();\n+            if (memberMap.getMember(suspectedMember.getAddress(), suspectedMember.getUuid()) == null) {\n                 if (logger.isFineEnabled()) {\n-                    logger.fine(\"Removing suspected address \" + suspectedAddress + \", it's no longer a member.\");\n+                    logger.fine(\"Removing suspected address \" + suspectedMember.getAddress() + \", it's no longer a member.\");\n                 }\n \n                 it.remove();\n             }\n         }\n     }\n \n-    boolean isMemberSuspected(Address address) {\n-        return suspectedMembers.contains(address);\n+    Collection<MemberImpl> getSuspectedMembers() {\n+        return new HashSet<>(suspectedMembers);\n+    }\n+\n+    boolean isMemberSuspected(Address address, UUID uuid) {\n+        for (MemberImpl suspectedMember : suspectedMembers) {\n+            if (suspectedMember.getAddress().equals(address) && suspectedMember.getUuid().equals(uuid)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n     }\n \n-    boolean clearMemberSuspicion(Address address, String reason) {\n+    boolean clearMemberSuspicion(Address address, UUID uuid, String reason) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU4Njc5OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozNDo1NFrOFuA7og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozNDo1NFrOFuA7og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NDA4Mg==", "bodyText": "Can't we make just use Member as parameter, instead of Address and UUID pair?\nisMemberSuspected(MemberImpl member)", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383794082", "createdAt": "2020-02-25T10:34:54Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -456,27 +487,37 @@ void setMembers(MemberMap memberMap) {\n \n     // called under cluster service lock\n     private void retainSuspectedMembers(MemberMap memberMap) {\n-        Iterator<Address> it = suspectedMembers.iterator();\n+        Iterator<MemberImpl> it = suspectedMembers.iterator();\n         while (it.hasNext()) {\n-            Address suspectedAddress = it.next();\n-            if (!memberMap.contains(suspectedAddress)) {\n+            Member suspectedMember = it.next();\n+            if (memberMap.getMember(suspectedMember.getAddress(), suspectedMember.getUuid()) == null) {\n                 if (logger.isFineEnabled()) {\n-                    logger.fine(\"Removing suspected address \" + suspectedAddress + \", it's no longer a member.\");\n+                    logger.fine(\"Removing suspected address \" + suspectedMember.getAddress() + \", it's no longer a member.\");\n                 }\n \n                 it.remove();\n             }\n         }\n     }\n \n-    boolean isMemberSuspected(Address address) {\n-        return suspectedMembers.contains(address);\n+    Collection<MemberImpl> getSuspectedMembers() {\n+        return new HashSet<>(suspectedMembers);\n+    }\n+\n+    boolean isMemberSuspected(Address address, UUID uuid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU5MzYyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozNjo0NVrOFuA_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzoxNjo0OVrOFugXKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NTEzMQ==", "bodyText": "getMissingMembers() returns mutable collection now?", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383795131", "createdAt": "2020-02-25T10:36:45Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -986,7 +1029,7 @@ MemberImpl getMissingMember(Address address, UUID uuid) {\n      * Returns all missing members.\n      */\n     Collection<MemberImpl> getMissingMembers() {\n-        return Collections.unmodifiableCollection(missingMembersRef.get().values());\n+        return missingMembersRef.get().values();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwMzgzOA==", "bodyText": "we always set immutable map to it. So I removed the immutable decoration here.", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r384303838", "createdAt": "2020-02-26T06:59:06Z", "author": {"login": "metanet"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -986,7 +1029,7 @@ MemberImpl getMissingMember(Address address, UUID uuid) {\n      * Returns all missing members.\n      */\n     Collection<MemberImpl> getMissingMembers() {\n-        return Collections.unmodifiableCollection(missingMembersRef.get().values());\n+        return missingMembersRef.get().values();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NTEzMQ=="}, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwOTAzNQ==", "bodyText": "ah I got it... \ud83e\udd26\u200d\u2642", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r384309035", "createdAt": "2020-02-26T07:16:49Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -986,7 +1029,7 @@ MemberImpl getMissingMember(Address address, UUID uuid) {\n      * Returns all missing members.\n      */\n     Collection<MemberImpl> getMissingMembers() {\n-        return Collections.unmodifiableCollection(missingMembersRef.get().values());\n+        return missingMembersRef.get().values();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NTEzMQ=="}, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 394}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjYwOTc0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDo0MTowNlrOFuBJBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDo0MTowNlrOFuBJBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NzUwOQ==", "bodyText": "Is this really an illegal state: IllegalStateException ?  maybe something like TimeoutException would be better..", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383797509", "createdAt": "2020-02-25T10:41:06Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.cluster.impl;\n+\n+import com.hazelcast.cluster.impl.MemberImpl;\n+import com.hazelcast.internal.util.graph.BronKerboschCliqueFinder;\n+import com.hazelcast.internal.util.graph.Graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+class PartialDisconnectionHandler {\n+    private final long detectionIntervalMs;\n+    private final long algorithmTimeoutMs;\n+    private Map<MemberImpl, Set<MemberImpl>> disconnections = new HashMap<>();\n+    private long lastUpdated;\n+\n+    PartialDisconnectionHandler(long detectionIntervalMs, long algorithmTimeoutMs) {\n+        this.detectionIntervalMs = detectionIntervalMs;\n+        this.algorithmTimeoutMs = algorithmTimeoutMs;\n+    }\n+\n+    boolean update(MemberImpl member, long timestamp, Collection<MemberImpl> disconnectedMembers) {\n+        if (timestamp < lastUpdated) {\n+            return false;\n+        }\n+\n+        Set<MemberImpl> currentDisconnectedMembers =  disconnections.get(member);\n+        if (currentDisconnectedMembers == null) {\n+            if (disconnectedMembers.isEmpty()) {\n+                return false;\n+            }\n+\n+            currentDisconnectedMembers = new HashSet<>();\n+            disconnections.put(member, currentDisconnectedMembers);\n+        }\n+\n+        boolean updated = false;\n+\n+        for (MemberImpl disconnectedMember : disconnectedMembers) {\n+            if (currentDisconnectedMembers.add(disconnectedMember)\n+                    && !disconnections.getOrDefault(disconnectedMember, emptySet()).contains(member)) {\n+                lastUpdated = timestamp;\n+                updated = true;\n+            }\n+        }\n+\n+        if (currentDisconnectedMembers.retainAll(disconnectedMembers)) {\n+            lastUpdated = timestamp;\n+            updated = true;\n+        }\n+\n+        if (currentDisconnectedMembers.isEmpty()) {\n+            disconnections.remove(member);\n+        }\n+\n+        return updated;\n+    }\n+\n+    boolean shouldResolvePartialDisconnections(long timestamp) {\n+        return !disconnections.isEmpty() && timestamp - lastUpdated >= detectionIntervalMs;\n+    }\n+\n+    Collection<MemberImpl> resolve(Map<MemberImpl, Set<MemberImpl>> disconnections) {\n+        Set<MemberImpl> members = new HashSet<>();\n+        disconnections.forEach((k, v) -> {\n+            members.add(k);\n+            members.addAll(v);\n+        });\n+\n+        Graph<MemberImpl> connectivityGraph = buildConnectionGraph(members, disconnections);\n+        BronKerboschCliqueFinder<MemberImpl> cliqueFinder = createCliqueFinder(connectivityGraph);\n+        Collection<Set<MemberImpl>> maxCliques = cliqueFinder.computeMaxCliques();\n+\n+        if (cliqueFinder.isTimeLimitReached()) {\n+            throw new IllegalStateException(\"Partial disconnection resolution algorithm timed out! disconnectivity map: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjYxOTIzOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDo0MzozNlrOFuBOlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDo0MzozNlrOFuBOlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5ODkzMg==", "bodyText": "Shouldn't we filter out algorithm timeout? Due to my understanding, this is not always a severe failure...", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383798932", "createdAt": "2020-02-25T10:43:36Z", "author": {"login": "mdogan"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -1268,5 +1385,48 @@ private void innerRun() {\n             }\n         }\n     }\n+\n+    private class ResolvePartialDisconnectionsTask\n+            implements Runnable {\n+\n+        final Map<MemberImpl, Set<MemberImpl>> disconnections;\n+\n+        ResolvePartialDisconnectionsTask(Map<MemberImpl, Set<MemberImpl>> disconnections) {\n+            this.disconnections = disconnections;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Collection<MemberImpl> membersToRemove = partialDisconnectionHandler.resolve(disconnections);\n+                clusterServiceLock.lock();\n+                try {\n+                    for (MemberImpl member : membersToRemove) {\n+                        if (getMember(member.getAddress(), member.getUuid()) == null) {\n+                            logger.warning(\"Won't remove partially disconnected members: \" + membersToRemove);\n+                            return;\n+                        }\n+                    }\n+\n+                    for (MemberImpl member : membersToRemove) {\n+                        String reason = format(\"Removing %s because it has disconnected from some of the members!\", member);\n+                        logger.warning(reason);\n+                        suspectMember(member, reason, true);\n+                    }\n+                } finally {\n+                    clusterServiceLock.unlock();\n+                }\n+            } catch (Exception e) {\n+                logger.severe(\"Partial disconnection resolution algorithm failed.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 554}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjgyMTU2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTo0NzowN1rOFuDHxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODoyMDo1NVrOFuhxYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyOTk1Ng==", "bodyText": "Is it legitimate to see null master here? if yes, this change can lead NPE.", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383829956", "createdAt": "2020-02-25T11:47:07Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -274,14 +282,14 @@ private void onInvalidHeartbeat(MembersViewMetadata senderMembersViewMetadata) {\n                 clusterService.sendExplicitSuspicion(senderMembersViewMetadata);\n             }\n         } else {\n-            Address masterAddress = clusterService.getMasterAddress();\n-            if (clusterService.getMembershipManager().isMemberSuspected(masterAddress)) {\n+            MemberImpl master = clusterService.getMember(clusterService.getMasterAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMjEyOA==", "bodyText": "this method is called under the cluster service lock when the member has joined to the cluster. Because if this, master cannot be null here I think.", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r384332128", "createdAt": "2020-02-26T08:20:55Z", "author": {"login": "metanet"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -274,14 +282,14 @@ private void onInvalidHeartbeat(MembersViewMetadata senderMembersViewMetadata) {\n                 clusterService.sendExplicitSuspicion(senderMembersViewMetadata);\n             }\n         } else {\n-            Address masterAddress = clusterService.getMasterAddress();\n-            if (clusterService.getMembershipManager().isMemberSuspected(masterAddress)) {\n+            MemberImpl master = clusterService.getMember(clusterService.getMasterAddress());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyOTk1Ng=="}, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjgzNzAyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTo1Mjo0MlrOFuDRNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTo1Mjo0MlrOFuDRNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzMjM3NA==", "bodyText": "minor:\ncan be rewritten without else:\nCollection<MemberInfo> suspectedMembers = Collections.emptySet();\nif (clusterService.getMembershipManager().isPartialDisconnectionDetectionEnabled()\n                    && !clusterService.isMaster() && target.getAddress().equals(clusterService.getMasterAddress())) {\n                suspectedMembers = clusterService.getMembershipManager()\n                        .getSuspectedMembers()\n                        .stream()\n                        .map(MemberInfo::new)\n                        .collect(toSet());\n}", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383832374", "createdAt": "2020-02-25T11:52:42Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -610,7 +618,20 @@ private void sendHeartbeat(Member target) {\n         }\n         try {\n             MembersViewMetadata membersViewMetadata = clusterService.getMembershipManager().createLocalMembersViewMetadata();\n-            Operation op = new HeartbeatOp(membersViewMetadata, target.getUuid(), clusterClock.getClusterTime());\n+            Collection<MemberInfo> suspectedMembers;\n+            if (clusterService.getMembershipManager().isPartialDisconnectionDetectionEnabled()\n+                    && !clusterService.isMaster() && target.getAddress().equals(clusterService.getMasterAddress())) {\n+                suspectedMembers = clusterService.getMembershipManager()\n+                                                 .getSuspectedMembers()\n+                                                 .stream()\n+                                                 .map(MemberInfo::new)\n+                                                 .collect(toSet());\n+            } else {\n+                suspectedMembers = Collections.emptySet();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Njg3ODczOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjowNjo1M1rOFuDp-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjowNjo1M1rOFuDp-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzODcxNQ==", "bodyText": "Type of currentDisconnectedMembers  is a Set, as i understand it is because same MemberImpl can be added multiple times?", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383838715", "createdAt": "2020-02-25T12:06:53Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.cluster.impl;\n+\n+import com.hazelcast.cluster.impl.MemberImpl;\n+import com.hazelcast.internal.util.graph.BronKerboschCliqueFinder;\n+import com.hazelcast.internal.util.graph.Graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+class PartialDisconnectionHandler {\n+    private final long detectionIntervalMs;\n+    private final long algorithmTimeoutMs;\n+    private Map<MemberImpl, Set<MemberImpl>> disconnections = new HashMap<>();\n+    private long lastUpdated;\n+\n+    PartialDisconnectionHandler(long detectionIntervalMs, long algorithmTimeoutMs) {\n+        this.detectionIntervalMs = detectionIntervalMs;\n+        this.algorithmTimeoutMs = algorithmTimeoutMs;\n+    }\n+\n+    boolean update(MemberImpl member, long timestamp, Collection<MemberImpl> disconnectedMembers) {\n+        if (timestamp < lastUpdated) {\n+            return false;\n+        }\n+\n+        Set<MemberImpl> currentDisconnectedMembers =  disconnections.get(member);\n+        if (currentDisconnectedMembers == null) {\n+            if (disconnectedMembers.isEmpty()) {\n+                return false;\n+            }\n+\n+            currentDisconnectedMembers = new HashSet<>();\n+            disconnections.put(member, currentDisconnectedMembers);\n+        }\n+\n+        boolean updated = false;\n+\n+        for (MemberImpl disconnectedMember : disconnectedMembers) {\n+            if (currentDisconnectedMembers.add(disconnectedMember)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Njg4MzI1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjowODoyMlrOFuDskQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjowODoyMlrOFuDskQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzOTM3Nw==", "bodyText": "can you please add javaDoc for returned boolean?", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383839377", "createdAt": "2020-02-25T12:08:22Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -371,9 +379,9 @@ public void handleHeartbeatComplaint(MembersViewMetadata receiverMVMetadata, Mem\n      * @param member    the member sending the heartbeat\n      * @param timestamp the timestamp when the heartbeat was created\n      */\n-    public void onHeartbeat(MemberImpl member, long timestamp) {\n+    public boolean onHeartbeat(MemberImpl member, long timestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjkxMjc0OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjoxODozOFrOFuD-FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjoxODozOFrOFuD-FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0Mzg2MA==", "bodyText": "Can we encapsulate these prop readings into PartialDisconnectionHandler to increase isolation?", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383843860", "createdAt": "2020-02-25T12:18:38Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -112,7 +125,25 @@\n         this.nodeEngine = node.getNodeEngine();\n         this.logger = node.getLogger(getClass());\n \n-        mastershipClaimTimeoutSeconds = node.getProperties().getInteger(MASTERSHIP_CLAIM_TIMEOUT_SECONDS);\n+        this.mastershipClaimTimeoutSeconds = node.getProperties().getInteger(MASTERSHIP_CLAIM_TIMEOUT_SECONDS);\n+\n+        int partialDisconnectionResolutionHeartbeatCount = node.getProperties().getInteger(\n+                PARTIAL_MEMBER_DISCONNECTION_RESOLUTION_HEARTBEAT_COUNT);\n+        this.partialDisconnectionDetectionEnabled = partialDisconnectionResolutionHeartbeatCount > 0;\n+        long heartbeatIntervalMs = SECONDS.toMillis(node.getProperties().getInteger(HEARTBEAT_INTERVAL_SECONDS));\n+        long partialDisconnectivityDetectionIntervalMs =\n+                partialDisconnectionResolutionHeartbeatCount * heartbeatIntervalMs;\n+        long heartbeatTimeoutMs = SECONDS.toMillis(node.getProperties().getInteger(MAX_NO_HEARTBEAT_SECONDS));\n+\n+        if (!partialDisconnectionDetectionEnabled) {\n+            partialDisconnectivityDetectionIntervalMs = Long.MAX_VALUE;\n+        } else if (heartbeatTimeoutMs < partialDisconnectivityDetectionIntervalMs) {\n+            partialDisconnectivityDetectionIntervalMs = heartbeatTimeoutMs;\n+        }\n+\n+        this.partialDisconnectionHandler = new PartialDisconnectionHandler(partialDisconnectivityDetectionIntervalMs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjkyMjcwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/graph/BronKerboschCliqueFinder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjoyMjowM1rOFuEEBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjoyMjowM1rOFuEEBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0NTM4MA==", "bodyText": "timeout zero seems a special value for infinity, if it is possible to eliminate it, code may be clearer.", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383845380", "createdAt": "2020-02-25T12:22:03Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/internal/util/graph/BronKerboschCliqueFinder.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+*  Original work Copyright (c) 2005-2020, by Ewgenij Proschak and Contributors.\n+ * Modified work Copyright (c) 2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+public class BronKerboschCliqueFinder<V> {\n+\n+    private final Graph<V> graph;\n+    private final long nanos;\n+    private boolean timeLimitReached;\n+    private List<Set<V>> maximumCliques;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param graph   the input graph; must be simple\n+     * @param timeout the maximum time to wait, if zero no timeout\n+     * @param unit    the time unit of the timeout argument\n+     */\n+    public BronKerboschCliqueFinder(Graph<V> graph, long timeout, TimeUnit unit) {\n+        this.graph = Objects.requireNonNull(graph, \"Graph cannot be null\");\n+        if (timeout == 0L) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 702, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}