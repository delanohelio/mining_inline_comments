{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNzE4NDYy", "number": 17977, "title": "Introduce Per Config Record Creation ", "bodyText": "EE: hazelcast/hazelcast-enterprise#3887", "createdAt": "2020-12-15T21:03:49Z", "url": "https://github.com/hazelcast/hazelcast/pull/17977", "merged": true, "mergeCommit": {"oid": "2b3db74d0e11861f4f03789b069d91cfefc78387"}, "closed": true, "closedAt": "2021-02-04T10:34:21Z", "author": {"login": "ahmetmircik"}, "timelineItems": {"totalCount": 95, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmtCl5gBqjQxMTkxNTg4NjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd2wwKsAFqTU4MzE0NTQ4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5e464b14c60f06dde8484001691efc74de6dee5", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e5e464b14c60f06dde8484001691efc74de6dee5", "committedDate": "2020-12-15T20:59:41Z", "message": "wip checlstyle"}, "afterCommit": {"oid": "fc278947247684c16fd96ee30e4136206f861627", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fc278947247684c16fd96ee30e4136206f861627", "committedDate": "2020-12-16T11:14:43Z", "message": "test fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f64f48f5431b42716cf8e37efacdcafb7c615998", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f64f48f5431b42716cf8e37efacdcafb7c615998", "committedDate": "2020-12-16T14:34:11Z", "message": "test fix 2"}, "afterCommit": {"oid": "7249783288084e242974dcb16fda88834d52dd6f", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7249783288084e242974dcb16fda88834d52dd6f", "committedDate": "2020-12-24T08:43:46Z", "message": "test fix 2"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4131ac75648876fd2dc63980f7982f65a93a99f4", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4131ac75648876fd2dc63980f7982f65a93a99f4", "committedDate": "2020-12-24T09:39:05Z", "message": "remove key createRecord"}, "afterCommit": {"oid": "6b86ffa57b64b99a230a9749abd434f71e469210", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6b86ffa57b64b99a230a9749abd434f71e469210", "committedDate": "2020-12-28T10:02:25Z", "message": "remove key createRecord"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33239ce24e5b2ba6db810caf426a30a9c410b9c1", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/33239ce24e5b2ba6db810caf426a30a9c410b9c1", "committedDate": "2021-01-01T21:43:28Z", "message": "hdmap stress test related fixes, onshutdown, on destroy etc."}, "afterCommit": {"oid": "4dfa1f732248af866b4f7667c47549723b57ad17", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4dfa1f732248af866b4f7667c47549723b57ad17", "committedDate": "2021-01-04T10:11:16Z", "message": "polish"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab5ac5c48a239870bce28f55a4f11470bf3c8df4", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ab5ac5c48a239870bce28f55a4f11470bf3c8df4", "committedDate": "2021-01-04T21:07:12Z", "message": "fix failed tests 2"}, "afterCommit": {"oid": "f00a535bf7dcdc562a16c1c532369e343e46cdc8", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f00a535bf7dcdc562a16c1c532369e343e46cdc8", "committedDate": "2021-01-05T11:17:00Z", "message": "remove old record impl except withStats extensions\n- add object header to entry costs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d21092a52081dc1b80bee9a1b5d4a3983fb25e4", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3d21092a52081dc1b80bee9a1b5d4a3983fb25e4", "committedDate": "2021-01-05T14:30:11Z", "message": "fix failed tests 2"}, "afterCommit": {"oid": "9a33c375b67e06bad04f0bbc9840008747a0fe0e", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9a33c375b67e06bad04f0bbc9840008747a0fe0e", "committedDate": "2021-01-06T11:09:18Z", "message": "remove unneeded stats update from records"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97088a9f54d74397b3e7b4a9daa4a8c65c3fdfb0", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/97088a9f54d74397b3e7b4a9daa4a8c65c3fdfb0", "committedDate": "2021-01-06T11:36:42Z", "message": "checkstyle"}, "afterCommit": {"oid": "05a2d6952c771881fb06b05284c868a25ca0ffc0", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/05a2d6952c771881fb06b05284c868a25ca0ffc0", "committedDate": "2021-01-07T13:51:12Z", "message": "Object2ObjectHashMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ccc256f799ed9e2fc09568e17e68084e0d66fff", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8ccc256f799ed9e2fc09568e17e68084e0d66fff", "committedDate": "2021-01-07T15:24:05Z", "message": "Remove serializable from Object2ObjMap"}, "afterCommit": {"oid": "a21cbc4351bfbbc27384c76b5b8caec7556fdebe", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a21cbc4351bfbbc27384c76b5b8caec7556fdebe", "committedDate": "2021-01-07T16:00:00Z", "message": "Remove serializable from Object2ObjMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3dab17a94f3a3dafdccb0ccaac9d22ffe8314f93", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3dab17a94f3a3dafdccb0ccaac9d22ffe8314f93", "committedDate": "2021-01-07T22:35:18Z", "message": "fix check style"}, "afterCommit": {"oid": "e430b42a831b868405d818e1e88e476d097a114a", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e430b42a831b868405d818e1e88e476d097a114a", "committedDate": "2021-01-09T19:28:57Z", "message": "improvements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6951ef9f4b9e827140675728f883c824e5e7c896", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6951ef9f4b9e827140675728f883c824e5e7c896", "committedDate": "2021-01-10T15:08:29Z", "message": "polish"}, "afterCommit": {"oid": "d99ee5924d67c26fb662fbaad4072dec445f7213", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d99ee5924d67c26fb662fbaad4072dec445f7213", "committedDate": "2021-01-15T11:15:01Z", "message": "polish"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d99ee5924d67c26fb662fbaad4072dec445f7213", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d99ee5924d67c26fb662fbaad4072dec445f7213", "committedDate": "2021-01-15T11:15:01Z", "message": "polish"}, "afterCommit": {"oid": "0eae15379f564a482774fa5b793157e64e44c9e1", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0eae15379f564a482774fa5b793157e64e44c9e1", "committedDate": "2021-01-15T13:52:12Z", "message": "desrease test run time"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0eae15379f564a482774fa5b793157e64e44c9e1", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0eae15379f564a482774fa5b793157e64e44c9e1", "committedDate": "2021-01-15T13:52:12Z", "message": "desrease test run time"}, "afterCommit": {"oid": "c48608a7db954e49e85ff1478ad31a53e18cc52b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c48608a7db954e49e85ff1478ad31a53e18cc52b", "committedDate": "2021-01-20T14:18:24Z", "message": "Restrore CHM iterator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c48608a7db954e49e85ff1478ad31a53e18cc52b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c48608a7db954e49e85ff1478ad31a53e18cc52b", "committedDate": "2021-01-20T14:18:24Z", "message": "Restrore CHM iterator"}, "afterCommit": {"oid": "acbfa570fd63889d98795221a7f24c3e496f7c75", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/acbfa570fd63889d98795221a7f24c3e496f7c75", "committedDate": "2021-01-21T18:46:48Z", "message": "Restrore CHM iterator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0e1a49ae83e8fe2a05d2d7dfb7e800876777b98", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e0e1a49ae83e8fe2a05d2d7dfb7e800876777b98", "committedDate": "2021-01-22T14:35:31Z", "message": "Polishing 4"}, "afterCommit": {"oid": "ca48a0db87fcdf94704a1ac073ee53669b0e6948", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ca48a0db87fcdf94704a1ac073ee53669b0e6948", "committedDate": "2021-01-22T15:22:25Z", "message": "Polishing 4"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96e4341cab89ec4ee3e6f81a8d7b35513b96d980", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/96e4341cab89ec4ee3e6f81a8d7b35513b96d980", "committedDate": "2021-01-22T22:20:04Z", "message": "Address TODO"}, "afterCommit": {"oid": "7148595cdecab4737f70815dca139c0773366126", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7148595cdecab4737f70815dca139c0773366126", "committedDate": "2021-01-23T10:23:36Z", "message": "perf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3b3916dc4671473b86982e14b69d3174cdf3ee4", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a3b3916dc4671473b86982e14b69d3174cdf3ee4", "committedDate": "2021-01-23T12:48:00Z", "message": "fix test"}, "afterCommit": {"oid": "9184f00c7ce33b70d1e8ad62264e3188641c3b5c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9184f00c7ce33b70d1e8ad62264e3188641c3b5c", "committedDate": "2021-01-25T11:54:34Z", "message": "Polishing 5"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9184f00c7ce33b70d1e8ad62264e3188641c3b5c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9184f00c7ce33b70d1e8ad62264e3188641c3b5c", "committedDate": "2021-01-25T11:54:34Z", "message": "Polishing 5"}, "afterCommit": {"oid": "c165ad5d7867d2930c3e5ea5eba5bee0d50c0f10", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c165ad5d7867d2930c3e5ea5eba5bee0d50c0f10", "committedDate": "2021-01-26T12:02:08Z", "message": "factory ifelse"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c165ad5d7867d2930c3e5ea5eba5bee0d50c0f10", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c165ad5d7867d2930c3e5ea5eba5bee0d50c0f10", "committedDate": "2021-01-26T12:02:08Z", "message": "factory ifelse"}, "afterCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b09caaaae8cbe09328786ff450e042f29decae55", "committedDate": "2021-01-27T09:08:00Z", "message": "factory ifelse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NDg0NjU0", "url": "https://github.com/hazelcast/hazelcast/pull/17977#pullrequestreview-577484654", "createdAt": "2021-01-27T15:51:22Z", "commit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxNTo1MToyM1rOIbOlJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQwMDoyMzo0NFrOIbhtlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQyMTM0OQ==", "bodyText": "How can it be negative? Or is it just a sanity check?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565421349", "createdAt": "2021-01-27T15:51:23Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/ExpirationTimeSetter.java", "diffHunk": "@@ -31,81 +28,15 @@\n     private ExpirationTimeSetter() {\n     }\n \n-    /**\n-     * Sets expiration time if statistics are enabled.\n-     */\n-    public static void setExpirationTime(Record record) {\n-        long expirationTime = calculateExpirationTime(record);\n-        record.setExpirationTime(expirationTime);\n-    }\n-\n-    private static long calculateExpirationTime(Record record) {\n-        // calculate TTL expiration time\n-        long ttl = checkedTime(record.getTtl());\n-        long ttlExpirationTime = sumForExpiration(ttl, getLifeStartTime(record));\n-\n-        // calculate MaxIdle expiration time\n-        long maxIdle = checkedTime(record.getMaxIdle());\n-        long maxIdleExpirationTime = sumForExpiration(maxIdle, getIdlenessStartTime(record));\n+    public static long calculateExpirationTime(long ttlMillis, long maxIdleMillis, long now) {\n         // select most nearest expiration time\n-        return Math.min(ttlExpirationTime, maxIdleExpirationTime);\n-    }\n-\n-    /**\n-     * Returns last-access-time of an entry if it was accessed before, otherwise it returns creation-time of the entry.\n-     * This calculation is required for max-idle-seconds expiration, because after first creation of an entry via\n-     * {@link IMap#put}, the {@code lastAccessTime} is zero till the first access.\n-     * Any subsequent get or update operation after first put will increase the {@code lastAccessTime}.\n-     */\n-    public static long getIdlenessStartTime(Record record) {\n-        long lastAccessTime = record.getLastAccessTime();\n-        return lastAccessTime <= 0 ? record.getCreationTime() : lastAccessTime;\n-    }\n-\n-    /**\n-     * Returns last-update-time of an entry if it was updated before, otherwise it returns creation-time of the entry.\n-     * This calculation is required for time-to-live expiration, because after first creation of an entry via\n-     * {@link IMap#put}, the {@code lastUpdateTime} is zero till the first update.\n-     */\n-    public static long getLifeStartTime(Record record) {\n-        long lastUpdateTime = record.getLastUpdateTime();\n-        return lastUpdateTime <= 0 ? record.getCreationTime() : lastUpdateTime;\n-    }\n-\n-    private static long checkedTime(long time) {\n-        return time <= 0 ? Long.MAX_VALUE : time;\n-    }\n-\n-    private static long sumForExpiration(long criteriaTime, long now) {\n-        if (criteriaTime < 0 || now < 0) {\n-            throw new IllegalArgumentException(\"Parameters can not have negative values\");\n+        long expiryTime = Math.min(ttlMillis, maxIdleMillis);\n+        if (expiryTime == Long.MAX_VALUE) {\n+            return expiryTime;\n+        } else {\n+            long nextExpiryTime = expiryTime + now;\n+            return nextExpiryTime <= 0 ? Long.MAX_VALUE : nextExpiryTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4NDM3Nw==", "bodyText": "Is it safe to remove the canEvictRecord check? It seems it was protecting against removing an evicted but then readded entry on the backups.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565484377", "createdAt": "2021-01-27T17:11:22Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/EvictBatchBackupOperation.java", "diffHunk": "@@ -63,11 +62,7 @@ protected void runInternal() {\n         }\n \n         for (ExpiredKey expiredKey : expiredKeys) {\n-            Data key = expiredKey.getKey();\n-            Record existingRecord = recordStore.getRecord(key);\n-            if (canEvictRecord(existingRecord, expiredKey)) {\n-                recordStore.evict(key, true);\n-            }\n+            recordStore.evict(expiredKey.getKey(), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4ODc1OA==", "bodyText": "What's the reason for removing the size check? Or what was the reason for it? \ud83d\ude04 It was just a shortcut we don't need anymore?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565488758", "createdAt": "2021-01-27T17:17:31Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/MapClearExpiredOperation.java", "diffHunk": "@@ -62,9 +62,10 @@ public void run() throws Exception {\n         PartitionContainer partitionContainer = mapServiceContext.getPartitionContainer(getPartitionId());\n         ConcurrentMap<String, RecordStore> recordStores = partitionContainer.getMaps();\n         boolean backup = !isOwner();\n+        long now = Clock.currentTimeMillis();\n         for (RecordStore recordStore : recordStores.values()) {\n-            if (recordStore.size() > 0 && recordStore.isExpirable()) {\n-                recordStore.evictExpiredEntries(expirationPercentage, backup);\n+            if (recordStore.isExpirable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYyMzg4NA==", "bodyText": "Not sure an int fits here well. I think we can overflow with a long-living, frequently updated entry.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565623884", "createdAt": "2021-01-27T20:49:55Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/AbstractRecord.java", "diffHunk": "@@ -16,63 +16,45 @@\n \n package com.hazelcast.map.impl.record;\n \n-import com.hazelcast.query.impl.Metadata;\n import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n-import java.util.Objects;\n-\n import static com.hazelcast.internal.nio.Bits.INT_SIZE_IN_BYTES;\n-import static com.hazelcast.internal.nio.Bits.LONG_SIZE_IN_BYTES;\n-import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_READER_WRITER;\n+import static com.hazelcast.internal.util.JVMUtil.OBJECT_HEADER_SIZE;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_WITH_STATS_READER_WRITER;\n \n /**\n  * @param <V> the type of the value of Record.\n  */\n @SuppressWarnings({\"checkstyle:methodcount\", \"VolatileLongOrDoubleField\"})\n public abstract class AbstractRecord<V> implements Record<V> {\n \n-    private static final int NUMBER_OF_LONGS = 1;\n     private static final int NUMBER_OF_INTS = 6;\n \n-    protected int ttl;\n-    protected int maxIdle;\n-    protected long version;\n-\n+    protected int version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzNjY5Mg==", "bodyText": "This if is redundant.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565636692", "createdAt": "2021-01-27T21:12:51Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/DataRecordFactory.java", "diffHunk": "@@ -17,31 +17,88 @@\n package com.hazelcast.map.impl.record;\n \n import com.hazelcast.config.CacheDeserializedValues;\n+import com.hazelcast.config.EvictionPolicy;\n import com.hazelcast.config.MapConfig;\n-import com.hazelcast.internal.serialization.SerializationService;\n import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.MapContainer;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.map.impl.eviction.Evictor.NULL_EVICTOR;\n \n public class DataRecordFactory implements RecordFactory<Data> {\n \n-    private final boolean statisticsEnabled;\n+    private final MapContainer mapContainer;\n     private final SerializationService ss;\n-    private final CacheDeserializedValues cacheDeserializedValues;\n \n-    public DataRecordFactory(MapConfig config, SerializationService ss) {\n+    public DataRecordFactory(MapContainer mapContainer, SerializationService ss) {\n         this.ss = ss;\n-        this.statisticsEnabled = config.isStatisticsEnabled();\n-        this.cacheDeserializedValues = config.getCacheDeserializedValues();\n+        this.mapContainer = mapContainer;\n     }\n \n     @Override\n     public Record<Data> newRecord(Object value) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        boolean statisticsEnabled = mapConfig.isStatisticsEnabled();\n+        CacheDeserializedValues cacheDeserializedValues = mapConfig.getCacheDeserializedValues();\n+        boolean hasEviction = mapContainer.getEvictor() != NULL_EVICTOR;\n+\n         Data valueData = ss.toData(value);\n \n         switch (cacheDeserializedValues) {\n             case NEVER:\n-                return statisticsEnabled ? new DataRecordWithStats(valueData) : new DataRecord(valueData);\n+                return newSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n             default:\n-                return statisticsEnabled ? new CachedDataRecordWithStats(valueData) : new CachedDataRecord(valueData);\n+                return newCachedSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n+        }\n+    }\n+\n+    @Nonnull\n+    private Record<Data> newCachedSimpleRecord(Data valueData, MapConfig mapConfig,\n+                                               boolean statisticsEnabled, boolean hasEviction) {\n+        if (!statisticsEnabled && !hasEviction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzNjk3NQ==", "bodyText": "Same redundancy here.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565636975", "createdAt": "2021-01-27T21:13:22Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/DataRecordFactory.java", "diffHunk": "@@ -17,31 +17,88 @@\n package com.hazelcast.map.impl.record;\n \n import com.hazelcast.config.CacheDeserializedValues;\n+import com.hazelcast.config.EvictionPolicy;\n import com.hazelcast.config.MapConfig;\n-import com.hazelcast.internal.serialization.SerializationService;\n import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.MapContainer;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.map.impl.eviction.Evictor.NULL_EVICTOR;\n \n public class DataRecordFactory implements RecordFactory<Data> {\n \n-    private final boolean statisticsEnabled;\n+    private final MapContainer mapContainer;\n     private final SerializationService ss;\n-    private final CacheDeserializedValues cacheDeserializedValues;\n \n-    public DataRecordFactory(MapConfig config, SerializationService ss) {\n+    public DataRecordFactory(MapContainer mapContainer, SerializationService ss) {\n         this.ss = ss;\n-        this.statisticsEnabled = config.isStatisticsEnabled();\n-        this.cacheDeserializedValues = config.getCacheDeserializedValues();\n+        this.mapContainer = mapContainer;\n     }\n \n     @Override\n     public Record<Data> newRecord(Object value) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        boolean statisticsEnabled = mapConfig.isStatisticsEnabled();\n+        CacheDeserializedValues cacheDeserializedValues = mapConfig.getCacheDeserializedValues();\n+        boolean hasEviction = mapContainer.getEvictor() != NULL_EVICTOR;\n+\n         Data valueData = ss.toData(value);\n \n         switch (cacheDeserializedValues) {\n             case NEVER:\n-                return statisticsEnabled ? new DataRecordWithStats(valueData) : new DataRecord(valueData);\n+                return newSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n             default:\n-                return statisticsEnabled ? new CachedDataRecordWithStats(valueData) : new CachedDataRecord(valueData);\n+                return newCachedSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n+        }\n+    }\n+\n+    @Nonnull\n+    private Record<Data> newCachedSimpleRecord(Data valueData, MapConfig mapConfig,\n+                                               boolean statisticsEnabled, boolean hasEviction) {\n+        if (!statisticsEnabled && !hasEviction) {\n+            return new CachedSimpleRecord(valueData);\n+        }\n+\n+        if (statisticsEnabled) {\n+            return new CachedDataRecordWithStats(valueData);\n         }\n+\n+        if (hasEviction) {\n+            if (mapConfig.getEvictionConfig().getEvictionPolicy() == EvictionPolicy.LRU) {\n+                return new CachedSimpleRecordWithLRUEviction(valueData);\n+            }\n+\n+            if (mapConfig.getEvictionConfig().getEvictionPolicy() == EvictionPolicy.LFU) {\n+                return new CachedSimpleRecordWithLFUEviction(valueData);\n+            }\n+        }\n+\n+        return new CachedSimpleRecord(valueData);\n+    }\n+\n+    @Nonnull\n+    private Record<Data> newSimpleRecord(Data valueData, MapConfig mapConfig,\n+                                         boolean statisticsEnabled, boolean hasEviction) {\n+        if (!statisticsEnabled && !hasEviction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzOTIzNg==", "bodyText": "Redundant if.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565639236", "createdAt": "2021-01-27T21:17:06Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/ObjectRecordFactory.java", "diffHunk": "@@ -16,25 +16,58 @@\n \n package com.hazelcast.map.impl.record;\n \n+import com.hazelcast.config.EvictionPolicy;\n import com.hazelcast.config.MapConfig;\n import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.MapContainer;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.map.impl.eviction.Evictor.NULL_EVICTOR;\n \n public class ObjectRecordFactory implements RecordFactory<Object> {\n \n-    private final boolean statisticsEnabled;\n+    private final MapContainer mapContainer;\n     private final SerializationService serializationService;\n \n-    public ObjectRecordFactory(MapConfig config,\n+    public ObjectRecordFactory(MapContainer mapContainer,\n                                SerializationService serializationService) {\n         this.serializationService = serializationService;\n-        this.statisticsEnabled = config.isStatisticsEnabled();\n+        this.mapContainer = mapContainer;\n     }\n \n     @Override\n     public Record<Object> newRecord(Object value) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        boolean statisticsEnabled = mapConfig.isStatisticsEnabled();\n+        boolean hasEviction = mapContainer.getEvictor() != NULL_EVICTOR;\n+\n         Object objectValue = serializationService.toObject(value);\n-        return statisticsEnabled\n-                ? new ObjectRecordWithStats(objectValue)\n-                : new ObjectRecord(objectValue);\n+\n+        return newRecord(mapConfig, statisticsEnabled, hasEviction, objectValue);\n+    }\n+\n+    @Nonnull\n+    private Record<Object> newRecord(MapConfig mapConfig, boolean statisticsEnabled,\n+                                     boolean hasEviction, Object objectValue) {\n+        if (!statisticsEnabled && !hasEviction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5NDYyMA==", "bodyText": "Can't it break the txn if we freeze max int in version?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565694620", "createdAt": "2021-01-27T22:54:55Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/Record.java", "diffHunk": "@@ -197,7 +161,12 @@ default void onAccessSafe(long now) {\n     }\n \n     default void onUpdate(long now) {\n-        setVersion(getVersion() + 1);\n+        int version = getVersion();\n+        if (version < Integer.MAX_VALUE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMzY5NA==", "bodyText": "Minor: can be simplified to\nif (version.isLessThan(Versions.V4_2)) {\n  readerWriter  = RU_COMPAT_MAP.get(readerWriter);\n}\nout.writeByte(readerWriter.getId());", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565703694", "createdAt": "2021-01-27T23:15:11Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/Records.java", "diffHunk": "@@ -16,32 +16,74 @@\n \n package com.hazelcast.map.impl.record;\n \n+import com.hazelcast.internal.cluster.Versions;\n+import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.recordstore.expiry.ExpiryMetadata;\n import com.hazelcast.nio.ObjectDataInput;\n import com.hazelcast.nio.ObjectDataOutput;\n-import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.version.Version;\n \n import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.Map;\n \n import static com.hazelcast.map.impl.record.Record.NOT_CACHED;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_WITH_STATS_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_WITH_LFU_EVICTION_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_WITH_LRU_EVICTION_READER_WRITER;\n import static com.hazelcast.map.impl.record.RecordReaderWriter.getById;\n \n /**\n- * Contains various factory &amp; helper methods for a {@link com.hazelcast.map.impl.record.Record} object.\n+ * Contains various factory &amp; helper methods for a {@link\n+ * com.hazelcast.map.impl.record.Record} object.\n  */\n public final class Records {\n \n+    // RU_COMPAT_4_1\n+    /**\n+     * Maps RecordReaderWriter objects to their 4.1 equivalents. This is used to\n+     * support compatibility between 4.1 and 4.2 during rolling upgrades.\n+     */\n+    private static final Map<RecordReaderWriter, RecordReaderWriter> RU_COMPAT_MAP = createAndInitRuCompatMap();\n+\n     private Records() {\n     }\n \n-    public static void writeRecord(ObjectDataOutput out, Record record, Data dataValue) throws IOException {\n-        out.writeByte(record.getMatchingRecordReaderWriter().getId());\n-        record.getMatchingRecordReaderWriter().writeRecord(out, record, dataValue);\n+    private static EnumMap<RecordReaderWriter, RecordReaderWriter> createAndInitRuCompatMap() {\n+        EnumMap<RecordReaderWriter, RecordReaderWriter> ruCompatMap = new EnumMap<>(RecordReaderWriter.class);\n+        ruCompatMap.put(SIMPLE_DATA_RECORD_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(SIMPLE_DATA_RECORD_WITH_LFU_EVICTION_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(SIMPLE_DATA_RECORD_WITH_LRU_EVICTION_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(DATA_RECORD_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(DATA_RECORD_WITH_STATS_READER_WRITER, DATA_RECORD_WITH_STATS_READER_WRITER);\n+\n+        assert ruCompatMap.size() == RecordReaderWriter.values().length\n+                : \"Missing enum mapping for RU compatibility\";\n+\n+        return ruCompatMap;\n+    }\n+\n+    public static void writeRecord(ObjectDataOutput out, Record record,\n+                                   Data dataValue, ExpiryMetadata expiryMetadata) throws IOException {\n+        RecordReaderWriter readerWriter = record.getMatchingRecordReaderWriter();\n+        // RU_COMPAT_4_1\n+        Version version = out.getVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwNzg5Nw==", "bodyText": "Is it intentionally 0? Shouldn't it be OBJECT_HEADER_SIZE + REFERENCE_COST_IN_BYTES?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565707897", "createdAt": "2021-01-27T23:25:09Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/SimpleRecord.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.record;\n+\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.serialization.Data;\n+\n+import java.util.Objects;\n+\n+import static com.hazelcast.internal.util.JVMUtil.OBJECT_HEADER_SIZE;\n+import static com.hazelcast.internal.util.JVMUtil.REFERENCE_COST_IN_BYTES;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_READER_WRITER;\n+\n+/**\n+ * Used when {@link MapConfig#isStatisticsEnabled()} is {@code false}\n+ */\n+@SuppressWarnings({\"checkstyle:methodcount\", \"VolatileLongOrDoubleField\"})\n+class SimpleRecord<V> implements Record<V> {\n+    protected volatile V value;\n+    private int version;\n+\n+    SimpleRecord() {\n+    }\n+\n+    SimpleRecord(V value) {\n+        setValue(value);\n+    }\n+\n+    @Override\n+    public final int getVersion() {\n+        return version;\n+    }\n+\n+    @Override\n+    public final void setVersion(int version) {\n+        this.version = version;\n+    }\n+\n+    @Override\n+    public long getLastAccessTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setLastAccessTime(long lastAccessTime) {\n+    }\n+\n+    @Override\n+    public long getLastUpdateTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setLastUpdateTime(long lastUpdateTime) {\n+    }\n+\n+    @Override\n+    public long getCreationTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setCreationTime(long creationTime) {\n+    }\n+\n+    @Override\n+    public int getHits() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setHits(int hits) {\n+    }\n+\n+    @Override\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public void setValue(V value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public Object getCachedValueUnsafe() {\n+        return Record.NOT_CACHED;\n+    }\n+\n+    @Override\n+    public boolean casCachedValue(Object expectedValue, Object newValue) {\n+        return true;\n+    }\n+\n+    @Override\n+    public final long getSequence() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public final void setSequence(long sequence) {\n+    }\n+\n+    @Override\n+    public long getLastStoredTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setLastStoredTime(long lastStoredTime) {\n+    }\n+\n+    @Override\n+    public long getCost() {\n+        if (value instanceof Data) {\n+            return OBJECT_HEADER_SIZE\n+                    + REFERENCE_COST_IN_BYTES + ((Data) value).getHeapCost();\n+        } else {\n+            return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxMzI0NQ==", "bodyText": "Leftover", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565713245", "createdAt": "2021-01-27T23:33:01Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -83,13 +84,12 @@\n  */\n @SuppressWarnings({\"checkstyle:methodcount\", \"checkstyle:classfanoutcomplexity\"})\n public class DefaultRecordStore extends AbstractEvictableRecordStore {\n-\n     protected final ILogger logger;\n     protected final RecordStoreLoader recordStoreLoader;\n     protected final MapKeyLoader keyLoader;\n     /**\n      * A collection of futures representing pending completion of the key and\n-     * value loading tasks.\n+     * value loading tasks.ois", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxODEzNg==", "bodyText": "Minor: we can simply return with the returned value, no need for the if.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565718136", "createdAt": "2021-01-27T23:42:24Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -827,72 +858,78 @@ private Object putInternal(Data key, Object newValue, long ttl,\n \n         // Put new record or update existing one.\n         if (record == null) {\n-            putNewRecord(key, oldValue, newValue, ttl, maxIdle, now,\n+            putNewRecord(key, oldValue, newValue, ttl, maxIdle, expiryTime, now,\n                     transactionId, putFromLoad ? LOADED : ADDED, store, backup);\n         } else {\n-            updateRecord(record, key, oldValue, newValue, ttl, maxIdle, now,\n+            updateRecord(record, key, oldValue, newValue, ttl, maxIdle, expiryTime, now,\n                     transactionId, store, countAsAccess, backup);\n         }\n         return oldValue;\n     }\n \n-    private Record getOrLoadRecord(@Nullable Record record, Data key,\n-                                   long now, Address callerAddress, boolean backup) {\n-        if (record != null) {\n-            accessRecord(record, now);\n-            return record;\n+    @SuppressWarnings(\"checkstyle:parameternumber\")\n+    protected Record putNewRecord(Data key, Object oldValue, Object newValue, long ttl,\n+                                  long maxIdle, long expiryTime, long now, UUID transactionId,\n+                                  EntryEventType entryEventType, boolean store,\n+                                  boolean backup) {\n+        Record record = createRecord(newValue, ttl, maxIdle, now);\n+        if (mapDataStore != EMPTY_MAP_DATA_STORE && store) {\n+            putIntoMapStore(record, key, newValue, ttl, maxIdle, now, transactionId);\n         }\n+        storage.put(key, record);\n \n-        Record loadedRecord = loadRecordOrNull(key, backup, callerAddress);\n-        if (loadedRecord != null) {\n-            return loadedRecord;\n-        }\n+        expirySystem.addKeyIfExpirable(key, ttl, maxIdle, expiryTime, now);\n \n-        return null;\n+        if (entryEventType == EntryEventType.LOADED) {\n+            mutationObserver.onLoadRecord(key, record, backup);\n+        } else {\n+            mutationObserver.onPutRecord(key, record, oldValue, backup);\n+        }\n+        return record;\n     }\n \n     @SuppressWarnings(\"checkstyle:parameternumber\")\n     protected void updateRecord(Record record, Data key, Object oldValue, Object newValue,\n-                                long ttl, long maxIdle, long now, UUID transactionId,\n+                                long ttl, long maxIdle, long expiryTime, long now, UUID transactionId,\n                                 boolean store, boolean countAsAccess, boolean backup) {\n         updateStatsOnPut(countAsAccess, now);\n         record.onUpdate(now);\n+\n         if (countAsAccess) {\n             record.onAccess(now);\n         }\n-        setExpirationTimes(record, ttl, maxIdle, mapContainer.getMapConfig());\n-        if (store) {\n-            newValue = putIntoMapStore(record, key, newValue, now, transactionId);\n+\n+        if (mapDataStore != EMPTY_MAP_DATA_STORE && store) {\n+            newValue = putIntoMapStore(record, key, newValue,\n+                    ttl, maxIdle, now, transactionId);\n         }\n+\n         storage.updateRecordValue(key, record, newValue);\n-        markRecordStoreExpirable(ttl, maxIdle);\n+        expirySystem.addKeyIfExpirable(key, ttl, maxIdle, expiryTime, now);\n+\n         mutationObserver.onUpdateRecord(key, record, oldValue, newValue, backup);\n     }\n \n-    @SuppressWarnings(\"checkstyle:parameternumber\")\n-    protected Record putNewRecord(Data key, Object oldValue, Object newValue, long ttlMillis,\n-                                  long maxIdleMillis, long now, UUID transactionId,\n-                                  EntryEventType entryEventType, boolean store,\n-                                  boolean backup) {\n-\n-        Record record = createRecord(key, newValue, ttlMillis, maxIdleMillis, now);\n-        if (store) {\n-            putIntoMapStore(record, key, newValue, now, transactionId);\n+    private Record getOrLoadRecord(@Nullable Record record, Data key,\n+                                   long now, Address callerAddress, boolean backup) {\n+        if (record != null) {\n+            accessRecord(key, record, now);\n+            return record;\n         }\n-        storage.put(key, record);\n-        markRecordStoreExpirable(ttlMillis, maxIdleMillis);\n-        if (entryEventType == EntryEventType.LOADED) {\n-            mutationObserver.onLoadRecord(key, record, backup);\n-        } else {\n-            mutationObserver.onPutRecord(key, record, oldValue, backup);\n+\n+        Record loadedRecord = loadRecordOrNull(key, backup, callerAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyMDg4NA==", "bodyText": "Maybe these can be moved into TimeUtil?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565720884", "createdAt": "2021-01-27T23:49:38Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpiryMetadata.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+\n+import static com.hazelcast.map.impl.record.Record.EPOCH_TIME;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public interface ExpiryMetadata {\n+\n+    @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+    ExpiryMetadata NULL = new ExpiryMetadata() {\n+        @Override\n+        public long getTtl() {\n+            return Long.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public int getRawTtl() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setTtl(long ttl) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setRawTtl(int ttl) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public long getMaxIdle() {\n+            return Long.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public int getRawMaxIdle() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setMaxIdle(long maxIdle) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setRawMaxIdle(int maxIdle) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public long getExpirationTime() {\n+            return Long.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public int getRawExpirationTime() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setExpirationTime(long expirationTime) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setRawExpirationTime(int expirationTime) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+\n+    long getTtl();\n+\n+    int getRawTtl();\n+\n+    ExpiryMetadata setTtl(long ttl);\n+\n+    ExpiryMetadata setRawTtl(int ttl);\n+\n+    long getMaxIdle();\n+\n+    int getRawMaxIdle();\n+\n+    ExpiryMetadata setMaxIdle(long maxIdle);\n+\n+    ExpiryMetadata setRawMaxIdle(int maxIdle);\n+\n+    long getExpirationTime();\n+\n+    int getRawExpirationTime();\n+\n+    ExpiryMetadata setExpirationTime(long expirationTime);\n+\n+    ExpiryMetadata setRawExpirationTime(int expirationTime);\n+\n+    default int stripBaseTime(long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyNTQzNQ==", "bodyText": "Has this been done?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565725435", "createdAt": "2021-01-28T00:01:07Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpirySystem.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;\n+import com.hazelcast.internal.eviction.ExpiredKey;\n+import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.MapUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.map.impl.ExpirationTimeSetter;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.MapServiceContext;\n+import com.hazelcast.map.impl.eviction.Evictor;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.spi.properties.ClusterProperty;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+import com.hazelcast.spi.properties.HazelcastProperty;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.hazelcast.internal.util.ToHeapDataConverter.toHeapData;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickMaxIdleMillis;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickTTLMillis;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class has all logic to remove expired entries. Expiry reason\n+ * can be ttl or idleness. An instance of this class is created for\n+ * each {@link RecordStore} and it is always accessed by same single thread.\n+ */\n+public class ExpirySystem {\n+    private static final long DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = TimeUnit.MILLISECONDS.toNanos(1);\n+    private static final String PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = \"hazelcast.internal.map.expired.key.scan.timeout.nanos\";\n+    private static final HazelcastProperty EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = new HazelcastProperty(PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS,\n+            DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS, NANOSECONDS);\n+    private static final int ONE_HUNDRED_PERCENT = 100;\n+    private static final int MIN_SCANNABLE_ENTRY_COUNT = 100;\n+\n+    private final long expiryDelayMillis;\n+    private final long expiredKeyScanTimeoutNanos;\n+    private final boolean canPrimaryDriveExpiration;\n+    private final ILogger logger;\n+    private final RecordStore recordStore;\n+    private final MapContainer mapContainer;\n+    private final MapServiceContext mapServiceContext;\n+    private final ClearExpiredRecordsTask clearExpiredRecordsTask;\n+    private final InvalidationQueue<ExpiredKey> expiredKeys = new InvalidationQueue<>();\n+\n+    private Iterator<Map.Entry<Data, ExpiryMetadata>> cachedExpirationIterator;\n+    private Map<Data, ExpiryMetadata> expireTimeByKey;\n+\n+    public ExpirySystem(RecordStore recordStore,\n+                        MapContainer mapContainer,\n+                        MapServiceContext mapServiceContext) {\n+        this.recordStore = recordStore;\n+        this.clearExpiredRecordsTask = mapServiceContext.getExpirationManager().getTask();\n+        NodeEngine nodeEngine = mapServiceContext.getNodeEngine();\n+        this.logger = nodeEngine.getLogger(getClass());\n+        HazelcastProperties hazelcastProperties = nodeEngine.getProperties();\n+        this.expiryDelayMillis = hazelcastProperties.getMillis(ClusterProperty.MAP_EXPIRY_DELAY_SECONDS);\n+        this.mapContainer = mapContainer;\n+        this.mapServiceContext = mapServiceContext;\n+        this.canPrimaryDriveExpiration = mapServiceContext.getClearExpiredRecordsTask().canPrimaryDriveExpiration();\n+        this.expiredKeyScanTimeoutNanos = nodeEngine.getProperties().getNanos(EXPIRED_KEY_SCAN_TIMEOUT_NANOS);\n+    }\n+\n+    public boolean isEmpty() {\n+        return MapUtil.isNullOrEmpty(expireTimeByKey);\n+    }\n+\n+    // this method is overridden\n+    protected Map<Data, ExpiryMetadata> createExpiryTimeByKeyMap() {\n+        // Only one thread can access this class but we\n+        // used CHM here, because its iterator doesn't\n+        // throw ConcurrentModificationException.\n+        return new ConcurrentHashMap<>();\n+    }\n+\n+    // this method is overridden\n+    public void clear() {\n+        Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+        map.clear();\n+    }\n+\n+    protected Map<Data, ExpiryMetadata> getOrCreateExpireTimeByKeyMap(boolean createIfAbsent) {\n+        if (expireTimeByKey != null) {\n+            return expireTimeByKey;\n+        }\n+\n+        if (createIfAbsent) {\n+            expireTimeByKey = createExpiryTimeByKeyMap();\n+            return expireTimeByKey;\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    // this method is overridden\n+    protected ExpiryMetadata createExpiryMetadata(long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        return new ExpiryMetadataImpl(ttlMillis, maxIdleMillis, expirationTime);\n+    }\n+\n+    public void addKeyIfExpirable(Data key, long ttl, long maxIdle, long expiryTime, long now) {\n+        if (expiryTime <= 0) {\n+            MapConfig mapConfig = mapContainer.getMapConfig();\n+            long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+            long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+            long expirationTime = ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+            addExpirableKey(key, ttlMillis, maxIdleMillis, expirationTime);\n+        } else {\n+            addExpirableKey(key, ttl, maxIdle, expiryTime);\n+        }\n+    }\n+\n+    private void addExpirableKey(Data key, long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        if (expirationTime == Long.MAX_VALUE) {\n+            Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+            if (!map.isEmpty()) {\n+                Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+                callRemove(nativeKey, expireTimeByKey);\n+            }\n+            return;\n+        }\n+\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(true);\n+        ExpiryMetadata expiryMetadata = expireTimeByKey.get(key);\n+        if (expiryMetadata == null) {\n+            expiryMetadata = createExpiryMetadata(ttlMillis, maxIdleMillis, expirationTime);\n+            Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+            expireTimeByKey.put(nativeKey, expiryMetadata);\n+        } else {\n+            expiryMetadata.setTtl(ttlMillis)\n+                    .setMaxIdle(maxIdleMillis)\n+                    .setExpirationTime(expirationTime);\n+        }\n+\n+        mapServiceContext.getExpirationManager().scheduleExpirationTask();\n+    }\n+\n+    public long calculateExpirationTime(long ttl, long maxIdle, long now) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+        long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+        return ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+    }\n+\n+    public void removeKeyFromExpirySystem(Data key) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+        callRemove(key, expireTimeByKey);\n+    }\n+\n+    // TODO add test for this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTIzMQ==", "bodyText": "To skip the records that should have already been removed by the expiry logic if it was run since the expiry time of the record elapsed?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565731231", "createdAt": "2021-01-28T00:16:52Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/MapScanExecIterator.java", "diffHunk": "@@ -121,7 +121,8 @@ private void advance0() {\n             while (currentRecordStoreIterator.hasNext()) {\n                 Map.Entry<Data, Record<Object>> entry = currentRecordStoreIterator.next();\n \n-                if (!currentRecordStore.isExpired(entry.getValue(), now, false)) {\n+                // TODO why do we have expiry check here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTkyNw==", "bodyText": "Is it intentionally remained QuickTest?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565731927", "createdAt": "2021-01-28T00:18:41Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/internal/eviction/MapExpirationStressTest.java", "diffHunk": "@@ -43,7 +43,7 @@\n import static com.hazelcast.test.backup.TestBackupUtils.assertBackupSizeEventually;\n \n @RunWith(HazelcastSerialClassRunner.class)\n-@Category(NightlyTest.class)\n+@Category(QuickTest.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjI5OA==", "bodyText": "Leftover?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565732298", "createdAt": "2021-01-28T00:19:44Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/map/EntryCostEstimatorTest.java", "diffHunk": "@@ -33,6 +34,7 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n+@Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjY5OQ==", "bodyText": "Are these intentionally kept scaled down?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565732699", "createdAt": "2021-01-28T00:20:52Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/map/ExpirationTimeTest.java", "diffHunk": "@@ -140,25 +140,26 @@ public void test_replicated_entries_view_equal_after_cluster_scale_up() {\n \n         HazelcastInstance node1 = factory.newHazelcastInstance(config);\n         IMap<Integer, Integer> map = node1.getMap(mapName);\n-        for (int i = 0; i < 10; i++) {\n+        for (int i = 0; i < 1; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzQ3Mw==", "bodyText": "Leftover", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565733473", "createdAt": "2021-01-28T00:22:13Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/map/impl/mapstore/writebehind/MapStoreWriteBehindTest.java", "diffHunk": "@@ -80,6 +80,7 @@\n     public void testOneMemberWriteBehindWithMaxIdle() {\n         final EventBasedMapStore testMapStore = new EventBasedMapStore();\n         Config config = newConfig(testMapStore, 5, InitialLoadMode.EAGER);\n+//        Config config = getConfig();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczNDgwNw==", "bodyText": "Leftover", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565734807", "createdAt": "2021-01-28T00:23:44Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/map/impl/recordstore/LazyEvictableEntryViewTest.java", "diffHunk": "@@ -77,6 +84,8 @@ public void test_getValue() {\n     }\n \n     @Test\n+    @Ignore\n+    // TODO fixme", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b09caaaae8cbe09328786ff450e042f29decae55", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b09caaaae8cbe09328786ff450e042f29decae55", "committedDate": "2021-01-27T09:08:00Z", "message": "factory ifelse"}, "afterCommit": {"oid": "51681b0c10671051246e8b0bd664bba77125373b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/51681b0c10671051246e8b0bd664bba77125373b", "committedDate": "2021-01-28T15:36:57Z", "message": "Zoltan reviews"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTM0MDkw", "url": "https://github.com/hazelcast/hazelcast/pull/17977#pullrequestreview-578534090", "createdAt": "2021-01-28T16:47:17Z", "commit": {"oid": "dfbcd8e2f8ba2f3f84c850080a1d6df991f817a9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxNjo0NzoxN1rOIcA4xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxNjo0NzoxN1rOIcA4xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjI0NTU3Mg==", "bodyText": "Maybe keeping the math with the comments we had before would be better.", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566245572", "createdAt": "2021-01-28T16:47:17Z", "author": {"login": "blazember"}, "path": "hazelcast/src/test/java/com/hazelcast/map/EntryCostEstimatorTest.java", "diffHunk": "@@ -39,22 +39,29 @@\n         extends HazelcastTestSupport {\n \n     protected TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n-    // the JVM-independent portion of the cost of Integer key + Long value record is 104 bytes\n-    // (without taking into account 8 references to key, record and value objects)\n-    private static final int JVM_INDEPENDENT_ENTRY_COST_IN_BYTES = 100;\n-    // JVM-dependent total cost of entry\n-    private static final int ENTRY_COST_IN_BYTES = JVM_INDEPENDENT_ENTRY_COST_IN_BYTES + 8 * REFERENCE_COST_IN_BYTES;\n+\n+    public static final int ENTRY_COST_IN_BYTES = getExpectedCostInBytes();\n+\n+    private static int getExpectedCostInBytes() {\n+        if (JVMUtil.is32bitJVM() && JVMUtil.isCompressedOops()) {\n+            return 140;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfbcd8e2f8ba2f3f84c850080a1d6df991f817a9"}, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dfbcd8e2f8ba2f3f84c850080a1d6df991f817a9", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/dfbcd8e2f8ba2f3f84c850080a1d6df991f817a9", "committedDate": "2021-01-28T15:44:17Z", "message": "Zoltan reviews: allow version overflow 2"}, "afterCommit": {"oid": "31d6287bba2d28a46e1f27708250158f34f402ef", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/31d6287bba2d28a46e1f27708250158f34f402ef", "committedDate": "2021-01-29T09:32:06Z", "message": "remove duplicate method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "550e47f62f15c4d06f9b55c54e60789c176d9002", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/550e47f62f15c4d06f9b55c54e60789c176d9002", "committedDate": "2021-01-29T13:02:49Z", "message": "remove duplicate method 2"}, "afterCommit": {"oid": "b401991bc204d545f557bb2bf9cd8608237e7ca9", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b401991bc204d545f557bb2bf9cd8608237e7ca9", "committedDate": "2021-01-29T19:09:28Z", "message": "remove duplicate method 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxMTU1NDkx", "url": "https://github.com/hazelcast/hazelcast/pull/17977#pullrequestreview-581155491", "createdAt": "2021-02-02T09:42:41Z", "commit": {"oid": "b401991bc204d545f557bb2bf9cd8608237e7ca9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b401991bc204d545f557bb2bf9cd8608237e7ca9", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b401991bc204d545f557bb2bf9cd8608237e7ca9", "committedDate": "2021-01-29T19:09:28Z", "message": "remove duplicate method 2"}, "afterCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4ad19b6d763861a7b1f704c6b43da775c985a23c", "committedDate": "2021-02-03T09:17:49Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyMjYzNTM5", "url": "https://github.com/hazelcast/hazelcast/pull/17977#pullrequestreview-582263539", "createdAt": "2021-02-03T11:26:48Z", "commit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMToyNjo0OFrOIe9k_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzo1MjozOFrOIfDLBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzNzA4Ng==", "bodyText": "In which conditions operationTTLMillis is negative?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569337086", "createdAt": "2021-02-03T11:26:48Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/ExpirationTimeSetter.java", "diffHunk": "@@ -115,51 +48,41 @@ public static void setExpirationTimes(Record record, long operationTTLMillis,\n      * @param mapConfig          used to get configured TTL\n      * @return TTL value in millis to set to record\n      */\n-    private static long pickTTLMillis(long operationTTLMillis, MapConfig mapConfig) {\n-        // if user set operationTTLMillis when calling operation, use it\n-        if (operationTTLMillis > 0) {\n-            return checkedTime(operationTTLMillis);\n+    public static long pickTTLMillis(long operationTTLMillis, MapConfig mapConfig) {\n+        if (operationTTLMillis < 0 && mapConfig.getTimeToLiveSeconds() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MDc5Nw==", "bodyText": "Not sure that I understood this change. Can you please elaborate a bit?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569350797", "createdAt": "2021-02-03T11:49:50Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/PutIfAbsentOperation.java", "diffHunk": "@@ -63,7 +63,7 @@ public Object getResponse() {\n \n     @Override\n     public boolean shouldBackup() {\n-        return successful && recordStore.getRecord(dataKey) != null;\n+        return successful && super.shouldBackup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MTYxMA==", "bodyText": "Why we're not considering this case anymore?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569351610", "createdAt": "2021-02-03T11:51:10Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxySupport.java", "diffHunk": "@@ -1314,9 +1313,6 @@ public void addIndex(IndexConfig indexConfig) {\n \n     @Override\n     public LocalMapStats getLocalMapStats() {\n-        if (!mapConfig.isStatisticsEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MjM3NQ==", "bodyText": "We have metadata store only in HD case. Will it work in the on-heap scenario?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569352375", "createdAt": "2021-02-03T11:52:28Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/query/PartitionScanRunner.java", "diffHunk": "@@ -101,7 +100,7 @@ public void accept(Data key, Record record) {\n \n                 queryEntry.init(ss, key, value, extractors);\n                 queryEntry.setRecord(record);\n-                queryEntry.setMetadata(PartitionScanRunner.this.getMetadataFromRecord(recordStore, key, record));\n+                queryEntry.setMetadata(recordStore.getMetadataStore().get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM2NTExMw==", "bodyText": "We replace long with int here. Is int enough?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569365113", "createdAt": "2021-02-03T12:14:41Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/Record.java", "diffHunk": "@@ -66,9 +65,9 @@\n      */\n     long getCost();\n \n-    long getVersion();\n+    int getVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM2NTc2OA==", "bodyText": "Is it for backward compatibility?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569365768", "createdAt": "2021-02-03T12:15:46Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/RecordReaderWriter.java", "diffHunk": "@@ -16,78 +16,165 @@\n \n package com.hazelcast.map.impl.record;\n \n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.recordstore.expiry.ExpiryMetadata;\n import com.hazelcast.nio.ObjectDataInput;\n import com.hazelcast.nio.ObjectDataOutput;\n-import com.hazelcast.internal.serialization.Data;\n \n import java.io.IOException;\n \n import static com.hazelcast.internal.nio.IOUtil.readData;\n import static com.hazelcast.internal.nio.IOUtil.writeData;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n \n /**\n  * Used when reading and writing records\n  * for backup and replication operations\n  */\n public enum RecordReaderWriter {\n+    // RU_COMPAT_4_1\n+    // Remove enum DATA_RECORD_READER_WRITER in 4.3\n     DATA_RECORD_READER_WRITER(TypeId.DATA_RECORD_TYPE_ID) {\n         @Override\n-        void writeRecord(ObjectDataOutput out,\n-                         Record record, Data dataValue) throws IOException {\n+        void writeRecord(ObjectDataOutput out, Record record, Data dataValue,\n+                         ExpiryMetadata expiryMetadata) throws IOException {\n             writeData(out, dataValue);\n-            out.writeInt(record.getRawTtl());\n-            out.writeInt(record.getRawMaxIdle());\n-            out.writeInt(record.getRawCreationTime());\n-            out.writeInt(record.getRawLastAccessTime());\n-            out.writeInt(record.getRawLastUpdateTime());\n+            out.writeInt(expiryMetadata.getRawTtl());\n+            out.writeInt(expiryMetadata.getRawMaxIdle());\n+            out.writeInt(UNSET);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyNTE0Nw==", "bodyText": "Please add Javadoc", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569425147", "createdAt": "2021-02-03T13:47:38Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpiryReason.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyODc0MA==", "bodyText": "What if the iterator has not next element?", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569428740", "createdAt": "2021-02-03T13:52:38Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpirySystem.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;\n+import com.hazelcast.internal.eviction.ExpiredKey;\n+import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.MapUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.map.impl.ExpirationTimeSetter;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.MapServiceContext;\n+import com.hazelcast.map.impl.eviction.Evictor;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.spi.properties.ClusterProperty;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+import com.hazelcast.spi.properties.HazelcastProperty;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.hazelcast.internal.util.ToHeapDataConverter.toHeapData;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickMaxIdleMillis;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickTTLMillis;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class has all logic to remove expired entries. Expiry reason\n+ * can be ttl or idleness. An instance of this class is created for\n+ * each {@link RecordStore} and it is always accessed by same single thread.\n+ */\n+public class ExpirySystem {\n+    private static final long DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = TimeUnit.MILLISECONDS.toNanos(1);\n+    private static final String PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = \"hazelcast.internal.map.expired.key.scan.timeout.nanos\";\n+    private static final HazelcastProperty EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = new HazelcastProperty(PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS,\n+            DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS, NANOSECONDS);\n+    private static final int ONE_HUNDRED_PERCENT = 100;\n+    private static final int MIN_SCANNABLE_ENTRY_COUNT = 100;\n+\n+    private final long expiryDelayMillis;\n+    private final long expiredKeyScanTimeoutNanos;\n+    private final boolean canPrimaryDriveExpiration;\n+    private final ILogger logger;\n+    private final RecordStore recordStore;\n+    private final MapContainer mapContainer;\n+    private final MapServiceContext mapServiceContext;\n+    private final ClearExpiredRecordsTask clearExpiredRecordsTask;\n+    private final InvalidationQueue<ExpiredKey> expiredKeys = new InvalidationQueue<>();\n+\n+    private Iterator<Map.Entry<Data, ExpiryMetadata>> cachedExpirationIterator;\n+    private Map<Data, ExpiryMetadata> expireTimeByKey;\n+\n+    public ExpirySystem(RecordStore recordStore,\n+                        MapContainer mapContainer,\n+                        MapServiceContext mapServiceContext) {\n+        this.recordStore = recordStore;\n+        this.clearExpiredRecordsTask = mapServiceContext.getExpirationManager().getTask();\n+        NodeEngine nodeEngine = mapServiceContext.getNodeEngine();\n+        this.logger = nodeEngine.getLogger(getClass());\n+        HazelcastProperties hazelcastProperties = nodeEngine.getProperties();\n+        this.expiryDelayMillis = hazelcastProperties.getMillis(ClusterProperty.MAP_EXPIRY_DELAY_SECONDS);\n+        this.mapContainer = mapContainer;\n+        this.mapServiceContext = mapServiceContext;\n+        this.canPrimaryDriveExpiration = mapServiceContext.getClearExpiredRecordsTask().canPrimaryDriveExpiration();\n+        this.expiredKeyScanTimeoutNanos = nodeEngine.getProperties().getNanos(EXPIRED_KEY_SCAN_TIMEOUT_NANOS);\n+    }\n+\n+    public boolean isEmpty() {\n+        return MapUtil.isNullOrEmpty(expireTimeByKey);\n+    }\n+\n+    // this method is overridden\n+    protected Map<Data, ExpiryMetadata> createExpiryTimeByKeyMap() {\n+        // Only one thread can access this class but we\n+        // used CHM here, because its iterator doesn't\n+        // throw ConcurrentModificationException.\n+        return new ConcurrentHashMap<>();\n+    }\n+\n+    // this method is overridden\n+    public void clear() {\n+        Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+        map.clear();\n+    }\n+\n+    protected Map<Data, ExpiryMetadata> getOrCreateExpireTimeByKeyMap(boolean createIfAbsent) {\n+        if (expireTimeByKey != null) {\n+            return expireTimeByKey;\n+        }\n+\n+        if (createIfAbsent) {\n+            expireTimeByKey = createExpiryTimeByKeyMap();\n+            return expireTimeByKey;\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    // this method is overridden\n+    protected ExpiryMetadata createExpiryMetadata(long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        return new ExpiryMetadataImpl(ttlMillis, maxIdleMillis, expirationTime);\n+    }\n+\n+    public void addKeyIfExpirable(Data key, long ttl, long maxIdle, long expiryTime, long now) {\n+        if (expiryTime <= 0) {\n+            MapConfig mapConfig = mapContainer.getMapConfig();\n+            long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+            long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+            long expirationTime = ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+            addExpirableKey(key, ttlMillis, maxIdleMillis, expirationTime);\n+        } else {\n+            addExpirableKey(key, ttl, maxIdle, expiryTime);\n+        }\n+    }\n+\n+    private void addExpirableKey(Data key, long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        if (expirationTime == Long.MAX_VALUE) {\n+            Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+            if (!map.isEmpty()) {\n+                Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+                callRemove(nativeKey, expireTimeByKey);\n+            }\n+            return;\n+        }\n+\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(true);\n+        ExpiryMetadata expiryMetadata = expireTimeByKey.get(key);\n+        if (expiryMetadata == null) {\n+            expiryMetadata = createExpiryMetadata(ttlMillis, maxIdleMillis, expirationTime);\n+            Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+            expireTimeByKey.put(nativeKey, expiryMetadata);\n+        } else {\n+            expiryMetadata.setTtl(ttlMillis)\n+                    .setMaxIdle(maxIdleMillis)\n+                    .setExpirationTime(expirationTime);\n+        }\n+\n+        mapServiceContext.getExpirationManager().scheduleExpirationTask();\n+    }\n+\n+    public long calculateExpirationTime(long ttl, long maxIdle, long now) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+        long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+        return ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+    }\n+\n+    public void removeKeyFromExpirySystem(Data key) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+        callRemove(key, expireTimeByKey);\n+    }\n+\n+    public void extendExpiryTime(Data dataKey, long now) {\n+        if (isEmpty()) {\n+            return;\n+        }\n+\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+\n+        ExpiryMetadata expiryMetadata = getExpiryMetadataForExpiryCheck(dataKey, expireTimeByKey);\n+        if (expiryMetadata == null\n+                || expiryMetadata.getMaxIdle() == Long.MAX_VALUE) {\n+            return;\n+        }\n+\n+        long expirationTime = ExpirationTimeSetter.calculateExpirationTime(expiryMetadata.getTtl(),\n+                expiryMetadata.getMaxIdle(), now);\n+        expiryMetadata.setExpirationTime(expirationTime);\n+    }\n+\n+    public ExpiryReason hasExpired(Data key, long now, boolean backup) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+        ExpiryMetadata expiryMetadata = getExpiryMetadataForExpiryCheck(key, expireTimeByKey);\n+        return hasExpired(expiryMetadata, now, backup);\n+    }\n+\n+    private ExpiryReason hasExpired(ExpiryMetadata expiryMetadata, long now, boolean backup) {\n+        if (expiryMetadata == null) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+\n+        long nextExpirationTime = backup\n+                ? expiryMetadata.getExpirationTime() + expiryDelayMillis\n+                : expiryMetadata.getExpirationTime();\n+\n+        if (nextExpirationTime > now) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+\n+        ExpiryReason expiryReason = expiryMetadata.getTtl() > expiryMetadata.getMaxIdle()\n+                ? ExpiryReason.IDLENESS : ExpiryReason.TTL;\n+        if (backup && canPrimaryDriveExpiration\n+                && expiryReason == ExpiryReason.IDLENESS) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+        return expiryReason;\n+    }\n+\n+    public InvalidationQueue<ExpiredKey> getExpiredKeys() {\n+        return expiredKeys;\n+    }\n+\n+    @Nonnull\n+    public ExpiryMetadata getExpiredMetadata(Data key) {\n+        ExpiryMetadata expiryMetadata = getOrCreateExpireTimeByKeyMap(false).get(key);\n+        return expiryMetadata != null ? expiryMetadata : ExpiryMetadata.NULL;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    public void evictExpiredEntries(int percentage, long now, boolean backup) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+\n+        // Find max scannable key count\n+        int expirableKeysMapSize = expireTimeByKey.size();\n+        int keyCountInPercentage = (int) (1D * expirableKeysMapSize * percentage / ONE_HUNDRED_PERCENT);\n+        int maxScannableKeyCount = Math.max(MIN_SCANNABLE_ENTRY_COUNT, keyCountInPercentage);\n+\n+        scanAndEvictExpiredKeys(maxScannableKeyCount, now, backup);\n+\n+        accumulateOrSendExpiredKey(null);\n+    }\n+\n+    /**\n+     * Get cachedExpirationIterator or init it if it has no next entry.\n+     */\n+    private Iterator<Map.Entry<Data, ExpiryMetadata>> getOrInitCachedIterator() {\n+        if (cachedExpirationIterator == null || !cachedExpirationIterator.hasNext()) {\n+            cachedExpirationIterator = initIteratorOf(expireTimeByKey);\n+        }\n+\n+        return cachedExpirationIterator;\n+    }\n+\n+    private void scanAndEvictExpiredKeys(int maxScannableKeyCount, long now, boolean backup) {\n+        // Scan to find expired keys.\n+        long scanLoopStartNanos = System.nanoTime();\n+        List expiredKeyExpiryReasonList = new ArrayList<>();\n+        int scannedKeyCount = 0;\n+        int expiredKeyCount = 0;\n+        do {\n+            Map.Entry<Data, ExpiryMetadata> entry = getOrInitCachedIterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c"}, "originalPosition": 280}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4ad19b6d763861a7b1f704c6b43da775c985a23c", "committedDate": "2021-02-03T09:17:49Z", "message": "fix checkstyle"}, "afterCommit": {"oid": "6d1a713e86ad746893bdf5703cd8772bbe54c967", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6d1a713e86ad746893bdf5703cd8772bbe54c967", "committedDate": "2021-02-03T20:01:41Z", "message": "Address Petr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75eb1bc07b0eff0ab6880b13517f5810d3d88caf", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/75eb1bc07b0eff0ab6880b13517f5810d3d88caf", "committedDate": "2021-02-04T08:05:01Z", "message": "HD Simple data record for cluster version\nextend expiryTime for get requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a95ca6703e0477d477efbc085573f32ad34240e", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1a95ca6703e0477d477efbc085573f32ad34240e", "committedDate": "2021-02-04T08:05:01Z", "message": "fix hd"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fa84736eb6abb04e3848648958330fc00bd364b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7fa84736eb6abb04e3848648958330fc00bd364b", "committedDate": "2021-02-04T08:05:01Z", "message": "fix expiry-system"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2e0abef3fcdc19ba50949cf96324f49d504d5e9", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b2e0abef3fcdc19ba50949cf96324f49d504d5e9", "committedDate": "2021-02-04T08:05:01Z", "message": "wip overridable iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ca530c05cb9986aef95bd7fe63e627ff10e6fe5", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7ca530c05cb9986aef95bd7fe63e627ff10e6fe5", "committedDate": "2021-02-04T08:05:01Z", "message": "wip hd fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8107cdaeed09f60713b10dc33b409f741c2c5fee", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8107cdaeed09f60713b10dc33b409f741c2c5fee", "committedDate": "2021-02-04T08:05:01Z", "message": "eviction test passed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4d4a258c5025184d2ad3309509f1bc4e4e22151", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c4d4a258c5025184d2ad3309509f1bc4e4e22151", "committedDate": "2021-02-04T08:05:01Z", "message": "eviction test passed 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04373444bb531bee80b12a76ea86917f792f9c97", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/04373444bb531bee80b12a76ea86917f792f9c97", "committedDate": "2021-02-04T08:05:01Z", "message": "wip test foxes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80e0bbec6be06b174990e9940aecd51a06151d63", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/80e0bbec6be06b174990e9940aecd51a06151d63", "committedDate": "2021-02-04T08:05:01Z", "message": "backup expiry info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3c704ccd45008f300b438db629ec6483bcf1390", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a3c704ccd45008f300b438db629ec6483bcf1390", "committedDate": "2021-02-04T08:05:01Z", "message": "backup expiry info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f1bdbf12c741f8a717b600a9e817e8a46a64261", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0f1bdbf12c741f8a717b600a9e817e8a46a64261", "committedDate": "2021-02-04T08:05:01Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b9db6e9994b4c9f260c25274e0cc2cef5a267e", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/91b9db6e9994b4c9f260c25274e0cc2cef5a267e", "committedDate": "2021-02-04T08:05:01Z", "message": "wip checlstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ea33b2f4155c5342c59e2ae00a19bfe270fdf83", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5ea33b2f4155c5342c59e2ae00a19bfe270fdf83", "committedDate": "2021-02-04T08:05:01Z", "message": "test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4796eb6c24ebffbe71887a28a3eaabdccd8787e2", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4796eb6c24ebffbe71887a28a3eaabdccd8787e2", "committedDate": "2021-02-04T08:05:02Z", "message": "test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dc611964594afe8f7c09d6d170a287e98dbfd0b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4dc611964594afe8f7c09d6d170a287e98dbfd0b", "committedDate": "2021-02-04T08:05:02Z", "message": "test fix 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce29612a876a24c0e44a3fa3f25f8c30dcd36cb8", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ce29612a876a24c0e44a3fa3f25f8c30dcd36cb8", "committedDate": "2021-02-04T08:05:02Z", "message": "remove key createRecord"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15bd9d1a4be92a388d51dc0b31d280188225f4c7", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/15bd9d1a4be92a388d51dc0b31d280188225f4c7", "committedDate": "2021-02-04T08:05:02Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3318d9b6399eedf85396c8c5fd0260e4768e734f", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3318d9b6399eedf85396c8c5fd0260e4768e734f", "committedDate": "2021-02-04T08:05:02Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90f4b2340e4a9d3c2265d5d09081a1cdd32bb47f", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/90f4b2340e4a9d3c2265d5d09081a1cdd32bb47f", "committedDate": "2021-02-04T08:05:02Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e532bc392e7425a67d97a00d1cac6126011d813b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e532bc392e7425a67d97a00d1cac6126011d813b", "committedDate": "2021-02-04T08:05:02Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7b7ea147a3e196e65b0c3db89af1eddf7c6f06a", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d7b7ea147a3e196e65b0c3db89af1eddf7c6f06a", "committedDate": "2021-02-04T08:05:02Z", "message": "enhc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f70da73a54249154a6c2c1de8a0e923d33582a2b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f70da73a54249154a6c2c1de8a0e923d33582a2b", "committedDate": "2021-02-04T08:05:02Z", "message": "polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7419fd5600a9569415bbdeb9def052ab7a972d97", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7419fd5600a9569415bbdeb9def052ab7a972d97", "committedDate": "2021-02-04T08:05:02Z", "message": "test update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4b994252e86eedbc6ec670ab806731a7f103941", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d4b994252e86eedbc6ec670ab806731a7f103941", "committedDate": "2021-02-04T08:05:02Z", "message": "hdmap stress test related fixes, onshutdown, on destroy etc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74e3c9545bf30dfa210567c96195ab4ceb2412cb", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/74e3c9545bf30dfa210567c96195ab4ceb2412cb", "committedDate": "2021-02-04T08:05:02Z", "message": "polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2fa65c2995c9b8ca2fc8f050415251f8d014c2a", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e2fa65c2995c9b8ca2fc8f050415251f8d014c2a", "committedDate": "2021-02-04T08:05:02Z", "message": "enable metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1319ab38549bf7d5ff98128be27cc156f63170c8", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1319ab38549bf7d5ff98128be27cc156f63170c8", "committedDate": "2021-02-04T08:05:02Z", "message": "metadata unification and expiry related fields removal from record objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0adc7ae0253c9ce3e2c052954230aadd7d63d01", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c0adc7ae0253c9ce3e2c052954230aadd7d63d01", "committedDate": "2021-02-04T08:05:02Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3ef9eb75ce0ac156ecfb60e5c3157f3df2ede82", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a3ef9eb75ce0ac156ecfb60e5c3157f3df2ede82", "committedDate": "2021-02-04T08:05:02Z", "message": "fix failed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a59ac0d31538fb07e62b89d0ac54e201678606ec", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a59ac0d31538fb07e62b89d0ac54e201678606ec", "committedDate": "2021-02-04T08:05:02Z", "message": "fix failed tests 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4772e3fab25983097bbdba837a512b765d8a8c98", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4772e3fab25983097bbdba837a512b765d8a8c98", "committedDate": "2021-02-04T08:05:02Z", "message": "remove old record impl except withStats extensions\n- add object header to entry costs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e07ebf1b49f82ca43715e15a189fc5a217ad471", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6e07ebf1b49f82ca43715e15a189fc5a217ad471", "committedDate": "2021-02-04T08:05:02Z", "message": "map scan executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2d66a1027d3f94b980c43506cfa8ae1eaf343a2", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f2d66a1027d3f94b980c43506cfa8ae1eaf343a2", "committedDate": "2021-02-04T08:05:02Z", "message": "hasExpired backup, canPrimaryDriveBackup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc9064ba44bcccc54629a520abc0e3c88825618c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bc9064ba44bcccc54629a520abc0e3c88825618c", "committedDate": "2021-02-04T08:05:02Z", "message": "shared methods for record impls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e23e062a5699f9f63a49b63bc2e3175393f72674", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e23e062a5699f9f63a49b63bc2e3175393f72674", "committedDate": "2021-02-04T08:05:02Z", "message": "fix failed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5263299c3f8212e41cfa1abce1c5caabd9da3db2", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5263299c3f8212e41cfa1abce1c5caabd9da3db2", "committedDate": "2021-02-04T08:05:02Z", "message": "fix failed tests 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07d33411d7c0696a50b073369edb3b7c89a653b5", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/07d33411d7c0696a50b073369edb3b7c89a653b5", "committedDate": "2021-02-04T08:05:02Z", "message": "polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69e66b89e0f45bc9e5ce21bd7dc81d33b1a1e1ee", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/69e66b89e0f45bc9e5ce21bd7dc81d33b1a1e1ee", "committedDate": "2021-02-04T08:05:02Z", "message": "remove unneeded stats update from records"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dd5e49bd215d69636ac08447efa2b49c7d130b0", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2dd5e49bd215d69636ac08447efa2b49c7d130b0", "committedDate": "2021-02-04T08:05:02Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac4b65d709273bfbc7999198ef817336aaf36b2c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ac4b65d709273bfbc7999198ef817336aaf36b2c", "committedDate": "2021-02-04T08:05:02Z", "message": "mapDataStore != EMPTY_MAP_DATA_STORE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16734107d9ba933bdccd415768147324f03e2321", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/16734107d9ba933bdccd415768147324f03e2321", "committedDate": "2021-02-04T08:05:02Z", "message": "Object2ObjectHashMap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84e776181df54a920284b6605b7b8a393b7829a5", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/84e776181df54a920284b6605b7b8a393b7829a5", "committedDate": "2021-02-04T08:05:03Z", "message": "fix recordstore#get"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b02a64415ba94b7f141066ac0a15f07e093e61e", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1b02a64415ba94b7f141066ac0a15f07e093e61e", "committedDate": "2021-02-04T08:05:03Z", "message": "Remove serializable from Object2ObjMap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ab3639f724cdbdccff0b3834f74e58eb7f60c2b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3ab3639f724cdbdccff0b3834f74e58eb7f60c2b", "committedDate": "2021-02-04T08:05:03Z", "message": "int version and add version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86fbc5e1c93ae7bc4773057f9108dc821b39e4fe", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/86fbc5e1c93ae7bc4773057f9108dc821b39e4fe", "committedDate": "2021-02-04T08:05:03Z", "message": "fix version test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f59efeda99057d692dcf89470870d20a9afa71ee", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f59efeda99057d692dcf89470870d20a9afa71ee", "committedDate": "2021-02-04T08:05:03Z", "message": "fix check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5059d5567464d135bc4242c7e817452573ab5f55", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5059d5567464d135bc4242c7e817452573ab5f55", "committedDate": "2021-02-04T08:05:03Z", "message": "improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6ef3a5b92abac14cd5621bb38d06811ed73d297", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b6ef3a5b92abac14cd5621bb38d06811ed73d297", "committedDate": "2021-02-04T08:05:03Z", "message": "calculateExpirationTime, pickTtl,pickMaxIdle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "677430d9c05313e34fd5dd59fe78c5f1961d1b20", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/677430d9c05313e34fd5dd59fe78c5f1961d1b20", "committedDate": "2021-02-04T08:05:03Z", "message": "calculateExpirationTime, pickTtl,pickMaxIdle fix overflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17b070425c0533a2f6defd3c2b23f7dd7bb7d96f", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/17b070425c0533a2f6defd3c2b23f7dd7bb7d96f", "committedDate": "2021-02-04T08:05:03Z", "message": "calculateExpirationTime, pickTtl,pickMaxIdle fixes 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e0f116ad0e793d5790ed64c032948f643f1bf8c", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9e0f116ad0e793d5790ed64c032948f643f1bf8c", "committedDate": "2021-02-04T08:05:03Z", "message": "polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9229a0633ac4b9c6b3d8b4ec2b760f186ea56995", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9229a0633ac4b9c6b3d8b4ec2b760f186ea56995", "committedDate": "2021-02-04T08:05:03Z", "message": "desrease test run time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5cdfcfe13f4a626a0e32576a44a857189aafad", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9c5cdfcfe13f4a626a0e32576a44a857189aafad", "committedDate": "2021-02-04T08:05:03Z", "message": "Restrore CHM iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb933f50fce6e273583c4bf5b750c7b36451b2bb", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cb933f50fce6e273583c4bf5b750c7b36451b2bb", "committedDate": "2021-02-04T08:05:03Z", "message": "Polishing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7219f66a1754965614dc7a3bb0eb3ea065184048", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7219f66a1754965614dc7a3bb0eb3ea065184048", "committedDate": "2021-02-04T08:05:03Z", "message": "perf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef31b18c5294ef87ed57491b0a5052bd7f89b029", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ef31b18c5294ef87ed57491b0a5052bd7f89b029", "committedDate": "2021-02-04T08:05:03Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2044096abd1bca50aae80a9b781e6e2442822773", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2044096abd1bca50aae80a9b781e6e2442822773", "committedDate": "2021-02-04T08:05:03Z", "message": "Polishing 5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a37f829cb41519ad38f2fadf50d9afa6cd490e", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/17a37f829cb41519ad38f2fadf50d9afa6cd490e", "committedDate": "2021-02-04T08:05:03Z", "message": "factory ifelse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b81af6ab5288483642084940a9d11e47047fa95a", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b81af6ab5288483642084940a9d11e47047fa95a", "committedDate": "2021-02-04T08:05:03Z", "message": "Zoltan reviews"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a766a9e00d87789a9441e50dad5a18beecdbed7", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2a766a9e00d87789a9441e50dad5a18beecdbed7", "committedDate": "2021-02-04T08:05:03Z", "message": "Zoltan reviews: allow version overflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec1e386239eb0b927a7883ed07b37071ae4505f1", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ec1e386239eb0b927a7883ed07b37071ae4505f1", "committedDate": "2021-02-04T08:05:03Z", "message": "Zoltan reviews: allow version overflow 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8716526d6617d972c2070d8a5d0e13d42a1f4ab8", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8716526d6617d972c2070d8a5d0e13d42a1f4ab8", "committedDate": "2021-02-04T08:05:03Z", "message": "remove duplicate method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93f04bea319f08546e0cbe0b3c3d129b3148c62b", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/93f04bea319f08546e0cbe0b3c3d129b3148c62b", "committedDate": "2021-02-04T08:05:03Z", "message": "remove duplicate method 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b69e5f7fa94a050ba0576921cdafb053f036020", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7b69e5f7fa94a050ba0576921cdafb053f036020", "committedDate": "2021-02-04T08:05:03Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3141525ed2facae64a1bea5b10bd19f61f9e3c8", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f3141525ed2facae64a1bea5b10bd19f61f9e3c8", "committedDate": "2021-02-04T08:05:55Z", "message": "Address Petr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d471c80d1fc0771308f6315bc3869bd7ae58358a", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d471c80d1fc0771308f6315bc3869bd7ae58358a", "committedDate": "2021-02-04T08:06:00Z", "message": "Test failures"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0548fdad21db47c101dff086024bd2bc878771a1", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/0548fdad21db47c101dff086024bd2bc878771a1", "committedDate": "2021-02-03T22:38:35Z", "message": "Test failures"}, "afterCommit": {"oid": "d471c80d1fc0771308f6315bc3869bd7ae58358a", "author": {"user": {"login": "ahmetmircik", "name": "Ahmet Mircik"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d471c80d1fc0771308f6315bc3869bd7ae58358a", "committedDate": "2021-02-04T08:06:00Z", "message": "Test failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgzMTQ1NDg2", "url": "https://github.com/hazelcast/hazelcast/pull/17977#pullrequestreview-583145486", "createdAt": "2021-02-04T08:37:12Z", "commit": {"oid": "d471c80d1fc0771308f6315bc3869bd7ae58358a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3039, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}