{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMTU4MzIz", "number": 17379, "title": "Introduce SQL string functions (#17378)", "bodyText": "This PR introduces the following string functions:\n\nLOWER/UPPER\nCONCAT\nLIKE\nSUBSTRING\nLENGTH\nINITCAP\nASCII\n\nCloses #17378", "createdAt": "2020-08-19T13:17:09Z", "url": "https://github.com/hazelcast/hazelcast/pull/17379", "merged": true, "mergeCommit": {"oid": "600cd78e76777a82a138594a8de6edbc20e8175c"}, "closed": true, "closedAt": "2020-08-21T07:39:47Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 68, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-NFM3AH2gAyNDcwMTU4MzIzOjk3N2MzOGNkNTM1MDQzZjIxMjdkOTAwYjVjYWI2YTY5NjU2Y2YzY2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdA_P0cAFqTQ3MjI0OTM2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/977c38cd535043f2127d900b5cab6a69656cf3cf", "committedDate": "2020-08-12T15:23:50Z", "message": "SQL math expressions (#17339)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "298a55b287a0d68f302eb17d2189e10cb7aa10cc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/298a55b287a0d68f302eb17d2189e10cb7aa10cc", "committedDate": "2020-08-14T06:01:45Z", "message": "Merge branch 'master' into issues/17339\n\n# Conflicts:\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "474282c2fda86b821e4666ea6ada8bff548f4f89", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/474282c2fda86b821e4666ea6ada8bff548f4f89", "committedDate": "2020-08-14T06:35:15Z", "message": "Refactored tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "committedDate": "2020-08-14T06:40:47Z", "message": "ABS tests for negative zero"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "932c75f84fdec229b719bda8067b0db573bebfda", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/932c75f84fdec229b719bda8067b0db573bebfda", "committedDate": "2020-08-14T06:42:31Z", "message": "Removed unnecessary tests for Float.MIN_VALUE and Double.MIN_VALUE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "committedDate": "2020-08-14T06:45:08Z", "message": "Added missing test for numeric literals in single quotes for CEIL/FLOOR tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "committedDate": "2020-08-14T06:51:12Z", "message": "Test for several rows for RAND"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95442d9b91abe7324b404b3fee044505319410ce", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/95442d9b91abe7324b404b3fee044505319410ce", "committedDate": "2020-08-14T07:00:40Z", "message": "Added \"notAny\" to ROUND/TRUNCATE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d466387bbc40ac2977bf76730cb827e30455df61", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d466387bbc40ac2977bf76730cb827e30455df61", "committedDate": "2020-08-14T07:10:09Z", "message": "Fixed inference for double functions (DECIMAL -> DOUBLE) and RAND (DECIMAL -> BIGINT)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "committedDate": "2020-08-14T07:34:58Z", "message": "Fixed SpotBugs problem"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "493b6d471f6c1fa75b02a2de74eb800763df1d97", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/493b6d471f6c1fa75b02a2de74eb800763df1d97", "committedDate": "2020-08-14T08:45:54Z", "message": "Changed operand type inference for double functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "883ec348410adabed42e705bc43486fd47910e34", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/883ec348410adabed42e705bc43486fd47910e34", "committedDate": "2020-08-14T09:02:35Z", "message": "DoubleFunction: removed concrete functions from JavaDoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3111ee9c98418fbbe9a62cf6382f033755058d5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f3111ee9c98418fbbe9a62cf6382f033755058d5", "committedDate": "2020-08-14T11:26:26Z", "message": "Explicit inference for RAND"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71084cebcb6c919e0639a367f33369499f968d0d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/71084cebcb6c919e0639a367f33369499f968d0d", "committedDate": "2020-08-14T11:35:24Z", "message": "Assert types in RoundTruncateFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c400000d1523948822545362cc863d509afeabc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9c400000d1523948822545362cc863d509afeabc", "committedDate": "2020-08-14T11:38:25Z", "message": "Extended tests for RAND"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b76e16d69d95177d08f87bb4efef4f949b83c3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/63b76e16d69d95177d08f87bb4efef4f949b83c3", "committedDate": "2020-08-14T11:40:12Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "committedDate": "2020-08-14T12:16:16Z", "message": "Added lenght overflow handling to ROUND/TRUNCATE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfaecc359d9ca7ccc76f148ea7149796ceb862f7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/dfaecc359d9ca7ccc76f148ea7149796ceb862f7", "committedDate": "2020-08-15T07:48:45Z", "message": "Merge branch 'master' into issues/17339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b2cf5f249013cf53d34b8d63625624de1cde5ca", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6b2cf5f249013cf53d34b8d63625624de1cde5ca", "committedDate": "2020-08-15T14:28:58Z", "message": "Predicates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9654d668ef107bd5a3b7d1dccdcfe4efb8948e4e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9654d668ef107bd5a3b7d1dccdcfe4efb8948e4e", "committedDate": "2020-08-17T07:09:41Z", "message": "WIP on tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87bfbdc0702a4b8a10739e64f7f922ccbea4d998", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/87bfbdc0702a4b8a10739e64f7f922ccbea4d998", "committedDate": "2020-08-17T07:32:01Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a70841209bd9c914591e087d5467c0eb9cefb667", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a70841209bd9c914591e087d5467c0eb9cefb667", "committedDate": "2020-08-17T09:27:59Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c857ffa974be0181e3f3f72daefa547ad8e694a2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c857ffa974be0181e3f3f72daefa547ad8e694a2", "committedDate": "2020-08-17T10:56:10Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d78551ec10c434ec481669e5c111daf3fddd895", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5d78551ec10c434ec481669e5c111daf3fddd895", "committedDate": "2020-08-17T11:39:41Z", "message": "SUBSTRING ready"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfaaf2843c0cf50137ed752805a1eea8cddd82bb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/dfaaf2843c0cf50137ed752805a1eea8cddd82bb", "committedDate": "2020-08-19T13:06:39Z", "message": "IDs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2125ed36b764146a68f872b9f58826aa90eaefad", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2125ed36b764146a68f872b9f58826aa90eaefad", "committedDate": "2020-08-19T13:08:47Z", "message": "Merge branch 'master' into sql-string-exp\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b828911b95c636c4b27c19b9b889dd180bb0d7f5", "committedDate": "2020-08-19T14:03:12Z", "message": "SUID for LikeFunction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjczNTg0", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471273584", "createdAt": "2020-08-20T06:14:02Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNDowMlrOHDsbZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNDowMlrOHDsbZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNTY4NQ==", "bodyText": "notAny", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473635685", "createdAt": "2020-08-20T06:14:02Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -337,6 +341,59 @@\n \n     //#endregion\n \n+    //#region String functions\n+\n+    public static final SqlBinaryOperator CONCAT = new SqlBinaryOperator(\n+        \"||\",\n+        SqlKind.OTHER,\n+        60,\n+        true,\n+        ReturnTypes.DYADIC_STRING_SUM_PRECISION_NULLABLE,\n+        HazelcastInferTypes.VARCHAR_IF_UNKNOWN,\n+        OperandTypes.STRING_SAME_SAME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjczODM4", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471273838", "createdAt": "2020-08-20T06:14:40Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNDo0MFrOHDscsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNDo0MFrOHDscsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNjAxNg==", "bodyText": "precedence", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473636016", "createdAt": "2020-08-20T06:14:40Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlLikeOperator.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlSpecialOperator;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+public class HazelcastSqlLikeOperator extends SqlSpecialOperator {\n+\n+    private static final int PRECISION = 32;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjczOTA1", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471273905", "createdAt": "2020-08-20T06:14:49Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNDo0OVrOHDsdKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNDo0OVrOHDsdKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNjEzNw==", "bodyText": "notAny", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473636137", "createdAt": "2020-08-20T06:14:49Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlLikeOperator.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlSpecialOperator;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+public class HazelcastSqlLikeOperator extends SqlSpecialOperator {\n+\n+    private static final int PRECISION = 32;\n+\n+    public HazelcastSqlLikeOperator() {\n+        super(\n+            \"LIKE\",\n+            SqlKind.LIKE,\n+            PRECISION,\n+            false,\n+            ReturnTypes.BOOLEAN_NULLABLE,\n+            new ReplaceUnknownOperandTypeInference(SqlTypeName.VARCHAR),\n+            null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjc0OTk5", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471274999", "createdAt": "2020-08-20T06:17:16Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNzoxNlrOHDsjuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxNzoxNlrOHDsjuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNzgxOQ==", "bodyText": "notAny", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473637819", "createdAt": "2020-08-20T06:17:16Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlStringFunction.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+\n+public class HazelcastSqlStringFunction extends SqlFunction {\n+    public HazelcastSqlStringFunction(String name, SqlReturnTypeInference returnTypeInference) {\n+        super(\n+            name,\n+            SqlKind.OTHER_FUNCTION,\n+            returnTypeInference,\n+            HazelcastInferTypes.VARCHAR_IF_UNKNOWN,\n+            OperandTypes.CHARACTER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjc1NDEz", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471275413", "createdAt": "2020-08-20T06:18:12Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxODoxMlrOHDsmPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoxODoxMlrOHDsmPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzODQ2Mg==", "bodyText": "notAny", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473638462", "createdAt": "2020-08-20T06:18:12Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlSubstringFunction.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.linq4j.Ord;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.type.FamilyOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.List;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+\n+public class HazelcastSqlSubstringFunction extends SqlFunction {\n+    public HazelcastSqlSubstringFunction() {\n+        super(\n+            \"SUBSTRING\",\n+            SqlKind.OTHER_FUNCTION,\n+            ReturnTypes.ARG0_NULLABLE_VARYING,\n+            new ReplaceUnknownOperandTypeInference(new SqlTypeName[] { VARCHAR, INTEGER, INTEGER }),\n+            null,\n+            SqlFunctionCategory.STRING\n+        );\n+    }\n+\n+    @Override\n+    public String getSignatureTemplate(int operandsCount) {\n+        switch (operandsCount) {\n+            case 2:\n+                return \"{0}({1} FROM {2})\";\n+            case 3:\n+                return \"{0}({1} FROM {2} FOR {3})\";\n+            default:\n+                throw new AssertionError();\n+        }\n+    }\n+\n+    @Override\n+    public String getAllowedSignatures(String opName) {\n+        StringBuilder ret = new StringBuilder();\n+        for (Ord<SqlTypeName> typeName : Ord.zip(SqlTypeName.CHAR_TYPES)) {\n+            if (typeName.i > 0) {\n+                ret.append(NL);\n+            }\n+\n+            ret.append(\n+                SqlUtil.getAliasedSignature(this, opName, ImmutableList.of(typeName.e, SqlTypeName.INTEGER))\n+            );\n+            ret.append(NL);\n+            ret.append(\n+                SqlUtil.getAliasedSignature(this, opName, ImmutableList.of(typeName.e, SqlTypeName.INTEGER, SqlTypeName.INTEGER))\n+            );\n+        }\n+        return ret.toString();\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjc5MDM1", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471279035", "createdAt": "2020-08-20T06:26:12Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoyNjoxMlrOHDs74g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjoyNjoxMlrOHDs74g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY0NDAwMg==", "bodyText": ".equals?", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473644002", "createdAt": "2020-08-20T06:26:12Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastInferTypes.java", "diffHunk": "@@ -81,6 +81,18 @@\n         }\n     };\n \n+    public static final SqlOperandTypeInference VARCHAR_IF_UNKNOWN = (callBinding, returnType, operandTypes) -> {\n+        RelDataType unknownType = callBinding.getTypeFactory().createUnknownType();\n+\n+        for (int i = 0; i < operandTypes.length; i++) {\n+            RelDataType operandType = operandTypes[i];\n+\n+            if (operandType == unknownType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a01e16bd9b3450ef82536e461db30bb9017f1bc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6a01e16bd9b3450ef82536e461db30bb9017f1bc", "committedDate": "2020-08-20T06:35:03Z", "message": "WIP on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/03e7d2db16ccae3341710b34cec000554d079d43", "committedDate": "2020-08-20T06:35:55Z", "message": "Adjusted type IDs to simplify merge with indexes PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjg1NDgx", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471285481", "createdAt": "2020-08-20T06:37:52Z", "commit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjozNzo1MlrOHDtdsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjozNzo1MlrOHDtdsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MjY1Nw==", "bodyText": "that's not ascii, that's unicode code point", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473652657", "createdAt": "2020-08-20T06:37:52Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {\n+        // TODO: Validate the implementation against ANSI.\n+        if (source == null || startPos == null || length == null) {\n+            return null;\n+        }\n+\n+        int sourceLength = source.length();\n+\n+        if (startPos < 0) {\n+            startPos += sourceLength + 1;\n+        }\n+\n+        int endPos = startPos + length;\n+\n+        if (endPos < startPos) {\n+            throw QueryException.error(\"End position is less than start position.\");\n+        }\n+\n+        if (startPos > sourceLength || endPos < 1) {\n+            return \"\";\n+        }\n+\n+        int startPos0 = Math.max(startPos, 1);\n+        int endPos0 = Math.min(endPos, sourceLength + 1);\n+\n+        return source.substring(startPos0 - 1, endPos0 - 1);\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjg5MjYw", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471289260", "createdAt": "2020-08-20T06:45:31Z", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo0NTozMVrOHDt0Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo0NTozMVrOHDt0Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1ODM4Mg==", "bodyText": "if at least one operand is null, it should return null", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473658382", "createdAt": "2020-08-20T06:45:31Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjkxNzA0", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471291704", "createdAt": "2020-08-20T06:50:22Z", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo1MDoyMlrOHDuCrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo1MDoyMlrOHDuCrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2MjEyNQ==", "bodyText": "if escape was provided and its value is null, it should return null", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473662125", "createdAt": "2020-08-20T06:50:22Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape = operand3 != null ? asVarchar(operand3, row, context) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjkzMzA3", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471293307", "createdAt": "2020-08-20T06:53:25Z", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo1MzoyNVrOHDuL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo1MzoyNVrOHDuL8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NDQ5Nw==", "bodyText": "never used", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473664497", "createdAt": "2020-08-20T06:53:25Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjkzMzUz", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471293353", "createdAt": "2020-08-20T06:53:31Z", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo1MzozMVrOHDuMOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo1MzozMVrOHDuMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NDU2OQ==", "bodyText": "never used", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473664569", "createdAt": "2020-08-20T06:53:31Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "571f47ec6ddf8c9d19bc8d3b64fcfc6b9871160c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/571f47ec6ddf8c9d19bc8d3b64fcfc6b9871160c", "committedDate": "2020-08-20T07:08:41Z", "message": "Remove leftovers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf96a792b021e758f55a09c628d72d04b8d98594", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bf96a792b021e758f55a09c628d72d04b8d98594", "committedDate": "2020-08-20T07:08:52Z", "message": "Return NULL if LIKE ESCAPE is NULL"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzA0Njg3", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471304687", "createdAt": "2020-08-20T07:13:37Z", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoxMzozN1rOHDvK3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoxMzozN1rOHDvK3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MDYwNA==", "bodyText": "why title case and not upper case?", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473680604", "createdAt": "2020-08-20T07:13:37Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {\n+        // TODO: Validate the implementation against ANSI.\n+        if (source == null || startPos == null || length == null) {\n+            return null;\n+        }\n+\n+        int sourceLength = source.length();\n+\n+        if (startPos < 0) {\n+            startPos += sourceLength + 1;\n+        }\n+\n+        int endPos = startPos + length;\n+\n+        if (endPos < startPos) {\n+            throw QueryException.error(\"End position is less than start position.\");\n+        }\n+\n+        if (startPos > sourceLength || endPos < 1) {\n+            return \"\";\n+        }\n+\n+        int startPos0 = Math.max(startPos, 1);\n+        int endPos0 = Math.min(endPos, sourceLength + 1);\n+\n+        return source.substring(startPos0 - 1, endPos0 - 1);\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;\n+    }\n+\n+    public static String upper(String value) {\n+        return value != null ? value.toUpperCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String lower(String value) {\n+        return value != null ? value.toLowerCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String initcap(String value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (value.isEmpty()) {\n+            return value;\n+        }\n+\n+        int strLen = value.length();\n+\n+        StringBuilder res = new StringBuilder(strLen);\n+\n+        boolean capitalizeNext = true;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            char c = value.charAt(i);\n+\n+            if (Character.isWhitespace(c)) {\n+                res.append(c);\n+\n+                capitalizeNext = true;\n+            } else if (capitalizeNext) {\n+                res.append(Character.toTitleCase(c));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzA1NjU2", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471305656", "createdAt": "2020-08-20T07:15:19Z", "commit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoxNToxOVrOHDvQZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoxNToxOVrOHDvQZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MjAyMw==", "bodyText": "upper case letters should be lowercased if they are not starting a word", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473682023", "createdAt": "2020-08-20T07:15:19Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {\n+        // TODO: Validate the implementation against ANSI.\n+        if (source == null || startPos == null || length == null) {\n+            return null;\n+        }\n+\n+        int sourceLength = source.length();\n+\n+        if (startPos < 0) {\n+            startPos += sourceLength + 1;\n+        }\n+\n+        int endPos = startPos + length;\n+\n+        if (endPos < startPos) {\n+            throw QueryException.error(\"End position is less than start position.\");\n+        }\n+\n+        if (startPos > sourceLength || endPos < 1) {\n+            return \"\";\n+        }\n+\n+        int startPos0 = Math.max(startPos, 1);\n+        int endPos0 = Math.min(endPos, sourceLength + 1);\n+\n+        return source.substring(startPos0 - 1, endPos0 - 1);\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;\n+    }\n+\n+    public static String upper(String value) {\n+        return value != null ? value.toUpperCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String lower(String value) {\n+        return value != null ? value.toLowerCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String initcap(String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03e7d2db16ccae3341710b34cec000554d079d43"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2c7927a1e78d7f0e656e88a7073c08315eb4607", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e2c7927a1e78d7f0e656e88a7073c08315eb4607", "committedDate": "2020-08-20T07:44:14Z", "message": "Lowercase non-title characters for INITCAP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dab533ac3628b139b36fa06814602a8c4eba960", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2dab533ac3628b139b36fa06814602a8c4eba960", "committedDate": "2020-08-20T07:48:05Z", "message": "Return NULL for if one of CONCAT arguments is NULL"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzQ3OTgx", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471347981", "createdAt": "2020-08-20T07:50:54Z", "commit": {"oid": "e2c7927a1e78d7f0e656e88a7073c08315eb4607"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo1MDo1NVrOHDxk6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo1MDo1NVrOHDxk6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyMDA0MQ==", "bodyText": "if start was provided and its value is null, it should return null", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473720041", "createdAt": "2020-08-20T07:50:55Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2c7927a1e78d7f0e656e88a7073c08315eb4607"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzQ4Mjkw", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471348290", "createdAt": "2020-08-20T07:51:20Z", "commit": {"oid": "e2c7927a1e78d7f0e656e88a7073c08315eb4607"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo1MToyMFrOHDxnBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo1MToyMFrOHDxnBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyMDU4MQ==", "bodyText": "if length was provided and its value is null, it should return null", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473720581", "createdAt": "2020-08-20T07:51:20Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;\n+        } else if (start < 1) {\n+            // Different databases provide different semantics on negative values. Oracle start counting\n+            // from the end, SQL Server starts from the beginning, and uses the value to calculate the\n+            // final length, etc.\n+            // These semantics are pretty complicated, so wi disallow it completely.\n+            throw QueryException.dataException(\"SUBSTRING \\\"start\\\" operand must be positive\");\n+        }\n+\n+        // In SQL start position is 1-based. Convert it to 0-based for Java.\n+        int adjustedStart = start - 1;\n+\n+        if (adjustedStart > input.length()) {\n+            // Start position is beyond the string length, e.g. SUBSTRING(\"abc\", 4)\n+            return \"\";\n+        }\n+\n+        Integer length = operand3 != null ? MathFunctionUtils.asInt(operand3, row, context) : null;\n+\n+        if (length == null) {\n+            // Length is not specified, just cut from the start\n+            return adjustedStart > 0 ? input.substring(adjustedStart) : input;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2c7927a1e78d7f0e656e88a7073c08315eb4607"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37f0ac6b7b8fb8fbe440400f71d934f7044ee78b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/37f0ac6b7b8fb8fbe440400f71d934f7044ee78b", "committedDate": "2020-08-20T07:58:00Z", "message": "Return NULL if any of SUBSTRING arguments are NULL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "committedDate": "2020-08-20T08:44:23Z", "message": "Merge branch 'master' into issues/17378"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNDUwNzg2", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471450786", "createdAt": "2020-08-20T10:11:11Z", "commit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTYyMjMw", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471562230", "createdAt": "2020-08-20T12:52:07Z", "commit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo1MjowN1rOHD_VJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzoyNzozNFrOHEA60A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0NTM4Mw==", "bodyText": "Is it possible for substring to have 1 argument?", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473945383", "createdAt": "2020-08-20T12:52:07Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -266,6 +292,26 @@ private RexToExpression() {\n                     );\n                 }\n \n+                // Strings.\n+\n+                if (function == CHAR_LENGTH || function == CHARACTER_LENGTH || function == LENGTH) {\n+                    return CharLengthFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.UPPER) {\n+                    return UpperFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.LOWER) {\n+                    return LowerFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.INITCAP) {\n+                    return InitcapFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.ASCII) {\n+                    return AsciiFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.SUBSTRING) {\n+                    Expression<?> input = operands[0];\n+                    Expression<?> start = operands.length > 1 ? operands[1] : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDc0Nw==", "bodyText": "Maybe we should include the original exception in the message. The user won't see the cause, i wonder if it will even be in the member logs.\nAlso I couldn't find a test for this scenario.\n\"NPE on\" -> \"NPE in\"", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473950747", "createdAt": "2020-08-20T13:00:50Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MTYxMA==", "bodyText": "Maybe we should name this StringFunctionUtils - everything else in this package uses \"function\", there's also MathFunctionUtils", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473951610", "createdAt": "2020-08-20T13:02:16Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MzEyNw==", "bodyText": "SUBSTRING(this, 1, 1) syntax is also valid, shouldn't we test it? I guess after calcite parsing it's the same for us...", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473953127", "createdAt": "2020-08-20T13:04:46Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/string/SubstringFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@SuppressWarnings(\"SpellCheckingInspection\")\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class SubstringFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n+    @Test\n+    public void test_input() {\n+        // String column\n+        put(\"abcde\");\n+        checkValueInternal(\"SELECT SUBSTRING(this FROM 1) FROM map\", SqlColumnType.VARCHAR, \"abcde\");\n+        checkValueInternal(\"SELECT SUBSTRING(this FROM 1 FOR 1) FROM map\", SqlColumnType.VARCHAR, \"a\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NTg5Ng==", "bodyText": "This line is not covered by integration test. Actually I can't figure out how can you pass null operand2.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473955896", "createdAt": "2020-08-20T13:09:19Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start;\n+\n+        if (operand2 != null) {\n+            start = MathFunctionUtils.asInt(operand2, row, context);\n+\n+            if (start == null) {\n+                return null;\n+            }\n+        } else {\n+            start = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1Njg0Mg==", "bodyText": "This can be >=", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473956842", "createdAt": "2020-08-20T13:10:48Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start;\n+\n+        if (operand2 != null) {\n+            start = MathFunctionUtils.asInt(operand2, row, context);\n+\n+            if (start == null) {\n+                return null;\n+            }\n+        } else {\n+            start = null;\n+        }\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;\n+        } else if (start < 1) {\n+            // Different databases provide different semantics on negative values. Oracle start counting\n+            // from the end, SQL Server starts from the beginning, and uses the value to calculate the\n+            // final length, etc.\n+            // These semantics are pretty complicated, so wi disallow it completely.\n+            throw QueryException.dataException(\"SUBSTRING \\\"start\\\" operand must be positive\");\n+        }\n+\n+        // In SQL start position is 1-based. Convert it to 0-based for Java.\n+        int adjustedStart = start - 1;\n+\n+        if (adjustedStart > input.length()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1ODM5NQ==", "bodyText": "The start == 0 case is handled again in String.substring:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return adjustedStart > 0 ? input.substring(adjustedStart) : input;\n          \n          \n            \n                        return input.substring(adjustedStart);\n          \n      \n    \n    \n  \n\nAgain on line 114", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473958395", "createdAt": "2020-08-20T13:13:27Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start;\n+\n+        if (operand2 != null) {\n+            start = MathFunctionUtils.asInt(operand2, row, context);\n+\n+            if (start == null) {\n+                return null;\n+            }\n+        } else {\n+            start = null;\n+        }\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;\n+        } else if (start < 1) {\n+            // Different databases provide different semantics on negative values. Oracle start counting\n+            // from the end, SQL Server starts from the beginning, and uses the value to calculate the\n+            // final length, etc.\n+            // These semantics are pretty complicated, so wi disallow it completely.\n+            throw QueryException.dataException(\"SUBSTRING \\\"start\\\" operand must be positive\");\n+        }\n+\n+        // In SQL start position is 1-based. Convert it to 0-based for Java.\n+        int adjustedStart = start - 1;\n+\n+        if (adjustedStart > input.length()) {\n+            // Start position is beyond the string length, e.g. SUBSTRING(\"abc\", 4)\n+            return \"\";\n+        }\n+\n+        Integer length;\n+\n+        if (operand3 != null) {\n+            length = MathFunctionUtils.asInt(operand3, row, context);\n+\n+            if (length == null) {\n+                return null;\n+            }\n+        } else {\n+            length = null;\n+        }\n+\n+        if (length == null) {\n+            // Length is not specified, just cut from the start\n+            return adjustedStart > 0 ? input.substring(adjustedStart) : input;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2ODIwOA==", "bodyText": "We should capitalize not only after whitespace, but also after any non-letter. Oracle, Postgresql, do this, mysql and mssql don't have this function.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473968208", "createdAt": "2020-08-20T13:24:33Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return first != null && second != null ? first + \"\" + second : null;\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;\n+    }\n+\n+    public static String upper(String value) {\n+        return value != null ? value.toUpperCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String lower(String value) {\n+        return value != null ? value.toLowerCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String initcap(String value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (value.isEmpty()) {\n+            return value;\n+        }\n+\n+        int strLen = value.length();\n+\n+        StringBuilder res = new StringBuilder(strLen);\n+\n+        boolean capitalizeNext = true;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            char c = value.charAt(i);\n+\n+            if (Character.isWhitespace(c)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3MTQwOA==", "bodyText": "Why the + \"\" +?", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473971408", "createdAt": "2020-08-20T13:27:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return first != null && second != null ? first + \"\" + second : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNjE3NzY2", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471617766", "createdAt": "2020-08-20T13:32:44Z", "commit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzozMjo0NFrOHEBQNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzo1NjozNFrOHEC3BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3Njg4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw QueryException.error(\"Escape parameter should be a single character: \" + escape);\n          \n          \n            \n                                throw QueryException.error(\"ESCAPE parameter must be a single character: \" + escape);\n          \n      \n    \n    \n  \n\nWe can also leak user data to error logs by including the value.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473976887", "createdAt": "2020-08-20T13:32:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n+                return lastJavaPattern;\n+            }\n+\n+            String javaPatternStr = constructJavaPatternString(pattern, escape);\n+            Pattern javaPattern = Pattern.compile(javaPatternStr);\n+\n+            lastPattern = pattern;\n+            lastEscape = escape;\n+            lastJavaPattern = javaPattern;\n+\n+            return javaPattern;\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+        private static String constructJavaPatternString(String pattern, String escape) {\n+            // Get the escape character.\n+            Character escapeChar;\n+\n+            if (escape != null) {\n+                if (escape.length() != 1) {\n+                    throw QueryException.error(\"Escape parameter should be a single character: \" + escape);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk5ODY5MQ==", "bodyText": "- isn't a top-level special char, only inside of [] or {}.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473998691", "createdAt": "2020-08-20T13:52:28Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwMTExMg==", "bodyText": "We enable DOTALL mode for .*, but not for .. Why not for both?\nIf we'll do it for both, we can instead pass the DOTALL flag to Pattern.compile and save some parsing time.\nAlso we miss tests for matching newlines.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474001112", "createdAt": "2020-08-20T13:54:43Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwMzIwNQ==", "bodyText": "Why don't we use the term \"regex\"?\n\nescaping in Java -> escaping in regex\nconvertToJavaPattern -> convertToRegex\nlastJavaPattern -> lastRegex\n\netc.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474003205", "createdAt": "2020-08-20T13:56:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNjQ2MDQw", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471646040", "createdAt": "2020-08-20T14:02:23Z", "commit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowMjoyM1rOHEDHVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxMTo1OVrOHEDhTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwNzM4Mw==", "bodyText": "If pattern = \"(_\" and escape = \"(\", we'll produce the regex \\_ - the non-special _ will be unnecessarily escaped. This happens when the escape character is one of the regex special characters.\nWhile I couldn't find any case where this is an issue (in regex you can unnecessarily escape any character), seems weird to produce such output.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474007383", "createdAt": "2020-08-20T14:02:23Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n+                return lastJavaPattern;\n+            }\n+\n+            String javaPatternStr = constructJavaPatternString(pattern, escape);\n+            Pattern javaPattern = Pattern.compile(javaPatternStr);\n+\n+            lastPattern = pattern;\n+            lastEscape = escape;\n+            lastJavaPattern = javaPattern;\n+\n+            return javaPattern;\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+        private static String constructJavaPatternString(String pattern, String escape) {\n+            // Get the escape character.\n+            Character escapeChar;\n+\n+            if (escape != null) {\n+                if (escape.length() != 1) {\n+                    throw QueryException.error(\"Escape parameter should be a single character: \" + escape);\n+                }\n+\n+                escapeChar = escape.charAt(0);\n+            } else {\n+                escapeChar = null;\n+            }\n+\n+            // Main logic.\n+            StringBuilder javaPattern = new StringBuilder();\n+\n+            int i;\n+\n+            for (i = 0; i < pattern.length(); i++) {\n+                char patternChar = pattern.charAt(i);\n+\n+                // Escape special character as needed.\n+                if (ESCAPE_CHARACTERS_JAVA.indexOf(patternChar) >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwOTA1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return QueryException.error(\"Only '_' or '%' pattern wildcards could be escaped\");\n          \n          \n            \n                        return QueryException.error(\"Only '_', '%' and the escape character can be escaped\");", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474009050", "createdAt": "2020-08-20T14:04:46Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n+                return lastJavaPattern;\n+            }\n+\n+            String javaPatternStr = constructJavaPatternString(pattern, escape);\n+            Pattern javaPattern = Pattern.compile(javaPatternStr);\n+\n+            lastPattern = pattern;\n+            lastEscape = escape;\n+            lastJavaPattern = javaPattern;\n+\n+            return javaPattern;\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+        private static String constructJavaPatternString(String pattern, String escape) {\n+            // Get the escape character.\n+            Character escapeChar;\n+\n+            if (escape != null) {\n+                if (escape.length() != 1) {\n+                    throw QueryException.error(\"Escape parameter should be a single character: \" + escape);\n+                }\n+\n+                escapeChar = escape.charAt(0);\n+            } else {\n+                escapeChar = null;\n+            }\n+\n+            // Main logic.\n+            StringBuilder javaPattern = new StringBuilder();\n+\n+            int i;\n+\n+            for (i = 0; i < pattern.length(); i++) {\n+                char patternChar = pattern.charAt(i);\n+\n+                // Escape special character as needed.\n+                if (ESCAPE_CHARACTERS_JAVA.indexOf(patternChar) >= 0) {\n+                    javaPattern.append('\\\\');\n+                }\n+\n+                if (escapeChar != null && patternChar == escapeChar) {\n+                    if (i == (pattern.length() - 1)) {\n+                        throw escapeWildcardsOnly();\n+                    }\n+\n+                    char nextPatternChar = pattern.charAt(i + 1);\n+\n+                    if ((nextPatternChar == ONE_SQL) || (nextPatternChar == MANY_SQL) || (nextPatternChar == escapeChar)) {\n+                        javaPattern.append(nextPatternChar);\n+\n+                        i++;\n+                    } else {\n+                        throw escapeWildcardsOnly();\n+                    }\n+                } else if (patternChar == ONE_SQL) {\n+                    javaPattern.append(ONE_JAVA);\n+                } else if (patternChar == MANY_SQL) {\n+                    javaPattern.append(MANY_JAVA);\n+                } else {\n+                    javaPattern.append(patternChar);\n+                }\n+            }\n+\n+            return javaPattern.toString();\n+        }\n+\n+        private static QueryException escapeWildcardsOnly() {\n+            return QueryException.error(\"Only '_' or '%' pattern wildcards could be escaped\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTYyOA==", "bodyText": "We can create the state immediately in constructor and don't need this branching.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474011628", "createdAt": "2020-08-20T14:08:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNDAyOA==", "bodyText": "The first condition isn't needed: pattern is always not null here (we can assert it). If pattern.equals(lastPattern) it means that we've already been here and lastJavaPattern is also not null.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n          \n          \n            \n                        if (Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474014028", "createdAt": "2020-08-20T14:11:59Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNjY3MDg1", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-471667085", "createdAt": "2020-08-20T14:24:14Z", "commit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoyNDoxNFrOHEED7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoyOTo1M1rOHEEVcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyMjg5NA==", "bodyText": "This also works:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    check(\"this || ?\", null, new Object[] { null });\n          \n          \n            \n                    check(\"this || ?\", null, (Object) null);", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474022894", "createdAt": "2020-08-20T14:24:14Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/string/ConcatFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionBiValue;\n+import com.hazelcast.sql.support.expressions.ExpressionType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BIG_DECIMAL;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BIG_INTEGER;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BOOLEAN;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BYTE;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.DOUBLE;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.FLOAT;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.INTEGER;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.LONG;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.SHORT;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ConcatFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n+    @Test\n+    public void test_literal() {\n+        put(\"1\");\n+\n+        check(\"this || 2\", \"12\");\n+        check(\"this || '2'\", \"12\");\n+        check(\"this || 2e0\", \"12.0\");\n+\n+        check(\"this || true\", \"1true\");\n+\n+        check(\"this || null\", null);\n+        check(\"null || null\", null);\n+\n+        check(\"1 || 2\", \"12\");\n+        check(\"'1' || '2'\", \"12\");\n+    }\n+\n+    @Test\n+    public void test_parameter() {\n+        put(\"1\");\n+\n+        check(\"this || ?\", \"12\", \"2\");\n+        check(\"this || ?\", \"12\", '2');\n+        check(\"this || ?\", null, new Object[] { null });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyNzM3OA==", "bodyText": "We can add these tests:\ncheckColumn(new DoubleVal().field1(Double.NaN), \"Nan\");\ncheckColumn(new DoubleVal().field1(Double.NEGATIVE_INFINITY), \"-Infinity\");\nThe second one currently fails, but should not.", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474027378", "createdAt": "2020-08-20T14:29:53Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/string/InitcapFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.ByteVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.CharacterVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.IntegerVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.LongVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.ShortVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.StringVal;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.BigDecimalVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.BigIntegerVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.DoubleVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.FloatVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.ObjectVal;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class InitcapFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n+    @Test\n+    public void test_column() {\n+        checkColumn(new StringVal(), null);\n+        checkColumn(new StringVal().field1(\"fiRst\"), \"First\");\n+        checkColumn(new StringVal().field1(\"fiRst seCond\"), \"First Second\");\n+\n+        checkColumn(new CharacterVal().field1('a'), \"A\");\n+\n+        checkColumn(new ByteVal().field1((byte) 100), \"100\");\n+        checkColumn(new ShortVal().field1((short) 100), \"100\");\n+        checkColumn(new IntegerVal().field1(100), \"100\");\n+        checkColumn(new LongVal().field1((long) 100), \"100\");\n+        checkColumn(new BigIntegerVal().field1(new BigInteger(\"100\")), \"100\");\n+        checkColumn(new BigDecimalVal().field1(new BigDecimal(\"100.5\")), \"100.5\");\n+        checkColumn(new FloatVal().field1(100.5f), Float.toString(100.5f));\n+        checkColumn(new DoubleVal().field1(100.5d), Double.toString(100.5d));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c869c8996a970ea7d51e919890696763c1ecac50", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c869c8996a970ea7d51e919890696763c1ecac50", "committedDate": "2020-08-20T18:51:16Z", "message": "Remove leftover in concat implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1434d937e8d9f98c7429fa672993a77693999b87", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1434d937e8d9f98c7429fa672993a77693999b87", "committedDate": "2020-08-20T18:54:53Z", "message": "Include error text to the exception in SubstringFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daaa6666e7f4aaa67ed957e0113202c565059d82", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/daaa6666e7f4aaa67ed957e0113202c565059d82", "committedDate": "2020-08-20T18:56:59Z", "message": "StringExpressionUtils -> StringFunctionUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e3e6fcc8a73b446e02f323dfd546d7ab5fa821d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/3e3e6fcc8a73b446e02f323dfd546d7ab5fa821d", "committedDate": "2020-08-20T19:15:11Z", "message": "Tests for SUBSTRING(x,y,z)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77b2c2f19e8e2435fc686e0215cfd275cf7322e6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/77b2c2f19e8e2435fc686e0215cfd275cf7322e6", "committedDate": "2020-08-20T19:17:08Z", "message": "\">=\" instead of \">\" when checking for string overflow in SUBSTRING"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b01526f230f46d0b9cce59610696ecd8ff63fd1", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4b01526f230f46d0b9cce59610696ecd8ff63fd1", "committedDate": "2020-08-20T19:22:46Z", "message": "INITCAP: capitalize after any non-letter/digit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67200f6ab9dc0e1407051b1e631aa63400bcfb50", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/67200f6ab9dc0e1407051b1e631aa63400bcfb50", "committedDate": "2020-08-20T19:24:57Z", "message": "Exception wording in LIKE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58c6e639b5a0322a041afbc22b86696dff1a079a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/58c6e639b5a0322a041afbc22b86696dff1a079a", "committedDate": "2020-08-20T19:25:52Z", "message": "Do not leak faulty ESCAPE value to logs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c5972ea11c58da1cb145c16a8ddbe820c5d5614", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8c5972ea11c58da1cb145c16a8ddbe820c5d5614", "committedDate": "2020-08-20T19:30:17Z", "message": "Removed unnecessary condition in LIKE function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f030d3d7a79d2ec2ca7a6b54770e45dec61587c6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f030d3d7a79d2ec2ca7a6b54770e45dec61587c6", "committedDate": "2020-08-20T19:31:58Z", "message": "LIKE exceptions wording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a26fc6962a53f7afefb071f059a1a2839ff422e5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a26fc6962a53f7afefb071f059a1a2839ff422e5", "committedDate": "2020-08-20T19:44:01Z", "message": "LIKE function:\n1) Use DOTALL for both SQL patterns\n2) Add tests for the new line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "939d0a007f0bb858bd0f9c953abbab5bedd64fa0", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/939d0a007f0bb858bd0f9c953abbab5bedd64fa0", "committedDate": "2020-08-20T19:48:05Z", "message": "Do not escape minus"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjQ5MzY3", "url": "https://github.com/hazelcast/hazelcast/pull/17379#pullrequestreview-472249367", "createdAt": "2020-08-21T06:58:32Z", "commit": {"oid": "939d0a007f0bb858bd0f9c953abbab5bedd64fa0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3407, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}