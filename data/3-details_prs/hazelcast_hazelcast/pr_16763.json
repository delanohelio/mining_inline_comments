{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5Njg2ODY4", "number": 16763, "title": "SQL: Base executor and row interfaces (#16762)", "bodyText": "Design details could be found in the #16762 description. A design document will be created in a separate PR.\nCloses #16762", "createdAt": "2020-03-17T08:09:48Z", "url": "https://github.com/hazelcast/hazelcast/pull/16763", "merged": true, "mergeCommit": {"oid": "5513b6a18ab4c65c37c2993cf1aea0430e0509f3"}, "closed": true, "closedAt": "2020-03-25T12:51:03Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMjg0jAH2gAyMzg5Njg2ODY4OjI0YWQ3MjMxYzZhNzE3NGUyZTU2NjQ3NWJjYzU5MTIwZTQ1YTUxZTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRFeWMAFqTM4MTA0NjQ3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/24ad7231c6a7174e2e566475bcc59120e45a51e6", "committedDate": "2020-03-11T09:15:42Z", "message": "SQL type system."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a05a318f3348ceb1b50e0df94515ed5e5b81c74", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4a05a318f3348ceb1b50e0df94515ed5e5b81c74", "committedDate": "2020-03-11T11:35:52Z", "message": "WIP on tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a37c3a7f6bf83c2fda80556ac42fa38ee0a126cd", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a37c3a7f6bf83c2fda80556ac42fa38ee0a126cd", "committedDate": "2020-03-11T11:50:57Z", "message": "Heap row"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dff1b6ec3a720413698d86366ac96491aaccd17", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9dff1b6ec3a720413698d86366ac96491aaccd17", "committedDate": "2020-03-11T12:00:01Z", "message": "JoinRow tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "710ee92b553ca7cfb78395a5f22824fee76e549d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/710ee92b553ca7cfb78395a5f22824fee76e549d", "committedDate": "2020-03-11T16:36:20Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94859e9a37035c84c305ad8083e7e472e3ae983d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/94859e9a37035c84c305ad8083e7e472e3ae983d", "committedDate": "2020-03-11T16:44:24Z", "message": "AbstractExec test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40878714ccfb7ef81c7e46f2fc444e2c4cd53d4c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/40878714ccfb7ef81c7e46f2fc444e2c4cd53d4c", "committedDate": "2020-03-11T17:34:35Z", "message": "Upstream state."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7382174786f50c923c1549b19d0e88ed99748a7e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7382174786f50c923c1549b19d0e88ed99748a7e", "committedDate": "2020-03-11T17:43:21Z", "message": "Done."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a96bbf03ef9119da2c28de1a62be71596b9c501", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6a96bbf03ef9119da2c28de1a62be71596b9c501", "committedDate": "2020-03-12T11:34:22Z", "message": "Fixed review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "committedDate": "2020-03-12T11:44:00Z", "message": "Removed useless JavaDocs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af90816527413e2d6663ceba6b5687708459c7cf", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/af90816527413e2d6663ceba6b5687708459c7cf", "committedDate": "2020-03-12T14:32:36Z", "message": "Clarification on precedence."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52853076caf0544f7f19bb0ee38902af052a8255", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/52853076caf0544f7f19bb0ee38902af052a8255", "committedDate": "2020-03-13T11:41:22Z", "message": "Fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b7f32db0896793357a09edc4d882005a69ae530", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/2b7f32db0896793357a09edc4d882005a69ae530", "committedDate": "2020-03-13T17:29:02Z", "message": "Fixed type compatibility matrix for BIT."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8dbfa537ad955200f980c576ccf9945913006c2c", "committedDate": "2020-03-16T06:27:50Z", "message": "Merge branch 'master' into issues/15241"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ded98cf91ac6d1440ae6197e2941c2f3539fd24d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ded98cf91ac6d1440ae6197e2941c2f3539fd24d", "committedDate": "2020-03-16T06:45:35Z", "message": "Merge branch 'issues/15241' into sql-exec-interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da879db5027742866d622af5c39d99eb708b5de7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/da879db5027742866d622af5c39d99eb708b5de7", "committedDate": "2020-03-16T06:47:09Z", "message": "Merge."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdf9f084335595402a030e0a8e243f1cc4773a0d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cdf9f084335595402a030e0a8e243f1cc4773a0d", "committedDate": "2020-03-16T08:51:00Z", "message": "Fix review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8aab722371910e351e0517292da0389be99c21e8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8aab722371910e351e0517292da0389be99c21e8", "committedDate": "2020-03-16T09:18:56Z", "message": "Merge branch 'issues/15241' into prod-exec-row"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e75518d7c94e31b4c8b42467a0d0675821a8b126", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e75518d7c94e31b4c8b42467a0d0675821a8b126", "committedDate": "2020-03-17T07:56:45Z", "message": "Merge branch 'master' into prod-exec-row\n\n# Conflicts:\n#\tdocs/design/sql/01-type-system.md\n#\thazelcast/src/main/java/com/hazelcast/sql/HazelcastSqlException.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converter.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converters.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/type/QueryDataTypeTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5aa1a7373647881de9a229014d776ae8fa5e0a2f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5aa1a7373647881de9a229014d776ae8fa5e0a2f", "committedDate": "2020-03-17T08:02:55Z", "message": "Merge fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5895e977b72fe4b06e4b9654aad9c6f86e645155", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5895e977b72fe4b06e4b9654aad9c6f86e645155", "committedDate": "2020-03-17T14:15:31Z", "message": "Design doc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1124f5119eb46ae868f9e71adc8e631cc7229870", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1124f5119eb46ae868f9e71adc8e631cc7229870", "committedDate": "2020-03-17T14:26:23Z", "message": "Typos in 02."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b92b6653977ac5a1d1e9e844077d6c45b429e07c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b92b6653977ac5a1d1e9e844077d6c45b429e07c", "committedDate": "2020-03-17T14:27:58Z", "message": "Minors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9026003302687165c61c04797f30c877665d5b6e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9026003302687165c61c04797f30c877665d5b6e", "committedDate": "2020-03-17T14:30:38Z", "message": "Minors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe86ee721d2eea6df3884e9e6bded1b0973546d1", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fe86ee721d2eea6df3884e9e6bded1b0973546d1", "committedDate": "2020-03-17T14:38:47Z", "message": "Minors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3503b97b364103b427e5da11af1a4c022c504a6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b3503b97b364103b427e5da11af1a4c022c504a6", "committedDate": "2020-03-17T14:43:50Z", "message": "Typos."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/713ca1839ca03b2f2465a8c5ceb1986f45958944", "committedDate": "2020-03-18T12:35:12Z", "message": "Review."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2ODQ3ODA0", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-376847804", "createdAt": "2020-03-18T13:12:38Z", "commit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzoxMjozOFrOF4ER8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzoxMjozOFrOF4ER8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzNDcwNA==", "bodyText": "It's not clear who is the owner of the returned row batch. May the consumer assume the row batch is immutable and the the ownership is transferred to the consumer? Or should the consumer assume that the row batch content may change at any/some time and the ownership is still held by the producer?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394334704", "createdAt": "2020-03-18T13:12:38Z", "author": {"login": "taburet"}, "path": "docs/design/sql/02-operator-interface.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# SQL Operator Interface\n+\n+## Overview\n+In databases, SQL queries are typically represented in a form of operator tree, called **Volcano Model**,\n+introduced in Goetz Graefe seminal paper [[1]].\n+\n+In this document, we describe the design of the Hazelcast Mustang operator interface, which is based\n+on the Volcano Model.\n+\n+## Relational Operators\n+An SQL query is first parsed into a **parse tree**, which is used for syntactic and semantic checking.\n+\n+The parse tree is then converted into **relational operator tree**, or simply **relational tree**,\n+for optimization. The relational tree is more convenient because its structure is simpler than the\n+structure of the parse tree.\n+\n+A **query plan**, consisting of a relational tree and supplemental information, is submitted for execution\n+after the optimization.\n+\n+The table below lists common relational operators used in database engines.\n+\n+*Table 1: Common Relational Operators*\n+\n+| Name | Description |\n+|---|---|\n+| `Scan` | Iterate over source rows |\n+| `Project` | Return a set of original or derived attributes of the child operator |\n+| `Filter` | Return rows of the child operator which pass the provided predicate |\n+| `Aggregate` | Aggregate rows of the child operator |\n+| `Sort` | Sort rows of the child operator |\n+| `Join` | Join rows from several child operators |\n+\n+An example of a query, its parse tree, and its relational tree is provided below.\n+\n+*Snippet 1: Query*\n+```sql\n+SELECT a, SUM(b)\n+FROM table\n+GROUP BY a\n+HAVING SUM(b) > 50\n+```\n+*Snippet 2: Parse Tree*\n+```\n+-- Select\n+---- SelectList [a, SUM(b)]\n+---- From [table]\n+---- GroupBy [a]\n+---- Having [SUM(b) > 50]\n+```\n+*Snippet 3: Relational Tree*\n+```\n+-- Filter [SUM(b) > 50]\n+---- Aggregate [a -> SUM(b)]\n+------ Project [a, b]\n+-------- Scan [table]\n+```\n+\n+## Volcano Model\n+\n+Volcano Model defines the common data exchange interface between operators in the relational tree. This allows\n+for extensibility, as new operators could be implemented with minimal changes to the engine.\n+\n+In the original paper the interface consists of three operations:\n+\n+*Snippet 4: Volcano Interface*\n+```java\n+interface Operator {\n+    void open();  // Initialize the operator\n+    Row next();   // Get the next row\n+    void close(); // Close the operator and release all resources\n+}\n+```\n+\n+## Volcano Model in Hazelcast Mustang\n+\n+The original Volcano Model has two drawbacks:\n+1. Operators exchange one row at a time, which leads to performance overhead\n+2. Call to the `next()` is blocking, which is not optimal for the distributed environment, where\n+operators often wait for remote data or free space in the send buffer.\n+\n+To achieve high performance, we introduce several changes to the original Volcano Model: batching and\n+non-blocking execution.\n+\n+### Row and RowBatch\n+We define the `RowBatch` interface which a collection of rows (tuples).\n+\n+*Snippet 5: RowBatch interface*\n+```java\n+interface RowBatch {\n+    Row getRow(int index); // Get the row by index\n+    int getRowCount();     // Get the number of rows \n+} \n+```\n+\n+Then we define the `Row` interface, which provides access to values by index. The `Row` itself is considered\n+as a special case of `RowBatch` with one row. This allows saving on allocations in some parts of the engine.\n+\n+*Snippet 6: Row interface*\n+```java\n+interface Row extends RowBatch {\n+    Object get(int index); // Get the value by index\n+    int getColumnCount();  // Get the number of values in the row \n+    \n+    default int getRowCount() {\n+        return 1;\n+    }\n+    \n+    default int getRow(int index) {\n+        return this;\n+    }\n+}\n+```\n+\n+### Operator\n+The operator is defined by `Exec` interface:\n+1. Operators exchange `RowBatch` instead of `Row`\n+1. The blocking `next()` method is replaced with the non-blocking `advance()` method, which returns the iteration\n+result instead of the row batch\n+1. The `RowBatch` could be accessed through a separate method\n+1. The `open()` method is renamed to `setup()`. Special query context is passed to it as an argument\n+1. There is no separate `close()` method because the engine doesn't need explicit per-operator cleanup at the\n+moment. This may change in future, in this case the current document should be updated accordingly\n+\n+*Snippet 7: Exec interface*\n+```java\n+interface Exec {\n+    void setup(QueryContext context); // Initialize the operator\n+    IterationResult advance();        // Advance the operator if possible; never blocks\n+    RowBatch currentBatch();          // Get the batch returned by the previous advance() call \n+}\n+```\n+\n+The result of iteration is defined in the `IterationResult` enumeration.\n+\n+*Snippet 8: IterationResult enumeration*\n+```java\n+enum IterationResult {\n+    FETCHED,      // Iteration produced new rows\n+    FETCHED_DONE, // Iteration produced new rows and reached the end of the stream, no more rows are expected\n+    WAIT;         // Failed to produce new rows, release the control\n+}\n+```\n+\n+When the engine has received `FETCHED` or `FETCHED_DONE` from the `Exec.advance()` call, it may access the\n+produced rows through the `Exec.currentBatch()` call. If the engine has received `WAIT`, then query", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2ODQ5NTc3", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-376849577", "createdAt": "2020-03-18T13:14:49Z", "commit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzoxNDo0OVrOF4EXdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzoxNDo0OVrOF4EXdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzNjExOA==", "bodyText": "If it's referred everywhere as an operator, why not just name it the same way?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394336118", "createdAt": "2020-03-18T13:14:49Z", "author": {"login": "taburet"}, "path": "docs/design/sql/02-operator-interface.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# SQL Operator Interface\n+\n+## Overview\n+In databases, SQL queries are typically represented in a form of operator tree, called **Volcano Model**,\n+introduced in Goetz Graefe seminal paper [[1]].\n+\n+In this document, we describe the design of the Hazelcast Mustang operator interface, which is based\n+on the Volcano Model.\n+\n+## Relational Operators\n+An SQL query is first parsed into a **parse tree**, which is used for syntactic and semantic checking.\n+\n+The parse tree is then converted into **relational operator tree**, or simply **relational tree**,\n+for optimization. The relational tree is more convenient because its structure is simpler than the\n+structure of the parse tree.\n+\n+A **query plan**, consisting of a relational tree and supplemental information, is submitted for execution\n+after the optimization.\n+\n+The table below lists common relational operators used in database engines.\n+\n+*Table 1: Common Relational Operators*\n+\n+| Name | Description |\n+|---|---|\n+| `Scan` | Iterate over source rows |\n+| `Project` | Return a set of original or derived attributes of the child operator |\n+| `Filter` | Return rows of the child operator which pass the provided predicate |\n+| `Aggregate` | Aggregate rows of the child operator |\n+| `Sort` | Sort rows of the child operator |\n+| `Join` | Join rows from several child operators |\n+\n+An example of a query, its parse tree, and its relational tree is provided below.\n+\n+*Snippet 1: Query*\n+```sql\n+SELECT a, SUM(b)\n+FROM table\n+GROUP BY a\n+HAVING SUM(b) > 50\n+```\n+*Snippet 2: Parse Tree*\n+```\n+-- Select\n+---- SelectList [a, SUM(b)]\n+---- From [table]\n+---- GroupBy [a]\n+---- Having [SUM(b) > 50]\n+```\n+*Snippet 3: Relational Tree*\n+```\n+-- Filter [SUM(b) > 50]\n+---- Aggregate [a -> SUM(b)]\n+------ Project [a, b]\n+-------- Scan [table]\n+```\n+\n+## Volcano Model\n+\n+Volcano Model defines the common data exchange interface between operators in the relational tree. This allows\n+for extensibility, as new operators could be implemented with minimal changes to the engine.\n+\n+In the original paper the interface consists of three operations:\n+\n+*Snippet 4: Volcano Interface*\n+```java\n+interface Operator {\n+    void open();  // Initialize the operator\n+    Row next();   // Get the next row\n+    void close(); // Close the operator and release all resources\n+}\n+```\n+\n+## Volcano Model in Hazelcast Mustang\n+\n+The original Volcano Model has two drawbacks:\n+1. Operators exchange one row at a time, which leads to performance overhead\n+2. Call to the `next()` is blocking, which is not optimal for the distributed environment, where\n+operators often wait for remote data or free space in the send buffer.\n+\n+To achieve high performance, we introduce several changes to the original Volcano Model: batching and\n+non-blocking execution.\n+\n+### Row and RowBatch\n+We define the `RowBatch` interface which a collection of rows (tuples).\n+\n+*Snippet 5: RowBatch interface*\n+```java\n+interface RowBatch {\n+    Row getRow(int index); // Get the row by index\n+    int getRowCount();     // Get the number of rows \n+} \n+```\n+\n+Then we define the `Row` interface, which provides access to values by index. The `Row` itself is considered\n+as a special case of `RowBatch` with one row. This allows saving on allocations in some parts of the engine.\n+\n+*Snippet 6: Row interface*\n+```java\n+interface Row extends RowBatch {\n+    Object get(int index); // Get the value by index\n+    int getColumnCount();  // Get the number of values in the row \n+    \n+    default int getRowCount() {\n+        return 1;\n+    }\n+    \n+    default int getRow(int index) {\n+        return this;\n+    }\n+}\n+```\n+\n+### Operator\n+The operator is defined by `Exec` interface:\n+1. Operators exchange `RowBatch` instead of `Row`\n+1. The blocking `next()` method is replaced with the non-blocking `advance()` method, which returns the iteration\n+result instead of the row batch\n+1. The `RowBatch` could be accessed through a separate method\n+1. The `open()` method is renamed to `setup()`. Special query context is passed to it as an argument\n+1. There is no separate `close()` method because the engine doesn't need explicit per-operator cleanup at the\n+moment. This may change in future, in this case the current document should be updated accordingly\n+\n+*Snippet 7: Exec interface*\n+```java\n+interface Exec {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bce5fa3cb9dd6d9423ee72ca84c685cfc4512f61", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/bce5fa3cb9dd6d9423ee72ca84c685cfc4512f61", "committedDate": "2020-03-18T13:41:22Z", "message": "Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2ODcyNzMy", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-376872732", "createdAt": "2020-03-18T13:41:53Z", "commit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzo0MTo1M1rOF4Fczg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzo0MTo1M1rOF4Fczg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1Mzg3MA==", "bodyText": "The return type should be Row, I believe :)", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394353870", "createdAt": "2020-03-18T13:41:53Z", "author": {"login": "taburet"}, "path": "docs/design/sql/02-operator-interface.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# SQL Operator Interface\n+\n+## Overview\n+In databases, SQL queries are typically represented in a form of operator tree, called **Volcano Model**,\n+introduced in Goetz Graefe seminal paper [[1]].\n+\n+In this document, we describe the design of the Hazelcast Mustang operator interface, which is based\n+on the Volcano Model.\n+\n+## Relational Operators\n+An SQL query is first parsed into a **parse tree**, which is used for syntactic and semantic checking.\n+\n+The parse tree is then converted into **relational operator tree**, or simply **relational tree**,\n+for optimization. The relational tree is more convenient because its structure is simpler than the\n+structure of the parse tree.\n+\n+A **query plan**, consisting of a relational tree and supplemental information, is submitted for execution\n+after the optimization.\n+\n+The table below lists common relational operators used in database engines.\n+\n+*Table 1: Common Relational Operators*\n+\n+| Name | Description |\n+|---|---|\n+| `Scan` | Iterate over source rows |\n+| `Project` | Return a set of original or derived attributes of the child operator |\n+| `Filter` | Return rows of the child operator which pass the provided predicate |\n+| `Aggregate` | Aggregate rows of the child operator |\n+| `Sort` | Sort rows of the child operator |\n+| `Join` | Join rows from several child operators |\n+\n+An example of a query, its parse tree, and its relational tree is provided below.\n+\n+*Snippet 1: Query*\n+```sql\n+SELECT a, SUM(b)\n+FROM table\n+GROUP BY a\n+HAVING SUM(b) > 50\n+```\n+*Snippet 2: Parse Tree*\n+```\n+-- Select\n+---- SelectList [a, SUM(b)]\n+---- From [table]\n+---- GroupBy [a]\n+---- Having [SUM(b) > 50]\n+```\n+*Snippet 3: Relational Tree*\n+```\n+-- Filter [SUM(b) > 50]\n+---- Aggregate [a -> SUM(b)]\n+------ Project [a, b]\n+-------- Scan [table]\n+```\n+\n+## Volcano Model\n+\n+Volcano Model defines the common data exchange interface between operators in the relational tree. This allows\n+for extensibility, as new operators could be implemented with minimal changes to the engine.\n+\n+In the original paper the interface consists of three operations:\n+\n+*Snippet 4: Volcano Interface*\n+```java\n+interface Operator {\n+    void open();  // Initialize the operator\n+    Row next();   // Get the next row\n+    void close(); // Close the operator and release all resources\n+}\n+```\n+\n+## Volcano Model in Hazelcast Mustang\n+\n+The original Volcano Model has two drawbacks:\n+1. Operators exchange one row at a time, which leads to performance overhead\n+2. Call to the `next()` is blocking, which is not optimal for the distributed environment, where\n+operators often wait for remote data or free space in the send buffer.\n+\n+To achieve high performance, we introduce several changes to the original Volcano Model: batching and\n+non-blocking execution.\n+\n+### Row and RowBatch\n+We define the `RowBatch` interface which a collection of rows (tuples).\n+\n+*Snippet 5: RowBatch interface*\n+```java\n+interface RowBatch {\n+    Row getRow(int index); // Get the row by index\n+    int getRowCount();     // Get the number of rows \n+} \n+```\n+\n+Then we define the `Row` interface, which provides access to values by index. The `Row` itself is considered\n+as a special case of `RowBatch` with one row. This allows saving on allocations in some parts of the engine.\n+\n+*Snippet 6: Row interface*\n+```java\n+interface Row extends RowBatch {\n+    Object get(int index); // Get the value by index\n+    int getColumnCount();  // Get the number of values in the row \n+    \n+    default int getRowCount() {\n+        return 1;\n+    }\n+    \n+    default int getRow(int index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "713ca1839ca03b2f2465a8c5ceb1986f45958944"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c959d55cb4b8ec4842807a172143c3fc72c0a77", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9c959d55cb4b8ec4842807a172143c3fc72c0a77", "committedDate": "2020-03-18T13:47:49Z", "message": "Review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4620f01fdc2c3cb3b548962e177b6207ecaf6474", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4620f01fdc2c3cb3b548962e177b6207ecaf6474", "committedDate": "2020-03-18T13:50:42Z", "message": "Clarifications on row and row batch life cycles."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f91e6967d4faa6c3ff5d25e121d60236bf1acf8a", "committedDate": "2020-03-18T14:01:33Z", "message": "More clarifications."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NDc5ODY1", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-377479865", "createdAt": "2020-03-19T07:38:49Z", "commit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzozODo1MFrOF4i75w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzozODo1MFrOF4i75w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNjk2Nw==", "bodyText": "Just as an idea, these two methods can be combined into a single one: RowBatch  advance() returning special signaling RowBatch instances named the same and having the same semantics as IterationResult members.", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394836967", "createdAt": "2020-03-19T07:38:50Z", "author": {"login": "taburet"}, "path": "docs/design/sql/02-operator-interface.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# SQL Operator Interface\n+\n+## Overview\n+In databases, SQL queries are typically represented in a form of operator tree, called **Volcano Model**,\n+introduced in Goetz Graefe seminal paper [[1]].\n+\n+In this document, we describe the design of the Hazelcast Mustang operator interface, which is based\n+on the Volcano Model.\n+\n+## Relational Operators\n+An SQL query is first parsed into a **parse tree**, which is used for syntactic and semantic checking.\n+\n+The parse tree is then converted into **relational operator tree**, or simply **relational tree**,\n+for optimization. The relational tree is more convenient because its structure is simpler than the\n+structure of the parse tree.\n+\n+A **query plan**, consisting of a relational tree and supplemental information, is submitted for execution\n+after the optimization.\n+\n+The table below lists common relational operators used in database engines.\n+\n+*Table 1: Common Relational Operators*\n+\n+| Name | Description |\n+|---|---|\n+| `Scan` | Iterate over source rows |\n+| `Project` | Return a set of original or derived attributes of the child operator |\n+| `Filter` | Return rows of the child operator which pass the provided predicate |\n+| `Aggregate` | Aggregate rows of the child operator |\n+| `Sort` | Sort rows of the child operator |\n+| `Join` | Join rows from several child operators |\n+\n+An example of a query, its parse tree, and its relational tree is provided below.\n+\n+*Snippet 1: Query*\n+```sql\n+SELECT a, SUM(b)\n+FROM table\n+GROUP BY a\n+HAVING SUM(b) > 50\n+```\n+*Snippet 2: Parse Tree*\n+```\n+-- Select\n+---- SelectList [a, SUM(b)]\n+---- From [table]\n+---- GroupBy [a]\n+---- Having [SUM(b) > 50]\n+```\n+*Snippet 3: Relational Tree*\n+```\n+-- Filter [SUM(b) > 50]\n+---- Aggregate [a -> SUM(b)]\n+------ Project [a, b]\n+-------- Scan [table]\n+```\n+\n+## Volcano Model\n+\n+Volcano Model defines the common data exchange interface between operators in the relational tree. This allows\n+for extensibility, as new operators could be implemented with minimal changes to the engine.\n+\n+In the original paper the interface consists of three operations:\n+\n+*Snippet 4: Volcano Interface*\n+```java\n+interface Operator {\n+    void open();  // Initialize the operator\n+    Row next();   // Get the next row\n+    void close(); // Close the operator and release all resources\n+}\n+```\n+\n+## Volcano Model in Hazelcast Mustang\n+\n+The original Volcano Model has two drawbacks:\n+1. Operators exchange one row at a time, which leads to performance overhead\n+2. Call to the `next()` is blocking, which is not optimal for the distributed environment, where\n+operators often wait for remote data or free space in the send buffer.\n+\n+To achieve high performance, we introduce several changes to the original Volcano Model: batching and\n+non-blocking execution.\n+\n+### Row and RowBatch\n+We define the `RowBatch` interface which a collection of rows (tuples).\n+\n+*Snippet 5: RowBatch interface*\n+```java\n+interface RowBatch {\n+    Row getRow(int index); // Get the row by index\n+    int getRowCount();     // Get the number of rows \n+} \n+```\n+\n+Then we define the `Row` interface, which provides access to values by index. The `Row` itself is considered\n+as a special case of `RowBatch` with one row. This allows saving on allocations in some parts of the engine.\n+\n+*Snippet 6: Row interface*\n+```java\n+interface Row extends RowBatch {\n+    Object get(int index); // Get the value by index\n+    int getColumnCount();  // Get the number of values in the row \n+    \n+    default int getRowCount() {\n+        return 1;\n+    }\n+    \n+    default Row getRow(int index) {\n+        return this;\n+    }\n+}\n+```\n+\n+### Operator\n+The operator is defined by `Exec` interface:\n+1. Operators exchange `RowBatch` instead of `Row`\n+1. The blocking `next()` method is replaced with the non-blocking `advance()` method, which returns the iteration\n+result instead of the row batch\n+1. The `RowBatch` could be accessed through a separate method\n+1. The `open()` method is renamed to `setup()`. Special query context is passed to it as an argument\n+1. There is no separate `close()` method because the engine doesn't need explicit per-operator cleanup at the\n+moment. This may change in future, in this case the current document should be updated accordingly\n+\n+*Snippet 7: Executable operator interface*\n+```java\n+interface Exec {\n+    void setup(QueryContext context); // Initialize the operator\n+    IterationResult advance();        // Advance the operator if possible; never blocks\n+    RowBatch currentBatch();          // Get the batch returned by the previous advance() call ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NDgzMzUw", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-377483350", "createdAt": "2020-03-19T07:45:40Z", "commit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo0NTo0MFrOF4jHEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo0NTo0MFrOF4jHEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzOTgyNA==", "bodyText": "If it's a no-op method, we can make it abstract.", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394839824", "createdAt": "2020-03-19T07:45:40Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/AbstractExec.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+\n+/**\n+ * Abstract executor.\n+ */\n+public abstract class AbstractExec implements Exec {\n+\n+    protected QueryFragmentContext ctx;\n+    private final int id;\n+\n+    protected AbstractExec(int id) {\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public int getId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public final void setup(QueryFragmentContext ctx) {\n+        this.ctx = ctx;\n+\n+        setup0(ctx);\n+    }\n+\n+    @Override\n+    public final IterationResult advance() {\n+        return advance0();\n+    }\n+\n+    @Override\n+    public final RowBatch currentBatch() {\n+        RowBatch res = currentBatch0();\n+\n+        return res != null ? res : EmptyRowBatch.INSTANCE;\n+    }\n+\n+    protected void setup0(QueryFragmentContext ctx) {\n+        // No-op.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NDg0NDQ2", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-377484446", "createdAt": "2020-03-19T07:47:46Z", "commit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo0Nzo0N1rOF4jKWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo0Nzo0N1rOF4jKWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MDY2Nw==", "bodyText": "abstract?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394840667", "createdAt": "2020-03-19T07:47:47Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/AbstractUpstreamAwareExec.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+\n+/**\n+ * Executor which has an upstream executor and hence delegate to it at some stages.\n+ */\n+public abstract class AbstractUpstreamAwareExec extends AbstractExec {\n+    /** Upstream state. */\n+    protected final UpstreamState state;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param upstream Upstream stage.\n+     */\n+    protected AbstractUpstreamAwareExec(int id, Exec upstream) {\n+        super(id);\n+\n+        state = new UpstreamState(upstream);\n+    }\n+\n+    @Override\n+    protected final void setup0(QueryFragmentContext ctx) {\n+        state.setup(ctx);\n+\n+        setup1(ctx);\n+    }\n+\n+    protected void setup1(QueryFragmentContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NDg3NTYx", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-377487561", "createdAt": "2020-03-19T07:53:42Z", "commit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1Mzo0MlrOF4jUDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1Mzo0MlrOF4jUDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MzE0OQ==", "bodyText": "Some note on the uniqueness scope of this ID would be helpful. Is it globally unique or only in the scope of a single query/fragment? Does it stay the same between executions of the same query or valid only for a single execution?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r394843149", "createdAt": "2020-03-19T07:53:42Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/Exec.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+\n+/**\n+ * Basic execution stage.\n+ */\n+public interface Exec {\n+    /**\n+     * @return ID of the executor.\n+     */\n+    int getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91e6967d4faa6c3ff5d25e121d60236bf1acf8a"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af4db772903af79ecfcbd98e05715da11164bc23", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/af4db772903af79ecfcbd98e05715da11164bc23", "committedDate": "2020-03-19T08:14:05Z", "message": "JavaDoc for getId()."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06a7500c607ccf2b00e8dc985279942c99a4ce6a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/06a7500c607ccf2b00e8dc985279942c99a4ce6a", "committedDate": "2020-03-19T17:26:03Z", "message": "Merge branch 'master' into issues/16762"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c6b64606a093f8a60b70f126449097f3d9989aaa", "committedDate": "2020-03-19T17:36:20Z", "message": "Fixed spotbugs."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDUxOTY1", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-378451965", "createdAt": "2020-03-20T12:47:50Z", "commit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwOTkzMzUz", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-380993353", "createdAt": "2020-03-25T09:48:47Z", "commit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwOTo0ODo0N1rOF7TPGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMDoyNjozOFrOF7UpUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyNTQ2NA==", "bodyText": "which is a ..?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397725464", "createdAt": "2020-03-25T09:48:47Z", "author": {"login": "petrpleshachkov"}, "path": "docs/design/sql/02-operator-interface.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# SQL Operator Interface\n+\n+## Overview\n+In databases, SQL queries are typically represented in a form of operator tree, called **Volcano Model**,\n+introduced in Goetz Graefe seminal paper [[1]].\n+\n+In this document, we describe the design of the Hazelcast Mustang operator interface, which is based\n+on the Volcano Model.\n+\n+## Relational Operators\n+An SQL query is first parsed into a **parse tree**, which is used for syntactic and semantic checking.\n+\n+The parse tree is then converted into **relational operator tree**, or simply **relational tree**,\n+for optimization. The relational tree is more convenient because its structure is simpler than the\n+structure of the parse tree.\n+\n+A **query plan**, consisting of a relational tree and supplemental information, is submitted for execution\n+after the optimization.\n+\n+The table below lists common relational operators used in database engines.\n+\n+*Table 1: Common Relational Operators*\n+\n+| Name | Description |\n+|---|---|\n+| `Scan` | Iterate over source rows |\n+| `Project` | Return a set of original or derived attributes of the child operator |\n+| `Filter` | Return rows of the child operator which pass the provided predicate |\n+| `Aggregate` | Aggregate rows of the child operator |\n+| `Sort` | Sort rows of the child operator |\n+| `Join` | Join rows from several child operators |\n+\n+An example of a query, its parse tree, and its relational tree is provided below.\n+\n+*Snippet 1: Query*\n+```sql\n+SELECT a, SUM(b)\n+FROM table\n+GROUP BY a\n+HAVING SUM(b) > 50\n+```\n+*Snippet 2: Parse Tree*\n+```\n+-- Select\n+---- SelectList [a, SUM(b)]\n+---- From [table]\n+---- GroupBy [a]\n+---- Having [SUM(b) > 50]\n+```\n+*Snippet 3: Relational Tree*\n+```\n+-- Filter [SUM(b) > 50]\n+---- Aggregate [a -> SUM(b)]\n+------ Project [a, b]\n+-------- Scan [table]\n+```\n+\n+## Volcano Model\n+\n+Volcano Model defines the common data exchange interface between operators in the relational tree. This allows\n+for extensibility, as new operators could be implemented with minimal changes to the engine.\n+\n+In the original paper the interface consists of three operations:\n+\n+*Snippet 4: Volcano Interface*\n+```java\n+interface Operator {\n+    void open();  // Initialize the operator\n+    Row next();   // Get the next row\n+    void close(); // Close the operator and release all resources\n+}\n+```\n+\n+## Volcano Model in Hazelcast Mustang\n+\n+The original Volcano Model has two drawbacks:\n+1. Operators exchange one row at a time, which leads to performance overhead\n+2. Call to the `next()` is blocking, which is not optimal for the distributed environment, where\n+operators often wait for remote data or free space in the send buffer.\n+\n+To achieve high performance, we introduce several changes to the original Volcano Model: batching and\n+non-blocking execution.\n+\n+### Row and RowBatch\n+We define the `RowBatch` interface which a collection of rows (tuples).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzA0Ng==", "bodyText": "Why would we create new UUID object on every method call? It seems better to create the object once.", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397733046", "createdAt": "2020-03-25T10:01:10Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+/**\n+ * Cluster-wide unique query ID.\n+ */\n+public final class QueryId implements IdentifiedDataSerializable {\n+    /** Member ID: most significant bits */\n+    private long memberIdHigh;\n+\n+    /** Member ID: least significant bits. */\n+    private long memberIdLow;\n+\n+    /** Local ID: most significant bits. */\n+    private long localHigh;\n+\n+    /** Local ID: least significant bits. */\n+    private long localLow;\n+\n+    public QueryId() {\n+        // No-op.\n+    }\n+\n+    QueryId(long memberIdHigh, long memberIdLow, long localHigh, long localLow) {\n+        this.memberIdHigh = memberIdHigh;\n+        this.memberIdLow = memberIdLow;\n+        this.localHigh = localHigh;\n+        this.localLow = localLow;\n+    }\n+\n+    /**\n+     * Create new query ID for the given member.\n+     *\n+     * @param memberId Member ID.\n+     * @return Query ID.\n+     */\n+    public static QueryId create(UUID memberId) {\n+        UUID qryId = UuidUtil.newUnsecureUUID();\n+\n+        return new QueryId(\n+            memberId.getMostSignificantBits(),\n+            memberId.getLeastSignificantBits(),\n+            qryId.getMostSignificantBits(),\n+            qryId.getLeastSignificantBits()\n+        );\n+    }\n+\n+    public UUID getMemberId() {\n+        return new UUID(memberIdHigh, memberIdLow);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczOTUyNA==", "bodyText": "True -> true?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397739524", "createdAt": "2020-03-25T10:11:45Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/UpstreamState.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+\n+import java.util.Iterator;\n+\n+import static com.hazelcast.sql.impl.exec.IterationResult.FETCHED_DONE;\n+import static com.hazelcast.sql.impl.exec.IterationResult.WAIT;\n+\n+/**\n+ * Upstream state.\n+ */\n+public class UpstreamState implements Iterable<Row> {\n+    /** Upstream operator. */\n+    private final Exec upstream;\n+\n+    /** Iterator over the current batch. */\n+    private final UpstreamIterator iter;\n+\n+    /** Current batch returned from the upstream. */\n+    private RowBatch currentBatch = EmptyRowBatch.INSTANCE;\n+\n+    /** Current position. */\n+    private int currentBatchPos;\n+\n+    /** Last returned state. */\n+    private IterationResult state;\n+\n+    public UpstreamState(Exec upstream) {\n+        this.upstream = upstream;\n+\n+        iter = new UpstreamIterator();\n+    }\n+\n+    /**\n+     * Try advancing the upstream.\n+     *\n+     * @return {@code True} if the caller may try iteration over results; {@code false} if the caller should give", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0Mzc0NA==", "bodyText": "True -> true?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397743744", "createdAt": "2020-03-25T10:18:44Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/UpstreamState.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+\n+import java.util.Iterator;\n+\n+import static com.hazelcast.sql.impl.exec.IterationResult.FETCHED_DONE;\n+import static com.hazelcast.sql.impl.exec.IterationResult.WAIT;\n+\n+/**\n+ * Upstream state.\n+ */\n+public class UpstreamState implements Iterable<Row> {\n+    /** Upstream operator. */\n+    private final Exec upstream;\n+\n+    /** Iterator over the current batch. */\n+    private final UpstreamIterator iter;\n+\n+    /** Current batch returned from the upstream. */\n+    private RowBatch currentBatch = EmptyRowBatch.INSTANCE;\n+\n+    /** Current position. */\n+    private int currentBatchPos;\n+\n+    /** Last returned state. */\n+    private IterationResult state;\n+\n+    public UpstreamState(Exec upstream) {\n+        this.upstream = upstream;\n+\n+        iter = new UpstreamIterator();\n+    }\n+\n+    /**\n+     * Try advancing the upstream.\n+     *\n+     * @return {@code True} if the caller may try iteration over results; {@code false} if the caller should give\n+     * up execution and wait.\n+     */\n+    public boolean advance() {\n+        // If some data is available still, do not do anything, just return the previous result.\n+        if (currentBatchPos < currentBatch.getRowCount()) {\n+            return true;\n+        }\n+\n+        // If the upstream is exhausted, just return \"done\" flag.\n+        if (state == FETCHED_DONE) {\n+            return true;\n+        }\n+\n+        // Otherwise poll the upstream.\n+        state = upstream.advance();\n+\n+        switch (state) {\n+            case FETCHED_DONE:\n+            case FETCHED:\n+                currentBatch = upstream.currentBatch();\n+                assert currentBatch != null;\n+\n+                currentBatchPos = 0;\n+\n+                return true;\n+\n+            default:\n+                assert state == WAIT;\n+\n+                currentBatch = EmptyRowBatch.INSTANCE;\n+                currentBatchPos = 0;\n+\n+                return false;\n+        }\n+    }\n+\n+    public void setup(QueryFragmentContext ctx) {\n+        upstream.setup(ctx);\n+    }\n+\n+    public RowBatch consumeBatch() {\n+        if (currentBatchPos != 0) {\n+            throw HazelcastSqlException.error(\"Batch can be consumed only as a whole: \" + upstream);\n+        }\n+\n+        RowBatch batch = currentBatch;\n+\n+        currentBatchPos = batch.getRowCount();\n+\n+        return batch;\n+    }\n+\n+    /**\n+     * @return {@code True} if no more results will appear in future.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0NjYyNg==", "bodyText": "Why not to use standard hasNext()/next() methods semantics from Iterator instead of introducing isDone/nextIfExists?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397746626", "createdAt": "2020-03-25T10:23:34Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/UpstreamState.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+\n+import java.util.Iterator;\n+\n+import static com.hazelcast.sql.impl.exec.IterationResult.FETCHED_DONE;\n+import static com.hazelcast.sql.impl.exec.IterationResult.WAIT;\n+\n+/**\n+ * Upstream state.\n+ */\n+public class UpstreamState implements Iterable<Row> {\n+    /** Upstream operator. */\n+    private final Exec upstream;\n+\n+    /** Iterator over the current batch. */\n+    private final UpstreamIterator iter;\n+\n+    /** Current batch returned from the upstream. */\n+    private RowBatch currentBatch = EmptyRowBatch.INSTANCE;\n+\n+    /** Current position. */\n+    private int currentBatchPos;\n+\n+    /** Last returned state. */\n+    private IterationResult state;\n+\n+    public UpstreamState(Exec upstream) {\n+        this.upstream = upstream;\n+\n+        iter = new UpstreamIterator();\n+    }\n+\n+    /**\n+     * Try advancing the upstream.\n+     *\n+     * @return {@code True} if the caller may try iteration over results; {@code false} if the caller should give\n+     * up execution and wait.\n+     */\n+    public boolean advance() {\n+        // If some data is available still, do not do anything, just return the previous result.\n+        if (currentBatchPos < currentBatch.getRowCount()) {\n+            return true;\n+        }\n+\n+        // If the upstream is exhausted, just return \"done\" flag.\n+        if (state == FETCHED_DONE) {\n+            return true;\n+        }\n+\n+        // Otherwise poll the upstream.\n+        state = upstream.advance();\n+\n+        switch (state) {\n+            case FETCHED_DONE:\n+            case FETCHED:\n+                currentBatch = upstream.currentBatch();\n+                assert currentBatch != null;\n+\n+                currentBatchPos = 0;\n+\n+                return true;\n+\n+            default:\n+                assert state == WAIT;\n+\n+                currentBatch = EmptyRowBatch.INSTANCE;\n+                currentBatchPos = 0;\n+\n+                return false;\n+        }\n+    }\n+\n+    public void setup(QueryFragmentContext ctx) {\n+        upstream.setup(ctx);\n+    }\n+\n+    public RowBatch consumeBatch() {\n+        if (currentBatchPos != 0) {\n+            throw HazelcastSqlException.error(\"Batch can be consumed only as a whole: \" + upstream);\n+        }\n+\n+        RowBatch batch = currentBatch;\n+\n+        currentBatchPos = batch.getRowCount();\n+\n+        return batch;\n+    }\n+\n+    /**\n+     * @return {@code True} if no more results will appear in future.\n+     */\n+    public boolean isDone() {\n+        return state == FETCHED_DONE && !iter.hasNext();\n+    }\n+\n+    @SuppressWarnings(\"NullableProblems\")\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iter;\n+    }\n+\n+    /**\n+     * Return next row in the current batch if it exists.\n+     *\n+     * @return Next row or {@code null}.\n+     */\n+    public Row nextIfExists() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0ODU2Mg==", "bodyText": "index < arguments.size() ?", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397748562", "createdAt": "2020-03-25T10:26:38Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/fragment/QueryFragmentContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.fragment;\n+\n+import java.util.List;\n+\n+/**\n+ * Context of a running query fragment.\n+ */\n+public class QueryFragmentContext {\n+\n+    private final List<Object> arguments;\n+\n+    public QueryFragmentContext(List<Object> arguments) {\n+        assert arguments != null;\n+\n+        this.arguments = arguments;\n+    }\n+\n+    public Object getArgument(int index) {\n+        assert index >= 0 && index <= arguments.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89462eec84fb4d480b86d004827056cba8290963", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/89462eec84fb4d480b86d004827056cba8290963", "committedDate": "2020-03-25T10:47:24Z", "message": "Review fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMDQ2NDc0", "url": "https://github.com/hazelcast/hazelcast/pull/16763#pullrequestreview-381046474", "createdAt": "2020-03-25T11:04:11Z", "commit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMTowNDoxMVrOF7V_Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMTowNDoxMVrOF7V_Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc3MDU0Nw==", "bodyText": "I guess, you have isDone() to avoid calling this method when there is no new Row to consume. Anyway, it is a matter of taste.", "url": "https://github.com/hazelcast/hazelcast/pull/16763#discussion_r397770547", "createdAt": "2020-03-25T11:04:11Z", "author": {"login": "petrpleshachkov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/UpstreamState.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.fragment.QueryFragmentContext;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+\n+import java.util.Iterator;\n+\n+import static com.hazelcast.sql.impl.exec.IterationResult.FETCHED_DONE;\n+import static com.hazelcast.sql.impl.exec.IterationResult.WAIT;\n+\n+/**\n+ * Upstream state.\n+ */\n+public class UpstreamState implements Iterable<Row> {\n+    /** Upstream operator. */\n+    private final Exec upstream;\n+\n+    /** Iterator over the current batch. */\n+    private final UpstreamIterator iter;\n+\n+    /** Current batch returned from the upstream. */\n+    private RowBatch currentBatch = EmptyRowBatch.INSTANCE;\n+\n+    /** Current position. */\n+    private int currentBatchPos;\n+\n+    /** Last returned state. */\n+    private IterationResult state;\n+\n+    public UpstreamState(Exec upstream) {\n+        this.upstream = upstream;\n+\n+        iter = new UpstreamIterator();\n+    }\n+\n+    /**\n+     * Try advancing the upstream.\n+     *\n+     * @return {@code True} if the caller may try iteration over results; {@code false} if the caller should give\n+     * up execution and wait.\n+     */\n+    public boolean advance() {\n+        // If some data is available still, do not do anything, just return the previous result.\n+        if (currentBatchPos < currentBatch.getRowCount()) {\n+            return true;\n+        }\n+\n+        // If the upstream is exhausted, just return \"done\" flag.\n+        if (state == FETCHED_DONE) {\n+            return true;\n+        }\n+\n+        // Otherwise poll the upstream.\n+        state = upstream.advance();\n+\n+        switch (state) {\n+            case FETCHED_DONE:\n+            case FETCHED:\n+                currentBatch = upstream.currentBatch();\n+                assert currentBatch != null;\n+\n+                currentBatchPos = 0;\n+\n+                return true;\n+\n+            default:\n+                assert state == WAIT;\n+\n+                currentBatch = EmptyRowBatch.INSTANCE;\n+                currentBatchPos = 0;\n+\n+                return false;\n+        }\n+    }\n+\n+    public void setup(QueryFragmentContext ctx) {\n+        upstream.setup(ctx);\n+    }\n+\n+    public RowBatch consumeBatch() {\n+        if (currentBatchPos != 0) {\n+            throw HazelcastSqlException.error(\"Batch can be consumed only as a whole: \" + upstream);\n+        }\n+\n+        RowBatch batch = currentBatch;\n+\n+        currentBatchPos = batch.getRowCount();\n+\n+        return batch;\n+    }\n+\n+    /**\n+     * @return {@code True} if no more results will appear in future.\n+     */\n+    public boolean isDone() {\n+        return state == FETCHED_DONE && !iter.hasNext();\n+    }\n+\n+    @SuppressWarnings(\"NullableProblems\")\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iter;\n+    }\n+\n+    /**\n+     * Return next row in the current batch if it exists.\n+     *\n+     * @return Next row or {@code null}.\n+     */\n+    public Row nextIfExists() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0NjYyNg=="}, "originalCommit": {"oid": "c6b64606a093f8a60b70f126449097f3d9989aaa"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3886, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}