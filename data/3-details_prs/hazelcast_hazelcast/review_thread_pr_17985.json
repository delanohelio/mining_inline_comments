{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNDYzNjM2", "number": 17985, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMjowMToxM1rOFUBxaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzozNTo1N1rOFWLh9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2NTQ0ODcyOnYy", "diffSide": "LEFT", "path": "hazelcast-spring/src/main/resources/hazelcast-spring-4.1.xsd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMjowMToxM1rOIb0S7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwOTowNzoyMFrOIeGbIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjAzOTI3Nw==", "bodyText": "Does it make sense to remove this element from the 4.1 XSD, while it is still available in the actual 4.1.z releases?", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r566039277", "createdAt": "2021-01-28T12:01:13Z", "author": {"login": "vbekiaris"}, "path": "hazelcast-spring/src/main/resources/hazelcast-spring-4.1.xsd", "diffHunk": "@@ -5158,23 +5158,6 @@\n                     </xs:documentation>\n                 </xs:annotation>\n             </xs:element>\n-            <xs:element name=\"operation-pool-size\" type=\"xs:int\" minOccurs=\"0\" maxOccurs=\"1\" default=\"-1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5710f85b73b562b711175fec11c6bfd0ade60cc8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQzMzQ0Mw==", "bodyText": "Fixed. No need to change 4.1.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568433443", "createdAt": "2021-02-02T09:07:20Z", "author": {"login": "devozerov"}, "path": "hazelcast-spring/src/main/resources/hazelcast-spring-4.1.xsd", "diffHunk": "@@ -5158,23 +5158,6 @@\n                     </xs:documentation>\n                 </xs:annotation>\n             </xs:element>\n-            <xs:element name=\"operation-pool-size\" type=\"xs:int\" minOccurs=\"0\" maxOccurs=\"1\" default=\"-1\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjAzOTI3Nw=="}, "originalCommit": {"oid": "5710f85b73b562b711175fec11c6bfd0ade60cc8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3Nzg5MjYyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDoxOTo1NVrOIdjYLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwOTowNzozMVrOIeGblQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1OTI0NQ==", "bodyText": "minor: at this point, assuming this has not escaped, you can just set(true).", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567859245", "createdAt": "2021-02-01T14:19:55Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryState.java", "diffHunk": "@@ -98,6 +106,14 @@ private QueryState(\n \n         startTime = clockProvider.currentTimeMillis();\n         checkTime = startTime;\n+\n+        this.cancelled = cancelled;\n+\n+        if (cancelled) {\n+            completionGuard.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQzMzU1Nw==", "bodyText": "Good catch, thanks. Fixed.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568433557", "createdAt": "2021-02-02T09:07:31Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryState.java", "diffHunk": "@@ -98,6 +106,14 @@ private QueryState(\n \n         startTime = clockProvider.currentTimeMillis();\n         checkTime = startTime;\n+\n+        this.cancelled = cancelled;\n+\n+        if (cancelled) {\n+            completionGuard.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1OTI0NQ=="}, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3ODA3ODM2OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDo1NzozNFrOIdlH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwOTowODoxM1rOIeGd9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg4Nzg1NQ==", "bodyText": "Seems like those two volatile variables are actually assigned constant values (SqlServiceImpl#STATE_CHECK_FREQUENCY and DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY). They could be final,  except for test code. Can we make them final and override their values in tests via properties? eg\nprivate final long stateCheckFrequency = Long.getLong(\"hazelcast.sql.stateCheckFrequency\", 1_000L);\n...\n// test code\n@Rule\npublic OverridePropertyRule setStateCheckFreq = set(\"hazelcast.sql.stateCheckFrequency\", \"100\");\n\nIf that is not a viable alternative, then we should add comments so that the reason for being volatile is clear.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567887855", "createdAt": "2021-02-01T14:57:34Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -37,12 +37,15 @@\n  */\n public class QueryStateRegistryUpdater {\n \n+    private static final long DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY = 30_000L;\n+\n     private final NodeServiceProvider nodeServiceProvider;\n     private final QueryStateRegistry stateRegistry;\n     private final QueryClientStateRegistry clientStateRegistry;\n     private final QueryOperationHandler operationHandler;\n     private final PlanCacheChecker planCacheChecker;\n-    private final long stateCheckFrequency;\n+    private volatile long stateCheckFrequency;\n+    private volatile long orphanedQueryStateCheckFrequency = DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQzNDE2NQ==", "bodyText": "Added comments. We cannot use properties, because in our tests we need to change the value for the already created instance.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568434165", "createdAt": "2021-02-02T09:08:13Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -37,12 +37,15 @@\n  */\n public class QueryStateRegistryUpdater {\n \n+    private static final long DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY = 30_000L;\n+\n     private final NodeServiceProvider nodeServiceProvider;\n     private final QueryStateRegistry stateRegistry;\n     private final QueryClientStateRegistry clientStateRegistry;\n     private final QueryOperationHandler operationHandler;\n     private final PlanCacheChecker planCacheChecker;\n-    private final long stateCheckFrequency;\n+    private volatile long stateCheckFrequency;\n+    private volatile long orphanedQueryStateCheckFrequency = DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg4Nzg1NQ=="}, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3ODIxMDU2OnYy", "diffSide": "LEFT", "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNToyMzo1NVrOIdmYIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwOTowNzoxNlrOIeGa4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzkwODM4NA==", "bodyText": "same as above for hazelcast-spring-4.1.xsd: should we mutate already published XSDs?", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567908384", "createdAt": "2021-02-01T15:23:55Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "diffHunk": "@@ -5024,23 +5024,6 @@\n                     </xs:documentation>\n                 </xs:annotation>\n             </xs:element>\n-            <xs:element name=\"operation-pool-size\" type=\"xs:int\" minOccurs=\"0\" maxOccurs=\"1\" default=\"-1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQzMzM3OA==", "bodyText": "Fixed. No need to change 4.1.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568433378", "createdAt": "2021-02-02T09:07:16Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "diffHunk": "@@ -5024,23 +5024,6 @@\n                     </xs:documentation>\n                 </xs:annotation>\n             </xs:element>\n-            <xs:element name=\"operation-pool-size\" type=\"xs:int\" minOccurs=\"0\" maxOccurs=\"1\" default=\"-1\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzkwODM4NA=="}, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzg2NzI3OnYy", "diffSide": "RIGHT", "path": "docs/design/sql/04-parallel-execution.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoxMzo1MlrOIebq7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoxMzo1MlrOIebq7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc4MTU1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n          \n          \n            \n            cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n          \n          \n            \n            Hazelcast Jet uses its own cooperative thread pool to execute Jet jobs. A job is split into \"tasklets\", each vertex in the DAG is\n          \n          \n            \n            backed by one or more tasklets on each cluster member. Every tasklet is assigned to one cooperative thread, the thread then\n          \n          \n            \n            executes the tasklets in a loop. There is no balancing: once a tasklet is submitted to a specific thread, it is always executed in\n          \n          \n            \n            that thread. Non-cooperative tasklets (those handling a blocking API such as JDBC) run on dedicated threads.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568781550", "createdAt": "2021-02-02T17:13:52Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzg3OTQ0OnYy", "diffSide": "RIGHT", "path": "docs/design/sql/04-parallel-execution.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoxNjoxNVrOIebyPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoxNjoxNVrOIebyPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc4MzQyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n          \n          \n            \n            Hazelcast Jet follows this principle, as only one thread may execute a particular tasklet. However, Hazelcast Jet pool doesn't", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568783420", "createdAt": "2021-02-02T17:16:15Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MzkyNzA1OnYy", "diffSide": "RIGHT", "path": "docs/design/sql/04-parallel-execution.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoyNjoyMFrOIecPww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzoxODo1M1rOIflvVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5MDk3OQ==", "bodyText": "Jet used to have work-stealing. But we determined it's not needed. There's no such thing as a long-running task in Jet pool. Each tasklet is required to do a small amount of work and yield so that a next tasklet can execute. One large job doesn't block other concurrent small jobs.\nOne operator is typically backed by as many tasklets as there are local threads. Unless the operation is partitioned (such as aggregating by key), load balancing is performed by the upstream tasklet: each tasklet has an input queue with fixed capacity. The upstream tasklets, when adding items to queues, add to any queue that has space.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568790979", "createdAt": "2021-02-02T17:26:20Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n+satisfy the load balancing requirement discussed below.\n+\n+Second, the execution environment must support load balancing. Query execution may take a long time to complete. If several query\n+fragments have been assigned to a single execution thread, it should be possible to reassign them to idle threads dynamically.\n+Neither partition pool nor Hazelcast Jet pool designs are applicable to Hazelcast Mustang because they lack balancing\n+capabilities.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NTA5NQ==", "bodyText": "The IMDG SQL is different - it may allow for a long execution of a certain fragment. During this time, we do not want another task sitting in the queue of the same thread to wait. This is where the load balancing comes into play.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569995095", "createdAt": "2021-02-04T07:18:53Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n+satisfy the load balancing requirement discussed below.\n+\n+Second, the execution environment must support load balancing. Query execution may take a long time to complete. If several query\n+fragments have been assigned to a single execution thread, it should be possible to reassign them to idle threads dynamically.\n+Neither partition pool nor Hazelcast Jet pool designs are applicable to Hazelcast Mustang because they lack balancing\n+capabilities.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5MDk3OQ=="}, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MzkzOTI2OnYy", "diffSide": "RIGHT", "path": "docs/design/sql/04-parallel-execution.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoyOTowMlrOIecXjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzoyMDoyN1rOIflyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5Mjk3NA==", "bodyText": "This is probably wrong:\n\nif message A is received before message B, then it should be executed before B\n\nYou probably wanted to say: even if B is received before A, A should be executed before B.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568792974", "createdAt": "2021-02-02T17:29:02Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n+satisfy the load balancing requirement discussed below.\n+\n+Second, the execution environment must support load balancing. Query execution may take a long time to complete. If several query\n+fragments have been assigned to a single execution thread, it should be possible to reassign them to idle threads dynamically.\n+Neither partition pool nor Hazelcast Jet pool designs are applicable to Hazelcast Mustang because they lack balancing\n+capabilities.\n+\n+Third, it should be possible to execute some messages in order. That is, if message `A` is received before message `B`, then it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NTgyOQ==", "bodyText": "Removed that line from the document, since it causes confusion, but adds no value.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569995829", "createdAt": "2021-02-04T07:20:27Z", "author": {"login": "devozerov"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n+satisfy the load balancing requirement discussed below.\n+\n+Second, the execution environment must support load balancing. Query execution may take a long time to complete. If several query\n+fragments have been assigned to a single execution thread, it should be possible to reassign them to idle threads dynamically.\n+Neither partition pool nor Hazelcast Jet pool designs are applicable to Hazelcast Mustang because they lack balancing\n+capabilities.\n+\n+Third, it should be possible to execute some messages in order. That is, if message `A` is received before message `B`, then it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5Mjk3NA=="}, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NzA4OTYwOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo0ODo1N1rOIe5nKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzoyMjowNVrOIfl09g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MjEwNw==", "bodyText": "Style note: I'm wondering why don't we have the execute method on the operation?", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569272107", "createdAt": "2021-02-03T09:48:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java", "diffHunk": "@@ -131,31 +145,18 @@ public boolean submitRemote(UUID callerId, Connection connection, QueryOperation\n         }\n     }\n \n-    @Override\n-    public QueryOperationChannel createChannel(UUID sourceMemberId, UUID targetMemberId) {\n-        if (targetMemberId.equals(getLocalMemberId())) {\n-            return new QueryOperationChannelImpl(this, sourceMemberId, null);\n-        } else {\n-            Connection connection = getConnection(targetMemberId);\n-\n-            if (connection == null) {\n-                throw QueryException.memberConnection(targetMemberId);\n-            }\n-\n-            return new QueryOperationChannelImpl(this, sourceMemberId, connection);\n-        }\n-    }\n-\n     @Override\n     public void execute(QueryOperation operation) {\n+        assert operation.isSystem() == QueryOperationWorkerPool.isSystemThread();\n+\n         if (operation instanceof QueryExecuteOperation) {\n             handleExecute((QueryExecuteOperation) operation);\n-        } else if (operation instanceof QueryBatchExchangeOperation) {\n-            handleBatch((QueryBatchExchangeOperation) operation);\n+        } else if (operation instanceof QueryExecuteFragmentOperation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NjUzNA==", "bodyText": "Just a way to organize the code. Currently, messages are POJOs, and the logic is concentrated in the QueryOperationHandlerImpl. Otherwise, we would have to pass some context/state to messages, which may make the code a little bit more complicated. But in any case, this is primarily about styling. Both approaches work.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569996534", "createdAt": "2021-02-04T07:22:05Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java", "diffHunk": "@@ -131,31 +145,18 @@ public boolean submitRemote(UUID callerId, Connection connection, QueryOperation\n         }\n     }\n \n-    @Override\n-    public QueryOperationChannel createChannel(UUID sourceMemberId, UUID targetMemberId) {\n-        if (targetMemberId.equals(getLocalMemberId())) {\n-            return new QueryOperationChannelImpl(this, sourceMemberId, null);\n-        } else {\n-            Connection connection = getConnection(targetMemberId);\n-\n-            if (connection == null) {\n-                throw QueryException.memberConnection(targetMemberId);\n-            }\n-\n-            return new QueryOperationChannelImpl(this, sourceMemberId, connection);\n-        }\n-    }\n-\n     @Override\n     public void execute(QueryOperation operation) {\n+        assert operation.isSystem() == QueryOperationWorkerPool.isSystemThread();\n+\n         if (operation instanceof QueryExecuteOperation) {\n             handleExecute((QueryExecuteOperation) operation);\n-        } else if (operation instanceof QueryBatchExchangeOperation) {\n-            handleBatch((QueryBatchExchangeOperation) operation);\n+        } else if (operation instanceof QueryExecuteFragmentOperation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MjEwNw=="}, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NzEzOTc3OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo1OTozNFrOIe6GGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzoyMzoxMlrOIfl2sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI4MDAyNA==", "bodyText": "This whole javadoc is an exact copy of the javadoc of onDistributedQueryStarted. I think we should delete it.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569280024", "createdAt": "2021-02-03T09:59:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistry.java", "diffHunk": "@@ -90,17 +90,50 @@ public QueryState onInitiatorQueryStarted(\n      * of these events. This is not a problem, because {@link QueryStateRegistryUpdater} will eventually detect that\n      * the query is not longer active on the initiator member.\n      *\n-     * @param localMemberId Cache local member ID.\n-     * @param queryId Query ID.\n-     * @param completionCallback Callback that will be invoked when the query is completed.\n-     * @return Query state or {@code null} if the query with the given ID is guaranteed to be already completed.\n+     * @param localMemberId cached local member ID\n+     * @param queryId query ID\n+     * @param completionCallback callback that will be invoked when the query is completed\n+     * @param cancelled if the query should be created in the cancelled state\n+     * @return query state or {@code null} if the query with the given ID is guaranteed to be already completed\n      */\n     public QueryState onDistributedQueryStarted(\n         UUID localMemberId,\n         QueryId queryId,\n-        QueryStateCompletionCallback completionCallback\n+        QueryStateCompletionCallback completionCallback,\n+        boolean cancelled\n+    ) {\n+        QueryState state = onDistributedQueryStarted0(localMemberId, queryId, completionCallback, cancelled);\n+\n+        if (state != null) {\n+            state.updateLastActivityTime();\n+        }\n+\n+        return state;\n+    }\n+\n+    /**\n+     * Registers a distributed query in response to query start message or query batch message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5Njk3OQ==", "bodyText": "Removed the duplicated JavaDoc.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569996979", "createdAt": "2021-02-04T07:23:12Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistry.java", "diffHunk": "@@ -90,17 +90,50 @@ public QueryState onInitiatorQueryStarted(\n      * of these events. This is not a problem, because {@link QueryStateRegistryUpdater} will eventually detect that\n      * the query is not longer active on the initiator member.\n      *\n-     * @param localMemberId Cache local member ID.\n-     * @param queryId Query ID.\n-     * @param completionCallback Callback that will be invoked when the query is completed.\n-     * @return Query state or {@code null} if the query with the given ID is guaranteed to be already completed.\n+     * @param localMemberId cached local member ID\n+     * @param queryId query ID\n+     * @param completionCallback callback that will be invoked when the query is completed\n+     * @param cancelled if the query should be created in the cancelled state\n+     * @return query state or {@code null} if the query with the given ID is guaranteed to be already completed\n      */\n     public QueryState onDistributedQueryStarted(\n         UUID localMemberId,\n         QueryId queryId,\n-        QueryStateCompletionCallback completionCallback\n+        QueryStateCompletionCallback completionCallback,\n+        boolean cancelled\n+    ) {\n+        QueryState state = onDistributedQueryStarted0(localMemberId, queryId, completionCallback, cancelled);\n+\n+        if (state != null) {\n+            state.updateLastActivityTime();\n+        }\n+\n+        return state;\n+    }\n+\n+    /**\n+     * Registers a distributed query in response to query start message or query batch message.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI4MDAyNA=="}, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Nzg1MDQ4OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMjo1NTo1MVrOIfA2ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzoyNDozMVrOIfl5HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM5MDY5OA==", "bodyText": "The targetIsParticipant  name is misleading. IIUIC it means whether the operations are executed on the initiator or on the other member. But the initiator is also a participant. A better name would be targetIsInitiator (with inverse meaning).", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569390698", "createdAt": "2021-02-03T12:55:51Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -465,162 +540,124 @@ private QueryExecuteOperation createExecuteOperation(UUID toMemberId) {\n         );\n     }\n \n-    private QueryBatchExchangeOperation createBatch1Operation(UUID toMemberId) {\n-        return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n-            EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(0, BATCH_SIZE),\n-            false,\n-            Long.MAX_VALUE\n-        );\n-    }\n+    private QueryBatchExchangeOperation createBatchOperation(UUID targetMemberId, int value) {\n+        long ordinal = value;\n+        boolean last = value == 1;\n+        ListRowBatch rows = createMonotonicBatch(value, 1);\n \n-    private QueryBatchExchangeOperation createBatch2Operation(UUID toMemberId) {\n         return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n+            queryId,\n             EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(BATCH_SIZE, BATCH_SIZE),\n-            true,\n+            targetMemberId,\n+            rows,\n+            ordinal,\n+            last,\n             Long.MAX_VALUE\n         );\n     }\n \n-    private QueryCancelOperation createCancelOperation(UUID fromMemberId) {\n+    private QueryCancelOperation createCancelOperation(UUID sourceMemberId) {\n         return new QueryCancelOperation(\n-            testState.getQueryId(),\n+            queryId,\n             SqlErrorCode.GENERIC,\n             \"Error\",\n-            fromMemberId\n+            sourceMemberId\n         );\n     }\n \n-    private State startQueryOnInitiator(long timeout) {\n-        Plan plan = new Plan(\n-            partitionMap,\n-            Collections.emptyList(),\n-            Collections.emptyList(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            null,\n-            QueryParameterMetadata.EMPTY,\n-            null,\n-            Collections.emptySet(),\n-            Collections.emptyList()\n-        );\n-\n-        QueryId queryId = initiatorService.getStateRegistry().onInitiatorQueryStarted(\n-            QueryId.create(initiatorId),\n-            initiatorId,\n-            timeout,\n-            plan,\n-            null,\n-            null,\n-            new BlockingRootResultConsumer(),\n-            initiatorService.getOperationHandler()\n-        ).getQueryId();\n-\n-        testState = new State(queryId);\n-\n-        return testState;\n+    private UUID targetId() {\n+        return targetIsParticipant ? participantId : initiatorId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 870}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NzU5Ng==", "bodyText": "Renamed to targetIsNotInitiator.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569997596", "createdAt": "2021-02-04T07:24:31Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -465,162 +540,124 @@ private QueryExecuteOperation createExecuteOperation(UUID toMemberId) {\n         );\n     }\n \n-    private QueryBatchExchangeOperation createBatch1Operation(UUID toMemberId) {\n-        return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n-            EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(0, BATCH_SIZE),\n-            false,\n-            Long.MAX_VALUE\n-        );\n-    }\n+    private QueryBatchExchangeOperation createBatchOperation(UUID targetMemberId, int value) {\n+        long ordinal = value;\n+        boolean last = value == 1;\n+        ListRowBatch rows = createMonotonicBatch(value, 1);\n \n-    private QueryBatchExchangeOperation createBatch2Operation(UUID toMemberId) {\n         return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n+            queryId,\n             EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(BATCH_SIZE, BATCH_SIZE),\n-            true,\n+            targetMemberId,\n+            rows,\n+            ordinal,\n+            last,\n             Long.MAX_VALUE\n         );\n     }\n \n-    private QueryCancelOperation createCancelOperation(UUID fromMemberId) {\n+    private QueryCancelOperation createCancelOperation(UUID sourceMemberId) {\n         return new QueryCancelOperation(\n-            testState.getQueryId(),\n+            queryId,\n             SqlErrorCode.GENERIC,\n             \"Error\",\n-            fromMemberId\n+            sourceMemberId\n         );\n     }\n \n-    private State startQueryOnInitiator(long timeout) {\n-        Plan plan = new Plan(\n-            partitionMap,\n-            Collections.emptyList(),\n-            Collections.emptyList(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            null,\n-            QueryParameterMetadata.EMPTY,\n-            null,\n-            Collections.emptySet(),\n-            Collections.emptyList()\n-        );\n-\n-        QueryId queryId = initiatorService.getStateRegistry().onInitiatorQueryStarted(\n-            QueryId.create(initiatorId),\n-            initiatorId,\n-            timeout,\n-            plan,\n-            null,\n-            null,\n-            new BlockingRootResultConsumer(),\n-            initiatorService.getOperationHandler()\n-        ).getQueryId();\n-\n-        testState = new State(queryId);\n-\n-        return testState;\n+    private UUID targetId() {\n+        return targetIsParticipant ? participantId : initiatorId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM5MDY5OA=="}, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 870}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4ODAwNzcyOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzozMzozMFrOIfCWGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzoyNzozMVrOIfl-Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTE5Mg==", "bodyText": "We can probably remove this line, same code is on line 447.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569415192", "createdAt": "2021-02-03T13:33:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -105,357 +93,444 @@\n \n     private Map<UUID, PartitionIdSet> partitionMap;\n \n-    private QueryExecuteOperation initiatorExecuteOperation;\n-    private QueryBatchExchangeOperation initiatorBatch1Operation;\n-    private QueryBatchExchangeOperation initiatorBatch2Operation;\n-    private QueryCancelOperation initiatorCancelOperation;\n+    private QueryId queryId;\n+\n+    @Parameterized.Parameter\n+    public boolean targetIsParticipant;\n+\n+    @Parameterized.Parameters(name = \"targetIsParticipant:{0}\")\n+    public static Collection<Object[]> parameters() {\n+        List<Object[]> res = new ArrayList<>();\n \n-    private QueryExecuteOperation participantExecuteOperation;\n-    private QueryBatchExchangeOperation participantBatch1Operation;\n-    private QueryBatchExchangeOperation participantBatch2Operation;\n-    private QueryCancelOperation participantCancelOperation;\n+        res.add(new Object[] { true });\n+        res.add(new Object[] { false });\n \n-    private QueryOperationChannel toInitiatorChannel;\n-    private QueryOperationChannel toParticipantChannel;\n+        return res;\n+    }\n+\n+    @Override\n+    protected Config getConfig() {\n+        return smallInstanceConfig();\n+    }\n \n     @Before\n     public void before() {\n-        factory = new TestHazelcastInstanceFactory(2);\n-\n-        initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n-        participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n \n         initiatorId = initiator.getLocalEndpoint().getUuid();\n         participantId = participant.getLocalEndpoint().getUuid();\n \n-        initiatorService = setInternalService(initiator, STATE_CHECK_FREQUENCY);\n-        participantService = setInternalService(participant, STATE_CHECK_FREQUENCY);\n+        initiatorService = sqlInternalService(initiator);\n+        participantService = sqlInternalService(participant);\n+\n+        setStateCheckFrequency(Long.MAX_VALUE);\n \n         partitionMap = new HashMap<>();\n         partitionMap.put(initiatorId, new PartitionIdSet(2, Collections.singletonList(1)));\n-        partitionMap.put(participantId, new PartitionIdSet(1, Collections.singletonList(2)));\n+        partitionMap.put(participantId, new PartitionIdSet(2, Collections.singletonList(2)));\n+\n+        queryId = QueryId.create(initiatorId);\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void test_E() {\n+        sendExecute(false);\n+        assertQueryRegisteredEventually(queryId);\n+\n+        if (targetIsParticipant) {\n+            setOrphanedQueryStateCheckFrequency(100L);\n+            setStateCheckFrequency(100L);\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n+    }\n \n-        // Start the query with maximum timeout by default.\n-        prepare(Long.MAX_VALUE);\n+    @Test\n+    public void test_E_B1_B2_ordered() {\n+        check_E_B1_B2(true);\n     }\n \n-    private void prepare(long timeout) {\n-        testState = startQueryOnInitiator(timeout);\n+    @Test\n+    public void test_E_B1_B2_unordered() {\n+        check_E_B1_B2(false);\n+    }\n \n-        initiatorExecuteOperation = createExecuteOperation(initiatorId);\n-        participantExecuteOperation = createExecuteOperation(participantId);\n+    private void check_E_B1_B2(boolean ordered) {\n+        sendExecute(ordered);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        initiatorBatch1Operation = createBatch1Operation(initiatorId);\n-        participantBatch1Operation = createBatch1Operation(participantId);\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        initiatorBatch2Operation = createBatch2Operation(initiatorId);\n-        participantBatch2Operation = createBatch2Operation(participantId);\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        initiatorCancelOperation = createCancelOperation(participantId);\n-        participantCancelOperation = createCancelOperation(initiatorId);\n+        sendBatch(VALUE_1);\n+        assertConsumedEventually(exec, VALUE_1);\n \n-        toInitiatorChannel = participantService.getOperationHandler().createChannel(participantId, initiatorId);\n-        toParticipantChannel = initiatorService.getOperationHandler().createChannel(initiatorId, participantId);\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @After\n-    public void after() {\n-        if (factory != null) {\n-            factory.shutdownAll();\n-        }\n+    @Test\n+    public void test_E_B2_B1_ordered() {\n+        check_E_B2_B1(true);\n     }\n \n     @Test\n-    public void test_initiator_timeout() {\n-        stopQueryOnInitiator();\n-        prepare(50L);\n-\n-        sendToInitiator(initiatorExecuteOperation);\n-        checkNoQueryOnInitiator();\n+    public void test_E_B2_B1_unordered() {\n+        check_E_B2_B1(false);\n     }\n \n-    @Test\n-    public void test_initiator_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void check_E_B2_B1(boolean ordered) {\n+        sendExecute(ordered);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n-    }\n+        // Send the second batch, only unordered exec should process it\n+        sendBatch(VALUE_1);\n \n-    @Test\n-    public void test_initiator_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+        if (ordered) {\n+            assertNotConsumedWithDelay(exec, VALUE_1);\n+        } else {\n+            assertConsumedEventually(exec, VALUE_1);\n+        }\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        // Send the first batch, processing should be finished in both modes\n+        sendBatch(VALUE_0);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        assertConsumedEventually(exec, VALUE_0);\n+\n+        if (ordered) {\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+        } else {\n+            assertTrue(exec.reordered);\n+        }\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_B_C() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_L_B() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_C_B() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n+\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n+\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n \n-        // LEAVE\n-        participant.shutdown();\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n \n-        // BATCH\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        if (targetIsParticipant) {\n+            assertQueryRegisteredEventually(queryId);\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B() {\n+        sendBatch(VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            setStateCheckFrequency(100L);\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B_C() {\n+        sendBatch(VALUE_0);\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+            sendCancel();\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+    @Test\n+    public void test_B1_E_B2_ordered() {\n+        check_B1_E_B2(true);\n     }\n \n     @Test\n-    public void test_participant_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B1_E_B2_unordered() {\n+        check_B1_E_B2(false);\n+    }\n+\n+    private void check_B1_E_B2(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+            sendBatch(VALUE_1);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_E_B1_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_E_B1_ordered() {\n+        check_B2_E_B1(true);\n     }\n \n     @Test\n-    public void test_participant_B1_E_B2_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_E_B1_unordered() {\n+        check_B2_E_B1(false);\n+    }\n+\n+    private void check_B2_E_B1(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+\n+            if (ordered) {\n+                assertNotConsumedWithDelay(exec, VALUE_1);\n+            } else {\n+                assertConsumedEventually(exec, VALUE_1);\n+            }\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertConsumedEventually(exec, VALUE_1);\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n     @Test\n-    public void test_participant_B1_E_C_B2() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n-\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n-\n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n-\n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n-    }\n-\n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n+    public void test_B1_B2_E_ordered() {\n+        check_B1_B2_E(true);\n+    }\n+\n     @Test\n-    public void test_participant_B1_C_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B1_B2_E_unordered() {\n+        check_B1_B2_E(false);\n+    }\n+\n+    private void check_B1_B2_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendBatch(VALUE_1);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_B1_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_B1_E_ordered() {\n+        check_B2_B1_E(true);\n     }\n \n     @Test\n-    public void test_participant_B1_B2_E_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_B1_E_unordered() {\n+        check_B2_B1_E(false);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n+    private void check_B2_B1_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_B2_C_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_C_B2_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C_E() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            sendExecute(false);\n+            assertQueryNotRegisteredEventually(queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 681}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5ODkxOA==", "bodyText": "Removed the unnecessary line.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569998918", "createdAt": "2021-02-04T07:27:31Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -105,357 +93,444 @@\n \n     private Map<UUID, PartitionIdSet> partitionMap;\n \n-    private QueryExecuteOperation initiatorExecuteOperation;\n-    private QueryBatchExchangeOperation initiatorBatch1Operation;\n-    private QueryBatchExchangeOperation initiatorBatch2Operation;\n-    private QueryCancelOperation initiatorCancelOperation;\n+    private QueryId queryId;\n+\n+    @Parameterized.Parameter\n+    public boolean targetIsParticipant;\n+\n+    @Parameterized.Parameters(name = \"targetIsParticipant:{0}\")\n+    public static Collection<Object[]> parameters() {\n+        List<Object[]> res = new ArrayList<>();\n \n-    private QueryExecuteOperation participantExecuteOperation;\n-    private QueryBatchExchangeOperation participantBatch1Operation;\n-    private QueryBatchExchangeOperation participantBatch2Operation;\n-    private QueryCancelOperation participantCancelOperation;\n+        res.add(new Object[] { true });\n+        res.add(new Object[] { false });\n \n-    private QueryOperationChannel toInitiatorChannel;\n-    private QueryOperationChannel toParticipantChannel;\n+        return res;\n+    }\n+\n+    @Override\n+    protected Config getConfig() {\n+        return smallInstanceConfig();\n+    }\n \n     @Before\n     public void before() {\n-        factory = new TestHazelcastInstanceFactory(2);\n-\n-        initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n-        participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n \n         initiatorId = initiator.getLocalEndpoint().getUuid();\n         participantId = participant.getLocalEndpoint().getUuid();\n \n-        initiatorService = setInternalService(initiator, STATE_CHECK_FREQUENCY);\n-        participantService = setInternalService(participant, STATE_CHECK_FREQUENCY);\n+        initiatorService = sqlInternalService(initiator);\n+        participantService = sqlInternalService(participant);\n+\n+        setStateCheckFrequency(Long.MAX_VALUE);\n \n         partitionMap = new HashMap<>();\n         partitionMap.put(initiatorId, new PartitionIdSet(2, Collections.singletonList(1)));\n-        partitionMap.put(participantId, new PartitionIdSet(1, Collections.singletonList(2)));\n+        partitionMap.put(participantId, new PartitionIdSet(2, Collections.singletonList(2)));\n+\n+        queryId = QueryId.create(initiatorId);\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void test_E() {\n+        sendExecute(false);\n+        assertQueryRegisteredEventually(queryId);\n+\n+        if (targetIsParticipant) {\n+            setOrphanedQueryStateCheckFrequency(100L);\n+            setStateCheckFrequency(100L);\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n+    }\n \n-        // Start the query with maximum timeout by default.\n-        prepare(Long.MAX_VALUE);\n+    @Test\n+    public void test_E_B1_B2_ordered() {\n+        check_E_B1_B2(true);\n     }\n \n-    private void prepare(long timeout) {\n-        testState = startQueryOnInitiator(timeout);\n+    @Test\n+    public void test_E_B1_B2_unordered() {\n+        check_E_B1_B2(false);\n+    }\n \n-        initiatorExecuteOperation = createExecuteOperation(initiatorId);\n-        participantExecuteOperation = createExecuteOperation(participantId);\n+    private void check_E_B1_B2(boolean ordered) {\n+        sendExecute(ordered);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        initiatorBatch1Operation = createBatch1Operation(initiatorId);\n-        participantBatch1Operation = createBatch1Operation(participantId);\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        initiatorBatch2Operation = createBatch2Operation(initiatorId);\n-        participantBatch2Operation = createBatch2Operation(participantId);\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        initiatorCancelOperation = createCancelOperation(participantId);\n-        participantCancelOperation = createCancelOperation(initiatorId);\n+        sendBatch(VALUE_1);\n+        assertConsumedEventually(exec, VALUE_1);\n \n-        toInitiatorChannel = participantService.getOperationHandler().createChannel(participantId, initiatorId);\n-        toParticipantChannel = initiatorService.getOperationHandler().createChannel(initiatorId, participantId);\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @After\n-    public void after() {\n-        if (factory != null) {\n-            factory.shutdownAll();\n-        }\n+    @Test\n+    public void test_E_B2_B1_ordered() {\n+        check_E_B2_B1(true);\n     }\n \n     @Test\n-    public void test_initiator_timeout() {\n-        stopQueryOnInitiator();\n-        prepare(50L);\n-\n-        sendToInitiator(initiatorExecuteOperation);\n-        checkNoQueryOnInitiator();\n+    public void test_E_B2_B1_unordered() {\n+        check_E_B2_B1(false);\n     }\n \n-    @Test\n-    public void test_initiator_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void check_E_B2_B1(boolean ordered) {\n+        sendExecute(ordered);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n-    }\n+        // Send the second batch, only unordered exec should process it\n+        sendBatch(VALUE_1);\n \n-    @Test\n-    public void test_initiator_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+        if (ordered) {\n+            assertNotConsumedWithDelay(exec, VALUE_1);\n+        } else {\n+            assertConsumedEventually(exec, VALUE_1);\n+        }\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        // Send the first batch, processing should be finished in both modes\n+        sendBatch(VALUE_0);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        assertConsumedEventually(exec, VALUE_0);\n+\n+        if (ordered) {\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+        } else {\n+            assertTrue(exec.reordered);\n+        }\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_B_C() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_L_B() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_C_B() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n+\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n+\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n \n-        // LEAVE\n-        participant.shutdown();\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n \n-        // BATCH\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        if (targetIsParticipant) {\n+            assertQueryRegisteredEventually(queryId);\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B() {\n+        sendBatch(VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            setStateCheckFrequency(100L);\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B_C() {\n+        sendBatch(VALUE_0);\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+            sendCancel();\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+    @Test\n+    public void test_B1_E_B2_ordered() {\n+        check_B1_E_B2(true);\n     }\n \n     @Test\n-    public void test_participant_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B1_E_B2_unordered() {\n+        check_B1_E_B2(false);\n+    }\n+\n+    private void check_B1_E_B2(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+            sendBatch(VALUE_1);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_E_B1_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_E_B1_ordered() {\n+        check_B2_E_B1(true);\n     }\n \n     @Test\n-    public void test_participant_B1_E_B2_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_E_B1_unordered() {\n+        check_B2_E_B1(false);\n+    }\n+\n+    private void check_B2_E_B1(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+\n+            if (ordered) {\n+                assertNotConsumedWithDelay(exec, VALUE_1);\n+            } else {\n+                assertConsumedEventually(exec, VALUE_1);\n+            }\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertConsumedEventually(exec, VALUE_1);\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n     @Test\n-    public void test_participant_B1_E_C_B2() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n-\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n-\n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n-\n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n-    }\n-\n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n+    public void test_B1_B2_E_ordered() {\n+        check_B1_B2_E(true);\n+    }\n+\n     @Test\n-    public void test_participant_B1_C_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B1_B2_E_unordered() {\n+        check_B1_B2_E(false);\n+    }\n+\n+    private void check_B1_B2_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendBatch(VALUE_1);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_B1_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_B1_E_ordered() {\n+        check_B2_B1_E(true);\n     }\n \n     @Test\n-    public void test_participant_B1_B2_E_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_B1_E_unordered() {\n+        check_B2_B1_E(false);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n+    private void check_B2_B1_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_B2_C_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_C_B2_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C_E() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            sendExecute(false);\n+            assertQueryNotRegisteredEventually(queryId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTE5Mg=="}, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 681}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4ODAxOTExOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzozNTo1N1rOIfCc9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQxMTozNjozMlrOIfvfhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ==", "bodyText": "We miss a test for cancel after a completed execution (test_E_B1_B2_C)", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569416949", "createdAt": "2021-02-03T13:35:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -16,86 +16,74 @@\n \n package com.hazelcast.sql.impl.operation;\n \n-import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.config.Config;\n import com.hazelcast.instance.impl.HazelcastInstanceProxy;\n-import com.hazelcast.internal.serialization.InternalSerializationService;\n import com.hazelcast.internal.util.collection.PartitionIdSet;\n-import com.hazelcast.spi.impl.NodeEngineImpl;\n-import com.hazelcast.sql.impl.SqlErrorCode;\n-import com.hazelcast.sql.impl.NodeServiceProviderImpl;\n import com.hazelcast.sql.impl.QueryId;\n import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n import com.hazelcast.sql.impl.SqlInternalService;\n-import com.hazelcast.sql.impl.SqlServiceImpl;\n import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.exec.AbstractUpstreamAwareExec;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitor;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitorCallback;\n import com.hazelcast.sql.impl.exec.Exec;\n import com.hazelcast.sql.impl.exec.IterationResult;\n-import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n import com.hazelcast.sql.impl.plan.Plan;\n import com.hazelcast.sql.impl.plan.node.PlanNode;\n import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n import com.hazelcast.sql.impl.plan.node.io.ReceivePlanNode;\n import com.hazelcast.sql.impl.row.EmptyRowBatch;\n import com.hazelcast.sql.impl.row.ListRowBatch;\n-import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.state.QueryState;\n import com.hazelcast.sql.impl.type.QueryDataType;\n-import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.sql.impl.worker.QueryFragmentExecutable;\n+import com.hazelcast.test.HazelcastParallelParametersRunnerFactory;\n import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n \n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n /**\n- * A set of integration tests for query message processing on a single member.\n- * <p>\n- * Abbreviations:\n- * <ul>\n- *     <li>E - execute</li>\n- *     <li>Bx - batch request with x ordinal</li>\n- *     <li>C - cancel</li>\n- *     <li>L - leave of the other member</li>\n- * </ul>\n+ * Tests for different combinations of events\n  */\n-@RunWith(HazelcastSerialClassRunner.class)\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastParallelParametersRunnerFactory.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-@Ignore(\"https://github.com/hazelcast/hazelcast/issues/16929#issuecomment-699819103\")\n public class QueryOperationHandlerTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NzkxNA==", "bodyText": "This case is covered in test_C because we do not leave any state once the query is completed.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569997914", "createdAt": "2021-02-04T07:25:17Z", "author": {"login": "devozerov"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -16,86 +16,74 @@\n \n package com.hazelcast.sql.impl.operation;\n \n-import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.config.Config;\n import com.hazelcast.instance.impl.HazelcastInstanceProxy;\n-import com.hazelcast.internal.serialization.InternalSerializationService;\n import com.hazelcast.internal.util.collection.PartitionIdSet;\n-import com.hazelcast.spi.impl.NodeEngineImpl;\n-import com.hazelcast.sql.impl.SqlErrorCode;\n-import com.hazelcast.sql.impl.NodeServiceProviderImpl;\n import com.hazelcast.sql.impl.QueryId;\n import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n import com.hazelcast.sql.impl.SqlInternalService;\n-import com.hazelcast.sql.impl.SqlServiceImpl;\n import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.exec.AbstractUpstreamAwareExec;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitor;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitorCallback;\n import com.hazelcast.sql.impl.exec.Exec;\n import com.hazelcast.sql.impl.exec.IterationResult;\n-import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n import com.hazelcast.sql.impl.plan.Plan;\n import com.hazelcast.sql.impl.plan.node.PlanNode;\n import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n import com.hazelcast.sql.impl.plan.node.io.ReceivePlanNode;\n import com.hazelcast.sql.impl.row.EmptyRowBatch;\n import com.hazelcast.sql.impl.row.ListRowBatch;\n-import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.state.QueryState;\n import com.hazelcast.sql.impl.type.QueryDataType;\n-import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.sql.impl.worker.QueryFragmentExecutable;\n+import com.hazelcast.test.HazelcastParallelParametersRunnerFactory;\n import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n \n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n /**\n- * A set of integration tests for query message processing on a single member.\n- * <p>\n- * Abbreviations:\n- * <ul>\n- *     <li>E - execute</li>\n- *     <li>Bx - batch request with x ordinal</li>\n- *     <li>C - cancel</li>\n- *     <li>L - leave of the other member</li>\n- * </ul>\n+ * Tests for different combinations of events\n  */\n-@RunWith(HazelcastSerialClassRunner.class)\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastParallelParametersRunnerFactory.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-@Ignore(\"https://github.com/hazelcast/hazelcast/issues/16929#issuecomment-699819103\")\n public class QueryOperationHandlerTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ=="}, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDE1NDg4Nw==", "bodyText": "I still think such a test might be worthwhile. The current impl does as you say, but it's a common scenario and it should be easy to add such a test.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r570154887", "createdAt": "2021-02-04T11:36:32Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -16,86 +16,74 @@\n \n package com.hazelcast.sql.impl.operation;\n \n-import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.config.Config;\n import com.hazelcast.instance.impl.HazelcastInstanceProxy;\n-import com.hazelcast.internal.serialization.InternalSerializationService;\n import com.hazelcast.internal.util.collection.PartitionIdSet;\n-import com.hazelcast.spi.impl.NodeEngineImpl;\n-import com.hazelcast.sql.impl.SqlErrorCode;\n-import com.hazelcast.sql.impl.NodeServiceProviderImpl;\n import com.hazelcast.sql.impl.QueryId;\n import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n import com.hazelcast.sql.impl.SqlInternalService;\n-import com.hazelcast.sql.impl.SqlServiceImpl;\n import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.exec.AbstractUpstreamAwareExec;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitor;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitorCallback;\n import com.hazelcast.sql.impl.exec.Exec;\n import com.hazelcast.sql.impl.exec.IterationResult;\n-import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n import com.hazelcast.sql.impl.plan.Plan;\n import com.hazelcast.sql.impl.plan.node.PlanNode;\n import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n import com.hazelcast.sql.impl.plan.node.io.ReceivePlanNode;\n import com.hazelcast.sql.impl.row.EmptyRowBatch;\n import com.hazelcast.sql.impl.row.ListRowBatch;\n-import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.state.QueryState;\n import com.hazelcast.sql.impl.type.QueryDataType;\n-import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.sql.impl.worker.QueryFragmentExecutable;\n+import com.hazelcast.test.HazelcastParallelParametersRunnerFactory;\n import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n \n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n /**\n- * A set of integration tests for query message processing on a single member.\n- * <p>\n- * Abbreviations:\n- * <ul>\n- *     <li>E - execute</li>\n- *     <li>Bx - batch request with x ordinal</li>\n- *     <li>C - cancel</li>\n- *     <li>L - leave of the other member</li>\n- * </ul>\n+ * Tests for different combinations of events\n  */\n-@RunWith(HazelcastSerialClassRunner.class)\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastParallelParametersRunnerFactory.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-@Ignore(\"https://github.com/hazelcast/hazelcast/issues/16929#issuecomment-699819103\")\n public class QueryOperationHandlerTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ=="}, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 28, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}