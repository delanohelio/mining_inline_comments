{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2ODQ5NDY0", "number": 17340, "title": "SQL math expressions (#17339)", "bodyText": "This PR introduces base SQL math functions.\nOut of scope due to additional complexity: ATAN2, POWER/SQRT, RAND_INTEGER\nCloses #17339", "createdAt": "2020-08-12T15:32:37Z", "url": "https://github.com/hazelcast/hazelcast/pull/17340", "merged": true, "mergeCommit": {"oid": "cc9e7d33c882ef35ddd9cce1ba144c5fd2eb104e"}, "closed": true, "closedAt": "2020-08-18T05:50:42Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-NFM3AH2gAyNDY2ODQ5NDY0Ojk3N2MzOGNkNTM1MDQzZjIxMjdkOTAwYjVjYWI2YTY5NjU2Y2YzY2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc__yzKgFqTQ2ODk5MjEzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/977c38cd535043f2127d900b5cab6a69656cf3cf", "committedDate": "2020-08-12T15:23:50Z", "message": "SQL math expressions (#17339)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NTEyOTgz", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-466512983", "createdAt": "2020-08-13T07:35:15Z", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzozNToxNVrOG__i5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzo0OTozNlrOHAMaCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NDU5Ng==", "bodyText": "I'm not really sure about the difference, but shouldn't we use writer.keyword here?", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469754596", "createdAt": "2020-08-13T07:35:15Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlFloorFunction.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.fun.SqlMonotonicUnaryFunction;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n+public class HazelcastSqlFloorFunction extends SqlMonotonicUnaryFunction {\n+    public HazelcastSqlFloorFunction(SqlKind kind) {\n+        super(\n+            kind.name(),\n+            kind,\n+            ReturnTypes.ARG0_OR_EXACT_NO_SCALE,\n+            HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+            notAny(OperandTypes.NUMERIC),\n+            SqlFunctionCategory.NUMERIC\n+        );\n+    }\n+\n+    @Override public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {\n+        return call.getOperandMonotonicity(0).unstrict();\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:MagicNumber\")\n+    @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {\n+        SqlWriter.Frame frame = writer.startFunCall(getName());\n+\n+        if (call.operandCount() == 2) {\n+            call.operand(0).unparse(writer, 0, 100);\n+            writer.sep(\"TO\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNTY0Mg==", "bodyText": "We test infinities and NAN, we should also test -0.0f. Also in all other tests.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469935642", "createdAt": "2020-08-13T13:05:14Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class AbsFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testColumn() {\n+        checkColumn((byte) 0, SqlColumnType.SMALLINT, (short) 0);\n+        checkColumn((byte) 1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn((byte) -1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn(Byte.MAX_VALUE, SqlColumnType.SMALLINT, (short) Byte.MAX_VALUE);\n+        checkColumn(Byte.MIN_VALUE, SqlColumnType.SMALLINT, (short) (Byte.MAX_VALUE + 1));\n+\n+        checkColumn((short) 0, SqlColumnType.INTEGER, 0);\n+        checkColumn((short) 1, SqlColumnType.INTEGER, 1);\n+        checkColumn((short) -1, SqlColumnType.INTEGER, 1);\n+        checkColumn(Short.MAX_VALUE, SqlColumnType.INTEGER, (int) Short.MAX_VALUE);\n+        checkColumn(Short.MIN_VALUE, SqlColumnType.INTEGER, Short.MAX_VALUE + 1);\n+\n+        checkColumn(0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn(1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(-1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Integer.MAX_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE);\n+        checkColumn(Integer.MIN_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE + 1);\n+\n+        checkColumn((long) 0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn((long) 1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn((long) -1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Long.MAX_VALUE, SqlColumnType.BIGINT, Long.MAX_VALUE);\n+        checkColumnFailure(Long.MIN_VALUE, SqlErrorCode.DATA_EXCEPTION, \"BIGINT overflow in ABS function (consider adding an explicit CAST to DECIMAL)\");\n+\n+        checkColumn(BigInteger.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigInteger.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigInteger.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(BigDecimal.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigDecimal.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigDecimal.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn((float) 0, SqlColumnType.REAL, (float) 0);\n+        checkColumn((float) 1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn((float) -1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn(Float.MAX_VALUE, SqlColumnType.REAL, Float.MAX_VALUE);\n+        checkColumn(Float.MIN_VALUE, SqlColumnType.REAL, Math.abs(Float.MIN_VALUE));\n+        checkColumn(Float.POSITIVE_INFINITY, SqlColumnType.REAL, Float.POSITIVE_INFINITY);\n+        checkColumn(Float.NEGATIVE_INFINITY, SqlColumnType.REAL, Float.POSITIVE_INFINITY);\n+        checkColumn(Float.NaN, SqlColumnType.REAL, Float.NaN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNjA2Mw==", "bodyText": "Float.MIN_VALUE is a positive number actually...", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469936063", "createdAt": "2020-08-13T13:05:58Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class AbsFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testColumn() {\n+        checkColumn((byte) 0, SqlColumnType.SMALLINT, (short) 0);\n+        checkColumn((byte) 1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn((byte) -1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn(Byte.MAX_VALUE, SqlColumnType.SMALLINT, (short) Byte.MAX_VALUE);\n+        checkColumn(Byte.MIN_VALUE, SqlColumnType.SMALLINT, (short) (Byte.MAX_VALUE + 1));\n+\n+        checkColumn((short) 0, SqlColumnType.INTEGER, 0);\n+        checkColumn((short) 1, SqlColumnType.INTEGER, 1);\n+        checkColumn((short) -1, SqlColumnType.INTEGER, 1);\n+        checkColumn(Short.MAX_VALUE, SqlColumnType.INTEGER, (int) Short.MAX_VALUE);\n+        checkColumn(Short.MIN_VALUE, SqlColumnType.INTEGER, Short.MAX_VALUE + 1);\n+\n+        checkColumn(0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn(1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(-1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Integer.MAX_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE);\n+        checkColumn(Integer.MIN_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE + 1);\n+\n+        checkColumn((long) 0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn((long) 1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn((long) -1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Long.MAX_VALUE, SqlColumnType.BIGINT, Long.MAX_VALUE);\n+        checkColumnFailure(Long.MIN_VALUE, SqlErrorCode.DATA_EXCEPTION, \"BIGINT overflow in ABS function (consider adding an explicit CAST to DECIMAL)\");\n+\n+        checkColumn(BigInteger.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigInteger.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigInteger.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(BigDecimal.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigDecimal.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigDecimal.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn((float) 0, SqlColumnType.REAL, (float) 0);\n+        checkColumn((float) 1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn((float) -1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn(Float.MAX_VALUE, SqlColumnType.REAL, Float.MAX_VALUE);\n+        checkColumn(Float.MIN_VALUE, SqlColumnType.REAL, Math.abs(Float.MIN_VALUE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzODMzNg==", "bodyText": "We should test a good string literal too.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469938336", "createdAt": "2020-08-13T13:09:39Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/CeilFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CeilFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testColumn() {\n+        checkColumn((byte) 1, SqlColumnType.TINYINT, (byte) 1);\n+        checkColumn((short) 1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn(1, SqlColumnType.INTEGER, 1);\n+        checkColumn(1L, SqlColumnType.BIGINT, 1L);\n+        checkColumn(0.9f, SqlColumnType.REAL, 1f);\n+        checkColumn(0.9d, SqlColumnType.DOUBLE, 1d);\n+        checkColumn(BigInteger.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(new BigDecimal(\"0.9\"), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(\"0.9\", SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn('1', SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(Float.POSITIVE_INFINITY, SqlColumnType.REAL, Float.POSITIVE_INFINITY);\n+        checkColumn(Float.NEGATIVE_INFINITY, SqlColumnType.REAL, Float.NEGATIVE_INFINITY);\n+        checkColumn(Float.NaN, SqlColumnType.REAL, Float.NaN);\n+\n+        checkColumn(Double.POSITIVE_INFINITY, SqlColumnType.DOUBLE, Double.POSITIVE_INFINITY);\n+        checkColumn(Double.NEGATIVE_INFINITY, SqlColumnType.DOUBLE, Double.NEGATIVE_INFINITY);\n+        checkColumn(Double.NaN, SqlColumnType.DOUBLE, Double.NaN);\n+\n+        map.clear();\n+        map.put(0, new ExpressionValue.IntegerVal());\n+        assertNull(execute(\"field1\", SqlColumnType.INTEGER));\n+\n+        checkColumnFailure(\"bad\", SqlErrorCode.DATA_EXCEPTION, \"Cannot convert VARCHAR to DECIMAL\");\n+        checkColumnFailure('b', SqlErrorCode.DATA_EXCEPTION, \"Cannot convert VARCHAR to DECIMAL\");\n+        checkColumnFailure(new ExpressionValue.ObjectVal(), SqlErrorCode.PARSING, \"Cannot apply 'CEIL' to arguments of type 'CEIL(<OBJECT>)'\");\n+    }\n+\n+    private void checkColumn(Object value, SqlColumnType expectedType, Object expectedResult) {\n+        map.clear();\n+        map.put(0, value);\n+\n+        Object res = execute(\"this\", expectedType);\n+        assertEquals(expectedResult, res);\n+    }\n+\n+    private void checkColumnFailure(Object value, int expectedErrorCode, String expectedErrorMessage) {\n+        map.clear();\n+        map.put(0, value);\n+\n+        checkFailure(\"this\", expectedErrorCode, expectedErrorMessage);\n+    }\n+\n+    @Test\n+    public void testParameter() {\n+        map.put(0, 0);\n+\n+        checkParameter((byte) 1, BigDecimal.ONE);\n+        checkParameter((short) 1, BigDecimal.ONE);\n+        checkParameter(1, BigDecimal.ONE);\n+        checkParameter(1L, BigDecimal.ONE);\n+        checkParameter(0.9f, BigDecimal.ONE);\n+        checkParameter(0.9d, BigDecimal.ONE);\n+        checkParameter(BigInteger.ONE, BigDecimal.ONE);\n+        checkParameter(new BigDecimal(\"0.9\"), BigDecimal.ONE);\n+\n+        checkParameter(\"0.9\", BigDecimal.ONE);\n+        checkParameter('1', BigDecimal.ONE);\n+\n+        assertNull(execute(\"?\", SqlColumnType.DECIMAL, new Object[] { null }));\n+\n+        checkFailure(\"?\", SqlErrorCode.DATA_EXCEPTION, \"Failed to convert parameter at position 0 from VARCHAR to DECIMAL\", \"bad\");\n+        checkFailure(\"?\", SqlErrorCode.DATA_EXCEPTION, \"Failed to convert parameter at position 0 from VARCHAR to DECIMAL\", 'b');\n+        checkFailure(\"?\", SqlErrorCode.DATA_EXCEPTION, \"Failed to convert parameter at position 0 from OBJECT to DECIMAL\", new ExpressionValue.ObjectVal());\n+    }\n+\n+    private void checkParameter(Object param, Object expectedResult) {\n+        Object res = execute(\"?\", SqlColumnType.DECIMAL, param);\n+        assertEquals(res, expectedResult);\n+    }\n+\n+    @Test\n+    public void testLiteral() {\n+        map.put(0, 0);\n+\n+        checkLiteral(1, SqlColumnType.TINYINT, (byte) 1);\n+\n+        checkLiteral(\"null\", SqlColumnType.DECIMAL, null);\n+        checkLiteral(\"1.1\", SqlColumnType.DECIMAL, new BigDecimal(\"2\"));\n+        checkLiteral(\"1.1E0\", SqlColumnType.DOUBLE, 2d);\n+\n+        checkFailure(\"'bad'\", SqlErrorCode.PARSING, \"Literal ''bad'' can not be parsed to type 'DECIMAL'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA==", "bodyText": "We miss a test that two invocations of rand() in a single query return different value. It can be in a single row or in two rows or in the where clause: to sample 10% of rows one would use WHERE rand()<0.1", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469965320", "createdAt": "2020-08-13T13:49:36Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/RandFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class RandFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testNoArg() {\n+        map.put(0, 0);\n+\n+        double res1 = execute(\"\");\n+        double res2 = execute(\"\");\n+\n+        assertNotEquals(res1, res2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzkyMjE4", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-466792218", "createdAt": "2020-08-13T14:03:08Z", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDowMzowOVrOHANAWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDozMjozMFrOHAOWoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NTEzMQ==", "bodyText": "We can also do this if operand2 is a constant expression that is >=0", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469975131", "createdAt": "2020-08-13T14:03:09Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+\n+/**\n+ * Implementation of ROUND/TRUNCATE functions.\n+ */\n+public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    private boolean truncate;\n+\n+    public RoundTruncateFunction() {\n+        // No-op.\n+    }\n+\n+    private RoundTruncateFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType, boolean truncate) {\n+        super(operand1, operand2, resultType);\n+\n+        this.truncate = truncate;\n+    }\n+\n+    public static Expression<?> create(\n+        Expression<?> operand1,\n+        Expression<?> operand2,\n+        QueryDataType resultType,\n+        boolean truncate\n+    ) {\n+        if (operand2 == null) {\n+            QueryDataType operand1Type = operand1.getType();\n+\n+            // No conversion is expected for non-fractional types when the length operand is not defined.\n+            if (MathFunctionUtils.notFractional(operand1Type) && operand1Type == resultType) {\n+                return operand1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk4ODY3NA==", "bodyText": "These methods are unused.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Class<? extends ExpressionBiValue> createBiClass(ExpressionType<?> type1, ExpressionType<?> type2) {\n          \n          \n            \n                    return createBiClass(type1.typeName(), type2.typeName());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static Class<? extends ExpressionBiValue> createBiClass(String type1, String type2) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        String className = ExpressionBiValue.class.getName() + \"$\" + type1 + type2 + \"Val\";\n          \n          \n            \n            \n          \n          \n            \n                        return (Class<? extends ExpressionBiValue>) Class.forName(className);\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Cannot create \" + ExpressionBiValue.class.getSimpleName() + \" for types \\\"\"\n          \n          \n            \n                            + type1 + \"\\\" and \\\"\" + type2 + \"\\\"\", e);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                public static <T extends ExpressionBiValue> T createBiValue(Class<? extends ExpressionBiValue> clazz) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        return (T) clazz.newInstance();\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static <T extends ExpressionBiValue> T createBiValue(\n          \n          \n            \n                    Class<? extends ExpressionBiValue> clazz,\n          \n          \n            \n                    int key,\n          \n          \n            \n                    Object field1,\n          \n          \n            \n                    Object field2\n          \n          \n            \n                ) {\n          \n          \n            \n                    T res = create(clazz);\n          \n          \n            \n            \n          \n          \n            \n                    res.key = key;\n          \n          \n            \n                    res.field1(field1);\n          \n          \n            \n                    res.field2(field2);\n          \n          \n            \n            \n          \n          \n            \n                    return res;\n          \n          \n            \n                }", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469988674", "createdAt": "2020-08-13T14:21:25Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionBiValue.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@SuppressWarnings({\"unused\", \"unchecked\", \"checkstyle:MultipleVariableDeclarations\"})\n+public abstract class ExpressionBiValue extends ExpressionValue {\n+    public static Class<? extends ExpressionBiValue> createBiClass(ExpressionType<?> type1, ExpressionType<?> type2) {\n+        return createBiClass(type1.typeName(), type2.typeName());\n+    }\n+\n+    public static Class<? extends ExpressionBiValue> createBiClass(String type1, String type2) {\n+        try {\n+            String className = ExpressionBiValue.class.getName() + \"$\" + type1 + type2 + \"Val\";\n+\n+            return (Class<? extends ExpressionBiValue>) Class.forName(className);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Cannot create \" + ExpressionBiValue.class.getSimpleName() + \" for types \\\"\"\n+                + type1 + \"\\\" and \\\"\" + type2 + \"\\\"\", e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends ExpressionBiValue> T createBiValue(Class<? extends ExpressionBiValue> clazz) {\n+        try {\n+            return (T) clazz.newInstance();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n+        }\n+    }\n+\n+    public static <T extends ExpressionBiValue> T createBiValue(\n+        Class<? extends ExpressionBiValue> clazz,\n+        int key,\n+        Object field1,\n+        Object field2\n+    ) {\n+        T res = create(clazz);\n+\n+        res.key = key;\n+        res.field1(field1);\n+        res.field2(field2);\n+\n+        return res;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTI3OA==", "bodyText": "Whole class unused.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995278", "createdAt": "2020-08-13T14:29:50Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionPredicates.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import java.util.function.Predicate;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public final class ExpressionPredicates {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTQ4Nw==", "bodyText": "Whole class unused.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995487", "createdAt": "2020-08-13T14:30:06Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionType.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public abstract class ExpressionType<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTY2Nw==", "bodyText": "Whole class unused.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995667", "createdAt": "2020-08-13T14:30:21Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionTypes.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+public final class ExpressionTypes {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTk5Mw==", "bodyText": "Methods and field unused.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public int key;\n          \n          \n            \n            \n          \n          \n            \n                public static Class<? extends ExpressionValue> createClass(ExpressionType<?> type) {\n          \n          \n            \n                    return createClass(type.typeName());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static Class<? extends ExpressionValue> createClass(String type) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        String className = ExpressionValue.class.getName() + \"$\" + type + \"Val\";\n          \n          \n            \n            \n          \n          \n            \n                        return (Class<? extends ExpressionValue>) Class.forName(className);\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Cannot create \" + ExpressionValue.class.getSimpleName() + \" for type \\\"\"\n          \n          \n            \n                            + type + \"\\\"\", e);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        return (T) clazz.newInstance();\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz, int key, Object field) {\n          \n          \n            \n                    T res = create(clazz);\n          \n          \n            \n            \n          \n          \n            \n                    res.key = key;\n          \n          \n            \n                    res.field1(field);\n          \n          \n            \n            \n          \n          \n            \n                    return res;\n          \n          \n            \n                }", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995993", "createdAt": "2020-08-13T14:30:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionValue.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@SuppressWarnings({\"unused\", \"unchecked, checkstyle:MultipleVariableDeclarations\"})\n+public abstract class ExpressionValue implements Serializable {\n+\n+    public int key;\n+\n+    public static Class<? extends ExpressionValue> createClass(ExpressionType<?> type) {\n+        return createClass(type.typeName());\n+    }\n+\n+    public static Class<? extends ExpressionValue> createClass(String type) {\n+        try {\n+            String className = ExpressionValue.class.getName() + \"$\" + type + \"Val\";\n+\n+            return (Class<? extends ExpressionValue>) Class.forName(className);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Cannot create \" + ExpressionValue.class.getSimpleName() + \" for type \\\"\"\n+                + type + \"\\\"\", e);\n+        }\n+    }\n+\n+    public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz) {\n+        try {\n+            return (T) clazz.newInstance();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n+        }\n+    }\n+\n+    public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz, int key, Object field) {\n+        T res = create(clazz);\n+\n+        res.key = key;\n+        res.field1(field);\n+\n+        return res;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NzIxNw==", "bodyText": "Might be better to name these FUNCTION_x", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469997217", "createdAt": "2020-08-13T14:32:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java", "diffHunk": "@@ -123,7 +129,14 @@\n     public static final int EXPRESSION_IS_NOT_FALSE = 39;\n     public static final int EXPRESSION_IS_NOT_NULL = 40;\n \n-    public static final int LEN = EXPRESSION_IS_NOT_NULL + 1;\n+    public static final int EXPRESSION_ABS = 41;\n+    public static final int EXPRESSION_SIGN = 42;\n+    public static final int EXPRESSION_RAND = 43;\n+    public static final int EXPRESSION_DOUBLE = 44;\n+    public static final int EXPRESSION_FLOOR_CEIL = 45;\n+    public static final int EXPRESSION_ROUND_TRUNCATE = 46;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODMzODQ4", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-466833848", "createdAt": "2020-08-13T14:46:05Z", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzAxNDI4", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467301428", "createdAt": "2020-08-14T04:35:10Z", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNDozNToxMFrOHAnP5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNDozNToxMFrOHAnP5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTA5NQ==", "bodyText": "notAny?", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470405095", "createdAt": "2020-08-14T04:35:10Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -263,6 +267,71 @@\n \n     //#endregion\n \n+    //#region Math functions.\n+\n+    public static final SqlFunction ABS = new SqlFunction(\n+        \"ABS\",\n+        SqlKind.OTHER_FUNCTION,\n+        HazelcastReturnTypes.UNARY_MINUS,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC_OR_INTERVAL),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction SIGN = new SqlFunction(\n+        \"SIGN\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction RAND = new SqlFunction(\n+        \"RAND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.DOUBLE,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        OperandTypes.or(OperandTypes.NILADIC, notAny(OperandTypes.NUMERIC)),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction COS = new HazelcastDoubleFunction(\"COS\");\n+    public static final SqlFunction SIN = new HazelcastDoubleFunction(\"SIN\");\n+    public static final SqlFunction TAN = new HazelcastDoubleFunction(\"TAN\");\n+    public static final SqlFunction COT = new HazelcastDoubleFunction(\"COT\");\n+    public static final SqlFunction ACOS = new HazelcastDoubleFunction(\"ACOS\");\n+    public static final SqlFunction ASIN = new HazelcastDoubleFunction(\"ASIN\");\n+    public static final SqlFunction ATAN = new HazelcastDoubleFunction(\"ATAN\");\n+    public static final SqlFunction EXP = new HazelcastDoubleFunction(\"EXP\");\n+    public static final SqlFunction LN = new HazelcastDoubleFunction(\"LN\");\n+    public static final SqlFunction LOG10 = new HazelcastDoubleFunction(\"LOG10\");\n+    public static final SqlFunction DEGREES = new HazelcastDoubleFunction(\"DEGREES\");\n+    public static final SqlFunction RADIANS = new HazelcastDoubleFunction(\"RADIANS\");\n+\n+    public static final SqlFunction FLOOR = new HazelcastSqlFloorFunction(SqlKind.FLOOR);\n+    public static final SqlFunction CEIL = new HazelcastSqlFloorFunction(SqlKind.CEIL);\n+\n+    public static final SqlFunction ROUND = new SqlFunction(\n+        \"ROUND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0_NULLABLE,\n+        HazelcastInferTypes.ROUND,\n+        OperandTypes.NUMERIC_OPTIONAL_INTEGER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzAxNTEw", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467301510", "createdAt": "2020-08-14T04:35:25Z", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNDozNToyNVrOHAnQIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNDozNToyNVrOHAnQIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTE1Mw==", "bodyText": "notAny?", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470405153", "createdAt": "2020-08-14T04:35:25Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -263,6 +267,71 @@\n \n     //#endregion\n \n+    //#region Math functions.\n+\n+    public static final SqlFunction ABS = new SqlFunction(\n+        \"ABS\",\n+        SqlKind.OTHER_FUNCTION,\n+        HazelcastReturnTypes.UNARY_MINUS,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC_OR_INTERVAL),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction SIGN = new SqlFunction(\n+        \"SIGN\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction RAND = new SqlFunction(\n+        \"RAND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.DOUBLE,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        OperandTypes.or(OperandTypes.NILADIC, notAny(OperandTypes.NUMERIC)),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction COS = new HazelcastDoubleFunction(\"COS\");\n+    public static final SqlFunction SIN = new HazelcastDoubleFunction(\"SIN\");\n+    public static final SqlFunction TAN = new HazelcastDoubleFunction(\"TAN\");\n+    public static final SqlFunction COT = new HazelcastDoubleFunction(\"COT\");\n+    public static final SqlFunction ACOS = new HazelcastDoubleFunction(\"ACOS\");\n+    public static final SqlFunction ASIN = new HazelcastDoubleFunction(\"ASIN\");\n+    public static final SqlFunction ATAN = new HazelcastDoubleFunction(\"ATAN\");\n+    public static final SqlFunction EXP = new HazelcastDoubleFunction(\"EXP\");\n+    public static final SqlFunction LN = new HazelcastDoubleFunction(\"LN\");\n+    public static final SqlFunction LOG10 = new HazelcastDoubleFunction(\"LOG10\");\n+    public static final SqlFunction DEGREES = new HazelcastDoubleFunction(\"DEGREES\");\n+    public static final SqlFunction RADIANS = new HazelcastDoubleFunction(\"RADIANS\");\n+\n+    public static final SqlFunction FLOOR = new HazelcastSqlFloorFunction(SqlKind.FLOOR);\n+    public static final SqlFunction CEIL = new HazelcastSqlFloorFunction(SqlKind.CEIL);\n+\n+    public static final SqlFunction ROUND = new SqlFunction(\n+        \"ROUND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0_NULLABLE,\n+        HazelcastInferTypes.ROUND,\n+        OperandTypes.NUMERIC_OPTIONAL_INTEGER,\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction TRUNCATE = new SqlFunction(\n+        \"TRUNCATE\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0_NULLABLE,\n+        HazelcastInferTypes.ROUND,\n+        OperandTypes.NUMERIC_OPTIONAL_INTEGER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "298a55b287a0d68f302eb17d2189e10cb7aa10cc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/298a55b287a0d68f302eb17d2189e10cb7aa10cc", "committedDate": "2020-08-14T06:01:45Z", "message": "Merge branch 'master' into issues/17339\n\n# Conflicts:\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "474282c2fda86b821e4666ea6ada8bff548f4f89", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/474282c2fda86b821e4666ea6ada8bff548f4f89", "committedDate": "2020-08-14T06:35:15Z", "message": "Refactored tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "committedDate": "2020-08-14T06:40:47Z", "message": "ABS tests for negative zero"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzQwNjQ3", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467340647", "createdAt": "2020-08-14T06:41:50Z", "commit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNjo0MTo1MVrOHApUkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNjo0MTo1MVrOHApUkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzOTA1Ng==", "bodyText": "Kind of strange to infer it as a decimal for a function accepting only double.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470439056", "createdAt": "2020-08-14T06:41:51Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n+/**\n+ * Function that accepts a DOUBLE argument and produces a DOUBLE result.\n+ */\n+public class HazelcastDoubleFunction extends SqlFunction {\n+    public HazelcastDoubleFunction(String name) {\n+        super(\n+            name,\n+            SqlKind.OTHER_FUNCTION,\n+            ReturnTypes.DOUBLE_NULLABLE,\n+            HazelcastInferTypes.DECIMAL_IF_UNKNOWN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "932c75f84fdec229b719bda8067b0db573bebfda", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/932c75f84fdec229b719bda8067b0db573bebfda", "committedDate": "2020-08-14T06:42:31Z", "message": "Removed unnecessary tests for Float.MIN_VALUE and Double.MIN_VALUE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "committedDate": "2020-08-14T06:45:08Z", "message": "Added missing test for numeric literals in single quotes for CEIL/FLOOR tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "committedDate": "2020-08-14T06:51:12Z", "message": "Test for several rows for RAND"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95442d9b91abe7324b404b3fee044505319410ce", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/95442d9b91abe7324b404b3fee044505319410ce", "committedDate": "2020-08-14T07:00:40Z", "message": "Added \"notAny\" to ROUND/TRUNCATE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d466387bbc40ac2977bf76730cb827e30455df61", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d466387bbc40ac2977bf76730cb827e30455df61", "committedDate": "2020-08-14T07:10:09Z", "message": "Fixed inference for double functions (DECIMAL -> DOUBLE) and RAND (DECIMAL -> BIGINT)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "committedDate": "2020-08-14T07:34:58Z", "message": "Fixed SpotBugs problem"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzkwMjQy", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467390242", "createdAt": "2020-08-14T08:17:51Z", "commit": {"oid": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwODoxNzo1MVrOHArxPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwODoxNzo1MVrOHArxPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ3OTE2Ng==", "bodyText": "Looks like a proper way of doing this is:\nInferTypes.explicit(singletonList(HazelcastTypeFactory.INSTANCE.createSqlType(SqlTypeName.DOUBLE)))\n\nThis basically tells Calcite that the function accepts only doubles, also there would be no need in the conversion performed in DoubleFunction.eval, something like ((Number) value).doubleValue() should do the trick, plain (double) value would not work since conversion between numeric types is not necessarily leading to CAST insertion in Calcite.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470479166", "createdAt": "2020-08-14T08:17:51Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n+/**\n+ * Function that accepts a DOUBLE argument and produces a DOUBLE result.\n+ */\n+public class HazelcastDoubleFunction extends SqlFunction {\n+    public HazelcastDoubleFunction(String name) {\n+        super(\n+            name,\n+            SqlKind.OTHER_FUNCTION,\n+            ReturnTypes.DOUBLE_NULLABLE,\n+            new ReplaceUnknownOperandTypeInference(SqlTypeName.DOUBLE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "493b6d471f6c1fa75b02a2de74eb800763df1d97", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/493b6d471f6c1fa75b02a2de74eb800763df1d97", "committedDate": "2020-08-14T08:45:54Z", "message": "Changed operand type inference for double functions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDE0NDE4", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467414418", "createdAt": "2020-08-14T08:53:59Z", "commit": {"oid": "493b6d471f6c1fa75b02a2de74eb800763df1d97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwODo1Mzo1OVrOHAs8AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwODo1Mzo1OVrOHAs8AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ5ODMwNQ==", "bodyText": "SQRT is missing in the actual code, are there some complications with it?", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470498305", "createdAt": "2020-08-14T08:53:59Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/DoubleFunction.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.UniExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Family of functions which accept a single double operand and return double result:\n+ *     COS, SIN, TAN, COT, ACOS, ASIN, ATAN, SQRT, EXP, LN, LOG10, DEGREES, RADIANS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "493b6d471f6c1fa75b02a2de74eb800763df1d97"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "883ec348410adabed42e705bc43486fd47910e34", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/883ec348410adabed42e705bc43486fd47910e34", "committedDate": "2020-08-14T09:02:35Z", "message": "DoubleFunction: removed concrete functions from JavaDoc."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDMwNDY0", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467430464", "createdAt": "2020-08-14T09:18:41Z", "commit": {"oid": "883ec348410adabed42e705bc43486fd47910e34"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwOToxODo0MVrOHAtsKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwOToxODo0MVrOHAtsKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUxMDYzNA==", "bodyText": "Shouldn't it be done the same way as for DoubleFunction?", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470510634", "createdAt": "2020-08-14T09:18:41Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -263,6 +272,71 @@\n \n     //#endregion\n \n+    //#region Math functions.\n+\n+    public static final SqlFunction ABS = new SqlFunction(\n+        \"ABS\",\n+        SqlKind.OTHER_FUNCTION,\n+        HazelcastReturnTypes.UNARY_MINUS,\n+        new ReplaceUnknownOperandTypeInference(DECIMAL),\n+        notAny(OperandTypes.NUMERIC_OR_INTERVAL),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction SIGN = new SqlFunction(\n+        \"SIGN\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0,\n+        new ReplaceUnknownOperandTypeInference(DECIMAL),\n+        notAny(OperandTypes.NUMERIC),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction RAND = new SqlFunction(\n+        \"RAND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.DOUBLE,\n+        new ReplaceUnknownOperandTypeInference(BIGINT),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883ec348410adabed42e705bc43486fd47910e34"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDkxMjU2", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467491256", "createdAt": "2020-08-14T11:04:02Z", "commit": {"oid": "883ec348410adabed42e705bc43486fd47910e34"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMTowNDowM1rOHAwohg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMTowNDowM1rOHAwohg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU1ODg1NA==", "bodyText": "Are conversions necessary here, if all the types are already should be inferred statically by Calcite?", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470558854", "createdAt": "2020-08-14T11:04:03Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/AbsFunction.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.UniExpressionWithType;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+\n+import static com.hazelcast.sql.impl.expression.math.ExpressionMath.DECIMAL_MATH_CONTEXT;\n+\n+public class AbsFunction<T> extends UniExpressionWithType<T> implements IdentifiedDataSerializable {\n+    @SuppressWarnings(\"unused\")\n+    public AbsFunction() {\n+        // No-op.\n+    }\n+\n+    private AbsFunction(Expression<?> operand, QueryDataType resultType) {\n+        super(operand, resultType);\n+    }\n+\n+    public static AbsFunction<?> create(Expression<?> operand, QueryDataType resultType) {\n+        return new AbsFunction<>(operand, resultType);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object operandValue = operand.eval(row, context);\n+\n+        if (operandValue == null) {\n+            return null;\n+        }\n+\n+        return (T) abs(operandValue, operand.getType(), resultType);\n+    }\n+\n+    private static Object abs(Object operand, QueryDataType operandType, QueryDataType resultType) {\n+        Converter operandConverter = operandType.getConverter();\n+\n+        switch (resultType.getTypeFamily()) {\n+            case TINYINT:\n+                return (byte) Math.abs(operandConverter.asTinyint(operand));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883ec348410adabed42e705bc43486fd47910e34"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDk5NjU5", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467499659", "createdAt": "2020-08-14T11:20:33Z", "commit": {"oid": "883ec348410adabed42e705bc43486fd47910e34"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToyMDozNFrOHAxBnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMToyMDozNFrOHAxBnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NTI3Nw==", "bodyText": "operandType == resultType should be always true since the return type inference is defined as ReturnTypes.ARG0_NULLABLE for ROUND and TRUNCATE, it might make sense to convert it into a general assert for this method.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470565277", "createdAt": "2020-08-14T11:20:34Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+\n+/**\n+ * Implementation of ROUND/TRUNCATE functions.\n+ */\n+public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    private boolean truncate;\n+\n+    public RoundTruncateFunction() {\n+        // No-op.\n+    }\n+\n+    private RoundTruncateFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType, boolean truncate) {\n+        super(operand1, operand2, resultType);\n+\n+        this.truncate = truncate;\n+    }\n+\n+    public static Expression<?> create(\n+        Expression<?> operand1,\n+        Expression<?> operand2,\n+        QueryDataType resultType,\n+        boolean truncate\n+    ) {\n+        if (operand2 == null) {\n+            QueryDataType operand1Type = operand1.getType();\n+\n+            // No conversion is expected for non-fractional types when the length operand is not defined.\n+            if (MathFunctionUtils.notFractional(operand1Type) && operand1Type == resultType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883ec348410adabed42e705bc43486fd47910e34"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3111ee9c98418fbbe9a62cf6382f033755058d5", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f3111ee9c98418fbbe9a62cf6382f033755058d5", "committedDate": "2020-08-14T11:26:26Z", "message": "Explicit inference for RAND"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71084cebcb6c919e0639a367f33369499f968d0d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/71084cebcb6c919e0639a367f33369499f968d0d", "committedDate": "2020-08-14T11:35:24Z", "message": "Assert types in RoundTruncateFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c400000d1523948822545362cc863d509afeabc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9c400000d1523948822545362cc863d509afeabc", "committedDate": "2020-08-14T11:38:25Z", "message": "Extended tests for RAND"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b76e16d69d95177d08f87bb4efef4f949b83c3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/63b76e16d69d95177d08f87bb4efef4f949b83c3", "committedDate": "2020-08-14T11:40:12Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIyNDQw", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-467522440", "createdAt": "2020-08-14T12:05:36Z", "commit": {"oid": "63b76e16d69d95177d08f87bb4efef4f949b83c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMjowNTozNlrOHAyJcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMjowNTozNlrOHAyJcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU4MzY2NA==", "bodyText": "This line may produce a cryptic conversion error since operand type checker for ROUND and TRUNCATE is defined as NUMERIC_OPTIONAL_INTEGER. That last INTEGER is referring to SqlTypeFamily.INTEGER (not to SqlTypeName.INTEGER) and that family refers to all integer types including BIGINT. Either the type checker should allow only the compatible types or some meaningful error message should be provided.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470583664", "createdAt": "2020-08-14T12:05:36Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+\n+/**\n+ * Implementation of ROUND/TRUNCATE functions.\n+ */\n+public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    private boolean truncate;\n+\n+    public RoundTruncateFunction() {\n+        // No-op.\n+    }\n+\n+    private RoundTruncateFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType, boolean truncate) {\n+        super(operand1, operand2, resultType);\n+\n+        this.truncate = truncate;\n+    }\n+\n+    public static Expression<?> create(\n+        Expression<?> operand1,\n+        Expression<?> operand2,\n+        QueryDataType resultType,\n+        boolean truncate\n+    ) {\n+        if (operand2 == null) {\n+            QueryDataType operand1Type = operand1.getType();\n+\n+            // No conversion is expected for non-fractional types when the length operand is not defined.\n+            if (MathFunctionUtils.notFractional(operand1Type)) {\n+                assert operand1Type == resultType;\n+\n+                return operand1;\n+            }\n+        }\n+\n+        return new RoundTruncateFunction<>(operand1, operand2, resultType, truncate);\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\"})\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        // Get base operand.\n+        Object operand1Value = operand1.eval(row, context);\n+\n+        // NULL always yields NULL\n+        if (operand1Value == null) {\n+            return null;\n+        }\n+\n+        // Get length.\n+        Integer operand2Value = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63b76e16d69d95177d08f87bb4efef4f949b83c3"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "committedDate": "2020-08-14T12:16:16Z", "message": "Added lenght overflow handling to ROUND/TRUNCATE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MjE0ODA1", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-468214805", "createdAt": "2020-08-17T07:04:06Z", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNzowNDowN1rOHBcRLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNzowNDowN1rOHBcRLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg==", "bodyText": "It might make sense to create Random once if seed is provided and use setSeed in eval instead of allocating a new Random on every invocation.\nWhat it the semantics of seed? Calcite's SqlRandFunction and RandomFunction define it as \"initializing the random number generator with seed on first call\".\nBTW, what thread safety level is expected for expressions? As far as I remember, Exec is not required to be thread safe and expressions belong to its state.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471273772", "createdAt": "2020-08-17T07:04:07Z", "author": {"login": "taburet"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RandFunction.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.UniExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Random function implementation.\n+ */\n+public class RandFunction extends UniExpression<Double> implements IdentifiedDataSerializable {\n+    public RandFunction() {\n+        // No-op.\n+    }\n+\n+    public RandFunction(Expression<?> seedExp) {\n+        super(seedExp);\n+    }\n+\n+    public static RandFunction create(Expression<?> seedExp) {\n+        return new RandFunction(seedExp);\n+    }\n+\n+    @Override\n+    public Double eval(Row row, ExpressionEvalContext context) {\n+        Long seed = operand != null ? MathFunctionUtils.asBigint(operand, row, context) : null;\n+\n+        Random random = seed != null ? new Random(seed) : ThreadLocalRandom.current();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzAwMzU5", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-468300359", "createdAt": "2020-08-17T09:18:22Z", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOToxODoyMlrOHBg5cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOToxODoyMlrOHBg5cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ==", "bodyText": "Looks like there are no tests for boolean columns and parameters here and for other expressions as well.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471349619", "createdAt": "2020-08-17T09:18:22Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class AbsFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzE1NTM5", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-468315539", "createdAt": "2020-08-17T09:40:37Z", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOTo0MDozOFrOHBhpHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOTo0MDozOFrOHBhpHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTgyMA==", "bodyText": "It might make sense to create a test for it in HazelcastInferTypesTest.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471361820", "createdAt": "2020-08-17T09:40:38Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastInferTypes.java", "diffHunk": "@@ -80,6 +82,10 @@\n     };\n \n     private HazelcastInferTypes() {\n+        // No-op.\n     }\n \n+    public static SqlOperandTypeInference explicit(SqlTypeName typeName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzE5MTI4", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-468319128", "createdAt": "2020-08-17T09:45:50Z", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOTo0NTo1MFrOHBhz_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOTo0NTo1MFrOHBhz_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2NDYwNQ==", "bodyText": "Missing test in HazelcastInferTypesTest.", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471364605", "createdAt": "2020-08-17T09:45:50Z", "author": {"login": "taburet"}, "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/ReplaceUnknownOperandTypeInference.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+/**\n+ * Type inference, that replaces unknown operands with the given types.\n+ */\n+public class ReplaceUnknownOperandTypeInference implements SqlOperandTypeInference {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTkyMTMy", "url": "https://github.com/hazelcast/hazelcast/pull/17340#pullrequestreview-468992132", "createdAt": "2020-08-18T05:02:49Z", "commit": {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3380, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}