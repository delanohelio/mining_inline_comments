{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNDYzNjM2", "number": 17985, "title": "New SQL threading model [IMDG-127]", "bodyText": "This PR introduces the new threading model for SQL.\nBefore\nIn 4.1 we used the model with two thread pools:\n\nFirst any SQL operation arrives in a partitioned pool. We used the partitions to order operations against each other, e.g. this guaranteed that cancel is processed after execute, or that batch2 is processed after batch1.\nIf the operation should trigger the execution of the query fragment, the triggering was performed in this pool, but the actual execution is performed in another fragment pool, which is based on ForkJoinPool and hence has load-balancing capabilities.\n\nThe motivation was that execution of a fragment could take significant time, and if all threads from the partitioned pool are occupied with long-running fragments, we cannot process other operations, such as cancel. Another problem was that partitioned pool cannot balance tasks between threads, which may compromise the throughput. The second thread pool solved both problems.\nTo summarize, the execution flow was like this: io pool (packet) -> partitioned pool (operation) -> fragment pool (query). The problem was that we had to do 2 context switches to trigger the execution of the query, which decreased performance, which was confirmed by benchmarks.\nAfter\nWith this PR we switch to another model.\n\nNow operations that may trigger the execution of the query (execute, batch, flow_control) are scheduled directly to the fragment pool. Therefore we reduce the number of context switches to 1: io pool (packet) -> fragment pool (query).\nFor system operations that may trigger query cancellation (cancel, check) we introduce a small dedicated pool that is guaranteed to process them quickly (as opposed to the fragment pool that might be busy with the long-running fragments).\nThe partitioned pool is removed completely, including the public configuration.\n\nIn this model, we have only one context switch, which is good. However, now we lose the ordering guarantees that were provided by the partitioned pool. E.g., now batch2 could be processed before batch1. Or cancel may arrive before execute. We solve these problems as follows:\n\nFor the out-of-order cancel message, we create a surrogate state that is destroyed by the subsequent execute request (QueryOperationHandlerImpl.handleCancel). There is a periodic checker that cleans this state if execute never arrives (QueryState.requestQueryCheck).\nFor the out-of-order batch and flow_control messages, we introduce the ordinal field to the respective classes (QueryBatchExchangeOperation, QueryFlowControlExchangeOperation). For out-of-order batch messages, we save them in memory and unwind them later (AbstractInbox.SenderState.onBatch). For out-of-order flow_control messages, we ignore the stale message (Outbox.onFlowControl).\n\nThe main test for different state permutations is QueryOperationHandlerTest. It sends messages to a single member without actually starting the real query, and verifies that the member's reaction is correct.\nNote that with this PR the performance is improved only for local queries, but not distributed. This could seem like a non-important case for now, because most of the queries are indeed distributed. However, this will change dramatically in future releases, when we introduce the partition pruning optimization. With this optimization, many distributed queries will be converted into local queries, and the new threading model will boost the performance of such queries significantly.\nCloses #17563", "createdAt": "2020-12-18T10:47:53Z", "url": "https://github.com/hazelcast/hazelcast/pull/17985", "merged": true, "mergeCommit": {"oid": "5ef6f112e19e10346b09cfe4fb7db03a23881ce8"}, "closed": true, "closedAt": "2021-02-04T11:25:42Z", "author": {"login": "devozerov"}, "timelineItems": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJv0yagH2gAyNTQyNDYzNjM2OjU5Y2YzYWM0YzU4YTM1YWJkZmRiMjc1YjIxYmQ3NDI4ZDBkZmQ1Yjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd2v1OOgH2gAyNTQyNDYzNjM2OjhkODFjMGZhNWM2NzNkOWQxZTVlMWYxOTZjZDg3YWE4ZGQyOTJiMjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "59cf3ac4c58a35abdfdb275b21bd7428d0dfd5b7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/59cf3ac4c58a35abdfdb275b21bd7428d0dfd5b7", "committedDate": "2020-09-17T12:05:45Z", "message": "New pools"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5aeb00050ca87257b9bcfab67705cdc43073648f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5aeb00050ca87257b9bcfab67705cdc43073648f", "committedDate": "2020-09-17T12:08:03Z", "message": "Minors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74625a22c333c3b39003ed406a762fdb8962d5d7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/74625a22c333c3b39003ed406a762fdb8962d5d7", "committedDate": "2020-09-17T16:46:15Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47415d3d1a8efc79f30da06759a788dcb396d453", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/47415d3d1a8efc79f30da06759a788dcb396d453", "committedDate": "2020-09-17T17:05:42Z", "message": "Flow control"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a63efc30c29e27cd01ebfd653d989d5c6d1152bc", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a63efc30c29e27cd01ebfd653d989d5c6d1152bc", "committedDate": "2020-09-17T17:37:07Z", "message": "Cancel rework"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e012ba09b435fb41b0e45145f187d6de6296f898", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e012ba09b435fb41b0e45145f187d6de6296f898", "committedDate": "2020-09-18T07:21:32Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "517751d5353bc7f8cc0e89101fe4c9cfdfc4f0b6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/517751d5353bc7f8cc0e89101fe4c9cfdfc4f0b6", "committedDate": "2020-09-18T09:18:45Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dfaf76c6631b7d9727d4009dc68b087e4a0fd2c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5dfaf76c6631b7d9727d4009dc68b087e4a0fd2c", "committedDate": "2020-09-18T10:09:11Z", "message": "Merge branch 'master' into sql-threading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "423f173689f5b40520fb3592aac796a298a95068", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/423f173689f5b40520fb3592aac796a298a95068", "committedDate": "2020-12-15T09:28:12Z", "message": "Merge branch 'before-module-split' into sql-threading\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/index/SqlIndexTest.java\n#\thazelcast/src/main/java/com/hazelcast/internal/nio/Packet.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/worker/QueryPoolTask.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationChannelTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/state/QueryStateRegistryTest.java\n#\thazelcast/src/test/java/com/hazelcast/test/HazelcastTestSupport.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a52e39698ffd2cba430be8b38b59e2cf2f964a4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1a52e39698ffd2cba430be8b38b59e2cf2f964a4", "committedDate": "2020-12-15T09:37:38Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc278b8c0958177e4093039568a10bc308cfc0bd", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fc278b8c0958177e4093039568a10bc308cfc0bd", "committedDate": "2020-12-15T09:41:09Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44c15cbcae86deaa6836af481e32e727b44c0e1c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/44c15cbcae86deaa6836af481e32e727b44c0e1c", "committedDate": "2020-12-15T09:42:01Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c184c9bf070ef5287bca52af81c3197c6c92465", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8c184c9bf070ef5287bca52af81c3197c6c92465", "committedDate": "2020-12-15T09:42:24Z", "message": "Merge branch 'master' into sql-threading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35469f5a874cc2708e0862dcb3395502777b1685", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/35469f5a874cc2708e0862dcb3395502777b1685", "committedDate": "2020-12-15T09:49:08Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d1be36111458563b384eb8549144e7166fc03ad", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6d1be36111458563b384eb8549144e7166fc03ad", "committedDate": "2020-12-15T10:06:49Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "250baa8a0ad4fce814d827df4158b3028347a5cb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/250baa8a0ad4fce814d827df4158b3028347a5cb", "committedDate": "2020-12-15T11:05:56Z", "message": "Fixing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee98c91db153c9e4ef44210161f73fc27689f94e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ee98c91db153c9e4ef44210161f73fc27689f94e", "committedDate": "2020-12-16T08:09:22Z", "message": "Docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4783ce963a9de0352df2391357f3bdfd2c23e2ca", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4783ce963a9de0352df2391357f3bdfd2c23e2ca", "committedDate": "2020-12-16T08:10:32Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5367c98161d7a076fe1bfff3bc8207870dd0b7", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1c5367c98161d7a076fe1bfff3bc8207870dd0b7", "committedDate": "2020-12-16T08:18:44Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aec38c67d47fcd9cbbf06fd25233be45bb0c46e2", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/aec38c67d47fcd9cbbf06fd25233be45bb0c46e2", "committedDate": "2020-12-16T08:26:12Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b2a5112d028f56afc0f0c1184c56f676b86672d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1b2a5112d028f56afc0f0c1184c56f676b86672d", "committedDate": "2020-12-16T11:22:38Z", "message": "WIP on the new test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56a6ce018a6560d16eac96140c261ab07753422c", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/56a6ce018a6560d16eac96140c261ab07753422c", "committedDate": "2020-12-17T09:34:08Z", "message": "WIP on tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bc4a57b6d78f3145be8415a10ead86c7ec3c590", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9bc4a57b6d78f3145be8415a10ead86c7ec3c590", "committedDate": "2020-12-17T09:37:56Z", "message": "WIP on tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac02f13ba575c098112dd3b80a67bbd0d9668c22", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ac02f13ba575c098112dd3b80a67bbd0d9668c22", "committedDate": "2020-12-17T09:39:25Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28194f644d94e7520a22beeca4032e7b730d82fa", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/28194f644d94e7520a22beeca4032e7b730d82fa", "committedDate": "2020-12-17T09:47:12Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa6c2742cb5f6b72d00bf16890c0da8249f97116", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fa6c2742cb5f6b72d00bf16890c0da8249f97116", "committedDate": "2020-12-17T10:10:47Z", "message": "Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9067621550b8186cb17058164ab0617fde768cc9", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/9067621550b8186cb17058164ab0617fde768cc9", "committedDate": "2020-12-17T10:23:34Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f000031d70e1611f97471adc914cdcc1e7fed650", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/f000031d70e1611f97471adc914cdcc1e7fed650", "committedDate": "2020-12-17T10:37:12Z", "message": "WIP on tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5407c61ece0607b3b43c2c52116725792eaf3bdb", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5407c61ece0607b3b43c2c52116725792eaf3bdb", "committedDate": "2020-12-17T11:09:56Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b75df1d0c03c06cad95dca1f241596b02179f101", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/b75df1d0c03c06cad95dca1f241596b02179f101", "committedDate": "2020-12-17T12:03:23Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676c49ca122536931398097bfa972f93d6064c06", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/676c49ca122536931398097bfa972f93d6064c06", "committedDate": "2020-12-17T12:14:06Z", "message": "Added tests for initiator, they hang"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ea634cafbcb9fb8c6f9879c71ee157334db1726", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4ea634cafbcb9fb8c6f9879c71ee157334db1726", "committedDate": "2020-12-17T12:53:54Z", "message": "Tests for both initiator and participant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9795880d5d4c247afcca328d46dd3c33568c7b9", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/a9795880d5d4c247afcca328d46dd3c33568c7b9", "committedDate": "2020-12-17T12:55:10Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d728e4b25326bf3da3e2f3ceb5da17b1f1dc42e4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d728e4b25326bf3da3e2f3ceb5da17b1f1dc42e4", "committedDate": "2020-12-18T07:03:31Z", "message": "Asserting proper thread pool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7473bbb4f040f22a0999e0917f26645ee10a5f0", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/c7473bbb4f040f22a0999e0917f26645ee10a5f0", "committedDate": "2020-12-18T08:20:19Z", "message": "Fix vertical parallelism"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "460e8b0dd5e2bae526de6541fc480ce74c4074a3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/460e8b0dd5e2bae526de6541fc480ce74c4074a3", "committedDate": "2020-12-18T08:39:30Z", "message": "Design docs adjustment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc45e07cc28afbb55685ab93211f6219025dadae", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/fc45e07cc28afbb55685ab93211f6219025dadae", "committedDate": "2020-12-18T10:46:18Z", "message": "Remove operation thread pool size config."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cc735b5ebb10b3c76949057f0e89525fa0d637a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6cc735b5ebb10b3c76949057f0e89525fa0d637a", "committedDate": "2020-12-18T10:46:29Z", "message": "Merge branch 'master' into sql-threading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e02dc88ca7afd4429dd3873709448470ed917f76", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e02dc88ca7afd4429dd3873709448470ed917f76", "committedDate": "2020-12-18T11:31:36Z", "message": "Propagate ordered flag."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "516199c8eabfdc5a10ebc775ee86f0e73b555eb0", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/516199c8eabfdc5a10ebc775ee86f0e73b555eb0", "committedDate": "2020-12-18T11:41:01Z", "message": "Added missing default ctor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12efe8e13ff383b4454e925e8e2566af8561b2f4", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/12efe8e13ff383b4454e925e8e2566af8561b2f4", "committedDate": "2021-01-19T09:11:55Z", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "767cd634418ebe27ac73f44650e4a7cd7416954f", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/767cd634418ebe27ac73f44650e4a7cd7416954f", "committedDate": "2021-01-26T12:03:10Z", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5710f85b73b562b711175fec11c6bfd0ade60cc8", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/5710f85b73b562b711175fec11c6bfd0ade60cc8", "committedDate": "2021-01-26T12:10:54Z", "message": "Compilation fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6729f32d1c1acb2902fe012bfdac6b05b13c4add", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/6729f32d1c1acb2902fe012bfdac6b05b13c4add", "committedDate": "2021-02-01T08:39:40Z", "message": "Merge branch 'master' into sql-threading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/d498e1d50a503e5c663a9648c2dd67b943915d4a", "committedDate": "2021-02-01T08:45:06Z", "message": "Fixes after merge."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4MjYxMTM5", "url": "https://github.com/hazelcast/hazelcast/pull/17985#pullrequestreview-578261139", "createdAt": "2021-01-28T12:01:12Z", "commit": {"oid": "5710f85b73b562b711175fec11c6bfd0ade60cc8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMjowMToxM1rOIb0S7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNToyMzo1NVrOIdmYIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjAzOTI3Nw==", "bodyText": "Does it make sense to remove this element from the 4.1 XSD, while it is still available in the actual 4.1.z releases?", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r566039277", "createdAt": "2021-01-28T12:01:13Z", "author": {"login": "vbekiaris"}, "path": "hazelcast-spring/src/main/resources/hazelcast-spring-4.1.xsd", "diffHunk": "@@ -5158,23 +5158,6 @@\n                     </xs:documentation>\n                 </xs:annotation>\n             </xs:element>\n-            <xs:element name=\"operation-pool-size\" type=\"xs:int\" minOccurs=\"0\" maxOccurs=\"1\" default=\"-1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5710f85b73b562b711175fec11c6bfd0ade60cc8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1OTI0NQ==", "bodyText": "minor: at this point, assuming this has not escaped, you can just set(true).", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567859245", "createdAt": "2021-02-01T14:19:55Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryState.java", "diffHunk": "@@ -98,6 +106,14 @@ private QueryState(\n \n         startTime = clockProvider.currentTimeMillis();\n         checkTime = startTime;\n+\n+        this.cancelled = cancelled;\n+\n+        if (cancelled) {\n+            completionGuard.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg4Nzg1NQ==", "bodyText": "Seems like those two volatile variables are actually assigned constant values (SqlServiceImpl#STATE_CHECK_FREQUENCY and DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY). They could be final,  except for test code. Can we make them final and override their values in tests via properties? eg\nprivate final long stateCheckFrequency = Long.getLong(\"hazelcast.sql.stateCheckFrequency\", 1_000L);\n...\n// test code\n@Rule\npublic OverridePropertyRule setStateCheckFreq = set(\"hazelcast.sql.stateCheckFrequency\", \"100\");\n\nIf that is not a viable alternative, then we should add comments so that the reason for being volatile is clear.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567887855", "createdAt": "2021-02-01T14:57:34Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -37,12 +37,15 @@\n  */\n public class QueryStateRegistryUpdater {\n \n+    private static final long DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY = 30_000L;\n+\n     private final NodeServiceProvider nodeServiceProvider;\n     private final QueryStateRegistry stateRegistry;\n     private final QueryClientStateRegistry clientStateRegistry;\n     private final QueryOperationHandler operationHandler;\n     private final PlanCacheChecker planCacheChecker;\n-    private final long stateCheckFrequency;\n+    private volatile long stateCheckFrequency;\n+    private volatile long orphanedQueryStateCheckFrequency = DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzkwODM4NA==", "bodyText": "same as above for hazelcast-spring-4.1.xsd: should we mutate already published XSDs?", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567908384", "createdAt": "2021-02-01T15:23:55Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/resources/hazelcast-config-4.1.xsd", "diffHunk": "@@ -5024,23 +5024,6 @@\n                     </xs:documentation>\n                 </xs:annotation>\n             </xs:element>\n-            <xs:element name=\"operation-pool-size\" type=\"xs:int\" minOccurs=\"0\" maxOccurs=\"1\" default=\"-1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "236828966ad577d989ee787435faa86185bda7ee", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/236828966ad577d989ee787435faa86185bda7ee", "committedDate": "2021-02-02T09:05:22Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed07dae7aa103fbc2ba9f332b1ff7689e0e976db", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/ed07dae7aa103fbc2ba9f332b1ff7689e0e976db", "committedDate": "2021-02-02T09:47:34Z", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/worker/QueryFragmentExecutable.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/worker/QueryFragmentExecutableTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "193d98f1058fa7ab2b59a1fbcda346fed222edf3", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/193d98f1058fa7ab2b59a1fbcda346fed222edf3", "committedDate": "2021-02-02T09:56:33Z", "message": "Split slow \"ORDER BY\" test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/aaf143f69c2b923e9addd60ec8562f5aec1b4227", "committedDate": "2021-02-02T09:57:25Z", "message": "Split slow \"ORDER BY\" test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1963491ff831f30748b8bdf94beee44c666dfb37", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/1963491ff831f30748b8bdf94beee44c666dfb37", "committedDate": "2021-02-03T11:16:27Z", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationChannelImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/worker/QueryFragmentWorkerPool.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationChannelTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/355bf76a5dc7cbfa65af11f842cc444f3e046e39", "committedDate": "2021-02-03T11:19:17Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e66bcc2c4e15171d6e35ee33b4f70b29b5d187ef", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e66bcc2c4e15171d6e35ee33b4f70b29b5d187ef", "committedDate": "2021-02-03T13:59:01Z", "message": "Minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxNTgxMTMw", "url": "https://github.com/hazelcast/hazelcast/pull/17985#pullrequestreview-581581130", "createdAt": "2021-02-02T17:13:52Z", "commit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzoxMzo1MlrOIebq7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzozNTo1N1rOIfCc9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc4MTU1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n          \n          \n            \n            cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n          \n          \n            \n            Hazelcast Jet uses its own cooperative thread pool to execute Jet jobs. A job is split into \"tasklets\", each vertex in the DAG is\n          \n          \n            \n            backed by one or more tasklets on each cluster member. Every tasklet is assigned to one cooperative thread, the thread then\n          \n          \n            \n            executes the tasklets in a loop. There is no balancing: once a tasklet is submitted to a specific thread, it is always executed in\n          \n          \n            \n            that thread. Non-cooperative tasklets (those handling a blocking API such as JDBC) run on dedicated threads.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568781550", "createdAt": "2021-02-02T17:13:52Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc4MzQyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n          \n          \n            \n            Hazelcast Jet follows this principle, as only one thread may execute a particular tasklet. However, Hazelcast Jet pool doesn't", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568783420", "createdAt": "2021-02-02T17:16:15Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5MDk3OQ==", "bodyText": "Jet used to have work-stealing. But we determined it's not needed. There's no such thing as a long-running task in Jet pool. Each tasklet is required to do a small amount of work and yield so that a next tasklet can execute. One large job doesn't block other concurrent small jobs.\nOne operator is typically backed by as many tasklets as there are local threads. Unless the operation is partitioned (such as aggregating by key), load balancing is performed by the upstream tasklet: each tasklet has an input queue with fixed capacity. The upstream tasklets, when adding items to queues, add to any queue that has space.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568790979", "createdAt": "2021-02-02T17:26:20Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n+satisfy the load balancing requirement discussed below.\n+\n+Second, the execution environment must support load balancing. Query execution may take a long time to complete. If several query\n+fragments have been assigned to a single execution thread, it should be possible to reassign them to idle threads dynamically.\n+Neither partition pool nor Hazelcast Jet pool designs are applicable to Hazelcast Mustang because they lack balancing\n+capabilities.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5Mjk3NA==", "bodyText": "This is probably wrong:\n\nif message A is received before message B, then it should be executed before B\n\nYou probably wanted to say: even if B is received before A, A should be executed before B.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568792974", "createdAt": "2021-02-02T17:29:02Z", "author": {"login": "viliam-durina"}, "path": "docs/design/sql/04-parallel-execution.md", "diffHunk": "@@ -0,0 +1,146 @@\n+# SQL Parallel Execution\n+\n+## Overview\n+\n+The Hazelcast Mustang engine executes queries in parallel. This document describes the design of the parallel execution\n+environment of the engine.\n+\n+The document doesn't discuss operator-level parallelism, which is a different topic.\n+\n+The rest of this document is organized as follows. In section 1 we discuss the existing threading infrastructure of Hazelcast\n+IMDG and Hazelcast Jet. In section 2 we analyze why the existing infrastructure is inappropriate for query execution and then\n+describe the design of the Hazelcast Mustang execution environment. In section 3 we discuss possible alternative approaches\n+that were rejected.\n+\n+## 1 Existing Infrastructure\n+\n+Hazelcast IMDG uses staged event-driven architecture (SEDA) for message processing. During execution, a message passes through\n+several thread pools (stages), each optimized for a specific type of workload. We now describe stages that exist in Hazelcast.\n+\n+### 1.1 IO Pool\n+\n+Hazelcast uses a dedicated thread pool for a message send and receive, which will be referred to as **IO Pool** in this paper.\n+Each thread from the IO pool maintains a subset of connections to remote members. Consider that we have a sender member (S)\n+and a receiver member (R). The typical execution flow is organized as follows:\n+1. The message is added to the queue of a single IO thread, and the thread is notified.\n+1. The sender IO thread wakes up and sends the message over the network.\n+1. A receiver IO thread is notified by the operating system on receive.\n+1. The receiver IO thread wakes up, determines the next execution stage, adds the message to the stage's queue and notifies the\n+   stage.\n+1. The next execution stage processes the message.\n+\n+*Snippet 1: Message execution flow*\n+```\n+Stage(S)                 IO(S)        IO(R)                Stage(R)\n+   |----enqueue/notify->--|            |                      |\n+   |                      |----send->--|                      |\n+   |                      |            |----enqueue/notify->--|\n+```\n+\n+We now discuss the organization of different execution stages.\n+\n+### 1.2 Partition Pool\n+\n+A message may have a logical **partition**, which is a positive integer number. Messages with defined partition are routed to\n+a special thread pool, which we refer to as **partition pool**. The pool has several threads. Every thread has a dedicated task\n+queue. Partition of the message is used to determine the exact thread which will process the message:\n+`threadIndex = partition % threadCount`.\n+\n+The partition pool has the following advantages:\n+1. Only one thread processes messages with the given partition so that processing logic may use less synchronization.\n+1. Dedicated thread queues reduce contention on enqueue/deque operations.\n+\n+However, there is no load balancing in the partition pool: a single long-running task may delay other tasks from the same \n+partition indefinitely. An imbalance between partitions may cause low resource utilization.\n+\n+The partition pool is thus suitable for small tasks that operate on independent physical resources, and that are\n+distributed equally between logical partitions. An example is `IMap` operations, which operate on separate physical\n+partitions, such as `GET` and `PUT`.\n+\n+Since the partition is a logical notion, it is possible to multiplex tasks from different components to a single partition pool.\n+For example, CP Subsystem schedules tasks, all with the same partition, to the partition pool to ensure total processing order.\n+\n+### 1.3 Generic Pool\n+\n+If a message doesn't have a logical partition, it is submitted to the **generic pool**. This is a conventional thread pool with\n+a shared blocking queue. It has inherent balancing capabilities. At the same time, this pool may demonstrate less than\n+optimal throughput when a lot of small tasks are submitted due to contention on the queue.\n+\n+### 1.4 Hazelcast Jet Pool\n+\n+Hazelcast Jet uses its own cooperative pool to execute Jet jobs. Every thread has its own queue of jobs that are executed\n+cooperatively. There is no balancing: once the job is submitted to a specific thread, it is always executed in that thread.\n+\n+IO pool doesn't notify the Jet pool about new data batch (\"push\"). Instead, the message is just enqueued, and the Jet thread\n+checks the queue periodically (\"poll\").\n+\n+## 2 Design\n+\n+We now define the requirements to Hazelcast Mustang threading model, analyze them concerning existing infrastructure, and\n+define the design.\n+\n+### 2.1 Requirements\n+\n+The requirements are thread safety, load balancing, and ordered processing.\n+\n+First, the infrastructure must guarantee that operator execution is thread-safe. That is, the stateful operator should not be\n+executed by multiple threads simultaneously. This simplifies operator implementations and makes them more performant.\n+Hazelcast Jet follows this principle, as only one thread may execute a particular job. However, Hazelcast Jet pool doesn't\n+satisfy the load balancing requirement discussed below.\n+\n+Second, the execution environment must support load balancing. Query execution may take a long time to complete. If several query\n+fragments have been assigned to a single execution thread, it should be possible to reassign them to idle threads dynamically.\n+Neither partition pool nor Hazelcast Jet pool designs are applicable to Hazelcast Mustang because they lack balancing\n+capabilities.\n+\n+Third, it should be possible to execute some messages in order. That is, if message `A` is received before message `B`, then it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MjEwNw==", "bodyText": "Style note: I'm wondering why don't we have the execute method on the operation?", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569272107", "createdAt": "2021-02-03T09:48:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java", "diffHunk": "@@ -131,31 +145,18 @@ public boolean submitRemote(UUID callerId, Connection connection, QueryOperation\n         }\n     }\n \n-    @Override\n-    public QueryOperationChannel createChannel(UUID sourceMemberId, UUID targetMemberId) {\n-        if (targetMemberId.equals(getLocalMemberId())) {\n-            return new QueryOperationChannelImpl(this, sourceMemberId, null);\n-        } else {\n-            Connection connection = getConnection(targetMemberId);\n-\n-            if (connection == null) {\n-                throw QueryException.memberConnection(targetMemberId);\n-            }\n-\n-            return new QueryOperationChannelImpl(this, sourceMemberId, connection);\n-        }\n-    }\n-\n     @Override\n     public void execute(QueryOperation operation) {\n+        assert operation.isSystem() == QueryOperationWorkerPool.isSystemThread();\n+\n         if (operation instanceof QueryExecuteOperation) {\n             handleExecute((QueryExecuteOperation) operation);\n-        } else if (operation instanceof QueryBatchExchangeOperation) {\n-            handleBatch((QueryBatchExchangeOperation) operation);\n+        } else if (operation instanceof QueryExecuteFragmentOperation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI4MDAyNA==", "bodyText": "This whole javadoc is an exact copy of the javadoc of onDistributedQueryStarted. I think we should delete it.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569280024", "createdAt": "2021-02-03T09:59:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistry.java", "diffHunk": "@@ -90,17 +90,50 @@ public QueryState onInitiatorQueryStarted(\n      * of these events. This is not a problem, because {@link QueryStateRegistryUpdater} will eventually detect that\n      * the query is not longer active on the initiator member.\n      *\n-     * @param localMemberId Cache local member ID.\n-     * @param queryId Query ID.\n-     * @param completionCallback Callback that will be invoked when the query is completed.\n-     * @return Query state or {@code null} if the query with the given ID is guaranteed to be already completed.\n+     * @param localMemberId cached local member ID\n+     * @param queryId query ID\n+     * @param completionCallback callback that will be invoked when the query is completed\n+     * @param cancelled if the query should be created in the cancelled state\n+     * @return query state or {@code null} if the query with the given ID is guaranteed to be already completed\n      */\n     public QueryState onDistributedQueryStarted(\n         UUID localMemberId,\n         QueryId queryId,\n-        QueryStateCompletionCallback completionCallback\n+        QueryStateCompletionCallback completionCallback,\n+        boolean cancelled\n+    ) {\n+        QueryState state = onDistributedQueryStarted0(localMemberId, queryId, completionCallback, cancelled);\n+\n+        if (state != null) {\n+            state.updateLastActivityTime();\n+        }\n+\n+        return state;\n+    }\n+\n+    /**\n+     * Registers a distributed query in response to query start message or query batch message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM5MDY5OA==", "bodyText": "The targetIsParticipant  name is misleading. IIUIC it means whether the operations are executed on the initiator or on the other member. But the initiator is also a participant. A better name would be targetIsInitiator (with inverse meaning).", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569390698", "createdAt": "2021-02-03T12:55:51Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -465,162 +540,124 @@ private QueryExecuteOperation createExecuteOperation(UUID toMemberId) {\n         );\n     }\n \n-    private QueryBatchExchangeOperation createBatch1Operation(UUID toMemberId) {\n-        return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n-            EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(0, BATCH_SIZE),\n-            false,\n-            Long.MAX_VALUE\n-        );\n-    }\n+    private QueryBatchExchangeOperation createBatchOperation(UUID targetMemberId, int value) {\n+        long ordinal = value;\n+        boolean last = value == 1;\n+        ListRowBatch rows = createMonotonicBatch(value, 1);\n \n-    private QueryBatchExchangeOperation createBatch2Operation(UUID toMemberId) {\n         return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n+            queryId,\n             EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(BATCH_SIZE, BATCH_SIZE),\n-            true,\n+            targetMemberId,\n+            rows,\n+            ordinal,\n+            last,\n             Long.MAX_VALUE\n         );\n     }\n \n-    private QueryCancelOperation createCancelOperation(UUID fromMemberId) {\n+    private QueryCancelOperation createCancelOperation(UUID sourceMemberId) {\n         return new QueryCancelOperation(\n-            testState.getQueryId(),\n+            queryId,\n             SqlErrorCode.GENERIC,\n             \"Error\",\n-            fromMemberId\n+            sourceMemberId\n         );\n     }\n \n-    private State startQueryOnInitiator(long timeout) {\n-        Plan plan = new Plan(\n-            partitionMap,\n-            Collections.emptyList(),\n-            Collections.emptyList(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            null,\n-            QueryParameterMetadata.EMPTY,\n-            null,\n-            Collections.emptySet(),\n-            Collections.emptyList()\n-        );\n-\n-        QueryId queryId = initiatorService.getStateRegistry().onInitiatorQueryStarted(\n-            QueryId.create(initiatorId),\n-            initiatorId,\n-            timeout,\n-            plan,\n-            null,\n-            null,\n-            new BlockingRootResultConsumer(),\n-            initiatorService.getOperationHandler()\n-        ).getQueryId();\n-\n-        testState = new State(queryId);\n-\n-        return testState;\n+    private UUID targetId() {\n+        return targetIsParticipant ? participantId : initiatorId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 870}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTE5Mg==", "bodyText": "We can probably remove this line, same code is on line 447.", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569415192", "createdAt": "2021-02-03T13:33:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -105,357 +93,444 @@\n \n     private Map<UUID, PartitionIdSet> partitionMap;\n \n-    private QueryExecuteOperation initiatorExecuteOperation;\n-    private QueryBatchExchangeOperation initiatorBatch1Operation;\n-    private QueryBatchExchangeOperation initiatorBatch2Operation;\n-    private QueryCancelOperation initiatorCancelOperation;\n+    private QueryId queryId;\n+\n+    @Parameterized.Parameter\n+    public boolean targetIsParticipant;\n+\n+    @Parameterized.Parameters(name = \"targetIsParticipant:{0}\")\n+    public static Collection<Object[]> parameters() {\n+        List<Object[]> res = new ArrayList<>();\n \n-    private QueryExecuteOperation participantExecuteOperation;\n-    private QueryBatchExchangeOperation participantBatch1Operation;\n-    private QueryBatchExchangeOperation participantBatch2Operation;\n-    private QueryCancelOperation participantCancelOperation;\n+        res.add(new Object[] { true });\n+        res.add(new Object[] { false });\n \n-    private QueryOperationChannel toInitiatorChannel;\n-    private QueryOperationChannel toParticipantChannel;\n+        return res;\n+    }\n+\n+    @Override\n+    protected Config getConfig() {\n+        return smallInstanceConfig();\n+    }\n \n     @Before\n     public void before() {\n-        factory = new TestHazelcastInstanceFactory(2);\n-\n-        initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n-        participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n \n         initiatorId = initiator.getLocalEndpoint().getUuid();\n         participantId = participant.getLocalEndpoint().getUuid();\n \n-        initiatorService = setInternalService(initiator, STATE_CHECK_FREQUENCY);\n-        participantService = setInternalService(participant, STATE_CHECK_FREQUENCY);\n+        initiatorService = sqlInternalService(initiator);\n+        participantService = sqlInternalService(participant);\n+\n+        setStateCheckFrequency(Long.MAX_VALUE);\n \n         partitionMap = new HashMap<>();\n         partitionMap.put(initiatorId, new PartitionIdSet(2, Collections.singletonList(1)));\n-        partitionMap.put(participantId, new PartitionIdSet(1, Collections.singletonList(2)));\n+        partitionMap.put(participantId, new PartitionIdSet(2, Collections.singletonList(2)));\n+\n+        queryId = QueryId.create(initiatorId);\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void test_E() {\n+        sendExecute(false);\n+        assertQueryRegisteredEventually(queryId);\n+\n+        if (targetIsParticipant) {\n+            setOrphanedQueryStateCheckFrequency(100L);\n+            setStateCheckFrequency(100L);\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n+    }\n \n-        // Start the query with maximum timeout by default.\n-        prepare(Long.MAX_VALUE);\n+    @Test\n+    public void test_E_B1_B2_ordered() {\n+        check_E_B1_B2(true);\n     }\n \n-    private void prepare(long timeout) {\n-        testState = startQueryOnInitiator(timeout);\n+    @Test\n+    public void test_E_B1_B2_unordered() {\n+        check_E_B1_B2(false);\n+    }\n \n-        initiatorExecuteOperation = createExecuteOperation(initiatorId);\n-        participantExecuteOperation = createExecuteOperation(participantId);\n+    private void check_E_B1_B2(boolean ordered) {\n+        sendExecute(ordered);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        initiatorBatch1Operation = createBatch1Operation(initiatorId);\n-        participantBatch1Operation = createBatch1Operation(participantId);\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        initiatorBatch2Operation = createBatch2Operation(initiatorId);\n-        participantBatch2Operation = createBatch2Operation(participantId);\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        initiatorCancelOperation = createCancelOperation(participantId);\n-        participantCancelOperation = createCancelOperation(initiatorId);\n+        sendBatch(VALUE_1);\n+        assertConsumedEventually(exec, VALUE_1);\n \n-        toInitiatorChannel = participantService.getOperationHandler().createChannel(participantId, initiatorId);\n-        toParticipantChannel = initiatorService.getOperationHandler().createChannel(initiatorId, participantId);\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @After\n-    public void after() {\n-        if (factory != null) {\n-            factory.shutdownAll();\n-        }\n+    @Test\n+    public void test_E_B2_B1_ordered() {\n+        check_E_B2_B1(true);\n     }\n \n     @Test\n-    public void test_initiator_timeout() {\n-        stopQueryOnInitiator();\n-        prepare(50L);\n-\n-        sendToInitiator(initiatorExecuteOperation);\n-        checkNoQueryOnInitiator();\n+    public void test_E_B2_B1_unordered() {\n+        check_E_B2_B1(false);\n     }\n \n-    @Test\n-    public void test_initiator_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void check_E_B2_B1(boolean ordered) {\n+        sendExecute(ordered);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n-    }\n+        // Send the second batch, only unordered exec should process it\n+        sendBatch(VALUE_1);\n \n-    @Test\n-    public void test_initiator_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+        if (ordered) {\n+            assertNotConsumedWithDelay(exec, VALUE_1);\n+        } else {\n+            assertConsumedEventually(exec, VALUE_1);\n+        }\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        // Send the first batch, processing should be finished in both modes\n+        sendBatch(VALUE_0);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        assertConsumedEventually(exec, VALUE_0);\n+\n+        if (ordered) {\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+        } else {\n+            assertTrue(exec.reordered);\n+        }\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_B_C() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_L_B() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_C_B() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n+\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n+\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n \n-        // LEAVE\n-        participant.shutdown();\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n \n-        // BATCH\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        if (targetIsParticipant) {\n+            assertQueryRegisteredEventually(queryId);\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B() {\n+        sendBatch(VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            setStateCheckFrequency(100L);\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B_C() {\n+        sendBatch(VALUE_0);\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+            sendCancel();\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+    @Test\n+    public void test_B1_E_B2_ordered() {\n+        check_B1_E_B2(true);\n     }\n \n     @Test\n-    public void test_participant_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B1_E_B2_unordered() {\n+        check_B1_E_B2(false);\n+    }\n+\n+    private void check_B1_E_B2(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+            sendBatch(VALUE_1);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_E_B1_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_E_B1_ordered() {\n+        check_B2_E_B1(true);\n     }\n \n     @Test\n-    public void test_participant_B1_E_B2_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_E_B1_unordered() {\n+        check_B2_E_B1(false);\n+    }\n+\n+    private void check_B2_E_B1(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+\n+            if (ordered) {\n+                assertNotConsumedWithDelay(exec, VALUE_1);\n+            } else {\n+                assertConsumedEventually(exec, VALUE_1);\n+            }\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertConsumedEventually(exec, VALUE_1);\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n     @Test\n-    public void test_participant_B1_E_C_B2() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n-\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n-\n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n-\n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n-    }\n-\n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n+    public void test_B1_B2_E_ordered() {\n+        check_B1_B2_E(true);\n+    }\n+\n     @Test\n-    public void test_participant_B1_C_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B1_B2_E_unordered() {\n+        check_B1_B2_E(false);\n+    }\n+\n+    private void check_B1_B2_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendBatch(VALUE_1);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_B1_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_B1_E_ordered() {\n+        check_B2_B1_E(true);\n     }\n \n     @Test\n-    public void test_participant_B1_B2_E_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_B1_E_unordered() {\n+        check_B2_B1_E(false);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n+    private void check_B2_B1_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_B2_C_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_C_B2_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C_E() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            sendExecute(false);\n+            assertQueryNotRegisteredEventually(queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 681}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ==", "bodyText": "We miss a test for cancel after a completed execution (test_E_B1_B2_C)", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569416949", "createdAt": "2021-02-03T13:35:57Z", "author": {"login": "viliam-durina"}, "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -16,86 +16,74 @@\n \n package com.hazelcast.sql.impl.operation;\n \n-import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.config.Config;\n import com.hazelcast.instance.impl.HazelcastInstanceProxy;\n-import com.hazelcast.internal.serialization.InternalSerializationService;\n import com.hazelcast.internal.util.collection.PartitionIdSet;\n-import com.hazelcast.spi.impl.NodeEngineImpl;\n-import com.hazelcast.sql.impl.SqlErrorCode;\n-import com.hazelcast.sql.impl.NodeServiceProviderImpl;\n import com.hazelcast.sql.impl.QueryId;\n import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n import com.hazelcast.sql.impl.SqlInternalService;\n-import com.hazelcast.sql.impl.SqlServiceImpl;\n import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.exec.AbstractUpstreamAwareExec;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitor;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitorCallback;\n import com.hazelcast.sql.impl.exec.Exec;\n import com.hazelcast.sql.impl.exec.IterationResult;\n-import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n import com.hazelcast.sql.impl.plan.Plan;\n import com.hazelcast.sql.impl.plan.node.PlanNode;\n import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n import com.hazelcast.sql.impl.plan.node.io.ReceivePlanNode;\n import com.hazelcast.sql.impl.row.EmptyRowBatch;\n import com.hazelcast.sql.impl.row.ListRowBatch;\n-import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.state.QueryState;\n import com.hazelcast.sql.impl.type.QueryDataType;\n-import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.sql.impl.worker.QueryFragmentExecutable;\n+import com.hazelcast.test.HazelcastParallelParametersRunnerFactory;\n import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n \n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n /**\n- * A set of integration tests for query message processing on a single member.\n- * <p>\n- * Abbreviations:\n- * <ul>\n- *     <li>E - execute</li>\n- *     <li>Bx - batch request with x ordinal</li>\n- *     <li>C - cancel</li>\n- *     <li>L - leave of the other member</li>\n- * </ul>\n+ * Tests for different combinations of events\n  */\n-@RunWith(HazelcastSerialClassRunner.class)\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastParallelParametersRunnerFactory.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-@Ignore(\"https://github.com/hazelcast/hazelcast/issues/16929#issuecomment-699819103\")\n public class QueryOperationHandlerTest extends SqlTestSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTU4NDUz", "url": "https://github.com/hazelcast/hazelcast/pull/17985#pullrequestreview-582558453", "createdAt": "2021-02-03T16:32:34Z", "commit": {"oid": "e66bcc2c4e15171d6e35ee33b4f70b29b5d187ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52c012d3d00a57db94f1922b4cdaf88f872ec5c6", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/52c012d3d00a57db94f1922b4cdaf88f872ec5c6", "committedDate": "2021-02-04T07:15:17Z", "message": "Merge branch 'master' into sql-threading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1cf4e5ec00a4ab14ccc1cc343980cb7f7f67b90", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/e1cf4e5ec00a4ab14ccc1cc343980cb7f7f67b90", "committedDate": "2021-02-04T07:15:58Z", "message": "Merge remote-tracking branch 'devozerov/sql-threading' into sql-threading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c6d7e32c03858cf7b51771b48778beb8521785e", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/7c6d7e32c03858cf7b51771b48778beb8521785e", "committedDate": "2021-02-04T07:16:25Z", "message": "Update docs/design/sql/04-parallel-execution.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06364d9ed46a569d551680d1adbd38ca3186c14b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/06364d9ed46a569d551680d1adbd38ca3186c14b", "committedDate": "2021-02-04T07:16:59Z", "message": "Update docs/design/sql/04-parallel-execution.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "785f86a8408bc211f8d8069fe337483e9ff87a6b", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/785f86a8408bc211f8d8069fe337483e9ff87a6b", "committedDate": "2021-02-04T07:19:59Z", "message": "Remove the confusing line from the document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ac020dbfd3870439b0217084ad82cc4bd694f41", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/4ac020dbfd3870439b0217084ad82cc4bd694f41", "committedDate": "2021-02-04T07:23:02Z", "message": "Removed unnecessary JavaDoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "528a4eb4c8cea60569fb17eb75c2ed76580577fa", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/528a4eb4c8cea60569fb17eb75c2ed76580577fa", "committedDate": "2021-02-04T07:24:24Z", "message": "Renamed a variable with the unclear name."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "994d1bedc091094d2b768c1729e7474913df8b1d", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/994d1bedc091094d2b768c1729e7474913df8b1d", "committedDate": "2021-02-04T07:27:11Z", "message": "Removed unnecessary line of code from the test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d81c0fa5c673d9d1e5e1f196cd87aa8dd292b28", "author": {"user": {"login": "devozerov", "name": "Vladimir Ozerov"}}, "url": "https://github.com/hazelcast/hazelcast/commit/8d81c0fa5c673d9d1e5e1f196cd87aa8dd292b28", "committedDate": "2021-02-04T07:32:49Z", "message": "Merge branch 'master' into sql-threading"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3044, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}