{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTk2MTM4", "number": 17169, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTowNTo1OVrOEez5iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMTowMzo0MVrOEg5Fsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzQzMDUxOnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapServiceContextImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTowNTo1OVrOHKtF_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowMjoxMFrOHLuBRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4NjYyMw==", "bodyText": "Here we need to validate a positive value of nodeEngine.getProperties().getInteger(LOADED_KEY_LIMITER), otherwise the map loader will be stuck", "url": "https://github.com/hazelcast/hazelcast/pull/17169#discussion_r480986623", "createdAt": "2020-09-01T09:05:59Z", "author": {"login": "vbekiaris"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapServiceContextImpl.java", "diffHunk": "@@ -173,6 +176,7 @@\n         this.operationProviders = createOperationProviders();\n         this.partitioningStrategyFactory = new PartitioningStrategyFactory(nodeEngine.getConfigClassLoader());\n         this.nodeWideUsedCapacityCounter = new NodeWideUsedCapacityCounter(nodeEngine.getProperties());\n+        this.loadedKeyLimiter = new Semaphore(nodeEngine.getProperties().getInteger(LOADED_KEY_LIMITER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373369f304e15d7589c727fd3c95b1f2b3039a38"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MDM3Mg==", "bodyText": "done", "url": "https://github.com/hazelcast/hazelcast/pull/17169#discussion_r482050372", "createdAt": "2020-09-02T13:02:10Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapServiceContextImpl.java", "diffHunk": "@@ -173,6 +176,7 @@\n         this.operationProviders = createOperationProviders();\n         this.partitioningStrategyFactory = new PartitioningStrategyFactory(nodeEngine.getConfigClassLoader());\n         this.nodeWideUsedCapacityCounter = new NodeWideUsedCapacityCounter(nodeEngine.getProperties());\n+        this.loadedKeyLimiter = new Semaphore(nodeEngine.getProperties().getInteger(LOADED_KEY_LIMITER));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4NjYyMw=="}, "originalCommit": {"oid": "373369f304e15d7589c727fd3c95b1f2b3039a38"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTI1MjM1OnYy", "diffSide": "RIGHT", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapKeyLoaderUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMTowMzo0MVrOHN7DMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo1NjoyNVrOHODyzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2MTAxMA==", "bodyText": "I wonder if we should use .acquire() here or drop in an IdleStrategy. As I understand if this method returns an empty batch, we call this method in a tight loop until the semaphore gives us the green light to proceed. Along the path, we create hashmaps etc.\nAs a second thought, shouldn't the semaphore be checked for available permits in MapKeyLoader#sendKeysInBatches in its\nwhile (batches.hasNext()) {\n                Map<Integer, List<Data>> batch = batches.next();\n                futures.addAll(sendBatch(batch, replaceExistingValues, nodeWideLoadedKeyLimiter));\n            }\n\nloop? Then the whole concurrency control would be in the same class and avoiding unnecessary allocations would be easier. WDYT?", "url": "https://github.com/hazelcast/hazelcast/pull/17169#discussion_r484361010", "createdAt": "2020-09-07T11:03:41Z", "author": {"login": "blazember"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapKeyLoaderUtil.java", "diffHunk": "@@ -110,13 +112,19 @@ public boolean hasNext() {\n      * until at least one group has up to {@code maxBatch}\n      * entries or until the {@code entries} have been exhausted.\n      *\n-     * @param entries  the entries to be grouped by key\n-     * @param maxBatch the maximum size of a group\n+     * @param entries                  the entries to be grouped by key\n+     * @param maxBatch                 the maximum size of a group\n+     * @param nodeWideLoadedKeyLimiter controls the loaded number of keys per node\n      * @return the grouped entries by entry key\n      */\n-    private static Map<Integer, List<Data>> nextBatch(Iterator<Entry<Integer, Data>> entries, int maxBatch) {\n+    private static Map<Integer, List<Data>> nextBatch(Iterator<Entry<Integer, Data>> entries,\n+                                                      int maxBatch, Semaphore nodeWideLoadedKeyLimiter) {\n         Map<Integer, List<Data>> batch = createHashMap(maxBatch);\n         while (entries.hasNext()) {\n+            if (!nodeWideLoadedKeyLimiter.tryAcquire()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456b716bbc5927b3045844af18a51ead39055aec"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNDI2OA==", "bodyText": "Acquire is not an option, since we have to return from method. But adding an idle-strategy makes sense. I have added it.", "url": "https://github.com/hazelcast/hazelcast/pull/17169#discussion_r484504268", "createdAt": "2020-09-07T15:56:25Z", "author": {"login": "ahmetmircik"}, "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapKeyLoaderUtil.java", "diffHunk": "@@ -110,13 +112,19 @@ public boolean hasNext() {\n      * until at least one group has up to {@code maxBatch}\n      * entries or until the {@code entries} have been exhausted.\n      *\n-     * @param entries  the entries to be grouped by key\n-     * @param maxBatch the maximum size of a group\n+     * @param entries                  the entries to be grouped by key\n+     * @param maxBatch                 the maximum size of a group\n+     * @param nodeWideLoadedKeyLimiter controls the loaded number of keys per node\n      * @return the grouped entries by entry key\n      */\n-    private static Map<Integer, List<Data>> nextBatch(Iterator<Entry<Integer, Data>> entries, int maxBatch) {\n+    private static Map<Integer, List<Data>> nextBatch(Iterator<Entry<Integer, Data>> entries,\n+                                                      int maxBatch, Semaphore nodeWideLoadedKeyLimiter) {\n         Map<Integer, List<Data>> batch = createHashMap(maxBatch);\n         while (entries.hasNext()) {\n+            if (!nodeWideLoadedKeyLimiter.tryAcquire()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2MTAxMA=="}, "originalCommit": {"oid": "456b716bbc5927b3045844af18a51ead39055aec"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 419, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}