{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDcyMjcz", "number": 1091, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNDo0NzowNlrOEQqJGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDozMzoxNFrOEW9DmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTAzMTI5OnYy", "diffSide": "RIGHT", "path": "Examples/OneSignalDemo/app/src/main/java/com/onesignal/sdktest/notification/AppNotificationExtensionService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNDo0NzowNlrOG07luw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoxMDozOFrOG9hgiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NTQ1MQ==", "bodyText": "can we use Log.i  instead of sysout", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r458155451", "createdAt": "2020-07-21T14:47:06Z", "author": {"login": "Jeasmine"}, "path": "Examples/OneSignalDemo/app/src/main/java/com/onesignal/sdktest/notification/AppNotificationExtensionService.java", "diffHunk": "@@ -1,43 +1,50 @@\n package com.onesignal.sdktest.notification;\n \n+import android.content.Context;\n+\n import androidx.core.app.NotificationCompat;\n \n-import com.onesignal.NotificationExtenderService;\n+import com.onesignal.OSNotificationDisplayedResult;\n+import com.onesignal.OSNotificationExtender;\n import com.onesignal.OSNotificationGenerationJob.ExtNotificationGenerationJob;\n import com.onesignal.OSNotificationOpenResult;\n import com.onesignal.OSNotificationPayload;\n-import com.onesignal.OSNotificationReceivedResult;\n+import com.onesignal.OSNotificationReceived;\n import com.onesignal.OneSignal;\n import com.onesignal.sdktest.R;\n \n-public class AppNotificationExtenderService extends NotificationExtenderService implements\n+public class AppNotificationExtensionService implements\n+        OneSignal.NotificationProcessingHandler,\n         OneSignal.ExtNotificationWillShowInForegroundHandler,\n         OneSignal.NotificationOpenedHandler {\n \n    @Override\n-   protected boolean onNotificationProcessing(OSNotificationReceivedResult notification) {\n+   public void notificationProcessing(Context context, OSNotificationReceived notification) {\n       if (notification.payload.actionButtons != null) {\n          for (OSNotificationPayload.ActionButton button : notification.payload.actionButtons) {\n             System.out.println(\"button:\" + button.toString());\n          }\n       }\n \n-      OverrideSettings overrideSettings = new NotificationExtenderService.OverrideSettings();\n+      OSNotificationExtender.OverrideSettings overrideSettings = new OSNotificationExtender.OverrideSettings();\n       overrideSettings.extender = new NotificationCompat.Extender() {\n          @Override\n          public NotificationCompat.Builder extend(NotificationCompat.Builder builder) {\n-            return builder.setColor(getResources().getColor(R.color.colorPrimary));\n+            return builder.setColor(context.getResources().getColor(R.color.colorPrimary));\n          }\n       };\n \n-      displayNotification(overrideSettings);\n+      notification.setModifiedContent(overrideSettings);\n+\n+      OSNotificationDisplayedResult notificationDisplayedResult = notification.display();\n+      System.out.println(\"Android notification id: \" + notificationDisplayedResult.androidNotificationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MzAzMw==", "bodyText": "This is just demo app but yes we can replace sysout with Log.i", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467163033", "createdAt": "2020-08-07T17:06:01Z", "author": {"login": "mikechoch"}, "path": "Examples/OneSignalDemo/app/src/main/java/com/onesignal/sdktest/notification/AppNotificationExtensionService.java", "diffHunk": "@@ -1,43 +1,50 @@\n package com.onesignal.sdktest.notification;\n \n+import android.content.Context;\n+\n import androidx.core.app.NotificationCompat;\n \n-import com.onesignal.NotificationExtenderService;\n+import com.onesignal.OSNotificationDisplayedResult;\n+import com.onesignal.OSNotificationExtender;\n import com.onesignal.OSNotificationGenerationJob.ExtNotificationGenerationJob;\n import com.onesignal.OSNotificationOpenResult;\n import com.onesignal.OSNotificationPayload;\n-import com.onesignal.OSNotificationReceivedResult;\n+import com.onesignal.OSNotificationReceived;\n import com.onesignal.OneSignal;\n import com.onesignal.sdktest.R;\n \n-public class AppNotificationExtenderService extends NotificationExtenderService implements\n+public class AppNotificationExtensionService implements\n+        OneSignal.NotificationProcessingHandler,\n         OneSignal.ExtNotificationWillShowInForegroundHandler,\n         OneSignal.NotificationOpenedHandler {\n \n    @Override\n-   protected boolean onNotificationProcessing(OSNotificationReceivedResult notification) {\n+   public void notificationProcessing(Context context, OSNotificationReceived notification) {\n       if (notification.payload.actionButtons != null) {\n          for (OSNotificationPayload.ActionButton button : notification.payload.actionButtons) {\n             System.out.println(\"button:\" + button.toString());\n          }\n       }\n \n-      OverrideSettings overrideSettings = new NotificationExtenderService.OverrideSettings();\n+      OSNotificationExtender.OverrideSettings overrideSettings = new OSNotificationExtender.OverrideSettings();\n       overrideSettings.extender = new NotificationCompat.Extender() {\n          @Override\n          public NotificationCompat.Builder extend(NotificationCompat.Builder builder) {\n-            return builder.setColor(getResources().getColor(R.color.colorPrimary));\n+            return builder.setColor(context.getResources().getColor(R.color.colorPrimary));\n          }\n       };\n \n-      displayNotification(overrideSettings);\n+      notification.setModifiedContent(overrideSettings);\n+\n+      OSNotificationDisplayedResult notificationDisplayedResult = notification.display();\n+      System.out.println(\"Android notification id: \" + notificationDisplayedResult.androidNotificationId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NTQ1MQ=="}, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTMyMw==", "bodyText": "Fixed!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467165323", "createdAt": "2020-08-07T17:10:38Z", "author": {"login": "mikechoch"}, "path": "Examples/OneSignalDemo/app/src/main/java/com/onesignal/sdktest/notification/AppNotificationExtensionService.java", "diffHunk": "@@ -1,43 +1,50 @@\n package com.onesignal.sdktest.notification;\n \n+import android.content.Context;\n+\n import androidx.core.app.NotificationCompat;\n \n-import com.onesignal.NotificationExtenderService;\n+import com.onesignal.OSNotificationDisplayedResult;\n+import com.onesignal.OSNotificationExtender;\n import com.onesignal.OSNotificationGenerationJob.ExtNotificationGenerationJob;\n import com.onesignal.OSNotificationOpenResult;\n import com.onesignal.OSNotificationPayload;\n-import com.onesignal.OSNotificationReceivedResult;\n+import com.onesignal.OSNotificationReceived;\n import com.onesignal.OneSignal;\n import com.onesignal.sdktest.R;\n \n-public class AppNotificationExtenderService extends NotificationExtenderService implements\n+public class AppNotificationExtensionService implements\n+        OneSignal.NotificationProcessingHandler,\n         OneSignal.ExtNotificationWillShowInForegroundHandler,\n         OneSignal.NotificationOpenedHandler {\n \n    @Override\n-   protected boolean onNotificationProcessing(OSNotificationReceivedResult notification) {\n+   public void notificationProcessing(Context context, OSNotificationReceived notification) {\n       if (notification.payload.actionButtons != null) {\n          for (OSNotificationPayload.ActionButton button : notification.payload.actionButtons) {\n             System.out.println(\"button:\" + button.toString());\n          }\n       }\n \n-      OverrideSettings overrideSettings = new NotificationExtenderService.OverrideSettings();\n+      OSNotificationExtender.OverrideSettings overrideSettings = new OSNotificationExtender.OverrideSettings();\n       overrideSettings.extender = new NotificationCompat.Extender() {\n          @Override\n          public NotificationCompat.Builder extend(NotificationCompat.Builder builder) {\n-            return builder.setColor(getResources().getColor(R.color.colorPrimary));\n+            return builder.setColor(context.getResources().getColor(R.color.colorPrimary));\n          }\n       };\n \n-      displayNotification(overrideSettings);\n+      notification.setModifiedContent(overrideSettings);\n+\n+      OSNotificationDisplayedResult notificationDisplayedResult = notification.display();\n+      System.out.println(\"Android notification id: \" + notificationDisplayedResult.androidNotificationId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NTQ1MQ=="}, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTA2NDQ4OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNDo1Mzo1OFrOG076ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzowODo0MVrOG9hcfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2MDgwMw==", "bodyText": "remove extra enters", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r458160803", "createdAt": "2020-07-21T14:53:58Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java", "diffHunk": "@@ -59,534 +58,530 @@\n  * */\n class NotificationBundleProcessor {\n \n-   public static final String PUSH_ADDITIONAL_DATA_KEY = \"a\";\n+    public static final String PUSH_ADDITIONAL_DATA_KEY = \"a\";\n \n-   public static final String PUSH_MINIFIED_BUTTONS_LIST = \"o\";\n-   public static final String PUSH_MINIFIED_BUTTON_ID = \"i\";\n-   public static final String PUSH_MINIFIED_BUTTON_TEXT = \"n\";\n-   public static final String PUSH_MINIFIED_BUTTON_ICON = \"p\";\n+    public static final String PUSH_MINIFIED_BUTTONS_LIST = \"o\";\n+    public static final String PUSH_MINIFIED_BUTTON_ID = \"i\";\n+    public static final String PUSH_MINIFIED_BUTTON_TEXT = \"n\";\n+    public static final String PUSH_MINIFIED_BUTTON_ICON = \"p\";\n \n-   private static final String IAM_PREVIEW_KEY = \"os_in_app_message_preview_id\";\n-   static final String DEFAULT_ACTION = \"__DEFAULT__\";\n+    private static final String IAM_PREVIEW_KEY = \"os_in_app_message_preview_id\";\n+    static final String DEFAULT_ACTION = \"__DEFAULT__\";\n \n-   static void ProcessFromFCMIntentService(Context context, BundleCompat bundle, NotificationExtenderService.OverrideSettings overrideSettings) {\n-      OneSignal.setAppContext(context);\n-      try {\n-         String jsonStrPayload = bundle.getString(\"json_payload\");\n-         if (jsonStrPayload == null) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"json_payload key is nonexistent from mBundle passed to ProcessFromFCMIntentService: \" + bundle);\n-            return;\n-         }\n+    static void processFromFCMIntentService(Context context, BundleCompat bundle, OSNotificationExtender.OverrideSettings overrideSettings) {\n+        OneSignal.setAppContext(context);\n+        try {\n+            String jsonStrPayload = bundle.getString(\"json_payload\");\n+            if (jsonStrPayload == null) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"json_payload key is nonexistent from mBundle passed to ProcessFromFCMIntentService: \" + bundle);\n+                return;\n+            }\n \n-         OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n-         notifJob.isRestoring = bundle.getBoolean(\"restoring\", false);\n-         notifJob.shownTimeStamp = bundle.getLong(\"timestamp\");\n-         notifJob.jsonPayload = new JSONObject(jsonStrPayload);\n-         notifJob.isIamPreview = inAppPreviewPushUUID(notifJob.jsonPayload) != null;\n+            OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n+            notifJob.jsonPayload = new JSONObject(jsonStrPayload);\n+            notifJob.isRestoring = bundle.getBoolean(\"is_restoring\", false);\n+            notifJob.shownTimeStamp = bundle.getLong(\"timestamp\");\n+            notifJob.isIamPreview = inAppPreviewPushUUID(notifJob.jsonPayload) != null;\n+\n+            if (!notifJob.isRestoring &&\n+                    !notifJob.isIamPreview &&\n+                    OneSignal.notValidOrDuplicated(context, notifJob.jsonPayload))\n+                return;\n+\n+            if (bundle.containsKey(\"android_notif_id\")) {\n+                if (overrideSettings == null)\n+                    overrideSettings = new OSNotificationExtender.OverrideSettings();\n+                overrideSettings.androidNotificationId = bundle.getInt(\"android_notif_id\");\n+            }\n \n-         if (!notifJob.isRestoring &&\n-             !notifJob.isIamPreview &&\n-             OneSignal.notValidOrDuplicated(context, notifJob.jsonPayload))\n-            return;\n+            notifJob.overrideSettings = overrideSettings;\n+            processJobForDisplay(notifJob);\n \n-         if (bundle.containsKey(\"android_notif_id\")) {\n-            if (overrideSettings == null)\n-               overrideSettings = new NotificationExtenderService.OverrideSettings();\n-            overrideSettings.androidNotificationId = bundle.getInt(\"android_notif_id\");\n-         }\n-         \n-         notifJob.overrideSettings = overrideSettings;\n-         ProcessJobForDisplay(notifJob);\n-\n-         // Delay to prevent CPU spikes.\n-         //    Normally more than one notification is restored at a time.\n-         if (notifJob.isRestoring)\n-            OSUtils.sleep(100);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-   }\n+            // Delay to prevent CPU spikes.\n+            //    Normally more than one notification is restored at a time.\n+            if (notifJob.isRestoring)\n+                OSUtils.sleep(100);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n \n     /**\n      * Recommended method to process notification before displaying\n-     * Only use the {@link NotificationBundleProcessor#ProcessJobForDisplay(OSNotificationGenerationJob, boolean, boolean)}\n+     * Only use the {@link NotificationBundleProcessor#processJobForDisplay(OSNotificationGenerationJob, boolean, boolean)}\n      *     in the event where you want to mark a notification as opened or displayed different than the defaults\n      */\n-    static int ProcessJobForDisplay(OSNotificationGenerationJob notifJob) {\n-        return ProcessJobForDisplay(notifJob, false, true);\n+    static int processJobForDisplay(OSNotificationGenerationJob notifJob) {\n+        return processJobForDisplay(notifJob, false, true);\n     }\n \n-    static int ProcessJobForDisplay(OSNotificationGenerationJob notifJob, boolean opened, boolean displayed) {\n+    static int processJobForDisplay(OSNotificationGenerationJob notifJob, boolean opened, boolean displayed) {\n         processCollapseKey(notifJob);\n \n+        int androidNotifId = notifJob.getAndroidIdWithoutCreate();\n         boolean doDisplay = shouldDisplayNotif(notifJob);\n-        if (doDisplay)\n+        if (doDisplay) {\n+            androidNotifId = notifJob.getAndroidId();\n             OneSignal.fireNotificationWillShowInForegroundHandlers(notifJob);\n+        }\n \n         if (!notifJob.isRestoring && !notifJob.isIamPreview) {\n             processNotification(notifJob, opened);\n             OneSignal.handleNotificationReceived(notifJob, displayed);\n         }\n \n-        return notifJob.getAndroidIdWithoutCreate();\n+        return androidNotifId;\n+    }\n+\n+    private static boolean shouldDisplayNotif(OSNotificationGenerationJob notifJob) {\n+        // Validate that the current Android device is Android 4.4 or higher and the current job is a\n+        //    preview push\n+        if (notifJob.isIamPreview && Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR2)\n+            return false;\n+\n+        // Otherwise, this is a normal notification and should be shown\n+        return notifJob.hasExtender() || shouldDisplay(notifJob.jsonPayload.optString(\"alert\"));\n+    }\n+\n+    /**\n+     * Save notification, updates Outcomes, and sends Received Receipt if they are enabled.\n+     */\n+    static void processNotification(OSNotificationGenerationJob notifJob, boolean opened) {\n+        saveNotification(notifJob, opened);\n+\n+        if (!notifJob.isNotificationToDisplay())\n+            return;\n+\n+        String notificationId = notifJob.getApiNotificationId();\n+        OneSignal.getSessionManager().onNotificationReceived(notificationId);\n+        OSReceiveReceiptController.getInstance().sendReceiveReceipt(notificationId);\n+    }\n+\n+    // Saving the notification provides the following:\n+    //   * Prevent duplicates\n+    //   * Build summary notifications\n+    //   * Collapse key / id support - Used to lookup the android notification id later\n+    //   * Redisplay notifications after reboot, upgrade of app, or cold boot after a force kill.\n+    //   * Future - Public API to get a list of notifications\n+    private static void saveNotification(OSNotificationGenerationJob notifiJob, boolean opened) {\n+        Context context = notifiJob.context;\n+        JSONObject jsonPayload = notifiJob.jsonPayload;\n+\n+        try {\n+            JSONObject customJSON = getCustomJSONObject(notifiJob.jsonPayload);\n+\n+            OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n+            SQLiteDatabase writableDb = null;\n+\n+            try {\n+                writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n+\n+                writableDb.beginTransaction();\n+\n+                // Count any notifications with duplicated android notification ids as dismissed.\n+                // -1 is used to note never displayed\n+                if (notifiJob.isNotificationToDisplay()) {\n+                    String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+\n+                    ContentValues values = new ContentValues();\n+                    values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+\n+                    writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n+                    BadgeCountUpdater.update(writableDb, context);\n+                }\n+\n+                // Save just received notification to DB\n+                ContentValues values = new ContentValues();\n+                values.put(NotificationTable.COLUMN_NAME_NOTIFICATION_ID, customJSON.optString(\"i\"));\n+                if (jsonPayload.has(\"grp\"))\n+                    values.put(NotificationTable.COLUMN_NAME_GROUP_ID, jsonPayload.optString(\"grp\"));\n+                if (jsonPayload.has(\"collapse_key\") && !\"do_not_collapse\".equals(jsonPayload.optString(\"collapse_key\")))\n+                    values.put(NotificationTable.COLUMN_NAME_COLLAPSE_ID, jsonPayload.optString(\"collapse_key\"));\n+\n+                values.put(NotificationTable.COLUMN_NAME_OPENED, opened ? 1 : 0);\n+                if (!opened)\n+                    values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, notifiJob.getAndroidIdWithoutCreate());\n+\n+                if (notifiJob.getTitle() != null)\n+                    values.put(NotificationTable.COLUMN_NAME_TITLE, notifiJob.getTitle().toString());\n+                if (notifiJob.getBody() != null)\n+                    values.put(NotificationTable.COLUMN_NAME_MESSAGE, notifiJob.getBody().toString());\n+\n+                // Set expire_time\n+                long sentTime = jsonPayload.optLong(\"google.sent_time\", SystemClock.currentThreadTimeMillis()) / 1_000L;\n+                int ttl = jsonPayload.optInt(\"google.ttl\", NotificationRestorer.DEFAULT_TTL_IF_NOT_IN_PAYLOAD);\n+                long expireTime = sentTime + ttl;\n+                values.put(NotificationTable.COLUMN_NAME_EXPIRE_TIME, expireTime);\n+\n+                values.put(NotificationTable.COLUMN_NAME_FULL_DATA, jsonPayload.toString());\n+\n+                writableDb.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n+\n+                if (!opened)\n+                    BadgeCountUpdater.update(writableDb, context);\n+                writableDb.setTransactionSuccessful();\n+            } catch (Exception e) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n+            } finally {\n+                if (writableDb != null) {\n+                    try {\n+                        writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                    } catch (Throwable t) {\n+                        OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                    }\n+                }\n+            }\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n     }\n \n-   private static boolean shouldDisplayNotif(OSNotificationGenerationJob notifJob) {\n-      // Validate that the current Android device is Android 4.4 or higher and the current job is a\n-      //    preview push\n-      if (notifJob.isIamPreview && Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR2)\n-         return false;\n-\n-      // Otherwise, this is a normal notification and should be shown\n-      return notifJob.hasExtender() || shouldDisplay(notifJob.jsonPayload.optString(\"alert\"));\n-   }\n-\n-   private static JSONArray bundleAsJsonArray(Bundle bundle) {\n-      JSONArray jsonArray = new JSONArray();\n-      jsonArray.put(bundleAsJSONObject(bundle));\n-      return jsonArray;\n-   }\n-\n-   private static OSNotificationGenerationJob saveAndProcessNotification(Context context, Bundle bundle, boolean opened, int notificationId) {\n-      OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n-      notifJob.jsonPayload = bundleAsJSONObject(bundle);\n-      notifJob.overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      notifJob.overrideSettings.androidNotificationId = notificationId;\n-\n-      processNotification(notifJob, opened);\n-\n-      return notifJob;\n-   }\n-\n-   /**\n-    * Save notification, updates Outcomes, and sends Received Receipt if they are enabled.\n-    */\n-   static void processNotification(OSNotificationGenerationJob notifJob, boolean opened) {\n-      saveNotification(notifJob, opened);\n-\n-      if (!notifJob.isNotificationToDisplay())\n-         return;\n-\n-      String notificationId = notifJob.getApiNotificationId();\n-      OneSignal.getSessionManager().onNotificationReceived(notificationId);\n-      OSReceiveReceiptController.getInstance().sendReceiveReceipt(notificationId);\n-   }\n-\n-   // Saving the notification provides the following:\n-   //   * Prevent duplicates\n-   //   * Build summary notifications\n-   //   * Collapse key / id support - Used to lookup the android notification id later\n-   //   * Redisplay notifications after reboot, upgrade of app, or cold boot after a force kill.\n-   //   * Future - Public API to get a list of notifications\n-   private static void saveNotification(OSNotificationGenerationJob notifiJob, boolean opened) {\n-      Context context = notifiJob.context;\n-      JSONObject jsonPayload = notifiJob.jsonPayload;\n-      \n-      try {\n-         JSONObject customJSON = getCustomJSONObject(notifiJob.jsonPayload);\n-   \n-         OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n-         SQLiteDatabase writableDb = null;\n-\n-         try {\n+    static void markRestoredNotificationAsDismissed(OSNotificationGenerationJob notifiJob) {\n+        if (notifiJob.getAndroidIdWithoutCreate() == -1)\n+            return;\n+\n+        String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+\n+        OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n+        SQLiteDatabase writableDb = null;\n+\n+        try {\n             writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n-   \n             writableDb.beginTransaction();\n-            \n-            // Count any notifications with duplicated android notification ids as dismissed.\n-            // -1 is used to note never displayed\n-            if (notifiJob.isNotificationToDisplay()) {\n-               String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n-   \n-               ContentValues values = new ContentValues();\n-               values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n-   \n-               writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n-               BadgeCountUpdater.update(writableDb, context);\n-            }\n \n-            // Save just received notification to DB\n             ContentValues values = new ContentValues();\n-            values.put(NotificationTable.COLUMN_NAME_NOTIFICATION_ID, customJSON.optString(\"i\"));\n-            if (jsonPayload.has(\"grp\"))\n-               values.put(NotificationTable.COLUMN_NAME_GROUP_ID, jsonPayload.optString(\"grp\"));\n-            if (jsonPayload.has(\"collapse_key\") && !\"do_not_collapse\".equals(jsonPayload.optString(\"collapse_key\")))\n-               values.put(NotificationTable.COLUMN_NAME_COLLAPSE_ID, jsonPayload.optString(\"collapse_key\"));\n-\n-            values.put(NotificationTable.COLUMN_NAME_OPENED, opened ? 1 : 0);\n-            if (!opened)\n-               values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, notifiJob.getAndroidIdWithoutCreate());\n-            \n-            if (notifiJob.getTitle() != null)\n-               values.put(NotificationTable.COLUMN_NAME_TITLE, notifiJob.getTitle().toString());\n-            if (notifiJob.getBody() != null)\n-               values.put(NotificationTable.COLUMN_NAME_MESSAGE, notifiJob.getBody().toString());\n-\n-            // Set expire_time\n-            long sentTime = jsonPayload.optLong(\"google.sent_time\", SystemClock.currentThreadTimeMillis()) / 1_000L;\n-            int ttl = jsonPayload.optInt(\"google.ttl\", NotificationRestorer.DEFAULT_TTL_IF_NOT_IN_PAYLOAD);\n-            long expireTime = sentTime + ttl;\n-            values.put(NotificationTable.COLUMN_NAME_EXPIRE_TIME, expireTime);\n-\n-            values.put(NotificationTable.COLUMN_NAME_FULL_DATA, jsonPayload.toString());\n-\n-            writableDb.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n-\n-            if (!opened)\n-               BadgeCountUpdater.update(writableDb, context);\n+            values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+\n+            writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n+            BadgeCountUpdater.update(writableDb, notifiJob.context);\n+\n             writableDb.setTransactionSuccessful();\n-         } catch (Exception e) {\n+\n+        } catch (Exception e) {\n             OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n-         } finally {\n+        } finally {\n             if (writableDb != null) {\n-               try {\n-                  writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n-               } catch (Throwable t) {\n-                  OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n-               }\n+                try {\n+                    writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                } catch (Throwable t) {\n+                    OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                }\n+            }\n+        }\n+    }\n+\n+    static @NonNull\n+    JSONObject bundleAsJSONObject(Bundle bundle) {\n+        JSONObject json = new JSONObject();\n+        Set<String> keys = bundle.keySet();\n+\n+        for (String key : keys) {\n+            try {\n+                json.put(key, bundle.get(key));\n+            } catch (JSONException e) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"bundleAsJSONObject error for key: \" + key, e);\n             }\n-         }\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-   }\n+        }\n \n-   static void markRestoredNotificationAsDismissed(OSNotificationGenerationJob notifiJob) {\n-      if (notifiJob.getAndroidIdWithoutCreate() == -1)\n-         return;\n+        return json;\n+    }\n \n-      String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+    // Format our short keys into more readable ones.\n+    private static void maximizeButtonsFromBundle(Bundle fcmBundle) {\n+        if (!fcmBundle.containsKey(\"o\"))\n+            return;\n \n-      OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n-      SQLiteDatabase writableDb = null;\n+        try {\n+            JSONObject customJSON = new JSONObject(fcmBundle.getString(\"custom\"));\n+            JSONObject additionalDataJSON;\n+\n+            if (customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n+                additionalDataJSON = customJSON.getJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n+            else\n+                additionalDataJSON = new JSONObject();\n+\n+            JSONArray buttons = new JSONArray(fcmBundle.getString(PUSH_MINIFIED_BUTTONS_LIST));\n+            fcmBundle.remove(PUSH_MINIFIED_BUTTONS_LIST);\n+            for (int i = 0; i < buttons.length(); i++) {\n+                JSONObject button = buttons.getJSONObject(i);\n+\n+                String buttonText = button.getString(PUSH_MINIFIED_BUTTON_TEXT);\n+                button.remove(PUSH_MINIFIED_BUTTON_TEXT);\n+\n+                String buttonId;\n+                if (button.has(PUSH_MINIFIED_BUTTON_ID)) {\n+                    buttonId = button.getString(PUSH_MINIFIED_BUTTON_ID);\n+                    button.remove(PUSH_MINIFIED_BUTTON_ID);\n+                } else\n+                    buttonId = buttonText;\n+\n+                button.put(\"id\", buttonId);\n+                button.put(\"text\", buttonText);\n+\n+                if (button.has(PUSH_MINIFIED_BUTTON_ICON)) {\n+                    button.put(\"icon\", button.getString(PUSH_MINIFIED_BUTTON_ICON));\n+                    button.remove(PUSH_MINIFIED_BUTTON_ICON);\n+                }\n+            }\n \n-      try {\n-         writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n-         writableDb.beginTransaction();\n+            additionalDataJSON.put(\"actionButtons\", buttons);\n+            additionalDataJSON.put(BUNDLE_KEY_ACTION_ID, DEFAULT_ACTION);\n+            if (!customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n+                customJSON.put(PUSH_ADDITIONAL_DATA_KEY, additionalDataJSON);\n \n-         ContentValues values = new ContentValues();\n-         values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+            fcmBundle.putString(\"custom\", customJSON.toString());\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n \n-         writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n-         BadgeCountUpdater.update(writableDb, notifiJob.context);\n+    static OSNotificationPayload OSNotificationPayloadFrom(JSONObject currentJsonPayload) {\n+        OSNotificationPayload notification = new OSNotificationPayload();\n+        try {\n+            JSONObject customJson = getCustomJSONObject(currentJsonPayload);\n+            notification.notificationID = customJson.optString(\"i\");\n+            notification.templateId = customJson.optString(\"ti\");\n+            notification.templateName = customJson.optString(\"tn\");\n+            notification.rawPayload = currentJsonPayload.toString();\n+            notification.additionalData = customJson.optJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n+            notification.launchURL = customJson.optString(\"u\", null);\n+\n+            notification.body = currentJsonPayload.optString(\"alert\", null);\n+            notification.title = currentJsonPayload.optString(\"title\", null);\n+            notification.smallIcon = currentJsonPayload.optString(\"sicon\", null);\n+            notification.bigPicture = currentJsonPayload.optString(\"bicon\", null);\n+            notification.largeIcon = currentJsonPayload.optString(\"licon\", null);\n+            notification.sound = currentJsonPayload.optString(\"sound\", null);\n+            notification.groupKey = currentJsonPayload.optString(\"grp\", null);\n+            notification.groupMessage = currentJsonPayload.optString(\"grp_msg\", null);\n+            notification.smallIconAccentColor = currentJsonPayload.optString(\"bgac\", null);\n+            notification.ledColor = currentJsonPayload.optString(\"ledc\", null);\n+            String visibility = currentJsonPayload.optString(\"vis\", null);\n+            if (visibility != null)\n+                notification.lockScreenVisibility = Integer.parseInt(visibility);\n+            notification.fromProjectNumber = currentJsonPayload.optString(\"from\", null);\n+            notification.priority = currentJsonPayload.optInt(\"pri\", 0);\n+            String collapseKey = currentJsonPayload.optString(\"collapse_key\", null);\n+            if (!\"do_not_collapse\".equals(collapseKey))\n+                notification.collapseId = collapseKey;\n \n-         writableDb.setTransactionSuccessful();\n+            try {\n+                setActionButtons(notification);\n+            } catch (Throwable t) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload.actionButtons values!\", t);\n+            }\n \n-      } catch (Exception e) {\n-         OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n-      } finally {\n-         if (writableDb != null) {\n             try {\n-               writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                setBackgroundImageLayout(notification, currentJsonPayload);\n             } catch (Throwable t) {\n-               OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload.backgroundImageLayout values!\", t);\n             }\n-         }\n-      }\n-   }\n-\n-   static @NonNull JSONObject bundleAsJSONObject(Bundle bundle) {\n-      JSONObject json = new JSONObject();\n-      Set<String> keys = bundle.keySet();\n-\n-      for (String key : keys) {\n-         try {\n-            json.put(key, bundle.get(key));\n-         } catch (JSONException e) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"bundleAsJSONObject error for key: \" + key, e);\n-         }\n-      }\n-\n-      return json;\n-   }\n-\n-   // Format our short keys into more readable ones.\n-   private static void maximizeButtonsFromBundle(Bundle fcmBundle) {\n-      if (!fcmBundle.containsKey(\"o\"))\n-         return;\n-      \n-      try {\n-         JSONObject customJSON = new JSONObject(fcmBundle.getString(\"custom\"));\n-         JSONObject additionalDataJSON;\n-\n-         if (customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n-            additionalDataJSON = customJSON.getJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n-         else\n-            additionalDataJSON = new JSONObject();\n-\n-         JSONArray buttons = new JSONArray(fcmBundle.getString(PUSH_MINIFIED_BUTTONS_LIST));\n-         fcmBundle.remove(PUSH_MINIFIED_BUTTONS_LIST);\n-         for (int i = 0; i < buttons.length(); i++) {\n-            JSONObject button = buttons.getJSONObject(i);\n-\n-            String buttonText = button.getString(PUSH_MINIFIED_BUTTON_TEXT);\n-            button.remove(PUSH_MINIFIED_BUTTON_TEXT);\n-\n-            String buttonId;\n-            if (button.has(PUSH_MINIFIED_BUTTON_ID)) {\n-               buttonId = button.getString(PUSH_MINIFIED_BUTTON_ID);\n-               button.remove(PUSH_MINIFIED_BUTTON_ID);\n-            } else\n-               buttonId = buttonText;\n-\n-            button.put(\"id\", buttonId);\n-            button.put(\"text\", buttonText);\n-\n-            if (button.has(PUSH_MINIFIED_BUTTON_ICON)) {\n-               button.put(\"icon\", button.getString(PUSH_MINIFIED_BUTTON_ICON));\n-               button.remove(PUSH_MINIFIED_BUTTON_ICON);\n+        } catch (Throwable t) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload values!\", t);\n+        }\n+\n+        return notification;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 595}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NDI4Ng==", "bodyText": "Fixed!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467164286", "createdAt": "2020-08-07T17:08:41Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java", "diffHunk": "@@ -59,534 +58,530 @@\n  * */\n class NotificationBundleProcessor {\n \n-   public static final String PUSH_ADDITIONAL_DATA_KEY = \"a\";\n+    public static final String PUSH_ADDITIONAL_DATA_KEY = \"a\";\n \n-   public static final String PUSH_MINIFIED_BUTTONS_LIST = \"o\";\n-   public static final String PUSH_MINIFIED_BUTTON_ID = \"i\";\n-   public static final String PUSH_MINIFIED_BUTTON_TEXT = \"n\";\n-   public static final String PUSH_MINIFIED_BUTTON_ICON = \"p\";\n+    public static final String PUSH_MINIFIED_BUTTONS_LIST = \"o\";\n+    public static final String PUSH_MINIFIED_BUTTON_ID = \"i\";\n+    public static final String PUSH_MINIFIED_BUTTON_TEXT = \"n\";\n+    public static final String PUSH_MINIFIED_BUTTON_ICON = \"p\";\n \n-   private static final String IAM_PREVIEW_KEY = \"os_in_app_message_preview_id\";\n-   static final String DEFAULT_ACTION = \"__DEFAULT__\";\n+    private static final String IAM_PREVIEW_KEY = \"os_in_app_message_preview_id\";\n+    static final String DEFAULT_ACTION = \"__DEFAULT__\";\n \n-   static void ProcessFromFCMIntentService(Context context, BundleCompat bundle, NotificationExtenderService.OverrideSettings overrideSettings) {\n-      OneSignal.setAppContext(context);\n-      try {\n-         String jsonStrPayload = bundle.getString(\"json_payload\");\n-         if (jsonStrPayload == null) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"json_payload key is nonexistent from mBundle passed to ProcessFromFCMIntentService: \" + bundle);\n-            return;\n-         }\n+    static void processFromFCMIntentService(Context context, BundleCompat bundle, OSNotificationExtender.OverrideSettings overrideSettings) {\n+        OneSignal.setAppContext(context);\n+        try {\n+            String jsonStrPayload = bundle.getString(\"json_payload\");\n+            if (jsonStrPayload == null) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"json_payload key is nonexistent from mBundle passed to ProcessFromFCMIntentService: \" + bundle);\n+                return;\n+            }\n \n-         OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n-         notifJob.isRestoring = bundle.getBoolean(\"restoring\", false);\n-         notifJob.shownTimeStamp = bundle.getLong(\"timestamp\");\n-         notifJob.jsonPayload = new JSONObject(jsonStrPayload);\n-         notifJob.isIamPreview = inAppPreviewPushUUID(notifJob.jsonPayload) != null;\n+            OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n+            notifJob.jsonPayload = new JSONObject(jsonStrPayload);\n+            notifJob.isRestoring = bundle.getBoolean(\"is_restoring\", false);\n+            notifJob.shownTimeStamp = bundle.getLong(\"timestamp\");\n+            notifJob.isIamPreview = inAppPreviewPushUUID(notifJob.jsonPayload) != null;\n+\n+            if (!notifJob.isRestoring &&\n+                    !notifJob.isIamPreview &&\n+                    OneSignal.notValidOrDuplicated(context, notifJob.jsonPayload))\n+                return;\n+\n+            if (bundle.containsKey(\"android_notif_id\")) {\n+                if (overrideSettings == null)\n+                    overrideSettings = new OSNotificationExtender.OverrideSettings();\n+                overrideSettings.androidNotificationId = bundle.getInt(\"android_notif_id\");\n+            }\n \n-         if (!notifJob.isRestoring &&\n-             !notifJob.isIamPreview &&\n-             OneSignal.notValidOrDuplicated(context, notifJob.jsonPayload))\n-            return;\n+            notifJob.overrideSettings = overrideSettings;\n+            processJobForDisplay(notifJob);\n \n-         if (bundle.containsKey(\"android_notif_id\")) {\n-            if (overrideSettings == null)\n-               overrideSettings = new NotificationExtenderService.OverrideSettings();\n-            overrideSettings.androidNotificationId = bundle.getInt(\"android_notif_id\");\n-         }\n-         \n-         notifJob.overrideSettings = overrideSettings;\n-         ProcessJobForDisplay(notifJob);\n-\n-         // Delay to prevent CPU spikes.\n-         //    Normally more than one notification is restored at a time.\n-         if (notifJob.isRestoring)\n-            OSUtils.sleep(100);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-   }\n+            // Delay to prevent CPU spikes.\n+            //    Normally more than one notification is restored at a time.\n+            if (notifJob.isRestoring)\n+                OSUtils.sleep(100);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n \n     /**\n      * Recommended method to process notification before displaying\n-     * Only use the {@link NotificationBundleProcessor#ProcessJobForDisplay(OSNotificationGenerationJob, boolean, boolean)}\n+     * Only use the {@link NotificationBundleProcessor#processJobForDisplay(OSNotificationGenerationJob, boolean, boolean)}\n      *     in the event where you want to mark a notification as opened or displayed different than the defaults\n      */\n-    static int ProcessJobForDisplay(OSNotificationGenerationJob notifJob) {\n-        return ProcessJobForDisplay(notifJob, false, true);\n+    static int processJobForDisplay(OSNotificationGenerationJob notifJob) {\n+        return processJobForDisplay(notifJob, false, true);\n     }\n \n-    static int ProcessJobForDisplay(OSNotificationGenerationJob notifJob, boolean opened, boolean displayed) {\n+    static int processJobForDisplay(OSNotificationGenerationJob notifJob, boolean opened, boolean displayed) {\n         processCollapseKey(notifJob);\n \n+        int androidNotifId = notifJob.getAndroidIdWithoutCreate();\n         boolean doDisplay = shouldDisplayNotif(notifJob);\n-        if (doDisplay)\n+        if (doDisplay) {\n+            androidNotifId = notifJob.getAndroidId();\n             OneSignal.fireNotificationWillShowInForegroundHandlers(notifJob);\n+        }\n \n         if (!notifJob.isRestoring && !notifJob.isIamPreview) {\n             processNotification(notifJob, opened);\n             OneSignal.handleNotificationReceived(notifJob, displayed);\n         }\n \n-        return notifJob.getAndroidIdWithoutCreate();\n+        return androidNotifId;\n+    }\n+\n+    private static boolean shouldDisplayNotif(OSNotificationGenerationJob notifJob) {\n+        // Validate that the current Android device is Android 4.4 or higher and the current job is a\n+        //    preview push\n+        if (notifJob.isIamPreview && Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR2)\n+            return false;\n+\n+        // Otherwise, this is a normal notification and should be shown\n+        return notifJob.hasExtender() || shouldDisplay(notifJob.jsonPayload.optString(\"alert\"));\n+    }\n+\n+    /**\n+     * Save notification, updates Outcomes, and sends Received Receipt if they are enabled.\n+     */\n+    static void processNotification(OSNotificationGenerationJob notifJob, boolean opened) {\n+        saveNotification(notifJob, opened);\n+\n+        if (!notifJob.isNotificationToDisplay())\n+            return;\n+\n+        String notificationId = notifJob.getApiNotificationId();\n+        OneSignal.getSessionManager().onNotificationReceived(notificationId);\n+        OSReceiveReceiptController.getInstance().sendReceiveReceipt(notificationId);\n+    }\n+\n+    // Saving the notification provides the following:\n+    //   * Prevent duplicates\n+    //   * Build summary notifications\n+    //   * Collapse key / id support - Used to lookup the android notification id later\n+    //   * Redisplay notifications after reboot, upgrade of app, or cold boot after a force kill.\n+    //   * Future - Public API to get a list of notifications\n+    private static void saveNotification(OSNotificationGenerationJob notifiJob, boolean opened) {\n+        Context context = notifiJob.context;\n+        JSONObject jsonPayload = notifiJob.jsonPayload;\n+\n+        try {\n+            JSONObject customJSON = getCustomJSONObject(notifiJob.jsonPayload);\n+\n+            OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n+            SQLiteDatabase writableDb = null;\n+\n+            try {\n+                writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n+\n+                writableDb.beginTransaction();\n+\n+                // Count any notifications with duplicated android notification ids as dismissed.\n+                // -1 is used to note never displayed\n+                if (notifiJob.isNotificationToDisplay()) {\n+                    String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+\n+                    ContentValues values = new ContentValues();\n+                    values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+\n+                    writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n+                    BadgeCountUpdater.update(writableDb, context);\n+                }\n+\n+                // Save just received notification to DB\n+                ContentValues values = new ContentValues();\n+                values.put(NotificationTable.COLUMN_NAME_NOTIFICATION_ID, customJSON.optString(\"i\"));\n+                if (jsonPayload.has(\"grp\"))\n+                    values.put(NotificationTable.COLUMN_NAME_GROUP_ID, jsonPayload.optString(\"grp\"));\n+                if (jsonPayload.has(\"collapse_key\") && !\"do_not_collapse\".equals(jsonPayload.optString(\"collapse_key\")))\n+                    values.put(NotificationTable.COLUMN_NAME_COLLAPSE_ID, jsonPayload.optString(\"collapse_key\"));\n+\n+                values.put(NotificationTable.COLUMN_NAME_OPENED, opened ? 1 : 0);\n+                if (!opened)\n+                    values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, notifiJob.getAndroidIdWithoutCreate());\n+\n+                if (notifiJob.getTitle() != null)\n+                    values.put(NotificationTable.COLUMN_NAME_TITLE, notifiJob.getTitle().toString());\n+                if (notifiJob.getBody() != null)\n+                    values.put(NotificationTable.COLUMN_NAME_MESSAGE, notifiJob.getBody().toString());\n+\n+                // Set expire_time\n+                long sentTime = jsonPayload.optLong(\"google.sent_time\", SystemClock.currentThreadTimeMillis()) / 1_000L;\n+                int ttl = jsonPayload.optInt(\"google.ttl\", NotificationRestorer.DEFAULT_TTL_IF_NOT_IN_PAYLOAD);\n+                long expireTime = sentTime + ttl;\n+                values.put(NotificationTable.COLUMN_NAME_EXPIRE_TIME, expireTime);\n+\n+                values.put(NotificationTable.COLUMN_NAME_FULL_DATA, jsonPayload.toString());\n+\n+                writableDb.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n+\n+                if (!opened)\n+                    BadgeCountUpdater.update(writableDb, context);\n+                writableDb.setTransactionSuccessful();\n+            } catch (Exception e) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n+            } finally {\n+                if (writableDb != null) {\n+                    try {\n+                        writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                    } catch (Throwable t) {\n+                        OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                    }\n+                }\n+            }\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n     }\n \n-   private static boolean shouldDisplayNotif(OSNotificationGenerationJob notifJob) {\n-      // Validate that the current Android device is Android 4.4 or higher and the current job is a\n-      //    preview push\n-      if (notifJob.isIamPreview && Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR2)\n-         return false;\n-\n-      // Otherwise, this is a normal notification and should be shown\n-      return notifJob.hasExtender() || shouldDisplay(notifJob.jsonPayload.optString(\"alert\"));\n-   }\n-\n-   private static JSONArray bundleAsJsonArray(Bundle bundle) {\n-      JSONArray jsonArray = new JSONArray();\n-      jsonArray.put(bundleAsJSONObject(bundle));\n-      return jsonArray;\n-   }\n-\n-   private static OSNotificationGenerationJob saveAndProcessNotification(Context context, Bundle bundle, boolean opened, int notificationId) {\n-      OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n-      notifJob.jsonPayload = bundleAsJSONObject(bundle);\n-      notifJob.overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      notifJob.overrideSettings.androidNotificationId = notificationId;\n-\n-      processNotification(notifJob, opened);\n-\n-      return notifJob;\n-   }\n-\n-   /**\n-    * Save notification, updates Outcomes, and sends Received Receipt if they are enabled.\n-    */\n-   static void processNotification(OSNotificationGenerationJob notifJob, boolean opened) {\n-      saveNotification(notifJob, opened);\n-\n-      if (!notifJob.isNotificationToDisplay())\n-         return;\n-\n-      String notificationId = notifJob.getApiNotificationId();\n-      OneSignal.getSessionManager().onNotificationReceived(notificationId);\n-      OSReceiveReceiptController.getInstance().sendReceiveReceipt(notificationId);\n-   }\n-\n-   // Saving the notification provides the following:\n-   //   * Prevent duplicates\n-   //   * Build summary notifications\n-   //   * Collapse key / id support - Used to lookup the android notification id later\n-   //   * Redisplay notifications after reboot, upgrade of app, or cold boot after a force kill.\n-   //   * Future - Public API to get a list of notifications\n-   private static void saveNotification(OSNotificationGenerationJob notifiJob, boolean opened) {\n-      Context context = notifiJob.context;\n-      JSONObject jsonPayload = notifiJob.jsonPayload;\n-      \n-      try {\n-         JSONObject customJSON = getCustomJSONObject(notifiJob.jsonPayload);\n-   \n-         OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n-         SQLiteDatabase writableDb = null;\n-\n-         try {\n+    static void markRestoredNotificationAsDismissed(OSNotificationGenerationJob notifiJob) {\n+        if (notifiJob.getAndroidIdWithoutCreate() == -1)\n+            return;\n+\n+        String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+\n+        OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n+        SQLiteDatabase writableDb = null;\n+\n+        try {\n             writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n-   \n             writableDb.beginTransaction();\n-            \n-            // Count any notifications with duplicated android notification ids as dismissed.\n-            // -1 is used to note never displayed\n-            if (notifiJob.isNotificationToDisplay()) {\n-               String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n-   \n-               ContentValues values = new ContentValues();\n-               values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n-   \n-               writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n-               BadgeCountUpdater.update(writableDb, context);\n-            }\n \n-            // Save just received notification to DB\n             ContentValues values = new ContentValues();\n-            values.put(NotificationTable.COLUMN_NAME_NOTIFICATION_ID, customJSON.optString(\"i\"));\n-            if (jsonPayload.has(\"grp\"))\n-               values.put(NotificationTable.COLUMN_NAME_GROUP_ID, jsonPayload.optString(\"grp\"));\n-            if (jsonPayload.has(\"collapse_key\") && !\"do_not_collapse\".equals(jsonPayload.optString(\"collapse_key\")))\n-               values.put(NotificationTable.COLUMN_NAME_COLLAPSE_ID, jsonPayload.optString(\"collapse_key\"));\n-\n-            values.put(NotificationTable.COLUMN_NAME_OPENED, opened ? 1 : 0);\n-            if (!opened)\n-               values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, notifiJob.getAndroidIdWithoutCreate());\n-            \n-            if (notifiJob.getTitle() != null)\n-               values.put(NotificationTable.COLUMN_NAME_TITLE, notifiJob.getTitle().toString());\n-            if (notifiJob.getBody() != null)\n-               values.put(NotificationTable.COLUMN_NAME_MESSAGE, notifiJob.getBody().toString());\n-\n-            // Set expire_time\n-            long sentTime = jsonPayload.optLong(\"google.sent_time\", SystemClock.currentThreadTimeMillis()) / 1_000L;\n-            int ttl = jsonPayload.optInt(\"google.ttl\", NotificationRestorer.DEFAULT_TTL_IF_NOT_IN_PAYLOAD);\n-            long expireTime = sentTime + ttl;\n-            values.put(NotificationTable.COLUMN_NAME_EXPIRE_TIME, expireTime);\n-\n-            values.put(NotificationTable.COLUMN_NAME_FULL_DATA, jsonPayload.toString());\n-\n-            writableDb.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n-\n-            if (!opened)\n-               BadgeCountUpdater.update(writableDb, context);\n+            values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+\n+            writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n+            BadgeCountUpdater.update(writableDb, notifiJob.context);\n+\n             writableDb.setTransactionSuccessful();\n-         } catch (Exception e) {\n+\n+        } catch (Exception e) {\n             OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n-         } finally {\n+        } finally {\n             if (writableDb != null) {\n-               try {\n-                  writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n-               } catch (Throwable t) {\n-                  OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n-               }\n+                try {\n+                    writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                } catch (Throwable t) {\n+                    OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                }\n+            }\n+        }\n+    }\n+\n+    static @NonNull\n+    JSONObject bundleAsJSONObject(Bundle bundle) {\n+        JSONObject json = new JSONObject();\n+        Set<String> keys = bundle.keySet();\n+\n+        for (String key : keys) {\n+            try {\n+                json.put(key, bundle.get(key));\n+            } catch (JSONException e) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"bundleAsJSONObject error for key: \" + key, e);\n             }\n-         }\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-   }\n+        }\n \n-   static void markRestoredNotificationAsDismissed(OSNotificationGenerationJob notifiJob) {\n-      if (notifiJob.getAndroidIdWithoutCreate() == -1)\n-         return;\n+        return json;\n+    }\n \n-      String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+    // Format our short keys into more readable ones.\n+    private static void maximizeButtonsFromBundle(Bundle fcmBundle) {\n+        if (!fcmBundle.containsKey(\"o\"))\n+            return;\n \n-      OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n-      SQLiteDatabase writableDb = null;\n+        try {\n+            JSONObject customJSON = new JSONObject(fcmBundle.getString(\"custom\"));\n+            JSONObject additionalDataJSON;\n+\n+            if (customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n+                additionalDataJSON = customJSON.getJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n+            else\n+                additionalDataJSON = new JSONObject();\n+\n+            JSONArray buttons = new JSONArray(fcmBundle.getString(PUSH_MINIFIED_BUTTONS_LIST));\n+            fcmBundle.remove(PUSH_MINIFIED_BUTTONS_LIST);\n+            for (int i = 0; i < buttons.length(); i++) {\n+                JSONObject button = buttons.getJSONObject(i);\n+\n+                String buttonText = button.getString(PUSH_MINIFIED_BUTTON_TEXT);\n+                button.remove(PUSH_MINIFIED_BUTTON_TEXT);\n+\n+                String buttonId;\n+                if (button.has(PUSH_MINIFIED_BUTTON_ID)) {\n+                    buttonId = button.getString(PUSH_MINIFIED_BUTTON_ID);\n+                    button.remove(PUSH_MINIFIED_BUTTON_ID);\n+                } else\n+                    buttonId = buttonText;\n+\n+                button.put(\"id\", buttonId);\n+                button.put(\"text\", buttonText);\n+\n+                if (button.has(PUSH_MINIFIED_BUTTON_ICON)) {\n+                    button.put(\"icon\", button.getString(PUSH_MINIFIED_BUTTON_ICON));\n+                    button.remove(PUSH_MINIFIED_BUTTON_ICON);\n+                }\n+            }\n \n-      try {\n-         writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n-         writableDb.beginTransaction();\n+            additionalDataJSON.put(\"actionButtons\", buttons);\n+            additionalDataJSON.put(BUNDLE_KEY_ACTION_ID, DEFAULT_ACTION);\n+            if (!customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n+                customJSON.put(PUSH_ADDITIONAL_DATA_KEY, additionalDataJSON);\n \n-         ContentValues values = new ContentValues();\n-         values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+            fcmBundle.putString(\"custom\", customJSON.toString());\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n \n-         writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n-         BadgeCountUpdater.update(writableDb, notifiJob.context);\n+    static OSNotificationPayload OSNotificationPayloadFrom(JSONObject currentJsonPayload) {\n+        OSNotificationPayload notification = new OSNotificationPayload();\n+        try {\n+            JSONObject customJson = getCustomJSONObject(currentJsonPayload);\n+            notification.notificationID = customJson.optString(\"i\");\n+            notification.templateId = customJson.optString(\"ti\");\n+            notification.templateName = customJson.optString(\"tn\");\n+            notification.rawPayload = currentJsonPayload.toString();\n+            notification.additionalData = customJson.optJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n+            notification.launchURL = customJson.optString(\"u\", null);\n+\n+            notification.body = currentJsonPayload.optString(\"alert\", null);\n+            notification.title = currentJsonPayload.optString(\"title\", null);\n+            notification.smallIcon = currentJsonPayload.optString(\"sicon\", null);\n+            notification.bigPicture = currentJsonPayload.optString(\"bicon\", null);\n+            notification.largeIcon = currentJsonPayload.optString(\"licon\", null);\n+            notification.sound = currentJsonPayload.optString(\"sound\", null);\n+            notification.groupKey = currentJsonPayload.optString(\"grp\", null);\n+            notification.groupMessage = currentJsonPayload.optString(\"grp_msg\", null);\n+            notification.smallIconAccentColor = currentJsonPayload.optString(\"bgac\", null);\n+            notification.ledColor = currentJsonPayload.optString(\"ledc\", null);\n+            String visibility = currentJsonPayload.optString(\"vis\", null);\n+            if (visibility != null)\n+                notification.lockScreenVisibility = Integer.parseInt(visibility);\n+            notification.fromProjectNumber = currentJsonPayload.optString(\"from\", null);\n+            notification.priority = currentJsonPayload.optInt(\"pri\", 0);\n+            String collapseKey = currentJsonPayload.optString(\"collapse_key\", null);\n+            if (!\"do_not_collapse\".equals(collapseKey))\n+                notification.collapseId = collapseKey;\n \n-         writableDb.setTransactionSuccessful();\n+            try {\n+                setActionButtons(notification);\n+            } catch (Throwable t) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload.actionButtons values!\", t);\n+            }\n \n-      } catch (Exception e) {\n-         OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n-      } finally {\n-         if (writableDb != null) {\n             try {\n-               writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                setBackgroundImageLayout(notification, currentJsonPayload);\n             } catch (Throwable t) {\n-               OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload.backgroundImageLayout values!\", t);\n             }\n-         }\n-      }\n-   }\n-\n-   static @NonNull JSONObject bundleAsJSONObject(Bundle bundle) {\n-      JSONObject json = new JSONObject();\n-      Set<String> keys = bundle.keySet();\n-\n-      for (String key : keys) {\n-         try {\n-            json.put(key, bundle.get(key));\n-         } catch (JSONException e) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"bundleAsJSONObject error for key: \" + key, e);\n-         }\n-      }\n-\n-      return json;\n-   }\n-\n-   // Format our short keys into more readable ones.\n-   private static void maximizeButtonsFromBundle(Bundle fcmBundle) {\n-      if (!fcmBundle.containsKey(\"o\"))\n-         return;\n-      \n-      try {\n-         JSONObject customJSON = new JSONObject(fcmBundle.getString(\"custom\"));\n-         JSONObject additionalDataJSON;\n-\n-         if (customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n-            additionalDataJSON = customJSON.getJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n-         else\n-            additionalDataJSON = new JSONObject();\n-\n-         JSONArray buttons = new JSONArray(fcmBundle.getString(PUSH_MINIFIED_BUTTONS_LIST));\n-         fcmBundle.remove(PUSH_MINIFIED_BUTTONS_LIST);\n-         for (int i = 0; i < buttons.length(); i++) {\n-            JSONObject button = buttons.getJSONObject(i);\n-\n-            String buttonText = button.getString(PUSH_MINIFIED_BUTTON_TEXT);\n-            button.remove(PUSH_MINIFIED_BUTTON_TEXT);\n-\n-            String buttonId;\n-            if (button.has(PUSH_MINIFIED_BUTTON_ID)) {\n-               buttonId = button.getString(PUSH_MINIFIED_BUTTON_ID);\n-               button.remove(PUSH_MINIFIED_BUTTON_ID);\n-            } else\n-               buttonId = buttonText;\n-\n-            button.put(\"id\", buttonId);\n-            button.put(\"text\", buttonText);\n-\n-            if (button.has(PUSH_MINIFIED_BUTTON_ICON)) {\n-               button.put(\"icon\", button.getString(PUSH_MINIFIED_BUTTON_ICON));\n-               button.remove(PUSH_MINIFIED_BUTTON_ICON);\n+        } catch (Throwable t) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload values!\", t);\n+        }\n+\n+        return notification;\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2MDgwMw=="}, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 595}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTEwMjY3OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationWorkManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTowMTozNlrOG08SRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTozMzo0MVrOG-T19w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2Njg1Mg==", "bodyText": "Can it happend that for the same notification we call more than once this method?", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r458166852", "createdAt": "2020-07-21T15:01:36Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationWorkManager.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.onesignal;\n+\n+import android.content.Context;\n+\n+import androidx.annotation.NonNull;\n+import androidx.work.Data;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.WorkManager;\n+import androidx.work.Worker;\n+import androidx.work.WorkerParameters;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSNotificationWorkManager {\n+\n+    private static final String ANDROID_NOTIF_ID_WORKER_DATA_PARAM = \"android_notif_id\";\n+    private static final String JSON_PAYLOAD_WORKER_DATA_PARAM = \"json_payload\";\n+    private static final String TIMESTAMP_WORKER_DATA_PARAM = \"timestamp\";\n+    private static final String IS_RESTORING_WORKER_DATA_PARAM = \"is_restoring\";\n+\n+    static void beginEnqueueingWork(Context context, int androidNotificationId, String jsonPayload, boolean isRestoring, long timestamp, boolean isHighPriority) {\n+        // TODO: Do we need isHighPriority only more?\n+\n+        Data inputData = new Data.Builder()\n+                .putInt(ANDROID_NOTIF_ID_WORKER_DATA_PARAM, androidNotificationId)\n+                .putString(JSON_PAYLOAD_WORKER_DATA_PARAM, jsonPayload)\n+                .putLong(TIMESTAMP_WORKER_DATA_PARAM, timestamp)\n+                .putBoolean(IS_RESTORING_WORKER_DATA_PARAM, isRestoring)\n+                .build();\n+\n+        OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(NotificationWorker.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NzY3NQ==", "bodyText": "Not sure but its a good point so a good idea would be to use the OS id as a tag for the job and make sure a job does not exist with that id name already. Otherwise im pretty sure we check for notifications being duplicate before this line of code", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465867675", "createdAt": "2020-08-05T16:53:29Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationWorkManager.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.onesignal;\n+\n+import android.content.Context;\n+\n+import androidx.annotation.NonNull;\n+import androidx.work.Data;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.WorkManager;\n+import androidx.work.Worker;\n+import androidx.work.WorkerParameters;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSNotificationWorkManager {\n+\n+    private static final String ANDROID_NOTIF_ID_WORKER_DATA_PARAM = \"android_notif_id\";\n+    private static final String JSON_PAYLOAD_WORKER_DATA_PARAM = \"json_payload\";\n+    private static final String TIMESTAMP_WORKER_DATA_PARAM = \"timestamp\";\n+    private static final String IS_RESTORING_WORKER_DATA_PARAM = \"is_restoring\";\n+\n+    static void beginEnqueueingWork(Context context, int androidNotificationId, String jsonPayload, boolean isRestoring, long timestamp, boolean isHighPriority) {\n+        // TODO: Do we need isHighPriority only more?\n+\n+        Data inputData = new Data.Builder()\n+                .putInt(ANDROID_NOTIF_ID_WORKER_DATA_PARAM, androidNotificationId)\n+                .putString(JSON_PAYLOAD_WORKER_DATA_PARAM, jsonPayload)\n+                .putLong(TIMESTAMP_WORKER_DATA_PARAM, timestamp)\n+                .putBoolean(IS_RESTORING_WORKER_DATA_PARAM, isRestoring)\n+                .build();\n+\n+        OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(NotificationWorker.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2Njg1Mg=="}, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk5MDAwNw==", "bodyText": "Here is my solution to what you are brining up, but maybe we want to change this or modify... Just an idea for now though...\nWorkManager.getInstance(context)\n    .enqueueUniqueWork(osNotificationId, ExistingWorkPolicy.KEEP, workRequest);\nWhat does ExistingWorkPolicy.KEEP do?\nWell... If there is existing pending (uncompleted) work with the same unique name (in this case, OneSignal notification id), do nothing. Otherwise, insert the newly-specified work.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467990007", "createdAt": "2020-08-10T15:33:41Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationWorkManager.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.onesignal;\n+\n+import android.content.Context;\n+\n+import androidx.annotation.NonNull;\n+import androidx.work.Data;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.WorkManager;\n+import androidx.work.Worker;\n+import androidx.work.WorkerParameters;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSNotificationWorkManager {\n+\n+    private static final String ANDROID_NOTIF_ID_WORKER_DATA_PARAM = \"android_notif_id\";\n+    private static final String JSON_PAYLOAD_WORKER_DATA_PARAM = \"json_payload\";\n+    private static final String TIMESTAMP_WORKER_DATA_PARAM = \"timestamp\";\n+    private static final String IS_RESTORING_WORKER_DATA_PARAM = \"is_restoring\";\n+\n+    static void beginEnqueueingWork(Context context, int androidNotificationId, String jsonPayload, boolean isRestoring, long timestamp, boolean isHighPriority) {\n+        // TODO: Do we need isHighPriority only more?\n+\n+        Data inputData = new Data.Builder()\n+                .putInt(ANDROID_NOTIF_ID_WORKER_DATA_PARAM, androidNotificationId)\n+                .putString(JSON_PAYLOAD_WORKER_DATA_PARAM, jsonPayload)\n+                .putLong(TIMESTAMP_WORKER_DATA_PARAM, timestamp)\n+                .putBoolean(IS_RESTORING_WORKER_DATA_PARAM, isRestoring)\n+                .build();\n+\n+        OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(NotificationWorker.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2Njg1Mg=="}, "originalCommit": {"oid": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDE3NzYzOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo1MzoyNlrOG8WaMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTowNTozMFrOG-SlUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA==", "bodyText": "Here we are creating a new thread, start it, and join right away. This is going to lock as if we don't have a thread at all.\nIs this always running off the main thread now with the new follow?\nWhat depends on this we need to wait for?", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465934898", "createdAt": "2020-08-05T18:53:26Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0Njg1Mw==", "bodyText": "Would easier to explain over a call if you have time.\nBasically the join method will await the current thread until the new thread is done with its work. It does not immediately join actually.\nThese docs explain it well as well as the diagram below", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465946853", "createdAt": "2020-08-05T19:15:33Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0OTQ3NQ==", "bodyText": "But where is the 2nd thread we are kicking off and where are we joining it?\nStill looking through the PR so that may uncover this question.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465949475", "createdAt": "2020-08-05T19:20:31Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NDA4Mg==", "bodyText": "Ahh I understand, so there are two places we call GenerateNotification.fromJsonPayload and both routes come from this method NotificationBundleProcessor.processJobForDisplay\nOne is at this line (don't fire or has no foreground handlers)\n\n  \n    \n      OneSignal-Android-SDK/OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java\n    \n    \n         Line 127\n      in\n      76b94f5\n    \n    \n    \n    \n\n        \n          \n           GenerateNotification.fromJsonPayload(notifJob); \n        \n    \n  \n\n\nOther is at this line (should fire and has foreground handlers)\n\n  \n    \n      OneSignal-Android-SDK/OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java\n    \n    \n         Line 301\n      in\n      76b94f5\n    \n    \n    \n    \n\n        \n          \n           GenerateNotification.fromJsonPayload(getNotifJob()); \n        \n    \n  \n\n\nThe purpose is so we wait until the showNotification method inside of the new thread is done. Then we can start the next part of the NotificationBundleProcessor.processJobForDisplay and return the android notification id", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465954082", "createdAt": "2020-08-05T19:29:39Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MTIwMA==", "bodyText": "Also that diagram is only showing you how the Thread.join method works, we only kick off Thread 1 technically and its only for the showNotification method", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465961200", "createdAt": "2020-08-05T19:43:37Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2NjYxOA==", "bodyText": "Update based on our discussion.\nAdding the thread here prevents throwing an exception of downloading on the main thread, however this can create an ANR if downloading takes 5+ sec", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465966618", "createdAt": "2020-08-05T19:54:13Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2OTM2Mw==", "bodyText": "Another update is we are not calling showNotification from Main Thread and therefore the new Thread is not necessary. Good talk though and after meeting with Josh to discuss this further we decided we should add a RuntimeException check right before the showNotification method PR for Main Thread RuntimeException check", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467969363", "createdAt": "2020-08-10T15:05:30Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ4ODQzOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyODo1OFrOG8ZdcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzowODoyN1rOG9hcEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDg4MA==", "bodyText": "exi should be exists", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465984880", "createdAt": "2020-08-05T20:28:58Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1OTcwOQ==", "bodyText": "Good catch!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467159709", "createdAt": "2020-08-07T16:59:32Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDg4MA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NDE3OQ==", "bodyText": "Fixed!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467164179", "createdAt": "2020-08-07T17:08:27Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDg4MA=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 460}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ4ODk2OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyOToxMFrOG8Zdzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzowODozMlrOG9hcOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDk3NQ==", "bodyText": "Remove blank comment", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465984975", "createdAt": "2020-08-05T20:29:10Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi\n+            //    or bubbling is set false\n+            if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n+                GenerateNotification.fromJsonPayload(getNotifJob());\n+                return;\n+            }\n+\n+            // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n+            //    the notificationWillShowInForeground implementation\n+            OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n+                    getNotifJob().toAppNotificationGenerationJob());\n+        }\n+    }\n \n    /**\n     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.AppNotificationWillShowInForegroundHandler}\n     *    without exposing internals publicly\n     */\n    public static class AppNotificationGenerationJob extends NotificationGenerationJob {\n \n-      AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n+        AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n \n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               AppNotificationGenerationJob.this.complete();\n-            }\n-         });\n-      }\n \n-      // Method controlling completion from the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and complete by default\n-      public synchronized void complete() {\n-         destroyTimeout();\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    AppNotificationGenerationJob.this.complete();\n+                }\n+            });\n+        }\n \n-         if (isComplete)\n-            return;\n+        /**\n+         * Method controlling completion from the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and complete by default\n+         */\n+        public synchronized void complete() {\n+            destroyTimeout();\n \n-         isComplete = true;\n+            if (isComplete)\n+                return;\n \n-         GenerateNotification.fromJsonPayload(getNotifJob());\n-      }\n-   }\n+            isComplete = true;\n+\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1OTY0MA==", "bodyText": "Good catch!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467159640", "createdAt": "2020-08-07T16:59:24Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi\n+            //    or bubbling is set false\n+            if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n+                GenerateNotification.fromJsonPayload(getNotifJob());\n+                return;\n+            }\n+\n+            // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n+            //    the notificationWillShowInForeground implementation\n+            OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n+                    getNotifJob().toAppNotificationGenerationJob());\n+        }\n+    }\n \n    /**\n     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.AppNotificationWillShowInForegroundHandler}\n     *    without exposing internals publicly\n     */\n    public static class AppNotificationGenerationJob extends NotificationGenerationJob {\n \n-      AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n+        AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n \n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               AppNotificationGenerationJob.this.complete();\n-            }\n-         });\n-      }\n \n-      // Method controlling completion from the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and complete by default\n-      public synchronized void complete() {\n-         destroyTimeout();\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    AppNotificationGenerationJob.this.complete();\n+                }\n+            });\n+        }\n \n-         if (isComplete)\n-            return;\n+        /**\n+         * Method controlling completion from the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and complete by default\n+         */\n+        public synchronized void complete() {\n+            destroyTimeout();\n \n-         isComplete = true;\n+            if (isComplete)\n+                return;\n \n-         GenerateNotification.fromJsonPayload(getNotifJob());\n-      }\n-   }\n+            isComplete = true;\n+\n+            //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDk3NQ=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NDIxOQ==", "bodyText": "Fixed!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467164219", "createdAt": "2020-08-07T17:08:32Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi\n+            //    or bubbling is set false\n+            if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n+                GenerateNotification.fromJsonPayload(getNotifJob());\n+                return;\n+            }\n+\n+            // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n+            //    the notificationWillShowInForeground implementation\n+            OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n+                    getNotifJob().toAppNotificationGenerationJob());\n+        }\n+    }\n \n    /**\n     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.AppNotificationWillShowInForegroundHandler}\n     *    without exposing internals publicly\n     */\n    public static class AppNotificationGenerationJob extends NotificationGenerationJob {\n \n-      AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n+        AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n \n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               AppNotificationGenerationJob.this.complete();\n-            }\n-         });\n-      }\n \n-      // Method controlling completion from the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and complete by default\n-      public synchronized void complete() {\n-         destroyTimeout();\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    AppNotificationGenerationJob.this.complete();\n+                }\n+            });\n+        }\n \n-         if (isComplete)\n-            return;\n+        /**\n+         * Method controlling completion from the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and complete by default\n+         */\n+        public synchronized void complete() {\n+            destroyTimeout();\n \n-         isComplete = true;\n+            if (isComplete)\n+                return;\n \n-         GenerateNotification.fromJsonPayload(getNotifJob());\n-      }\n-   }\n+            isComplete = true;\n+\n+            //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDk3NQ=="}, "originalCommit": {"oid": "76b94f52ea4aabba6b580710dc35a692042780ea"}, "originalPosition": 525}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTAzOTQwOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDozMToyOFrOG-ev9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDozMToyOFrOG-ev9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2ODY5NA==", "bodyText": "We do this so app devs can run their UI update code without having to worry about getting themselves on the main thread.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r468168694", "createdAt": "2020-08-10T20:31:28Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -2117,6 +2129,10 @@ private static OSNotificationOpenResult generateOsNotificationOpenResult(JSONArr\n    }\n \n    private static void fireNotificationOpenedHandler(final OSNotificationOpenResult openedResult) {\n+      // TODO: Is there a reason we need the opened handler to be fired from main thread?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd5ad130abb51d983583a4a822083114cfa66c6e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTA0NDczOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDozMzoxNFrOG-ezWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDozMzoxNFrOG-ezWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2OTU2MA==", "bodyText": "All the default behavior is done on a different thread before this call.\nThe reason we did a catch was so a notification would still be displayed, even though the app is going to crash from an uncaught exception.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r468169560", "createdAt": "2020-08-10T20:33:14Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -2117,6 +2129,10 @@ private static OSNotificationOpenResult generateOsNotificationOpenResult(JSONArr\n    }\n \n    private static void fireNotificationOpenedHandler(final OSNotificationOpenResult openedResult) {\n+      // TODO: Is there a reason we need the opened handler to be fired from main thread?\n+\n+      // TODO: Once the NotificationOpenedHandler gets a Worker, we should make sure we add a catch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd5ad130abb51d983583a4a822083114cfa66c6e"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2318, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}