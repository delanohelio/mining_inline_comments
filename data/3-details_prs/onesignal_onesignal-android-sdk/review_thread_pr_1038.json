{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MjczODIx", "number": 1038, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0MDoxNVrOERLAgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo1NzozM1rOEV9BfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDQxNjAxOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0MDoxNVrOG1vZiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0MDoxNVrOG1vZiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNDI5Nw==", "bodyText": "This should go in the root build.gradle.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459004297", "createdAt": "2020-07-22T18:40:15Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -66,6 +68,11 @@ dependencies {\n \n     // compileOnly as this is just for fallback code if AppCompatActivity wasn't added to the project.\n     compileOnly 'com.android.support:appcompat-v7:26.1.0'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n }\n \n apply from: 'maven-push.gradle'\n+repositories {\n+    mavenCentral()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDU2MzUzOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyMjowNVrOG1w2zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo1OToyMVrOG4ioUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODE3NQ==", "bodyText": "This code has a lot of nesting, probably ok as an upper limit. Ideally I would like to set this as an early return instead of a large amount of code nested under this let block. Or moved into another method.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459028175", "createdAt": "2020-07-22T19:22:05Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAxMjI4NA==", "bodyText": "made an auxiliary currentInfluenceType to avoid null check", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461012284", "createdAt": "2020-07-27T16:23:43Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODE3NQ=="}, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MDgxNw==", "bodyText": "\ud83d\udc4d val currentInfluenceType = influenceType ?: OSInfluenceType.DISABLED", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461940817", "createdAt": "2020-07-28T22:59:21Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODE3NQ=="}, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDU2ODY2OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyMzo0M1rOG1w6BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyMzo0M1rOG1w6BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODk5Ng==", "bodyText": "Remove this., to be more consistent with the code above.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459028996", "createdAt": "2020-07-22T19:23:43Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {\n+                if (it.isDirect()) {\n+                    if (isDirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = JSONArray().put(this@OSChannelTracker.directId)\n+                            influenceType = OSInfluenceType.DIRECT\n+                        }\n+                    }\n+                } else if (it.isIndirect()) {\n+                    if (isIndirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = this@OSChannelTracker.indirectIds\n+                            influenceType = OSInfluenceType.INDIRECT\n+                        }\n+                    }\n+                } else if (isUnattributedSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        this.influenceType = OSInfluenceType.UNATTRIBUTED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDU4NTI4OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyODo0MlrOG1xEQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzowMTozNVrOG4irgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTYxNg==", "bodyText": "Might be better to use just object so there isn't a companion object under the hood.\nhttps://stackoverflow.com/a/50520935\n@Jeasmine Thoughts on this?", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459031616", "createdAt": "2020-07-22T19:28:42Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {\n+                if (it.isDirect()) {\n+                    if (isDirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = JSONArray().put(this@OSChannelTracker.directId)\n+                            influenceType = OSInfluenceType.DIRECT\n+                        }\n+                    }\n+                } else if (it.isIndirect()) {\n+                    if (isIndirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = this@OSChannelTracker.indirectIds\n+                            influenceType = OSInfluenceType.INDIRECT\n+                        }\n+                    }\n+                } else if (isUnattributedSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        this.influenceType = OSInfluenceType.UNATTRIBUTED\n+                    }\n+                }\n+            }\n+            return sessionInfluence\n+        }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *\n+     * @return ids that happen between attribution window\n+     */\n+    val lastReceivedIds: JSONArray\n+        get() {\n+            val ids = JSONArray()\n+            try {\n+                val lastChannelObjectReceived = lastChannelObjects\n+                logger.debug(\"OneSignal ChannelTracker getLastReceivedIds lastChannelObjectReceived: $lastChannelObjectReceived\")\n+                val attributionWindow = indirectAttributionWindow * 60 * 1000L\n+                val currentTime = OneSignal.getTime().currentTimeMillis\n+                for (i in 0 until lastChannelObjectReceived.length()) {\n+                    val jsonObject = lastChannelObjectReceived.getJSONObject(i)\n+                    val time = jsonObject.getLong(TIME)\n+                    val difference = currentTime - time\n+                    if (difference <= attributionWindow) {\n+                        val id = jsonObject.getString(idTag)\n+                        ids.put(id)\n+                    }\n+                }\n+            } catch (exception: JSONException) {\n+                logger.error(\"Generating tracker getLastReceivedIds JSONObject \", exception)\n+            }\n+            return ids\n+        }\n+\n+    fun resetAndInitInfluence() {\n+        directId = null\n+        indirectIds = lastReceivedIds\n+        influenceType = if (indirectIds?.length() ?: 0 > 0) OSInfluenceType.INDIRECT else OSInfluenceType.UNATTRIBUTED\n+        cacheState()\n+        logger.debug(\"OneSignal OSChannelTracker resetAndInitInfluence: $idTag finish with influenceType: $influenceType\")\n+    }\n+\n+    /**\n+     * Save state of last ids received\n+     */\n+    fun saveLastId(id: String?) {\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId: $id\")\n+        if (id == null || id.isEmpty()) return\n+        val lastChannelObjectsReceived = getLastChannelObjectsReceivedByNewId(id)\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId with lastChannelObjectsReceived: $lastChannelObjectsReceived\")\n+        try {\n+            val newInfluenceId = JSONObject()\n+                    .put(idTag, id)\n+                    .put(TIME, OneSignal.getTime().currentTimeMillis)\n+            lastChannelObjectsReceived.put(newInfluenceId)\n+        } catch (exception: JSONException) {\n+            logger.error(\"Generating tracker newInfluenceId JSONObject \", exception)\n+            // We don't have new data, stop logic\n+            return\n+        }\n+        val channelLimit = channelLimit\n+        var channelObjectToSave = lastChannelObjectsReceived\n+        // Only save the last ids without surpassing the limit\n+        // Always keep the max quantity of ids possible\n+        // If the attribution window increases, old ids might influence\n+        if (lastChannelObjectsReceived.length() > channelLimit) {\n+            val lengthDifference = lastChannelObjectsReceived.length() - channelLimit\n+            // If min sdk is greater than KITKAT we can refactor this logic to removeObject from JSONArray\n+            channelObjectToSave = JSONArray()\n+            for (i in lengthDifference until lastChannelObjectsReceived.length()) {\n+                try {\n+                    channelObjectToSave.put(lastChannelObjectsReceived[i])\n+                } catch (exception: JSONException) {\n+                    logger.error(\"Generating tracker lastChannelObjectsReceived get JSONObject \", exception)\n+                }\n+            }\n+        }\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag with channelObjectToSave: $channelObjectToSave\")\n+        saveChannelObjects(channelObjectToSave)\n+    }\n+\n+    override fun toString(): String {\n+        return \"OSChannelTracker{\" +\n+                \"tag=\" + idTag +\n+                \", influenceType=\" + influenceType +\n+                \", indirectIds=\" + indirectIds +\n+                \", directId=\" + directId +\n+                '}'\n+    }\n+\n+    override fun equals(other: Any?): Boolean {\n+        if (this === other) return true\n+        if (other == null || javaClass != other.javaClass) return false\n+        val tracker = other as OSChannelTracker\n+        return influenceType === tracker.influenceType && tracker.idTag == idTag\n+    }\n+\n+    override fun hashCode(): Int {\n+        var result = influenceType.hashCode()\n+        result = 31 * result + idTag.hashCode()\n+        return result\n+    }\n+\n+    companion object {\n+        private const val TIME = \"time\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNjMzMQ==", "bodyText": "Thanks for this comment! I was looking to de decompiled java code for companion object and object inside a class, for both cases constants object are inlined where used, but a static class is defined and not used, so I checked that the best way is to have a single object file, in that way we don't have companion/object in the classes. Also, companion is a special case of an object. We should only use a companion for static initialization or method access. For reference https://blog.egorand.me/where-do-i-put-my-constants-in-kotlin/", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461116331", "createdAt": "2020-07-27T19:24:29Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {\n+                if (it.isDirect()) {\n+                    if (isDirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = JSONArray().put(this@OSChannelTracker.directId)\n+                            influenceType = OSInfluenceType.DIRECT\n+                        }\n+                    }\n+                } else if (it.isIndirect()) {\n+                    if (isIndirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = this@OSChannelTracker.indirectIds\n+                            influenceType = OSInfluenceType.INDIRECT\n+                        }\n+                    }\n+                } else if (isUnattributedSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        this.influenceType = OSInfluenceType.UNATTRIBUTED\n+                    }\n+                }\n+            }\n+            return sessionInfluence\n+        }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *\n+     * @return ids that happen between attribution window\n+     */\n+    val lastReceivedIds: JSONArray\n+        get() {\n+            val ids = JSONArray()\n+            try {\n+                val lastChannelObjectReceived = lastChannelObjects\n+                logger.debug(\"OneSignal ChannelTracker getLastReceivedIds lastChannelObjectReceived: $lastChannelObjectReceived\")\n+                val attributionWindow = indirectAttributionWindow * 60 * 1000L\n+                val currentTime = OneSignal.getTime().currentTimeMillis\n+                for (i in 0 until lastChannelObjectReceived.length()) {\n+                    val jsonObject = lastChannelObjectReceived.getJSONObject(i)\n+                    val time = jsonObject.getLong(TIME)\n+                    val difference = currentTime - time\n+                    if (difference <= attributionWindow) {\n+                        val id = jsonObject.getString(idTag)\n+                        ids.put(id)\n+                    }\n+                }\n+            } catch (exception: JSONException) {\n+                logger.error(\"Generating tracker getLastReceivedIds JSONObject \", exception)\n+            }\n+            return ids\n+        }\n+\n+    fun resetAndInitInfluence() {\n+        directId = null\n+        indirectIds = lastReceivedIds\n+        influenceType = if (indirectIds?.length() ?: 0 > 0) OSInfluenceType.INDIRECT else OSInfluenceType.UNATTRIBUTED\n+        cacheState()\n+        logger.debug(\"OneSignal OSChannelTracker resetAndInitInfluence: $idTag finish with influenceType: $influenceType\")\n+    }\n+\n+    /**\n+     * Save state of last ids received\n+     */\n+    fun saveLastId(id: String?) {\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId: $id\")\n+        if (id == null || id.isEmpty()) return\n+        val lastChannelObjectsReceived = getLastChannelObjectsReceivedByNewId(id)\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId with lastChannelObjectsReceived: $lastChannelObjectsReceived\")\n+        try {\n+            val newInfluenceId = JSONObject()\n+                    .put(idTag, id)\n+                    .put(TIME, OneSignal.getTime().currentTimeMillis)\n+            lastChannelObjectsReceived.put(newInfluenceId)\n+        } catch (exception: JSONException) {\n+            logger.error(\"Generating tracker newInfluenceId JSONObject \", exception)\n+            // We don't have new data, stop logic\n+            return\n+        }\n+        val channelLimit = channelLimit\n+        var channelObjectToSave = lastChannelObjectsReceived\n+        // Only save the last ids without surpassing the limit\n+        // Always keep the max quantity of ids possible\n+        // If the attribution window increases, old ids might influence\n+        if (lastChannelObjectsReceived.length() > channelLimit) {\n+            val lengthDifference = lastChannelObjectsReceived.length() - channelLimit\n+            // If min sdk is greater than KITKAT we can refactor this logic to removeObject from JSONArray\n+            channelObjectToSave = JSONArray()\n+            for (i in lengthDifference until lastChannelObjectsReceived.length()) {\n+                try {\n+                    channelObjectToSave.put(lastChannelObjectsReceived[i])\n+                } catch (exception: JSONException) {\n+                    logger.error(\"Generating tracker lastChannelObjectsReceived get JSONObject \", exception)\n+                }\n+            }\n+        }\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag with channelObjectToSave: $channelObjectToSave\")\n+        saveChannelObjects(channelObjectToSave)\n+    }\n+\n+    override fun toString(): String {\n+        return \"OSChannelTracker{\" +\n+                \"tag=\" + idTag +\n+                \", influenceType=\" + influenceType +\n+                \", indirectIds=\" + indirectIds +\n+                \", directId=\" + directId +\n+                '}'\n+    }\n+\n+    override fun equals(other: Any?): Boolean {\n+        if (this === other) return true\n+        if (other == null || javaClass != other.javaClass) return false\n+        val tracker = other as OSChannelTracker\n+        return influenceType === tracker.influenceType && tracker.idTag == idTag\n+    }\n+\n+    override fun hashCode(): Int {\n+        var result = influenceType.hashCode()\n+        result = 31 * result + idTag.hashCode()\n+        return result\n+    }\n+\n+    companion object {\n+        private const val TIME = \"time\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTYxNg=="}, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MTYzNQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461941635", "createdAt": "2020-07-28T23:01:35Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {\n+                if (it.isDirect()) {\n+                    if (isDirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = JSONArray().put(this@OSChannelTracker.directId)\n+                            influenceType = OSInfluenceType.DIRECT\n+                        }\n+                    }\n+                } else if (it.isIndirect()) {\n+                    if (isIndirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = this@OSChannelTracker.indirectIds\n+                            influenceType = OSInfluenceType.INDIRECT\n+                        }\n+                    }\n+                } else if (isUnattributedSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        this.influenceType = OSInfluenceType.UNATTRIBUTED\n+                    }\n+                }\n+            }\n+            return sessionInfluence\n+        }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *\n+     * @return ids that happen between attribution window\n+     */\n+    val lastReceivedIds: JSONArray\n+        get() {\n+            val ids = JSONArray()\n+            try {\n+                val lastChannelObjectReceived = lastChannelObjects\n+                logger.debug(\"OneSignal ChannelTracker getLastReceivedIds lastChannelObjectReceived: $lastChannelObjectReceived\")\n+                val attributionWindow = indirectAttributionWindow * 60 * 1000L\n+                val currentTime = OneSignal.getTime().currentTimeMillis\n+                for (i in 0 until lastChannelObjectReceived.length()) {\n+                    val jsonObject = lastChannelObjectReceived.getJSONObject(i)\n+                    val time = jsonObject.getLong(TIME)\n+                    val difference = currentTime - time\n+                    if (difference <= attributionWindow) {\n+                        val id = jsonObject.getString(idTag)\n+                        ids.put(id)\n+                    }\n+                }\n+            } catch (exception: JSONException) {\n+                logger.error(\"Generating tracker getLastReceivedIds JSONObject \", exception)\n+            }\n+            return ids\n+        }\n+\n+    fun resetAndInitInfluence() {\n+        directId = null\n+        indirectIds = lastReceivedIds\n+        influenceType = if (indirectIds?.length() ?: 0 > 0) OSInfluenceType.INDIRECT else OSInfluenceType.UNATTRIBUTED\n+        cacheState()\n+        logger.debug(\"OneSignal OSChannelTracker resetAndInitInfluence: $idTag finish with influenceType: $influenceType\")\n+    }\n+\n+    /**\n+     * Save state of last ids received\n+     */\n+    fun saveLastId(id: String?) {\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId: $id\")\n+        if (id == null || id.isEmpty()) return\n+        val lastChannelObjectsReceived = getLastChannelObjectsReceivedByNewId(id)\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId with lastChannelObjectsReceived: $lastChannelObjectsReceived\")\n+        try {\n+            val newInfluenceId = JSONObject()\n+                    .put(idTag, id)\n+                    .put(TIME, OneSignal.getTime().currentTimeMillis)\n+            lastChannelObjectsReceived.put(newInfluenceId)\n+        } catch (exception: JSONException) {\n+            logger.error(\"Generating tracker newInfluenceId JSONObject \", exception)\n+            // We don't have new data, stop logic\n+            return\n+        }\n+        val channelLimit = channelLimit\n+        var channelObjectToSave = lastChannelObjectsReceived\n+        // Only save the last ids without surpassing the limit\n+        // Always keep the max quantity of ids possible\n+        // If the attribution window increases, old ids might influence\n+        if (lastChannelObjectsReceived.length() > channelLimit) {\n+            val lengthDifference = lastChannelObjectsReceived.length() - channelLimit\n+            // If min sdk is greater than KITKAT we can refactor this logic to removeObject from JSONArray\n+            channelObjectToSave = JSONArray()\n+            for (i in lengthDifference until lastChannelObjectsReceived.length()) {\n+                try {\n+                    channelObjectToSave.put(lastChannelObjectsReceived[i])\n+                } catch (exception: JSONException) {\n+                    logger.error(\"Generating tracker lastChannelObjectsReceived get JSONObject \", exception)\n+                }\n+            }\n+        }\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag with channelObjectToSave: $channelObjectToSave\")\n+        saveChannelObjects(channelObjectToSave)\n+    }\n+\n+    override fun toString(): String {\n+        return \"OSChannelTracker{\" +\n+                \"tag=\" + idTag +\n+                \", influenceType=\" + influenceType +\n+                \", indirectIds=\" + indirectIds +\n+                \", directId=\" + directId +\n+                '}'\n+    }\n+\n+    override fun equals(other: Any?): Boolean {\n+        if (this === other) return true\n+        if (other == null || javaClass != other.javaClass) return false\n+        val tracker = other as OSChannelTracker\n+        return influenceType === tracker.influenceType && tracker.idTag == idTag\n+    }\n+\n+    override fun hashCode(): Int {\n+        var result = influenceType.hashCode()\n+        result = 31 * result + idTag.hashCode()\n+        return result\n+    }\n+\n+    companion object {\n+        private const val TIME = \"time\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTYxNg=="}, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDU5MDEyOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInAppMessageTracker.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTozMDowNFrOG1xHJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTozMDowNFrOG1xHJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMjM1OQ==", "bodyText": "Same, see my const comment above.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459032359", "createdAt": "2020-07-22T19:30:04Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInAppMessageTracker.kt", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+internal class OSInAppMessageTracker(dataRepository: OSInfluenceDataRepository, logger: OSLogger) : OSChannelTracker(dataRepository, logger) {\n+    override val idTag: String\n+        get() = iamIdTag\n+\n+    override val channelType: OSInfluenceChannel\n+        get() = OSInfluenceChannel.IAM\n+\n+    override fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray {\n+        var lastChannelObjectReceived: JSONArray\n+        lastChannelObjectReceived = try {\n+            lastChannelObjects\n+        } catch (exception: JSONException) {\n+            logger.error(\"Generating IAM tracker getLastChannelObjects JSONObject \", exception)\n+            return JSONArray()\n+        }\n+        // For IAM we handle redisplay, we need to remove duplicates for new influence Id\n+        // If min sdk is greater than KITKAT we can refactor this logic to removeObject from JSONArray\n+        try {\n+            val auxLastChannelObjectReceived = JSONArray()\n+            for (i in 0 until lastChannelObjectReceived.length()) {\n+                val objectId = lastChannelObjectReceived.getJSONObject(i).getString(idTag)\n+                if (id != objectId) {\n+                    auxLastChannelObjectReceived.put(lastChannelObjectReceived.getJSONObject(i))\n+                }\n+            }\n+            lastChannelObjectReceived = auxLastChannelObjectReceived\n+        } catch (exception: JSONException) {\n+            logger.error(\"Before KITKAT API, Generating tracker lastChannelObjectReceived get JSONObject \", exception)\n+        }\n+        return lastChannelObjectReceived\n+    }\n+\n+    @get:Throws(JSONException::class)\n+    override val lastChannelObjects: JSONArray\n+        get() = dataRepository.lastIAMsReceivedData\n+\n+    override val channelLimit: Int\n+        get() = dataRepository.iamLimit\n+\n+    override val indirectAttributionWindow: Int\n+        get() = dataRepository.iamIndirectAttributionWindow\n+\n+    override fun saveChannelObjects(channelObjects: JSONArray) {\n+        dataRepository.saveIAMs(channelObjects)\n+    }\n+\n+    override fun initInfluencedTypeFromCache() {\n+        influenceType = dataRepository.iamCachedInfluenceType.also {\n+            if (it.isIndirect()) indirectIds = lastReceivedIds\n+        }\n+        logger.debug(\"OneSignal InAppMessageTracker initInfluencedTypeFromCache: $this\")\n+    }\n+\n+    override fun addSessionData(jsonObject: JSONObject, influence: OSInfluence) { // In app message don't influence the session\n+    }\n+\n+    override fun cacheState() {\n+        dataRepository.cacheIAMInfluenceType((if (influenceType == null) OSInfluenceType.UNATTRIBUTED else influenceType)!!)\n+    }\n+\n+    companion object {\n+        @JvmField\n+        val TAG = OSInAppMessageTracker::class.java.canonicalName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDU5MjMyOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInfluenceDataRepository.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTozMDo0MlrOG1xIjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTozMDo0MlrOG1xIjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMjcxNg==", "bodyText": "Same, see my const comment above.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459032716", "createdAt": "2020-07-22T19:30:42Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInfluenceDataRepository.kt", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSSharedPreferences\n+import com.onesignal.OneSignalRemoteParams\n+import com.onesignal.OneSignalRemoteParams.InfluenceParams\n+import com.onesignal.influence.model.OSInfluenceType\n+import com.onesignal.influence.model.OSInfluenceType.Companion.fromString\n+import org.json.JSONArray\n+import org.json.JSONException\n+\n+/**\n+ * Setter and Getter of Notifications received\n+ */\n+class OSInfluenceDataRepository(private val preferences: OSSharedPreferences) {\n+\n+    /**\n+     * Cache a influence type enum for Notification as a string\n+     */\n+    fun cacheNotificationInfluenceType(influenceType: OSInfluenceType) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_OUTCOMES_CURRENT_NOTIFICATION_INFLUENCE,\n+                influenceType.toString()\n+        )\n+    }\n+\n+    /**\n+     * Get the current cached influence type string, convert it to the influence type enum, and return it\n+     */\n+    val notificationCachedInfluenceType: OSInfluenceType\n+        get() {\n+            val influenceType = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_OUTCOMES_CURRENT_NOTIFICATION_INFLUENCE,\n+                    OSInfluenceType.UNATTRIBUTED.toString()\n+            )\n+            return fromString(influenceType)\n+        }\n+\n+    /**\n+     * Cache a influence type enum for IAM as a string\n+     */\n+    fun cacheIAMInfluenceType(influenceType: OSInfluenceType) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_OUTCOMES_CURRENT_IAM_INFLUENCE,\n+                influenceType.toString()\n+        )\n+    }\n+\n+    /**\n+     * Get the current cached influence type string, convert it to the influence type enum, and return it\n+     */\n+    val iamCachedInfluenceType: OSInfluenceType\n+        get() {\n+            val influenceType = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_OUTCOMES_CURRENT_IAM_INFLUENCE,\n+                    OSInfluenceType.UNATTRIBUTED.toString()\n+            )\n+            return fromString(influenceType)\n+        }\n+\n+    /**\n+     * Cache attributed notification opened\n+     */\n+    fun cacheNotificationOpenId(id: String?) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_ATTRIBUTED_NOTIFICATION_OPEN,\n+                id\n+        )\n+    }\n+\n+    /**\n+     * Get the current cached notification id, null if not direct\n+     */\n+    val cachedNotificationOpenId: String?\n+        get() = preferences.getString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_ATTRIBUTED_NOTIFICATION_OPEN,\n+                null\n+        )\n+\n+    fun saveNotifications(notifications: JSONArray) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_NOTIFICATIONS_RECEIVED,\n+                notifications.toString())\n+    }\n+\n+    fun saveIAMs(iams: JSONArray) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_IAMS_RECEIVED,\n+                iams.toString())\n+    }\n+\n+    @get:Throws(JSONException::class)\n+    val lastNotificationsReceivedData: JSONArray\n+        get() {\n+            val notificationsReceived = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_LAST_NOTIFICATIONS_RECEIVED,\n+                    \"[]\")\n+            return notificationsReceived?.let { JSONArray(it) } ?: JSONArray()\n+        }\n+\n+    @get:Throws(JSONException::class)\n+    val lastIAMsReceivedData: JSONArray\n+        get() {\n+            val iamReceived = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_LAST_IAMS_RECEIVED,\n+                    \"[]\")\n+            return iamReceived?.let { JSONArray(it) } ?: JSONArray()\n+        }\n+\n+    val notificationLimit: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_LIMIT,\n+                OneSignalRemoteParams.DEFAULT_NOTIFICATION_LIMIT\n+        )\n+\n+    val iamLimit: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_LIMIT,\n+                OneSignalRemoteParams.DEFAULT_NOTIFICATION_LIMIT\n+        )\n+\n+    val notificationIndirectAttributionWindow: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_INDIRECT_ATTRIBUTION_WINDOW,\n+                OneSignalRemoteParams.DEFAULT_INDIRECT_ATTRIBUTION_WINDOW\n+        )\n+\n+    val iamIndirectAttributionWindow: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_INDIRECT_ATTRIBUTION_WINDOW,\n+                OneSignalRemoteParams.DEFAULT_INDIRECT_ATTRIBUTION_WINDOW\n+        )\n+\n+    val isDirectInfluenceEnabled: Boolean\n+        get() = preferences.getBool(\n+                preferences.preferencesName,\n+                PREFS_OS_DIRECT_ENABLED,\n+                false\n+        )\n+\n+    val isIndirectInfluenceEnabled: Boolean\n+        get() = preferences.getBool(\n+                preferences.preferencesName,\n+                PREFS_OS_INDIRECT_ENABLED,\n+                false\n+        )\n+\n+    val isUnattributedInfluenceEnabled: Boolean\n+        get() = preferences.getBool(\n+                preferences.preferencesName,\n+                PREFS_OS_UNATTRIBUTED_ENABLED,\n+                false\n+        )\n+\n+    fun saveInfluenceParams(influenceParams: InfluenceParams) {\n+        preferences.saveBool(\n+                preferences.preferencesName,\n+                PREFS_OS_DIRECT_ENABLED,\n+                influenceParams.isDirectEnabled\n+        )\n+        preferences.saveBool(\n+                preferences.preferencesName,\n+                PREFS_OS_INDIRECT_ENABLED,\n+                influenceParams.isIndirectEnabled\n+        )\n+        preferences.saveBool(\n+                preferences.preferencesName,\n+                PREFS_OS_UNATTRIBUTED_ENABLED,\n+                influenceParams.isUnattributedEnabled\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_LIMIT,\n+                influenceParams.notificationLimit\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_INDIRECT_ATTRIBUTION_WINDOW,\n+                influenceParams.indirectNotificationAttributionWindow\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_LIMIT,\n+                influenceParams.iamLimit\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_INDIRECT_ATTRIBUTION_WINDOW,\n+                influenceParams.indirectIAMAttributionWindow\n+        )\n+    }\n+\n+    companion object {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDYwNDQ5OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSTrackerFactory.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTozNDoxNFrOG1xQCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTozNDoxNFrOG1xQCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzNDYzMw==", "bodyText": "\ud83d\udc4d Nice! Liking the single line if statements. Seems like this is encengaged based on the Kotlin docs too.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459034633", "createdAt": "2020-07-22T19:34:14Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSTrackerFactory.kt", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OSSharedPreferences\n+import com.onesignal.OneSignal.AppEntryAction\n+import com.onesignal.OneSignalRemoteParams.InfluenceParams\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import org.json.JSONObject\n+import java.util.*\n+import java.util.concurrent.ConcurrentHashMap\n+\n+class OSTrackerFactory(preferences: OSSharedPreferences, logger: OSLogger) {\n+    private val trackers = ConcurrentHashMap<String, OSChannelTracker>()\n+    private val dataRepository: OSInfluenceDataRepository = OSInfluenceDataRepository(preferences)\n+\n+    val influences: List<OSInfluence>\n+        get() = trackers.values.map { it.currentSessionInfluence }\n+\n+    val iAMChannelTracker: OSChannelTracker\n+        get() = trackers[OSInAppMessageTracker.TAG]!!\n+\n+    val notificationChannelTracker: OSChannelTracker\n+        get() = trackers[OSNotificationTracker.TAG]!!\n+\n+    val channels: List<OSChannelTracker>\n+        get() {\n+            val channels: MutableList<OSChannelTracker> = mutableListOf()\n+            notificationChannelTracker?.let { channels.add(it) }\n+            iAMChannelTracker?.let { channels.add(it) }\n+            return channels\n+        }\n+\n+    init {\n+        trackers[OSInAppMessageTracker.TAG] = OSInAppMessageTracker(dataRepository, logger)\n+        trackers[OSNotificationTracker.TAG] = OSNotificationTracker(dataRepository, logger)\n+    }\n+\n+    fun initFromCache() {\n+        trackers.values.forEach {\n+            it.initInfluencedTypeFromCache()\n+        }\n+    }\n+\n+    fun saveInfluenceParams(influenceParams: InfluenceParams) {\n+        dataRepository.saveInfluenceParams(influenceParams)\n+    }\n+\n+    fun addSessionData(jsonObject: JSONObject, influences: List<OSInfluence>) {\n+        influences.forEach {\n+            when (it.influenceChannel) {\n+                OSInfluenceChannel.NOTIFICATION -> notificationChannelTracker?.addSessionData(jsonObject, it)\n+                OSInfluenceChannel.IAM -> {\n+                }\n+            }\n+        }\n+    }\n+\n+    fun getChannelByEntryAction(entryAction: AppEntryAction): OSChannelTracker? {\n+        return if (entryAction.isNotificationClick) notificationChannelTracker else null\n+    }\n+\n+    fun getChannelsToResetByEntryAction(entryAction: AppEntryAction): List<OSChannelTracker> {\n+        val channels: MutableList<OSChannelTracker> = ArrayList()\n+        // Avoid reset session if application is closed\n+        if (entryAction.isAppClose) return channels", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTI1OTgzOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/unittest/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzoyMToyMVrOG13iDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzoyMToyMVrOG13iDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzU1MA==", "bodyText": "This should be in the root build.gradle.", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459137550", "createdAt": "2020-07-22T23:21:21Z", "author": {"login": "jkasten2"}, "path": "OneSignalSDK/unittest/build.gradle", "diffHunk": "@@ -52,4 +54,10 @@ dependencies {\n     testImplementation 'junit:junit:4.12'\n     testImplementation 'org.robolectric:robolectric:4.3.1'\n     testImplementation 'org.awaitility:awaitility:3.1.5'\n+    testImplementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n+\n+    testImplementation 'org.reflections:reflections:0.9.12'\n+}\n+repositories {\n+    mavenCentral()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDQ3OTUyOnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/build.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODozNTozNlrOG8_mUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDowMDowOVrOG9mPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwOTc0NA==", "bodyText": "Super nit picky here but lets use ' instead of \" so its consistent with others", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466609744", "createdAt": "2020-08-06T18:35:36Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/build.gradle", "diffHunk": "@@ -18,6 +19,8 @@ buildscript {\n     dependencies {\n         classpath 'com.android.tools.build:gradle:3.6.2'\n \n+        classpath 'com.google.gms:google-services:4.3.2'\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTE3Mg==", "bodyText": "Also any reason we don't just add '1.3.72' to the end of the classpath instead of ext.kotlin_version = '1.3.72'", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466611172", "createdAt": "2020-08-06T18:38:22Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/build.gradle", "diffHunk": "@@ -18,6 +19,8 @@ buildscript {\n     dependencies {\n         classpath 'com.android.tools.build:gradle:3.6.2'\n \n+        classpath 'com.google.gms:google-services:4.3.2'\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwOTc0NA=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0MjkxNw==", "bodyText": "I wanted to start cleaning this, I usually use ext to define versions, but is not a must, I can change to make all use this new format or remove it, let me know what you think", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467242917", "createdAt": "2020-08-07T20:00:09Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/build.gradle", "diffHunk": "@@ -18,6 +19,8 @@ buildscript {\n     dependencies {\n         classpath 'com.android.tools.build:gradle:3.6.2'\n \n+        classpath 'com.google.gms:google-services:4.3.2'\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwOTc0NA=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDQ4OTA4OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/build.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODozODozN1rOG8_sdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzowMjozOFrOG-Xeqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw==", "bodyText": "Super nit picky here but lets use ' instead of \" so its consistent with others", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466611317", "createdAt": "2020-08-06T18:38:37Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -55,6 +57,8 @@ dependencies {\n     api 'androidx.browser:browser:[1.0.0, 1.99.99]'\n     api 'androidx.appcompat:appcompat:[1.0.0, 1.99.99]'\n     api 'androidx.work:work-runtime:[2.0.0, 2.99.99]'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0MzU4OQ==", "bodyText": "oh good eye!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467243589", "createdAt": "2020-08-07T20:01:55Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -55,6 +57,8 @@ dependencies {\n     api 'androidx.browser:browser:[1.0.0, 1.99.99]'\n     api 'androidx.appcompat:appcompat:[1.0.0, 1.99.99]'\n     api 'androidx.work:work-runtime:[2.0.0, 2.99.99]'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0NTQxNg==", "bodyText": "oooh actually if we want to start using $kotlin_version variables on gradle, it only use it with \" let mek nos if you prefer to continue with the old format", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467245416", "createdAt": "2020-08-07T20:06:30Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -55,6 +57,8 @@ dependencies {\n     api 'androidx.browser:browser:[1.0.0, 1.99.99]'\n     api 'androidx.appcompat:appcompat:[1.0.0, 1.99.99]'\n     api 'androidx.work:work-runtime:[2.0.0, 2.99.99]'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0OTU3OA==", "bodyText": "Then maybe as we start replacing with ext. we will add \" to all other dependencies", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r468049578", "createdAt": "2020-08-10T17:02:38Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -55,6 +57,8 @@ dependencies {\n     api 'androidx.browser:browser:[1.0.0, 1.99.99]'\n     api 'androidx.appcompat:appcompat:[1.0.0, 1.99.99]'\n     api 'androidx.work:work-runtime:[2.0.0, 2.99.99]'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDUwNTk4OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo0Mzo1NFrOG8_3DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDoxMTo0OVrOG9mhYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDAyOQ==", "bodyText": "Do we want this to be public?", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466614029", "createdAt": "2020-08-06T18:43:54Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -3072,9 +3073,17 @@ static void fireEmailUpdateFailure() {\n       }\n    }\n \n+   @NonNull\n+   public static OSTime getTime() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0NzQ1Ng==", "bodyText": "good catch!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467247456", "createdAt": "2020-08-07T20:11:49Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -3072,9 +3073,17 @@ static void fireEmailUpdateFailure() {\n       }\n    }\n \n+   @NonNull\n+   public static OSTime getTime() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDAyOQ=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDUxMzg5OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/data/OSChannelTracker.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo0NjoxNFrOG8_77A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo0NjoxNFrOG8_77A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNTI3Ng==", "bodyText": "Remove new line here", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466615276", "createdAt": "2020-08-06T18:46:14Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/data/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.onesignal.influence.data\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.OSInfluenceConstants\n+import com.onesignal.influence.domain.OSInfluence\n+import com.onesignal.influence.domain.OSInfluenceChannel\n+import com.onesignal.influence.domain.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+\n+            val currentInfluenceType = influenceType ?: OSInfluenceType.DISABLED\n+\n+            if (currentInfluenceType.isDirect()) {\n+                if (isDirectSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        ids = JSONArray().put(this@OSChannelTracker.directId)\n+                        influenceType = OSInfluenceType.DIRECT\n+                    }\n+                }\n+            } else if (currentInfluenceType.isIndirect()) {\n+                if (isIndirectSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        ids = this@OSChannelTracker.indirectIds\n+                        influenceType = OSInfluenceType.INDIRECT\n+                    }\n+                }\n+            } else if (isUnattributedSessionEnabled) {\n+                sessionInfluence.apply {\n+                    influenceType = OSInfluenceType.UNATTRIBUTED\n+                }\n+            }\n+\n+            return sessionInfluence\n+        }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDUyMDM2OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOSTime.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo0ODowNVrOG8__1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDoxODowMFrOG9mqoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNjI3Nw==", "bodyText": "Rename to MockOSTimeImpl to match our real OSTimeImpl?", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466616277", "createdAt": "2020-08-06T18:48:05Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOSTime.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.onesignal;\n+\n+import android.os.SystemClock;\n+\n+public class MockOSTime implements OSTime {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0OTgyNA==", "bodyText": "love this one!", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467249824", "createdAt": "2020-08-07T20:18:00Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOSTime.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.onesignal;\n+\n+import android.os.SystemClock;\n+\n+public class MockOSTime implements OSTime {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNjI3Nw=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDUyNzI0OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/GenerateNotificationRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo1MDowNVrOG9AEJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDozOTowMFrOG9nLhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzM4MQ==", "bodyText": "Instead of passing everything into the advanceSystemTimeBy maybe we should just call a method inside of time?\nExample:\ntime.advanceSystemTimeBy(604_801)?", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466617381", "createdAt": "2020-08-06T18:50:05Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/GenerateNotificationRunner.java", "diffHunk": "@@ -836,7 +842,7 @@ public void shouldRestoreNotifications() {\n \n       // Go forward 1 week\n       // Note: Does not effect the SQL function strftime\n-      advanceSystemTimeBy(604_801);\n+      advanceSystemTimeBy(time, 604_801);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1ODI0Ng==", "bodyText": ":not_bad: \ud83d\udc4d", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467258246", "createdAt": "2020-08-07T20:39:00Z", "author": {"login": "Jeasmine"}, "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/GenerateNotificationRunner.java", "diffHunk": "@@ -836,7 +842,7 @@ public void shouldRestoreNotifications() {\n \n       // Go forward 1 week\n       // Note: Does not effect the SQL function strftime\n-      advanceSystemTimeBy(604_801);\n+      advanceSystemTimeBy(time, 604_801);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzM4MQ=="}, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDU0MDI2OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/MainOneSignalClassRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo1NDowM1rOG9AMQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo1NDowM1rOG9AMQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxOTQ1OA==", "bodyText": "Add a space advanceSystemAndElapsedTimeBy(time, 0);", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466619458", "createdAt": "2020-08-06T18:54:03Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/MainOneSignalClassRunner.java", "diffHunk": "@@ -2516,12 +2531,13 @@ public void ensureSyncJobServiceRescheduleOnApiTimeout() throws Exception {\n    }\n \n    private void useAppFor2minThenBackground() throws Exception {\n+      advanceSystemAndElapsedTimeBy(time,0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 384}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDU1MzU2OnYy", "diffSide": "RIGHT", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/TestHelpers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo1NzozM1rOG9AUPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo1NzozM1rOG9AUPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTUwMg==", "bodyText": "Add a space advanceSystemAndElapsedTimeBy(time, 31);", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466621502", "createdAt": "2020-08-06T18:57:33Z", "author": {"login": "mikechoch"}, "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/TestHelpers.java", "diffHunk": "@@ -241,11 +241,11 @@ static void fastColdRestartApp() throws Exception {\n       StaticResetHelper.restSetStaticFields();\n    }\n \n-   static void restartAppAndElapseTimeToNextSession() throws Exception {\n+   static void restartAppAndElapseTimeToNextSession(MockOSTime time) throws Exception {\n       stopAllOSThreads();\n       flushBufferedSharedPrefs();\n       StaticResetHelper.restSetStaticFields();\n-      advanceSystemTimeBy(31);\n+      advanceSystemAndElapsedTimeBy(time,31);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dba89a3a54391538f99ccab383ccaa7e20a61af9"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2267, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}