{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NTk3NDcw", "number": 6637, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTozNjo0MlrODvFiyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1NTo0NFrODv8LUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzAwNDg5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTozNjo0M1rOGBTmxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMzoxMjo0MlrOGBxXEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMjk4MA==", "bodyText": "It's better to call setData() asynchronously.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r404022980", "createdAt": "2020-04-06T11:36:43Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -653,6 +654,101 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n         });\n     }\n \n+    protected void internalSetAutoSubscriptionCreation(AsyncResponse asyncResponse, AutoSubscriptionCreationOverride autoSubscriptionCreationOverride) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxMDQ4MQ==", "bodyText": "Done.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r404510481", "createdAt": "2020-04-07T03:12:42Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -653,6 +654,101 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n         });\n     }\n \n+    protected void internalSetAutoSubscriptionCreation(AsyncResponse asyncResponse, AutoSubscriptionCreationOverride autoSubscriptionCreationOverride) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMjk4MA=="}, "originalCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzAwNjczOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTozNzoyM1rOGBTn7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMzoxMjo1MFrOGBxXPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMzI3Nw==", "bodyText": "Same as the above comment.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r404023277", "createdAt": "2020-04-06T11:37:23Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -653,6 +654,101 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n         });\n     }\n \n+    protected void internalSetAutoSubscriptionCreation(AsyncResponse asyncResponse, AutoSubscriptionCreationOverride autoSubscriptionCreationOverride) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n+                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                            asyncResponse.resume(Response.noContent().build());\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n+                            return null;\n+                        } catch (KeeperException.NoNodeException e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status for namespace {}: does not exist\", clientAppId(),\n+                                    namespaceName);\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                            return null;\n+                        } catch (KeeperException.BadVersionException e) {\n+                            log.error(\n+                                    \"[{}] Failed to modify autoSubscriptionCreation status on namespace {} expected policy node version={} : concurrent modification\",\n+                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+\n+                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                            return null;\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoSubscriptionCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxMDUyNg==", "bodyText": "Done.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r404510526", "createdAt": "2020-04-07T03:12:50Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -653,6 +654,101 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n         });\n     }\n \n+    protected void internalSetAutoSubscriptionCreation(AsyncResponse asyncResponse, AutoSubscriptionCreationOverride autoSubscriptionCreationOverride) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n+                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                            asyncResponse.resume(Response.noContent().build());\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n+                            return null;\n+                        } catch (KeeperException.NoNodeException e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status for namespace {}: does not exist\", clientAppId(),\n+                                    namespaceName);\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                            return null;\n+                        } catch (KeeperException.BadVersionException e) {\n+                            log.error(\n+                                    \"[{}] Failed to modify autoSubscriptionCreation status on namespace {} expected policy node version={} : concurrent modification\",\n+                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+\n+                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                            return null;\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoSubscriptionCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMzI3Nw=="}, "originalCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTk0MDQzOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1MDozOVrOGCpvug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1NTo0OVrOGDG8Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNDI5OA==", "bodyText": "The response should complete in the zookeeper callback. Otherwise, the broker always returns success.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405434298", "createdAt": "2020-04-08T10:50:39Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoTopicCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());\n-                            log.info(\"[{}] Successfully {} on namespace {}\", clientAppId(),\n-                                    autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\", namespaceName);\n                             return null;\n-                        } catch (KeeperException.NoNodeException e) {\n-                            log.error(\"[{}] Failed to modify autoTopicCreation status for namespace {}: does not exist\", clientAppId(),\n-                                    namespaceName);\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoTopicCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n                             return null;\n-                        } catch (KeeperException.BadVersionException e) {\n-                            log.error(\n-                                    \"[{}] Failed to modify autoTopicCreation status on namespace {} expected policy node version={} : concurrent modification\",\n-                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoTopicCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n \n-                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            log.info(\"[{}] Successfully removed autoTopicCreation override on namespace {}\", clientAppId(), namespaceName);\n+                            asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMjY0Mg==", "bodyText": "@codelipenghui Thanks for pointing out this, have fixed.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405912642", "createdAt": "2020-04-09T01:55:49Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoTopicCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());\n-                            log.info(\"[{}] Successfully {} on namespace {}\", clientAppId(),\n-                                    autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\", namespaceName);\n                             return null;\n-                        } catch (KeeperException.NoNodeException e) {\n-                            log.error(\"[{}] Failed to modify autoTopicCreation status for namespace {}: does not exist\", clientAppId(),\n-                                    namespaceName);\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoTopicCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n                             return null;\n-                        } catch (KeeperException.BadVersionException e) {\n-                            log.error(\n-                                    \"[{}] Failed to modify autoTopicCreation status on namespace {} expected policy node version={} : concurrent modification\",\n-                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoTopicCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n \n-                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            log.info(\"[{}] Successfully removed autoTopicCreation override on namespace {}\", clientAppId(), namespaceName);\n+                            asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNDI5OA=="}, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTk0NzA4OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1Mjo0OVrOGCp0BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1NjowM1rOGDG8iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNTM5Ng==", "bodyText": "Looks should complete the asyncResponse here.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405435396", "createdAt": "2020-04-08T10:52:49Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMjcxNQ==", "bodyText": "Done.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405912715", "createdAt": "2020-04-09T01:56:03Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNTM5Ng=="}, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTk1MDM5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1Mzo1NFrOGCp2OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1NjoxMFrOGDG8oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNTk2MQ==", "bodyText": "Should move to the zookeeper callback.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405435961", "createdAt": "2020-04-08T10:53:54Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoTopicCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMjczNw==", "bodyText": "Done.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405912737", "createdAt": "2020-04-09T01:56:10Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoTopicCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNTk2MQ=="}, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTk1NDk2OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1NToxN1rOGCp5Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1NjoxNlrOGDG8xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNjY4Nw==", "bodyText": "Should move to the zookeeper callback.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405436687", "createdAt": "2020-04-08T10:55:17Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -615,29 +673,87 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n                 policies -> {\n                     if (policies.isPresent()) {\n                         Entry<Policies, Stat> policiesNode = policies.get();\n-                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMjc3NA==", "bodyText": "Done.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405912774", "createdAt": "2020-04-09T01:56:16Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -615,29 +673,87 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n                 policies -> {\n                     if (policies.isPresent()) {\n                         Entry<Policies, Stat> policiesNode = policies.get();\n-                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNjY4Nw=="}, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTk1NjAzOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1NTo0NFrOGCp5xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1Njo0OFrOGDG9Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNjg2OQ==", "bodyText": "Should move to the zookeeper callback.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405436869", "createdAt": "2020-04-08T10:55:44Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -615,29 +673,87 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n                 policies -> {\n                     if (policies.isPresent()) {\n                         Entry<Policies, Stat> policiesNode = policies.get();\n-                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());\n-                            log.info(\"[{}] Successfully removed override on namespace {}\", clientAppId(), namespaceName);\n                             return null;\n-                        } catch (KeeperException.NoNodeException e) {\n-                            log.error(\"[{}] Failed to modify autoTopicCreation status for namespace {}: does not exist\", clientAppId(),\n-                                    namespaceName);\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n                             return null;\n-                        } catch (KeeperException.BadVersionException e) {\n-                            log.error(\n-                                    \"[{}] Failed to modify autoTopicCreation status on namespace {} expected policy node version={} : concurrent modification\",\n-                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoSubscriptionCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n \n-                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            log.info(\"[{}] Successfully removed autoSubscriptionCreation override on namespace {}\", clientAppId(), namespaceName);\n+                            asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMjkzMQ==", "bodyText": "Done.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405912931", "createdAt": "2020-04-09T01:56:48Z", "author": {"login": "murong00"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -615,29 +673,87 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n                 policies -> {\n                     if (policies.isPresent()) {\n                         Entry<Policies, Stat> policiesNode = policies.get();\n-                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());\n-                            log.info(\"[{}] Successfully removed override on namespace {}\", clientAppId(), namespaceName);\n                             return null;\n-                        } catch (KeeperException.NoNodeException e) {\n-                            log.error(\"[{}] Failed to modify autoTopicCreation status for namespace {}: does not exist\", clientAppId(),\n-                                    namespaceName);\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n                             return null;\n-                        } catch (KeeperException.BadVersionException e) {\n-                            log.error(\n-                                    \"[{}] Failed to modify autoTopicCreation status on namespace {} expected policy node version={} : concurrent modification\",\n-                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoSubscriptionCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n \n-                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            log.info(\"[{}] Successfully removed autoSubscriptionCreation override on namespace {}\", clientAppId(), namespaceName);\n+                            asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNjg2OQ=="}, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1864, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}