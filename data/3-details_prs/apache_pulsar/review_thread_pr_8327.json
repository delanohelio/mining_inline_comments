{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3NDEyMjg1", "number": 8327, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo0MlrOExAUYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo0MlrOExAUYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIwODk4OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/context.go", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo0MlrOHm5qtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzoyNToyOVrOHnmpDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc1OA==", "bodyText": "why a pulsar.Producer is returned for this method?\nin the corresponding java side, public <O> TypedMessageBuilder<O> newOutputMessage(String topicName, Schema<O> schema)", "url": "https://github.com/apache/pulsar/pull/8327#discussion_r510552758", "createdAt": "2020-10-23T01:58:42Z", "author": {"login": "nlu90"}, "path": "pulsar-function-go/pf/context.go", "diffHunk": "@@ -119,6 +120,12 @@ func (c *FunctionContext) GetUserConfMap() map[string]interface{} {\n \treturn c.userConfigs\n }\n \n+// NewOutputMessage send message to the topic\n+// @param topicName: The name of the topic for output message\n+func (c *FunctionContext) NewOutputMessage(topicName string) pulsar.Producer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feb1049e44a61428848beff1ab8e8e8c593293b0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NDQ4NQ==", "bodyText": "This is because Java client and Go client have different packaging for producer and message. In the Go client, they are independent structs; in the Java client, they are unified encapsulated into TypedMessageBuilder objects.\nBut in fact, newOuputMessage essentially intercepts the link that sends messages to outputTopic during pulsar function processing. So we need to expose the producer to allow users to send messages out.", "url": "https://github.com/apache/pulsar/pull/8327#discussion_r510554485", "createdAt": "2020-10-23T02:06:07Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/context.go", "diffHunk": "@@ -119,6 +120,12 @@ func (c *FunctionContext) GetUserConfMap() map[string]interface{} {\n \treturn c.userConfigs\n }\n \n+// NewOutputMessage send message to the topic\n+// @param topicName: The name of the topic for output message\n+func (c *FunctionContext) NewOutputMessage(topicName string) pulsar.Producer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc1OA=="}, "originalCommit": {"oid": "feb1049e44a61428848beff1ab8e8e8c593293b0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNDc4OQ==", "bodyText": "I can understand the desire for naming parity, but I wonder whether or not it is better to call this something different, given how different the concepts are.  In Go, if I see New<Foo> I expect that I am going to be receiving a pointer to a new struct of that type, or at least an interface of some kind with that name.  In this case, I would expect to get a new Message.\nI think I would probably recommend something like the following:\nfunc (c *FunctionContext) SendTopic(topicName string, message *pulsar.ProducerMessage)\nor even\nfunc (c *FunctionContext) SendTopicMessage(topicName string, message *pulsar.ProducerMessage)\nfunc (c *FunctionContext) SendTopic(topicName string, payload []byte)\nwhich, given the way producers are currently packaged, might benefit from a registry of producers per topic:\nvar producerRegistry = map[string]pulsar.Producer{}\nfunc (gi *goInstance) getProducer(topicName string) (pulsar.Producer, error) {\n        if found := producerRegistry[topicName]; found != nil {\n                return found, nil\n        }\n\tproperties := getProperties(getDefaultSubscriptionName(\n\t\tgi.context.instanceConf.funcDetails.Tenant,\n\t\tgi.context.instanceConf.funcDetails.Namespace,\n\t\tgi.context.instanceConf.funcDetails.Name), gi.context.instanceConf.instanceID)\n\n\n\tproducer, err := gi.client.CreateProducer(pulsar.ProducerOptions{\n\t\tTopic:                   topicName,\n\t\tProperties:              properties,\n\t\tCompressionType:         pulsar.LZ4,\n\t\tBatchingMaxPublishDelay: time.Millisecond * 10,\n\t\t// Set send timeout to be infinity to prevent potential deadlock with consumer\n\t\t// that might happen when consumer is blocked due to unacked messages\n\t})\n\tif err != nil {\n\t\tgi.stats.incrTotalSysExceptions(err)\n\t\tlog.Errorf(\"create producer error:%s\", err.Error())\n\t\treturn nil, err\n\t}\n        producerRegistry[topicName] = producer\n\treturn producer, nil\n}", "url": "https://github.com/apache/pulsar/pull/8327#discussion_r511014789", "createdAt": "2020-10-23T16:53:35Z", "author": {"login": "flowchartsman"}, "path": "pulsar-function-go/pf/context.go", "diffHunk": "@@ -119,6 +120,12 @@ func (c *FunctionContext) GetUserConfMap() map[string]interface{} {\n \treturn c.userConfigs\n }\n \n+// NewOutputMessage send message to the topic\n+// @param topicName: The name of the topic for output message\n+func (c *FunctionContext) NewOutputMessage(topicName string) pulsar.Producer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc1OA=="}, "originalCommit": {"oid": "feb1049e44a61428848beff1ab8e8e8c593293b0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMDQ1Ng==", "bodyText": "Admittedly, there are certainly more idiomatic ways to handle some of these concepts. I am generally against using global variables, especially maps with no synchronization, but from what I can tell from the code all access to this map would be synchronous, so no problems there, and more profound changes to the Go functions SDK would require a PIP, which I'm certainly open to submitting down the road.", "url": "https://github.com/apache/pulsar/pull/8327#discussion_r511020456", "createdAt": "2020-10-23T17:04:18Z", "author": {"login": "flowchartsman"}, "path": "pulsar-function-go/pf/context.go", "diffHunk": "@@ -119,6 +120,12 @@ func (c *FunctionContext) GetUserConfMap() map[string]interface{} {\n \treturn c.userConfigs\n }\n \n+// NewOutputMessage send message to the topic\n+// @param topicName: The name of the topic for output message\n+func (c *FunctionContext) NewOutputMessage(topicName string) pulsar.Producer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc1OA=="}, "originalCommit": {"oid": "feb1049e44a61428848beff1ab8e8e8c593293b0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI4OTYxMw==", "bodyText": "Thanks @flowchartsman feedback. In fact, here we hope to expose the Producer interface rather than the producerMessage struct. In this way, users can use this interface to maximize their own behavior, including setting producerOptions when creating a producer.\nAgain, NewOutputMessage() most fundamental purpose is to intercept the results processed by the Pulsar Function, and then transfer the processing power of this result to the user for customization.", "url": "https://github.com/apache/pulsar/pull/8327#discussion_r511289613", "createdAt": "2020-10-24T03:25:29Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/context.go", "diffHunk": "@@ -119,6 +120,12 @@ func (c *FunctionContext) GetUserConfMap() map[string]interface{} {\n \treturn c.userConfigs\n }\n \n+// NewOutputMessage send message to the topic\n+// @param topicName: The name of the topic for output message\n+func (c *FunctionContext) NewOutputMessage(topicName string) pulsar.Producer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc1OA=="}, "originalCommit": {"oid": "feb1049e44a61428848beff1ab8e8e8c593293b0"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2953, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}