{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMDEzMTcz", "number": 6449, "title": "Support Consumers Set Custom Retry Delay", "bodyText": "Master Issue: #6448\nMotivation\nFor many online business systems, various exceptions usually occur in business logic processing, so the message needs to be re-consumed, but users hope that this delay time can be controlled flexibly. The current user's processing method is usually to send this message to a special retry topic, because production can specify any delay, so consumers subscribe the business topic and retry topic at the same time. I think this logic can be supported by pulsar itself, making it easier for users to use, and it looks like this is a very common requirement.\nModifications\nThis change can be supported on the client side,  need to add a set of interfaces to org.apache.pulsar.client.api.Consumer\nvoid reconsumeLater(Message<?> message, long delayTime, TimeUnit unit) throws PulsarClientException;\nCompletableFuture<Void> reconsumeLaterAsync(Message<?> message, long delayTime, TimeUnit unit);\nCompletableFuture<Void> reconsumeLaterAsync(Messages<?> messages, int delayLevel);\nDeadLetterPolicy add retry topic\npublic class DeadLetterPolicy {\n\n    /**\n     * Maximum number of times that a message will be redelivered before being sent to the dead letter queue.\n     */\n    private int maxRedeliverCount;\n\n    /**\n     * Name of the retry topic where the failing messages will be sent.\n     */\n    private String retryLetterTopic;\n\n    /**\n     * Name of the dead topic where the failing messages will be sent.\n     */\n    private String deadLetterTopic;\n\n}\n\norg.apache.pulsar.client.impl.ConsumerImpl add a retry producer\n  private volatile Producer<T> deadLetterProducer;\n\n  private volatile Producer<T> retryLetterProducer;\nCan specify whether to enable retry when creating a consumer\uff0cdefault unenable\n    @Override\n    public ConsumerBuilder<T> enableRetry(boolean retryEnable) {\n        conf.setRetryEnable(retryEnable);\n        return this;\n    }", "createdAt": "2020-03-01T08:08:16Z", "url": "https://github.com/apache/pulsar/pull/6449", "merged": true, "mergeCommit": {"oid": "30e762ec420306ff45cff03801e32f37a2de1c05"}, "closed": true, "closedAt": "2020-04-06T18:17:02Z", "author": {"login": "liudezhi2098"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcSkKSIAFqTM4MzQ4NDM0Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1SIQvgFqTQ0OTM3OTUzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDg0MzQ3", "url": "https://github.com/apache/pulsar/pull/6449#pullrequestreview-383484347", "createdAt": "2020-03-30T01:24:32Z", "commit": {"oid": "f2ccfd77a404ae19552d9a4b380998ea6f740372"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d9dfedab4c20632751a0a158e2fc91cecf9ae6e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/4d9dfedab4c20632751a0a158e2fc91cecf9ae6e", "committedDate": "2020-04-05T04:07:28Z", "message": "Support Consumers Set Custom Retry Delay"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "467d8519b411c99714839ec8a3f92b5bfdf65d03", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/467d8519b411c99714839ec8a3f92b5bfdf65d03", "committedDate": "2020-04-05T04:07:28Z", "message": "add flink PulsarConsumerSourceTests no impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5938ba288b252e948a2f5d25f3169ccfc40094d", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/b5938ba288b252e948a2f5d25f3169ccfc40094d", "committedDate": "2020-04-05T04:07:28Z", "message": "add Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "committedDate": "2020-04-05T04:09:02Z", "message": "add retryTopicTests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "045771be4dbcc8134ab2b0caa7e44b96b8830aec", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/045771be4dbcc8134ab2b0caa7e44b96b8830aec", "committedDate": "2020-04-05T02:58:05Z", "message": "add Tests"}, "afterCommit": {"oid": "68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "committedDate": "2020-04-05T04:09:02Z", "message": "add retryTopicTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5db9fa0c9124b0b16968a1c8ea215d65a809e572", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/5db9fa0c9124b0b16968a1c8ea215d65a809e572", "committedDate": "2020-04-05T06:46:45Z", "message": "add retryTopicTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a7421e47b6c0da5e5a213a3c47ec139460e117", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/b8a7421e47b6c0da5e5a213a3c47ec139460e117", "committedDate": "2020-04-05T06:56:26Z", "message": "add retryTopicTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a5a82529c6d945db1807941076f98c4a9c9bdf4", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/8a5a82529c6d945db1807941076f98c4a9c9bdf4", "committedDate": "2020-04-05T11:45:39Z", "message": "add retryTopicTests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3ODUyNDAz", "url": "https://github.com/apache/pulsar/pull/6449#pullrequestreview-387852403", "createdAt": "2020-04-05T19:29:48Z", "commit": {"oid": "8a5a82529c6d945db1807941076f98c4a9c9bdf4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MTY3NDk2", "url": "https://github.com/apache/pulsar/pull/6449#pullrequestreview-388167496", "createdAt": "2020-04-06T11:41:10Z", "commit": {"oid": "8a5a82529c6d945db1807941076f98c4a9c9bdf4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5Mzc5NTM2", "url": "https://github.com/apache/pulsar/pull/6449#pullrequestreview-449379536", "createdAt": "2020-07-15T22:11:23Z", "commit": {"oid": "8a5a82529c6d945db1807941076f98c4a9c9bdf4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMjoxMToyM1rOGyTFYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMjoxMToyM1rOGyTFYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM5NDY1OA==", "bodyText": "Does anyone know what is the point of this line? The logic of sending message to dead letter queue is described within more than twenty lines below as well as message acknowledgment, why is it done twice?", "url": "https://github.com/apache/pulsar/pull/6449#discussion_r455394658", "createdAt": "2020-07-15T22:11:23Z", "author": {"login": "Lanayx"}, "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java", "diffHunk": "@@ -511,6 +527,129 @@ boolean markAckForBatchMessage(BatchMessageIdImpl batchMessageId, AckType ackTyp\n         return sendAcknowledge(messageId, ackType, properties, txnImpl);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected CompletableFuture<Void> doReconsumeLater(Message<?> message, AckType ackType,\n+                                                       Map<String,Long> properties, \n+                                                       long delayTime,\n+                                                       TimeUnit unit) {\n+        MessageId messageId = message.getMessageId();\n+        if(messageId instanceof TopicMessageIdImpl) {\n+            messageId = ((TopicMessageIdImpl)messageId).getInnerMessageId();\n+        }\n+        checkArgument(messageId instanceof MessageIdImpl);\n+        if (getState() != State.Ready && getState() != State.Connecting) {\n+            stats.incrementNumAcksFailed();\n+            PulsarClientException exception = new PulsarClientException(\"Consumer not ready. State: \" + getState());\n+            if (AckType.Individual.equals(ackType)) {\n+                onAcknowledge(messageId, exception);\n+            } else if (AckType.Cumulative.equals(ackType)) {\n+                onAcknowledgeCumulative(messageId, exception);\n+            }\n+            return FutureUtil.failedFuture(exception);\n+        }\n+        if (delayTime < 0) {\n+            delayTime = 0;\n+        }\n+        if (retryLetterProducer == null) {\n+            try {\n+                createProducerLock.writeLock().lock();\n+                if (retryLetterProducer == null) {\n+                    retryLetterProducer = client.newProducer(schema)\n+                            .topic(this.deadLetterPolicy.getRetryLetterTopic())\n+                            .enableBatching(false)\n+                            .blockIfQueueFull(false)\n+                            .create();\n+                }\n+            } catch (Exception e) {\n+                log.error(\"Create retry letter producer exception with topic: {}\", deadLetterPolicy.getRetryLetterTopic(), e);\n+            } finally {\n+                createProducerLock.writeLock().unlock();\n+            }\n+        }\n+        if (retryLetterProducer != null) {\n+            try {\n+                MessageImpl<T> retryMessage = null;\n+                String originMessageIdStr = null;\n+                String originTopicNameStr = null;\n+                if (message instanceof TopicMessageImpl) {\n+                    retryMessage = (MessageImpl<T>) ((TopicMessageImpl<T>) message).getMessage();\n+                    originMessageIdStr = ((TopicMessageIdImpl) message.getMessageId()).getInnerMessageId().toString();\n+                    originTopicNameStr = ((TopicMessageIdImpl) message.getMessageId()).getTopicName();\n+                } else if (message instanceof MessageImpl) {\n+                    retryMessage = (MessageImpl<T>) message;\n+                    originMessageIdStr = ((MessageImpl<T>) message).getMessageId().toString();\n+                    originTopicNameStr =  ((MessageImpl<T>) message).getTopicName();\n+                }\n+                SortedMap<String, String> propertiesMap = new TreeMap<>();\n+                int reconsumetimes = 1;\n+                if (message.getProperties() != null) {\n+                    propertiesMap.putAll(message.getProperties());\n+                }\n+\n+                if (propertiesMap.containsKey(RetryMessageUtil.SYSTEM_PROPERTY_RECONSUMETIMES)) {\n+                    reconsumetimes = Integer.valueOf(propertiesMap.get(RetryMessageUtil.SYSTEM_PROPERTY_RECONSUMETIMES));\n+                    reconsumetimes = reconsumetimes + 1;\n+                   \n+                } else {\n+                    propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_REAL_TOPIC, originTopicNameStr);\n+                    propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_ORIGIN_MESSAGE_ID, originMessageIdStr);\n+                }\n+\n+                propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_RECONSUMETIMES, String.valueOf(reconsumetimes));\n+                propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_DELAY_TIME, String.valueOf(unit.toMillis(delayTime)));\n+                \n+               if (reconsumetimes > this.deadLetterPolicy.getMaxRedeliverCount()) {\n+                   processPossibleToDLQ((MessageIdImpl)messageId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a5a82529c6d945db1807941076f98c4a9c9bdf4"}, "originalPosition": 134}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4971, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}