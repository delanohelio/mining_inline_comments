{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MDAwMjE4", "number": 6791, "title": "Use consistent hashing in KeyShared distribution", "bodyText": "Motivation\nThe current implementation of KeyShared subscriptions uses a mechanism to divide they hash space across the available consumers. This is based on dividing the currently assigned hash ranges when a new consumer joins or leaves.\nThere are few problems with the current approach:\n\n\nWhen adding a new consumer, the bigger range is split to make space for the new consumer. That means that when adding 3 consumers, 1 of them will \"own\" a hash range that is double in size compared to the other 2 consumers and consequently it will receive twice the traffic. This is not terrible, but not ideal either.\n\n\nWhen removing consumers, the range for the removed consumer will always be assigned to the next consumer. The new hash distribution really depends on the sequence upon which the consumers are removed. If one is unlucky, the traffic will be very heavily skewed having situations where 1 consumer is getting >90% of the traffic.\n\n\nThis is an example of removing consumers in sequence, with attached the size of their respective hash ranges:\nRemoved consumer from rangeMap: {c1=8192, c10=4096, c3=4096, c4=8192, c5=4096, c6=8192, c7=16384, c8=8192, c9=4096}\nRemoved consumer from rangeMap: {c1=8192, c10=4096, c4=8192, c5=4096, c6=12288, c7=16384, c8=8192, c9=4096}\nRemoved consumer from rangeMap: {c1=8192, c10=4096, c5=4096, c6=12288, c7=16384, c8=16384, c9=4096}\nRemoved consumer from rangeMap: {c1=8192, c10=8192, c6=12288, c7=16384, c8=16384, c9=4096}\nRemoved consumer from rangeMap: {c1=24576, c10=8192, c6=12288, c7=16384, c9=4096}\nRemoved consumer from rangeMap: {c1=24576, c10=8192, c7=28672, c9=4096}\nRemoved consumer from rangeMap: {c1=53248, c10=8192, c9=4096}\n\nAs you can see, c1 will take most of the traffic.\nMost likely it will not be able to process all the messages and the backlog builds up.\nModifications\n\nNo functional difference from user perspective\nUse consistent hashing mechanism to assign keys to consumers. This will ensure even distribution without the degradation in the corner cases.\nNumber of points in the ring is configurable, default=100.\nRefactored current unit test. The test are currently duplicating the logic of the implementation and checking the a messages is placed on the bucket for one consumer. Of course it works, since it's the same code executed on both sides. But, instead, the test should focus on the contract of the feature: message should arrive in order, there should be \"decent\" sharing of load across consumers.\n@codelipenghui I've removed the selectByIndex(). In my opinion there's absolutely no difference in efficiency/performance as I've also explained on #6647 (comment). I'm happy to discuss more about it.", "createdAt": "2020-04-22T02:10:05Z", "url": "https://github.com/apache/pulsar/pull/6791", "merged": true, "mergeCommit": {"oid": "4bf8268a2fec78ba451ec517ce5a4e2e3f0a6951"}, "closed": true, "closedAt": "2020-06-01T03:57:53Z", "author": {"login": "merlimat"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaQqrygFqTM5ODY1MzYyMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcm4HShgFqTQyMTU4MDc3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjUzNjIw", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-398653620", "createdAt": "2020-04-22T23:13:12Z", "commit": {"oid": "de02daa34d51b92fe535f3470ad9ab328553fc66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoxMzoxMlrOGKPnyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoxMzoxMlrOGKPnyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NDg5MQ==", "bodyText": "\"numberOfPoints\"", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413394891", "createdAt": "2020-04-22T23:13:12Z", "author": {"login": "jerrypeng"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "diffHunk": "@@ -18,86 +18,64 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n-import org.apache.pulsar.common.util.Murmur3_32Hash;\n-\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n+import org.apache.pulsar.common.util.Murmur3_32Hash;\n \n /**\n  * This is a consumer selector based fixed hash range.\n  *\n- * 1.Each consumer serves a fixed range of hash value\n- * 2.The whole range of hash value could be covered by all the consumers.\n- * 3.Once a consumer is removed, the left consumers could still serve the whole range.\n- *\n- * Initializing with a fixed hash range, by default 2 << 5.\n- * First consumer added, hash range looks like:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * Second consumer added, will find a biggest range to split:\n- *\n- * 0 -> 32768(consumer-2) -> 65536(consumer-1)\n- *\n- * While a consumer removed, The range for this consumer will be taken over\n- * by other consumer, consumer-2 removed:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * In this approach use skip list map to maintain the hash range and consumers.\n- *\n- * Select consumer will return the ceiling key of message key hashcode % range size.\n- *\n+ * The implementation uses consistent hashing to evenly split, the\n+ * number of keys assigned to each consumer.\n  */\n public class HashRangeAutoSplitStickyKeyConsumerSelector implements StickyKeyConsumerSelector {\n \n-    private final int rangeSize;\n+    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n \n-    private final ConcurrentSkipListMap<Integer, Consumer> rangeMap;\n-    private final Map<Consumer, Integer> consumerRange;\n+    // Consistent-Hash ring\n+    private final NavigableMap<Integer, Consumer> hashRing;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector() {\n-        this(DEFAULT_RANGE_SIZE);\n-    }\n+    private final int numberOfPOints;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector(int rangeSize) {\n-        if (rangeSize < 2) {\n-            throw new IllegalArgumentException(\"range size must greater than 2\");\n-        }\n-        if (!is2Power(rangeSize)) {\n-            throw new IllegalArgumentException(\"range size must be nth power with 2\");\n-        }\n-        this.rangeMap = new ConcurrentSkipListMap<>();\n-        this.consumerRange = new HashMap<>();\n-        this.rangeSize = rangeSize;\n+    public HashRangeAutoSplitStickyKeyConsumerSelector(int numberOfPOints) {\n+        this.hashRing = new TreeMap<>();\n+        this.numberOfPOints = numberOfPOints;\n     }\n \n     @Override\n-    public synchronized void addConsumer(Consumer consumer) throws ConsumerAssignException {\n-        if (rangeMap.size() == 0) {\n-            rangeMap.put(rangeSize, consumer);\n-            consumerRange.put(consumer, rangeSize);\n-        } else {\n-            splitRange(findBiggestRange(), consumer);\n+    public void addConsumer(Consumer consumer) throws ConsumerAssignException {\n+        rwLock.writeLock().lock();\n+        try {\n+            // Insert multiple points on the hash ring for every consumer\n+            // The points are deterministically added based on the hash of the consumer name\n+            for (int i = 0; i < numberOfPOints; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de02daa34d51b92fe535f3470ad9ab328553fc66"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjU0MjIy", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-398654222", "createdAt": "2020-04-22T23:14:45Z", "commit": {"oid": "de02daa34d51b92fe535f3470ad9ab328553fc66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoxNDo0NVrOGKPqGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoxNDo0NVrOGKPqGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NTQ4MA==", "bodyText": "When removing consumers from the hash ring, is it necessary to check if the value of the key we are removing is also equals the consumer?  In what case, will that not be true?", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413395480", "createdAt": "2020-04-22T23:14:45Z", "author": {"login": "jerrypeng"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "diffHunk": "@@ -18,86 +18,64 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n-import org.apache.pulsar.common.util.Murmur3_32Hash;\n-\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n+import org.apache.pulsar.common.util.Murmur3_32Hash;\n \n /**\n  * This is a consumer selector based fixed hash range.\n  *\n- * 1.Each consumer serves a fixed range of hash value\n- * 2.The whole range of hash value could be covered by all the consumers.\n- * 3.Once a consumer is removed, the left consumers could still serve the whole range.\n- *\n- * Initializing with a fixed hash range, by default 2 << 5.\n- * First consumer added, hash range looks like:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * Second consumer added, will find a biggest range to split:\n- *\n- * 0 -> 32768(consumer-2) -> 65536(consumer-1)\n- *\n- * While a consumer removed, The range for this consumer will be taken over\n- * by other consumer, consumer-2 removed:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * In this approach use skip list map to maintain the hash range and consumers.\n- *\n- * Select consumer will return the ceiling key of message key hashcode % range size.\n- *\n+ * The implementation uses consistent hashing to evenly split, the\n+ * number of keys assigned to each consumer.\n  */\n public class HashRangeAutoSplitStickyKeyConsumerSelector implements StickyKeyConsumerSelector {\n \n-    private final int rangeSize;\n+    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n \n-    private final ConcurrentSkipListMap<Integer, Consumer> rangeMap;\n-    private final Map<Consumer, Integer> consumerRange;\n+    // Consistent-Hash ring\n+    private final NavigableMap<Integer, Consumer> hashRing;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector() {\n-        this(DEFAULT_RANGE_SIZE);\n-    }\n+    private final int numberOfPOints;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector(int rangeSize) {\n-        if (rangeSize < 2) {\n-            throw new IllegalArgumentException(\"range size must greater than 2\");\n-        }\n-        if (!is2Power(rangeSize)) {\n-            throw new IllegalArgumentException(\"range size must be nth power with 2\");\n-        }\n-        this.rangeMap = new ConcurrentSkipListMap<>();\n-        this.consumerRange = new HashMap<>();\n-        this.rangeSize = rangeSize;\n+    public HashRangeAutoSplitStickyKeyConsumerSelector(int numberOfPOints) {\n+        this.hashRing = new TreeMap<>();\n+        this.numberOfPOints = numberOfPOints;\n     }\n \n     @Override\n-    public synchronized void addConsumer(Consumer consumer) throws ConsumerAssignException {\n-        if (rangeMap.size() == 0) {\n-            rangeMap.put(rangeSize, consumer);\n-            consumerRange.put(consumer, rangeSize);\n-        } else {\n-            splitRange(findBiggestRange(), consumer);\n+    public void addConsumer(Consumer consumer) throws ConsumerAssignException {\n+        rwLock.writeLock().lock();\n+        try {\n+            // Insert multiple points on the hash ring for every consumer\n+            // The points are deterministically added based on the hash of the consumer name\n+            for (int i = 0; i < numberOfPOints; i++) {\n+                String key = consumer.consumerName() + i;\n+                int hash = Murmur3_32Hash.getInstance().makeHash(key.getBytes());\n+                hashRing.put(hash, consumer);\n+            }\n+        } finally {\n+            rwLock.writeLock().unlock();\n         }\n     }\n \n     @Override\n-    public synchronized void removeConsumer(Consumer consumer) {\n-        Integer removeRange = consumerRange.remove(consumer);\n-        if (removeRange != null) {\n-            if (removeRange == rangeSize && rangeMap.size() > 1) {\n-                Map.Entry<Integer, Consumer> lowerEntry = rangeMap.lowerEntry(removeRange);\n-                rangeMap.put(removeRange, lowerEntry.getValue());\n-                rangeMap.remove(lowerEntry.getKey());\n-                consumerRange.put(lowerEntry.getValue(), removeRange);\n-            } else {\n-                rangeMap.remove(removeRange);\n+    public void removeConsumer(Consumer consumer) {\n+        rwLock.writeLock().lock();\n+        try {\n+            // Remove all the points that were added for this consumer\n+            for (int i = 0; i < numberOfPOints; i++) {\n+                String key = consumer.consumerName() + i;\n+                int hash = Murmur3_32Hash.getInstance().makeHash(key.getBytes());\n+                hashRing.remove(hash, consumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de02daa34d51b92fe535f3470ad9ab328553fc66"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjYzOTgx", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-398663981", "createdAt": "2020-04-22T23:39:55Z", "commit": {"oid": "de02daa34d51b92fe535f3470ad9ab328553fc66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzozOTo1NVrOGKQQ0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzozOTo1NVrOGKQQ0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNTM5NQ==", "bodyText": "Why are we deleting this whole test?", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413405395", "createdAt": "2020-04-22T23:39:55Z", "author": {"login": "jerrypeng"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/client/api/NonPersistentKeySharedSubscriptionTest.java", "diffHunk": "@@ -1,482 +0,0 @@\n-/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de02daa34d51b92fe535f3470ad9ab328553fc66"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Njc4NDgy", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-398678482", "createdAt": "2020-04-23T00:21:16Z", "commit": {"oid": "92703ae95717996a52f32bf91950850b2b7647ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjgxMzMx", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-398681331", "createdAt": "2020-04-23T00:30:26Z", "commit": {"oid": "92703ae95717996a52f32bf91950850b2b7647ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Nzc1NjUw", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-398775650", "createdAt": "2020-04-23T05:47:27Z", "commit": {"oid": "92703ae95717996a52f32bf91950850b2b7647ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c5ca21346bc8bcb655964155d56499ae1811699", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/7c5ca21346bc8bcb655964155d56499ae1811699", "committedDate": "2020-05-27T23:25:24Z", "message": "Use consistent hashing in KeyShared distribution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92703ae95717996a52f32bf91950850b2b7647ef", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/92703ae95717996a52f32bf91950850b2b7647ef", "committedDate": "2020-04-22T23:42:33Z", "message": "Fixed variable name case issue"}, "afterCommit": {"oid": "3724dfcac8c12f17d89b26445ca9fd577a646b58", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/3724dfcac8c12f17d89b26445ca9fd577a646b58", "committedDate": "2020-05-27T23:37:25Z", "message": "Added configuration option to enable consistent hashing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf2833c26d87967354150d765e552e63f214e10c", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/bf2833c26d87967354150d765e552e63f214e10c", "committedDate": "2020-05-27T23:53:36Z", "message": "Added configuration option to enable consistent hashing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3724dfcac8c12f17d89b26445ca9fd577a646b58", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/3724dfcac8c12f17d89b26445ca9fd577a646b58", "committedDate": "2020-05-27T23:37:25Z", "message": "Added configuration option to enable consistent hashing"}, "afterCommit": {"oid": "bf2833c26d87967354150d765e552e63f214e10c", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/bf2833c26d87967354150d765e552e63f214e10c", "committedDate": "2020-05-27T23:53:36Z", "message": "Added configuration option to enable consistent hashing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Njk3Njc0", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-419697674", "createdAt": "2020-05-28T00:23:18Z", "commit": {"oid": "bf2833c26d87967354150d765e552e63f214e10c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3fe0b0f2d186cb62a7064d0b7ab0d1cf9727df1", "author": {"user": {"login": "merlimat", "name": "Matteo Merli"}}, "url": "https://github.com/apache/pulsar/commit/d3fe0b0f2d186cb62a7064d0b7ab0d1cf9727df1", "committedDate": "2020-05-29T05:40:36Z", "message": "Merge remote-tracking branch 'apache/master' into key-shared-master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTgwNTA0", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-421580504", "createdAt": "2020-06-01T03:56:34Z", "commit": {"oid": "d3fe0b0f2d186cb62a7064d0b7ab0d1cf9727df1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTgwNzcy", "url": "https://github.com/apache/pulsar/pull/6791#pullrequestreview-421580772", "createdAt": "2020-06-01T03:57:51Z", "commit": {"oid": "d3fe0b0f2d186cb62a7064d0b7ab0d1cf9727df1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3600, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}