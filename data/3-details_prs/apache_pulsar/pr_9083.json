{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2NDg4MjEy", "number": 9083, "title": "Issue 9082: Broker expires messages one at a time after topic unload", "bodyText": "Fixes #9082\nMotivation\nIn case of topic unload the ManagedLedger rolls a new ledger and this confuses the search for messages to be expired.\nThis is how OpFindNewest (the operation involved in message expiry, PersistentMessageExpiryMonitor) works:\n\nfirst check if first message is expired\ntest in the last message\nperform a search...\n\nAt step two we are jumping to a position that is not valid, and the search ends immediately, returning only the first message\nModifications\nEnsure that we are jumping only to a valid position, this change allows the PersistentMessageExpiryMonitor to find the best range of messages to expire.\nVerifying this change\nThis change added tests:\n\nunit test that covers the change\none reproducer for the problem, that now is fixes\nanother test case for the expected end-to-end behaviour for a consumer that waits too much and messages expire\n\nIt can be also verified trying to reproduce manually the reproducer at #9082, after applying this patch the issue is no more reproducible", "createdAt": "2020-12-29T13:35:28Z", "url": "https://github.com/apache/pulsar/pull/9083", "merged": true, "mergeCommit": {"oid": "7313b3403867d5ca16ea68edeaedd42f8c389ad3"}, "closed": true, "closedAt": "2021-01-07T17:44:49Z", "author": {"login": "eolivelli"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdo8fn1gH2gAyNTQ2NDg4MjEyOjhlYTcyMzY2Yzk1Y2ZmNmQ5MTc3OGE5NzZiOWFiODZjOTg0OWFkZTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdt3zENgFqTU2MzY5MjE5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8ea72366c95cff6d91778a976b9ab86c9849ade8", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/8ea72366c95cff6d91778a976b9ab86c9849ade8", "committedDate": "2020-12-23T10:23:03Z", "message": "Message TTL expires 1 message at a time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68e03cc8dd05f64d61f58849cd4b115190406d9e", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/68e03cc8dd05f64d61f58849cd4b115190406d9e", "committedDate": "2020-12-29T12:16:26Z", "message": "Fix message expiration in case of topic unload"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dae9528e5683d5da608c0ce060cd8a6de5ed71b", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/5dae9528e5683d5da608c0ce060cd8a6de5ed71b", "committedDate": "2020-12-29T12:17:20Z", "message": "clean log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d82838bc593ff2255745e4214ddb3a80be08e39", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/9d82838bc593ff2255745e4214ddb3a80be08e39", "committedDate": "2020-12-29T12:54:54Z", "message": "Merge branch 'fix/expire-batch' into fix/expire-more-messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22d814b7caa5d40e7a7d6e14bcf7ea0695f34d90", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/22d814b7caa5d40e7a7d6e14bcf7ea0695f34d90", "committedDate": "2020-12-29T13:21:15Z", "message": "add end-to-end tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b1b02868d5dda63a5d82f896d53513104c1320c", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/0b1b02868d5dda63a5d82f896d53513104c1320c", "committedDate": "2020-12-29T13:23:40Z", "message": "remove debug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "committedDate": "2020-12-29T14:08:53Z", "message": "Add unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjIzOTM1", "url": "https://github.com/apache/pulsar/pull/9083#pullrequestreview-559623935", "createdAt": "2020-12-29T17:09:13Z", "commit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNzowOToxNFrOIMT-LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNzoxNzo1NlrOIMUIvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTAzNg==", "bodyText": "add this to a if (log.isDebugEnabled()) block.", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549781036", "createdAt": "2020-12-29T17:09:14Z", "author": {"login": "sijie"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/OpFindNewest.java", "diffHunk": "@@ -92,10 +94,14 @@ public void readEntryComplete(Entry entry, Object ctx) {\n                 return;\n             } else {\n                 lastMatchedPosition = position;\n-\n                 // check last entry\n                 state = State.checkLast;\n+                PositionImpl lastPosition = ledger.getLastPosition();\n                 searchPosition = ledger.getPositionAfterN(searchPosition, max, PositionBound.startExcluded);\n+                if (lastPosition.compareTo(searchPosition) < 0) {\n+                    log.debug(\"first position {} matches, last should be {}, but moving to lastPos {}\", position, searchPosition, lastPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTUxMg==", "bodyText": "This test doesn't make any sense to me. You are adding 5 entries with the same content.", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549781512", "createdAt": "2020-12-29T17:10:58Z", "author": {"login": "sijie"}, "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/ManagedCursorTest.java", "diffHunk": "@@ -2140,6 +2141,28 @@ void testIndividuallyDeletedMessages3(boolean useOpenRangeSet) throws Exception\n         assertTrue(c1.isIndividuallyDeletedEntriesEmpty());\n     }\n \n+    @Test(timeOut = 20000)\n+    void testFindNewestMatchingAfterLedgerRollover() throws Exception {\n+        ManagedLedgerImpl ledger = (ManagedLedgerImpl) factory.open(\"my_test_ledger\");\n+        ManagedCursorImpl c1 = (ManagedCursorImpl) ledger.openCursor(\"c1\");\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        Position last = ledger.addEntry(\"expired\".getBytes(Encoding));\n+\n+        // roll a new ledger\n+        int numLedgersBefore = ledger.getLedgersInfo().size();\n+        ledger.getConfig().setMaxEntriesPerLedger(1);\n+        ledger.rollCurrentLedgerIfFull();\n+        Awaitility.await().atMost(20, TimeUnit.SECONDS)\n+                .until(() -> ledger.getLedgersInfo().size() > numLedgersBefore);\n+\n+        assertEquals(last,\n+                c1.findNewestMatching(entry -> Arrays.equals(entry.getDataAndRelease(), \"expired\".getBytes(Encoding))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTg4Nw==", "bodyText": "Can we avoid using Thread.sleep?", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549781887", "createdAt": "2020-12-29T17:12:10Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng==", "bodyText": "How does this make the test easier and predictable?", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549782046", "createdAt": "2020-12-29T17:12:46Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjYxNQ==", "bodyText": "You just use this consumer to create a subscription. Why setting receiverQueueSize makes the test easier and predictable?", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549782615", "createdAt": "2020-12-29T17:14:34Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MzY1NQ==", "bodyText": "This doesn't make any sense to me. It will result in the test waiting for 10 seconds.\nA deterministic approach is using getLastMessageId to check if the messages are expired.", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549783655", "createdAt": "2020-12-29T17:17:38Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4Mzc0Mw==", "bodyText": "Same comment as above.", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549783743", "createdAt": "2020-12-29T17:17:56Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);\n+        assertNull(msg);\n+        consumer.close();\n+    }\n+\n+    \n+    @Test\n+    public void testStandardMessageExpiry() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(subscriptionName)\n+                .subscriptionType(SubscriptionType.Key_Shared) // this has not effect, Exclusive mode works as well\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);\n+        assertNotNull(msg);\n+        consumer.acknowledge(msg);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        this.runMessageExpiryCheck();\n+        \n+        Message<byte[]> msg2 = consumer.receive(1, java.util.concurrent.TimeUnit.SECONDS);\n+        // the consumer prefetched a message (or a batch of messages in case of enableBatching(true))\n+        assertNotNull(msg);\n+        consumer.acknowledge(msg2);\n+        // all messages expired, so we expect to see a null here\n+        Message<byte[]> msg3 = consumer.receive(1, java.util.concurrent.TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c9c6f141f0f75aac110cb7ec668d4a708e7485b", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/8c9c6f141f0f75aac110cb7ec668d4a708e7485b", "committedDate": "2020-12-29T17:41:35Z", "message": "Address part of Sijie's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjMxMjcx", "url": "https://github.com/apache/pulsar/pull/9083#pullrequestreview-559631271", "createdAt": "2020-12-29T17:29:40Z", "commit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNzoyOTo0MVrOIMUXSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNzo0MToxNFrOIMUkoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4NzQ2Nw==", "bodyText": "it is the same thing that happens with \"expired\" messages.\nIf you have all of the messages \"expired\" the condition evaluates to true for every message (\"message is expired\"), and in that case findNewestMatching must return the last message in the topic.", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549787467", "createdAt": "2020-12-29T17:29:41Z", "author": {"login": "eolivelli"}, "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/ManagedCursorTest.java", "diffHunk": "@@ -2140,6 +2141,28 @@ void testIndividuallyDeletedMessages3(boolean useOpenRangeSet) throws Exception\n         assertTrue(c1.isIndividuallyDeletedEntriesEmpty());\n     }\n \n+    @Test(timeOut = 20000)\n+    void testFindNewestMatchingAfterLedgerRollover() throws Exception {\n+        ManagedLedgerImpl ledger = (ManagedLedgerImpl) factory.open(\"my_test_ledger\");\n+        ManagedCursorImpl c1 = (ManagedCursorImpl) ledger.openCursor(\"c1\");\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        Position last = ledger.addEntry(\"expired\".getBytes(Encoding));\n+\n+        // roll a new ledger\n+        int numLedgersBefore = ledger.getLedgersInfo().size();\n+        ledger.getConfig().setMaxEntriesPerLedger(1);\n+        ledger.rollCurrentLedgerIfFull();\n+        Awaitility.await().atMost(20, TimeUnit.SECONDS)\n+                .until(() -> ledger.getLedgersInfo().size() > numLedgersBefore);\n+\n+        assertEquals(last,\n+                c1.findNewestMatching(entry -> Arrays.equals(entry.getDataAndRelease(), \"expired\".getBytes(Encoding))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTUxMg=="}, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4NzYzNQ==", "bodyText": "it is only a copy/paste from the test below. I will drop this line, it does not matter", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549787635", "createdAt": "2020-12-29T17:30:15Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjYxNQ=="}, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4NzkyOA==", "bodyText": "because I want to see that the Consumer pre-fetched one message, and so it can \"see\" an expired message,\nthis is what happens and I want to test it in order to prevent behaviour changes in the future.", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549787928", "createdAt": "2020-12-29T17:31:17Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng=="}, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4OTUzMg==", "bodyText": "I cannot do it, because with this sleep all of the messages will be considered \"expired\"\nAKAIF there is no framework/tool in Pulsar Codebase to simulate wall clock time, if we want to do something better we will have to introduce it.\nProbably it is overkill for this patch.\nIn this case we are not \"waiting\" for something, we just have to let the time pass (so Awaitility won't help).", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549789532", "createdAt": "2020-12-29T17:36:40Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTg4Nw=="}, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc5MDg4MQ==", "bodyText": "I am not sure I understand, getLastMessageId is returning a non-null MessageId here", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549790881", "createdAt": "2020-12-29T17:41:14Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MzY1NQ=="}, "originalCommit": {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24a06b4c78ee66903f856d036e70b923d7075edb", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/24a06b4c78ee66903f856d036e70b923d7075edb", "committedDate": "2020-12-29T17:43:06Z", "message": "decrease timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca", "committedDate": "2020-12-30T11:22:04Z", "message": "address more comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMDEwMTIz", "url": "https://github.com/apache/pulsar/pull/9083#pullrequestreview-560010123", "createdAt": "2020-12-30T11:26:44Z", "commit": {"oid": "f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxMToyNjo0NFrOIMrLZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxMToyNjo0NFrOIMrLZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE2MTI1NA==", "bodyText": "these two values are the same, even if the messages are expired", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550161254", "createdAt": "2020-12-30T11:26:44Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+\n+        pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .subscribe()\n+                .close();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+\n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        MessageId lastMessageId = sendFutureList.get(sendFutureList.size() - 1).get();\n+\n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);\n+        admin.topics().getStats(topicName);\n+\n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        // wall clock time, we have to make the message to be considered \"expired\"\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .subscribe();\n+\n+        MessageId lastMessageIdOnConsumer = consumer.getLastMessageId();\n+        log.info(\"lastMessageID written {}, lastMessageIdForConsumer {}\", lastMessageId, lastMessageIdOnConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e78c0bb3956acf0fe7acc8a405261fea101afe82", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/e78c0bb3956acf0fe7acc8a405261fea101afe82", "committedDate": "2021-01-05T09:51:21Z", "message": "Merge remote-tracking branch 'origin/master' into fix/expire-more-messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf927dd0b88b2ebc1505f629259085d0ea058068", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/cf927dd0b88b2ebc1505f629259085d0ea058068", "committedDate": "2021-01-07T07:58:23Z", "message": "Merge remote-tracking branch 'origin/master' into fix/expire-more-messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20ddd5f7edd44035aa15f43200bd7f854239fa6b", "author": {"user": {"login": "eolivelli", "name": "Enrico Olivelli"}}, "url": "https://github.com/apache/pulsar/commit/20ddd5f7edd44035aa15f43200bd7f854239fa6b", "committedDate": "2021-01-07T08:29:50Z", "message": "Enhance test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNjkyMTky", "url": "https://github.com/apache/pulsar/pull/9083#pullrequestreview-563692192", "createdAt": "2021-01-07T17:44:23Z", "commit": {"oid": "20ddd5f7edd44035aa15f43200bd7f854239fa6b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 864, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}