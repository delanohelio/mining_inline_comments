{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1Mjc0ODkz", "number": 8881, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzozOTo0N1rOFPAsdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQxMjowMDowMFrOF9Ye_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjg0MzQzOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/generate_protobuf.sh", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzozOTo0N1rOIUG8hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzozOTo0N1rOIUG8hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1NjIyOA==", "bodyText": "why do we need this file ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557956228", "createdAt": "2021-01-15T07:39:47Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/generate_protobuf.sh", "diffHunk": "@@ -0,0 +1,23 @@\n+#!/usr/bin/env bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+\n+\n+PROTOC=${PROTOC:-protoc}\n+${PROTOC} --java_out=pulsar-broker/src/main/java pulsar-broker/src/main/proto/TransactionPendingAck.proto", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjg0NDEwOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/generate_protobuf_docker.sh", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzozOTo1M1rOIUG87w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzozOTo1M1rOIUG87w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1NjMzNQ==", "bodyText": "why do we need this file ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557956335", "createdAt": "2021-01-15T07:39:53Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/generate_protobuf_docker.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+\n+# Fail script in case of errors\n+set -e\n+\n+ROOT_DIR=$(git rev-parse --show-toplevel)\n+COMMON_DIR=$ROOT_DIR/\n+cd $COMMON_DIR\n+\n+BUILD_IMAGE_NAME=\"${BUILD_IMAGE_NAME:-apachepulsar/pulsar-build}\"\n+BUILD_IMAGE_VERSION=\"${BUILD_IMAGE_VERSION:-ubuntu-16.04}\"\n+\n+IMAGE=\"$BUILD_IMAGE_NAME:$BUILD_IMAGE_VERSION\"\n+\n+echo $IMAGE\n+\n+# Force to pull image in case it was updated\n+docker pull $IMAGE\n+\n+WORKDIR=/workdir\n+docker run -i \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjg1NzQ5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0MTozOVrOIUHF3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0MTozOVrOIUHF3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1ODYyMw==", "bodyText": "can we add checkIdReady to PendingAckHandle ?\nusing instanceof is not a good practice, we should leverage polymorphism", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557958623", "createdAt": "2021-01-15T07:41:39Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java", "diffHunk": "@@ -161,6 +162,12 @@ void setReplicated(boolean replicated) {\n \n     @Override\n     public synchronized void addConsumer(Consumer consumer) throws BrokerServiceException {\n+        if (pendingAckHandle instanceof PendingAckHandleImpl) {\n+            if (!((PendingAckHandleImpl) pendingAckHandle).checkIfReady()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjg2NjcyOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0Mjo1NlrOIUHMMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNVQwNjoyMDo0OFrOJPDCfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDI0Mw==", "bodyText": "how many times is this method supposed to be called ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557960243", "createdAt": "2021-01-15T07:42:56Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();\n+\n+    /**\n+     * Handle metadata entry.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1ODIwNg==", "bodyText": "handle pending ack log. invoke as many times as there have entry have to be recover.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619758206", "createdAt": "2021-04-25T06:20:48Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();\n+\n+    /**\n+     * Handle metadata entry.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDI0Mw=="}, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjg2ODU1OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0MzoxMVrOIUHNeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNVQwNjoyNDozMFrOJPDEBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDU2OQ==", "bodyText": "is there any way to receive notification of a failure ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557960569", "createdAt": "2021-01-15T07:43:11Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1ODU5Ng==", "bodyText": "it can't fail, unless metadata is corrupted", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619758596", "createdAt": "2021-04-25T06:24:30Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDU2OQ=="}, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjkwNjAxOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo0ODowNVrOIUHmXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNVQwNjoyNTozOFrOJPDEcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2Njk0MA==", "bodyText": "is this expected to happen inside the scheduledExecutorService ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557966940", "createdAt": "2021-01-15T07:48:05Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * In memory implementation of {@link PendingAckStore}.\n+ */\n+public class InMemoryPendingAckStore implements PendingAckStore {\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService scheduledExecutorService) {\n+        pendingAckHandle.changeToReadyState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1ODcwNA==", "bodyText": "InMemoryPendingAckStore.java don't need replay.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619758704", "createdAt": "2021-04-25T06:25:38Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * In memory implementation of {@link PendingAckStore}.\n+ */\n+public class InMemoryPendingAckStore implements PendingAckStore {\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService scheduledExecutorService) {\n+        pendingAckHandle.changeToReadyState();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2Njk0MA=="}, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjkyODEyOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo1MTowMlrOIUH1Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo1MTowMlrOIUH1Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3MDcxNQ==", "bodyText": "this is not good,\nthe contract is to exit the current activity in case of InterrupedException or at least set Thread.interrupted flag", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557970715", "createdAt": "2021-01-15T07:51:02Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjk2NjkxOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo1NToxMFrOIUIQQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNVQwNjoyNzo0NlrOJPDFmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3NzY2NA==", "bodyText": "what is the recovery story for this error ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557977664", "createdAt": "2021-01-15T07:55:10Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op\n+                    }\n+                }\n+            }\n+            pendingAckReplyCallBack.replayComplete();\n+        }\n+    }\n+\n+    class FillEntryQueueCallback implements AsyncCallbacks.ReadEntriesCallback {\n+\n+        private final AtomicLong outstandingReadsRequests = new AtomicLong(0);\n+\n+        public FillEntryQueueCallback() {\n+        }\n+\n+        void fillQueue() {\n+            if (entryQueue.size() < entryQueue.capacity() && outstandingReadsRequests.get() == 0) {\n+                if (cursor.hasMoreEntries()) {\n+                    outstandingReadsRequests.incrementAndGet();\n+                    readAsync(100, this);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n+            entryQueue.fill(new MessagePassingQueue.Supplier<Entry>() {\n+                private int i = 0;\n+                @Override\n+                public Entry get() {\n+                    Entry entry = entries.get(i);\n+                    i++;\n+                    return entry;\n+                }\n+            }, entries.size());\n+\n+            outstandingReadsRequests.decrementAndGet();\n+        }\n+\n+        @Override\n+        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n+            log.error(\"MLPendingAckStore stat reply fail!\", exception);\n+            outstandingReadsRequests.decrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1OTAwMw==", "bodyText": "read pending ack entry fail", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619759003", "createdAt": "2021-04-25T06:27:46Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op\n+                    }\n+                }\n+            }\n+            pendingAckReplyCallBack.replayComplete();\n+        }\n+    }\n+\n+    class FillEntryQueueCallback implements AsyncCallbacks.ReadEntriesCallback {\n+\n+        private final AtomicLong outstandingReadsRequests = new AtomicLong(0);\n+\n+        public FillEntryQueueCallback() {\n+        }\n+\n+        void fillQueue() {\n+            if (entryQueue.size() < entryQueue.capacity() && outstandingReadsRequests.get() == 0) {\n+                if (cursor.hasMoreEntries()) {\n+                    outstandingReadsRequests.incrementAndGet();\n+                    readAsync(100, this);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n+            entryQueue.fill(new MessagePassingQueue.Supplier<Entry>() {\n+                private int i = 0;\n+                @Override\n+                public Entry get() {\n+                    Entry entry = entries.get(i);\n+                    i++;\n+                    return entry;\n+                }\n+            }, entries.size());\n+\n+            outstandingReadsRequests.decrementAndGet();\n+        }\n+\n+        @Override\n+        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n+            log.error(\"MLPendingAckStore stat reply fail!\", exception);\n+            outstandingReadsRequests.decrementAndGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3NzY2NA=="}, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMjk4OTc1OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo1NzoxOVrOIUIgIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzo1NzoxOVrOIUIgIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk4MTcyOQ==", "bodyText": "what about creating a method in parent class MLPendingAckStoreProvider\nvoid ensureTimer() {\n     if (timer == null) {\n         synchronized(this) {\n             initialize();  \n       }\n    }\n}\n\nIMHO code will be more readable", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557981729", "createdAt": "2021-01-15T07:57:19Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreProvider.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timer;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.pulsar.broker.service.persistent.PersistentSubscription;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.TransactionPendingAckStoreProvider;\n+import org.apache.pulsar.broker.transaction.pendingack.exceptions.TransactionPendingAckStoreProviderException;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n+import org.apache.pulsar.common.naming.TopicName;\n+\n+/**\n+ * Provider is for MLPendingAckStore.\n+ */\n+@Slf4j\n+public class MLPendingAckStoreProvider implements TransactionPendingAckStoreProvider {\n+\n+    private volatile Timer timer;\n+\n+    private static final long tickTimeMillis = 1L;\n+\n+    @Override\n+    public CompletableFuture<PendingAckStore> newPendingAckStore(PersistentSubscription subscription) {\n+        CompletableFuture<PendingAckStore> pendingAckStoreFuture = new CompletableFuture<>();\n+\n+        if (subscription == null) {\n+            pendingAckStoreFuture.completeExceptionally(\n+                    new TransactionPendingAckStoreProviderException(\"The subscription is null.\"));\n+            return pendingAckStoreFuture;\n+        }\n+\n+        PersistentTopic originPersistentTopic = (PersistentTopic) subscription.getTopic();\n+        String pendingAckTopicName = MLPendingAckStore\n+                .getTransactionPendingAckStoreSuffix(originPersistentTopic.getName(), subscription.getName());\n+\n+        originPersistentTopic.getBrokerService().getManagedLedgerFactory()\n+                .asyncOpen(TopicName.get(pendingAckTopicName).getPersistenceNamingEncoding(),\n+                        new AsyncCallbacks.OpenLedgerCallback() {\n+                            @Override\n+                            public void openLedgerComplete(ManagedLedger ledger, Object ctx) {\n+                                ledger.asyncOpenCursor(MLPendingAckStore.getTransactionPendingAckStoreCursorName(),\n+                                        InitialPosition.Earliest, new AsyncCallbacks.OpenCursorCallback() {\n+                                            @Override\n+                                            public void openCursorComplete(ManagedCursor cursor, Object ctx) {\n+                                                if (timer == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzAzNzc0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreTimerTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODowMTo0OVrOIUJBLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODowMTo0OVrOIUJBLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk5MDE4OQ==", "bodyText": "this is very error prone,\ncan we detect an instance of a specific class of exception ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557990189", "createdAt": "2021-01-15T08:01:49Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreTimerTask.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.Timeout;\n+import io.netty.util.Timer;\n+import io.netty.util.TimerTask;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Pending ack timer task.\n+ */\n+@Slf4j\n+public class MLPendingAckStoreTimerTask implements TimerTask {\n+\n+    private int intervalTime;\n+\n+    private final int maxIntervalTime;\n+\n+    private final int minIntervalTime;\n+\n+    private final ManagedCursorImpl subManagedCursor;\n+\n+    private final ManagedLedgerImpl storeManagedLedger;\n+\n+    private final ManagedCursorImpl managedCursor;\n+\n+    private final Timer timer;\n+\n+    private volatile PositionImpl markDeletePosition;\n+\n+    public MLPendingAckStoreTimerTask(ManagedCursor managedCursor, ManagedLedger storeManagedLedger,\n+                                      int maxIntervalTime, int minIntervalTime,\n+                                      ManagedCursor subManageCursor, Timer timer) {\n+        this.intervalTime = minIntervalTime;\n+        this.maxIntervalTime = maxIntervalTime;\n+        this.minIntervalTime = minIntervalTime;\n+        this.managedCursor = (ManagedCursorImpl) managedCursor;\n+        this.subManagedCursor = (ManagedCursorImpl) subManageCursor;\n+        this.storeManagedLedger = (ManagedLedgerImpl) storeManagedLedger;\n+        this.markDeletePosition = (PositionImpl) managedCursor.getMarkDeletedPosition();\n+        this.timer = timer;\n+    }\n+\n+    @Override\n+    public void run(Timeout timeout) {\n+        if (this.managedCursor.getState().equals(\"Closed\")) {\n+            return;\n+        }\n+        try {\n+            // when no transaction ack operation in this pending ack store, it will increase the interval time\n+            if (markDeletePosition.compareTo((PositionImpl) storeManagedLedger.getLastConfirmedEntry()) == 0) {\n+                int time = intervalTime + minIntervalTime;\n+                if (time > maxIntervalTime) {\n+                    intervalTime = maxIntervalTime;\n+                } else {\n+                    intervalTime = time;\n+                }\n+                managedCursor.markDelete(markDeletePosition);\n+                timer.newTimeout(MLPendingAckStoreTimerTask.this, intervalTime, TimeUnit.SECONDS);\n+                return;\n+            } else {\n+                int time = intervalTime - minIntervalTime;\n+                if (time < minIntervalTime) {\n+                    intervalTime = minIntervalTime;\n+                } else {\n+                    intervalTime = time;\n+                }\n+            }\n+            // this while in order to find the last position witch can mark delete\n+            while (true) {\n+                PositionImpl nextPosition = storeManagedLedger.getNextValidPosition(markDeletePosition);\n+                Entry entry = getEntry(nextPosition).get();\n+                ByteBuf buffer = entry.getDataBuffer();\n+                ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                        PendingAckMetadataEntry.newBuilder();\n+                PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                try {\n+                    pendingAckMetadataEntry =\n+                            pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                    switch (pendingAckMetadataEntry.getPendingAckOp()) {\n+                        case ACK:\n+                            if (pendingAckMetadataEntry.getAckType() == AckType.Cumulative) {\n+                                PendingAckMetadata pendingAckMetadata =\n+                                        pendingAckMetadataEntry.getPendingAckMetadata(0);\n+                                handleAckCommon(PositionImpl.get(pendingAckMetadata.getLedgerId(),\n+                                        pendingAckMetadata.getEntryId()), nextPosition);\n+                            } else {\n+                                //this judge the pendingAckMetadataEntry is can delete\n+                                PositionImpl largestPosition = null;\n+                                List<PendingAckMetadata> metadataList =\n+                                        pendingAckMetadataEntry.getPendingAckMetadataList();\n+                                for (int i = 0; i < metadataList.size(); i++) {\n+                                    PendingAckMetadata pendingAckMetadata = metadataList.get(0);\n+                                    if (largestPosition == null) {\n+                                        largestPosition = PositionImpl.get(pendingAckMetadata.getLedgerId(),\n+                                                pendingAckMetadata.getEntryId());\n+                                    } else {\n+                                        PositionImpl comparePosition = PositionImpl\n+                                                .get(pendingAckMetadata.getLedgerId(),\n+                                                        pendingAckMetadata.getEntryId());\n+                                        if (largestPosition.compareTo(comparePosition) <  0) {\n+                                            largestPosition = comparePosition;\n+                                        }\n+\n+                                    }\n+                                }\n+                                if (largestPosition != null) {\n+                                    handleAckCommon(largestPosition, nextPosition);\n+                                }\n+                            }\n+                            break;\n+                        case ABORT:\n+                        case COMMIT:\n+                            markDeletePosition = nextPosition;\n+                            break;\n+                        default:\n+                            log.error(\"PendingAck timer task read illegal metadata state! {}\",\n+                                    pendingAckMetadataEntry.getPendingAckOp());\n+                    }\n+                } finally {\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                }\n+                // when markDeletePosition is not nextPosition, before markDeletePosition can delete\n+                if (markDeletePosition != nextPosition) {\n+                    this.managedCursor.markDelete(markDeletePosition);\n+                    break;\n+                }\n+            }\n+            this.timer.newTimeout(this, intervalTime, TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            log.error(\"PendingAck timer task error!\", e);\n+            if (\"Cursor was already closed\".equals(e.getCause().getMessage())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk5MTQxOTEzOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMVQwMTozMjoyOVrOJYnJkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQxMjoyNDowOVrOJZwpMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzAyNQ==", "bodyText": "Why do we need to catch the exception here? If the exception occurs, you already have .exceptionally to deal with this.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629787025", "createdAt": "2021-05-11T01:32:29Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -265,13 +265,23 @@ public void removeProducer(Producer producer) {\n \n         NonPersistentSubscription subscription = subscriptions.computeIfAbsent(subscriptionName,\n                 name -> new NonPersistentSubscription(this, subscriptionName));\n-\n-        try {\n-            Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n-                    cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n-            addConsumerToSubscription(subscription, consumer);\n+        Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n+                cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n+        addConsumerToSubscription(subscription, consumer).thenAccept(v -> {\n             if (!cnx.isActive()) {\n-                consumer.close();\n+                try {\n+                    consumer.close();\n+                } catch (BrokerServiceException e) {\n+                    if (e instanceof ConsumerBusyException) {\n+                        log.warn(\"[{}][{}] Consumer {} {} already connected\", topic, subscriptionName, consumerId,\n+                                consumerName);\n+                    } else if (e instanceof SubscriptionBusyException) {\n+                        log.warn(\"[{}][{}] {}\", topic, subscriptionName, e.getMessage());\n+                    }\n+\n+                    decrementUsageCount();\n+                    future.completeExceptionally(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDk5MTE1NA==", "bodyText": "the close is Is a synchronous method, so we should catch the exception.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r630991154", "createdAt": "2021-05-12T12:24:09Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -265,13 +265,23 @@ public void removeProducer(Producer producer) {\n \n         NonPersistentSubscription subscription = subscriptions.computeIfAbsent(subscriptionName,\n                 name -> new NonPersistentSubscription(this, subscriptionName));\n-\n-        try {\n-            Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n-                    cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n-            addConsumerToSubscription(subscription, consumer);\n+        Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n+                cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n+        addConsumerToSubscription(subscription, consumer).thenAccept(v -> {\n             if (!cnx.isActive()) {\n-                consumer.close();\n+                try {\n+                    consumer.close();\n+                } catch (BrokerServiceException e) {\n+                    if (e instanceof ConsumerBusyException) {\n+                        log.warn(\"[{}][{}] Consumer {} {} already connected\", topic, subscriptionName, consumerId,\n+                                consumerName);\n+                    } else if (e instanceof SubscriptionBusyException) {\n+                        log.warn(\"[{}][{}] {}\", topic, subscriptionName, e.getMessage());\n+                    }\n+\n+                    decrementUsageCount();\n+                    future.completeExceptionally(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzAyNQ=="}, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk5MTQyMjE2OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMVQwMTozNDoxN1rOJYnLkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMVQwMTozNDoxN1rOJYnLkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzUzOQ==", "bodyText": "It's better to get the Cause first and use it in the followings.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629787539", "createdAt": "2021-05-11T01:34:17Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -282,17 +292,18 @@ public void removeProducer(Producer producer) {\n                 log.info(\"[{}][{}] Created new subscription for {}\", topic, subscriptionName, consumerId);\n                 future.complete(consumer);\n             }\n-        } catch (BrokerServiceException e) {\n-            if (e instanceof ConsumerBusyException) {\n+        }).exceptionally(e -> {\n+            if (e.getCause() instanceof ConsumerBusyException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk5MTQyNTg4OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMVQwMTozNjowMFrOJYnNqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMVQwMTozNjowMFrOJYnNqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4ODA3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n          \n          \n            \n                private static final String PENDING_ACK_STORE_CURSOR_NAME = \"__pending_ack_state\";", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629788074", "createdAt": "2021-05-11T01:36:00Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import com.google.common.collect.ComparisonChain;\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.service.BrokerServiceException.PersistenceException;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk5OTA4NjA0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQxMjowMDowMFrOJZvrZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQxMjowMDowMFrOJZvrZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDk3NTMzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";\n          \n          \n            \n                public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pending_ack\";", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r630975335", "createdAt": "2021-05-12T12:00:00Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import com.google.common.collect.ComparisonChain;\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.service.BrokerServiceException.PersistenceException;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa50b7444daa3bc572fb926499672b55f56198e5"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2673, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}