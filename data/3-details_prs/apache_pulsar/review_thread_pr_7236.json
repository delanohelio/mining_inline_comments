{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNjAxOTc4", "number": 7236, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToxNjoxMlrOEEgnJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToyMTo1NlrOEEgqsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTY0MDcxOnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToxNjoxMlrOGiLUyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToxNjoxMlrOGiLUyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MDMxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    long firstNonDeletedLedger = ledgers\n          \n          \n            \n                            .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);\n          \n          \n            \n                    long firstNonDeletedLedger = ledgers\n          \n          \n            \n                            .higherKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId());", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r438490315", "createdAt": "2020-06-11T01:16:12Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "diffHunk": "@@ -2125,6 +2128,37 @@ public void operationFailed(MetaStoreException e) {\n         }\n     }\n \n+    /**\n+     * Non-durable cursors have to be moved forward when data is trimmed since they are not retain that data.\n+     * This is to make sure that the `consumedEntries` counter is correctly updated with the number of skipped\n+     * entries and the stats are reported correctly.\n+     */\n+    private void advanceNonDurableCursors(List<LedgerInfo> ledgersToDelete) {\n+        if (ledgersToDelete.isEmpty()) {\n+            return;\n+        }\n+\n+        long firstNonDeletedLedger = ledgers\n+                .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTY0MjQ0OnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToxNzoxNFrOGiLV0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxODo1NlrOGirUSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MDU3Ng==", "bodyText": "Shall we need to add check for non-durable cursor?", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r438490576", "createdAt": "2020-06-11T01:17:14Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "diffHunk": "@@ -2125,6 +2128,37 @@ public void operationFailed(MetaStoreException e) {\n         }\n     }\n \n+    /**\n+     * Non-durable cursors have to be moved forward when data is trimmed since they are not retain that data.\n+     * This is to make sure that the `consumedEntries` counter is correctly updated with the number of skipped\n+     * entries and the stats are reported correctly.\n+     */\n+    private void advanceNonDurableCursors(List<LedgerInfo> ledgersToDelete) {\n+        if (ledgersToDelete.isEmpty()) {\n+            return;\n+        }\n+\n+        long firstNonDeletedLedger = ledgers\n+                .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);\n+        PositionImpl highestPositionToDelete = new PositionImpl(firstNonDeletedLedger, -1);\n+\n+        cursors.forEach(cursor -> {\n+            if (highestPositionToDelete.compareTo((PositionImpl) cursor.getMarkDeletedPosition()) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDQ3NA==", "bodyText": "No need for that, a durable cursor would have been already moved ahead, otherwise we wouldn't be trimming that ledger.", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r439014474", "createdAt": "2020-06-11T19:18:56Z", "author": {"login": "merlimat"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "diffHunk": "@@ -2125,6 +2128,37 @@ public void operationFailed(MetaStoreException e) {\n         }\n     }\n \n+    /**\n+     * Non-durable cursors have to be moved forward when data is trimmed since they are not retain that data.\n+     * This is to make sure that the `consumedEntries` counter is correctly updated with the number of skipped\n+     * entries and the stats are reported correctly.\n+     */\n+    private void advanceNonDurableCursors(List<LedgerInfo> ledgersToDelete) {\n+        if (ledgersToDelete.isEmpty()) {\n+            return;\n+        }\n+\n+        long firstNonDeletedLedger = ledgers\n+                .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);\n+        PositionImpl highestPositionToDelete = new PositionImpl(firstNonDeletedLedger, -1);\n+\n+        cursors.forEach(cursor -> {\n+            if (highestPositionToDelete.compareTo((PositionImpl) cursor.getMarkDeletedPosition()) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MDU3Ng=="}, "originalCommit": {"oid": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTY0OTc3OnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/NonDurableCursorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToyMTo1NlrOGiLaVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxODo0OVrOGirUFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MTczNQ==", "bodyText": "Why durable cursor has 5 backlogs, non-durable cursor has 6 backlogs? Shouldn't they be the same?", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r438491735", "createdAt": "2020-06-11T01:21:56Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/NonDurableCursorTest.java", "diffHunk": "@@ -678,6 +681,48 @@ public void testGetSlowestConsumer() throws Exception {\n         ledger.close();\n     }\n \n+    @Test\n+    public void testBacklogStatsWhenDroppingData() throws Exception {\n+        ManagedLedgerImpl ledger = (ManagedLedgerImpl) factory.open(\"testBacklogStatsWhenDroppingData\",\n+                new ManagedLedgerConfig().setMaxEntriesPerLedger(1));\n+        ManagedCursor c1 = ledger.openCursor(\"c1\");\n+        ManagedCursor nonDurableCursor = ledger.newNonDurableCursor(PositionImpl.earliest);\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 0);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 0);\n+\n+        List<Position> positions = Lists.newArrayList();\n+        for (int i = 0; i < 10; i++) {\n+            positions.add(ledger.addEntry((\"entry-\" + i).getBytes(UTF_8)));\n+        }\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 10);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 10);\n+\n+        c1.markDelete(positions.get(4));\n+        assertEquals(c1.getNumberOfEntries(), 5);\n+        assertEquals(c1.getNumberOfEntriesInBacklog(true), 5);\n+\n+        // Since the durable cursor has moved, the data will be trimmed\n+        CompletableFuture<Void> promise = new CompletableFuture<>();\n+        ledger.internalTrimConsumedLedgers(promise);\n+        promise.join();\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 6);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDQyMQ==", "bodyText": "That's because the other cursor is positioned at the end of the 5th ledger, but not on the 6th. That means that only 4 ledgers are deleted. That cursor would move forward on the next mark-delete.\nWhen advancing the non-durable cursor, we advance to the first available ledger and that might be before the durable cursor mark-delete position, but that's ok.", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r439014421", "createdAt": "2020-06-11T19:18:49Z", "author": {"login": "merlimat"}, "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/NonDurableCursorTest.java", "diffHunk": "@@ -678,6 +681,48 @@ public void testGetSlowestConsumer() throws Exception {\n         ledger.close();\n     }\n \n+    @Test\n+    public void testBacklogStatsWhenDroppingData() throws Exception {\n+        ManagedLedgerImpl ledger = (ManagedLedgerImpl) factory.open(\"testBacklogStatsWhenDroppingData\",\n+                new ManagedLedgerConfig().setMaxEntriesPerLedger(1));\n+        ManagedCursor c1 = ledger.openCursor(\"c1\");\n+        ManagedCursor nonDurableCursor = ledger.newNonDurableCursor(PositionImpl.earliest);\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 0);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 0);\n+\n+        List<Position> positions = Lists.newArrayList();\n+        for (int i = 0; i < 10; i++) {\n+            positions.add(ledger.addEntry((\"entry-\" + i).getBytes(UTF_8)));\n+        }\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 10);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 10);\n+\n+        c1.markDelete(positions.get(4));\n+        assertEquals(c1.getNumberOfEntries(), 5);\n+        assertEquals(c1.getNumberOfEntriesInBacklog(true), 5);\n+\n+        // Since the durable cursor has moved, the data will be trimmed\n+        CompletableFuture<Void> promise = new CompletableFuture<>();\n+        ledger.internalTrimConsumedLedgers(promise);\n+        promise.join();\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 6);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 6);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MTczNQ=="}, "originalCommit": {"oid": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2493, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}