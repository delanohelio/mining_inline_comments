{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMzE5MDMz", "number": 8125, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjozNDowOFrOFZPKEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wNlQxMjoxMDo0MVrOGrIv_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDA3MDU4OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjozNDowOFrOIjq9xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwODoxMjoxNVrOIoxPMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NTAxMg==", "bodyText": "Can we avoid using a static variable here?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574275012", "createdAt": "2021-02-11T06:34:08Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMDY1OA==", "bodyText": "Moved it into PulsarService as non-static variable.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579620658", "createdAt": "2021-02-20T08:12:15Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NTAxMg=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDA3NTcwOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjozNjo1MVrOIjrAgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwODoxNToyMFrOIoxQog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NTcxMw==", "bodyText": "If there is no key schema, we should just use the value schema. We don't need to use KeyValueSchema.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574275713", "createdAt": "2021-02-11T06:36:51Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =\n+            new ConcurrentOpenHashMap<>();\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    protected  void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (owningTopics.containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // if we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo =\n+                            KeyValueSchemaInfo.decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToMultiplePartitions(topicName, request, owningTopics.get(topic), asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((owningTopics.containsKey(topic) && owningTopics.get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo = KeyValueSchemaInfo\n+                            .decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToSinglePartition(topicName, request, partition, asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                owningTopics.get(topicName.getPartitionedTopicName()).remove(topicName.getPartitionIndex());\n+            } else {\n+                t.get().publishMessage(messageToByteBuf(message),\n+                RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    private void publishMessagesToSinglePartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  KeyValueSchema keyValueSchema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void publishMessagesToMultiplePartitions(TopicName topicName, ProducerMessages request,\n+                                                     ConcurrentOpenHashSet<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, KeyValueSchema keyValueSchema,\n+                                                     SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            List<Integer> owningPartitions = partitionIndexes.values();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(owningPartitions.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(owningPartitions\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                    messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            e.printStackTrace();\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    owningTopics.remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic.\n+    // Return if asyncResponse has been completed.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+            // that own partition of the topic or know who own partition of the topic.\n+            if (!owningTopics.containsKey(topicName.getPartitionedTopicName())) {\n+                if (redirectAddresses.isEmpty()) {\n+                    // No broker to redirect, means look up for some partitions failed,\n+                    // client should retry with other brokers.\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                    future.complete(true);\n+                } else {\n+                    // Redirect client to other broker owns the topic or know which broker own the topic.\n+                    try {\n+                        URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath()));\n+                        asyncResponse.resume(Response.temporaryRedirect(redirectURI));\n+                        future.complete(true);\n+                    } catch (URISyntaxException | NullPointerException e) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                        asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                \"Fail to redirect client request.\"));\n+                        future.complete(true);\n+                    }\n+                }\n+            } else {\n+                future.complete(false);\n+            }\n+        }).exceptionally(e -> {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to look up topic: \" + e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Error look up topic: \"\n+                    + e.getLocalizedMessage()));\n+            future.complete(true);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                pulsar().getBrokerService().getLookupRequestSemaphore().release();\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                owningTopics.computeIfAbsent(partitionedTopicName.getPartitionedTopicName(),\n+                        (key) -> new ConcurrentOpenHashSet<Integer>()).add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            log.warn(\"Failed to lookup broker with rest produce message request for topic {}: {}\",\n+                    partitionedTopicName, exception.getMessage(), exception);\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      SchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        if (null != schemaData) {\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else {\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = owningTopics.get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        exception.printStackTrace();\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                        + \" to topic \" + topicName.getPartitionedTopicName()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            if ((keySchema == null || keySchema.isEmpty()) && (valueSchema == null || valueSchema.isEmpty())) {\n+                return null;\n+            } else {\n+                SchemaInfo keySchemaInfo = (keySchema == null || keySchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(keySchema), SchemaInfo.class);\n+                SchemaInfo valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(valueSchema), SchemaInfo.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                if (null == valueSchemaInfo.getName()) {\n+                    valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 475}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMTAyNg==", "bodyText": "updated.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579621026", "createdAt": "2021-02-20T08:15:20Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =\n+            new ConcurrentOpenHashMap<>();\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    protected  void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (owningTopics.containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // if we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo =\n+                            KeyValueSchemaInfo.decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToMultiplePartitions(topicName, request, owningTopics.get(topic), asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((owningTopics.containsKey(topic) && owningTopics.get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo = KeyValueSchemaInfo\n+                            .decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToSinglePartition(topicName, request, partition, asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                owningTopics.get(topicName.getPartitionedTopicName()).remove(topicName.getPartitionIndex());\n+            } else {\n+                t.get().publishMessage(messageToByteBuf(message),\n+                RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    private void publishMessagesToSinglePartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  KeyValueSchema keyValueSchema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void publishMessagesToMultiplePartitions(TopicName topicName, ProducerMessages request,\n+                                                     ConcurrentOpenHashSet<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, KeyValueSchema keyValueSchema,\n+                                                     SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            List<Integer> owningPartitions = partitionIndexes.values();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(owningPartitions.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(owningPartitions\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                    messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            e.printStackTrace();\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    owningTopics.remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic.\n+    // Return if asyncResponse has been completed.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+            // that own partition of the topic or know who own partition of the topic.\n+            if (!owningTopics.containsKey(topicName.getPartitionedTopicName())) {\n+                if (redirectAddresses.isEmpty()) {\n+                    // No broker to redirect, means look up for some partitions failed,\n+                    // client should retry with other brokers.\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                    future.complete(true);\n+                } else {\n+                    // Redirect client to other broker owns the topic or know which broker own the topic.\n+                    try {\n+                        URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath()));\n+                        asyncResponse.resume(Response.temporaryRedirect(redirectURI));\n+                        future.complete(true);\n+                    } catch (URISyntaxException | NullPointerException e) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                        asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                \"Fail to redirect client request.\"));\n+                        future.complete(true);\n+                    }\n+                }\n+            } else {\n+                future.complete(false);\n+            }\n+        }).exceptionally(e -> {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to look up topic: \" + e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Error look up topic: \"\n+                    + e.getLocalizedMessage()));\n+            future.complete(true);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                pulsar().getBrokerService().getLookupRequestSemaphore().release();\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                owningTopics.computeIfAbsent(partitionedTopicName.getPartitionedTopicName(),\n+                        (key) -> new ConcurrentOpenHashSet<Integer>()).add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            log.warn(\"Failed to lookup broker with rest produce message request for topic {}: {}\",\n+                    partitionedTopicName, exception.getMessage(), exception);\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      SchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        if (null != schemaData) {\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else {\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = owningTopics.get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        exception.printStackTrace();\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                        + \" to topic \" + topicName.getPartitionedTopicName()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            if ((keySchema == null || keySchema.isEmpty()) && (valueSchema == null || valueSchema.isEmpty())) {\n+                return null;\n+            } else {\n+                SchemaInfo keySchemaInfo = (keySchema == null || keySchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(keySchema), SchemaInfo.class);\n+                SchemaInfo valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(valueSchema), SchemaInfo.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                if (null == valueSchemaInfo.getName()) {\n+                    valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NTcxMw=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 475}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDA3ODY2OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjozNzo1N1rOIjrB-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwODoxMjo0OVrOIoxPdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjA4OQ==", "bodyText": "Please avoid doing this. Can you add a log statement properly?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574276089", "createdAt": "2021-02-11T06:37:57Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =\n+            new ConcurrentOpenHashMap<>();\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    protected  void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (owningTopics.containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // if we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo =\n+                            KeyValueSchemaInfo.decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToMultiplePartitions(topicName, request, owningTopics.get(topic), asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((owningTopics.containsKey(topic) && owningTopics.get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo = KeyValueSchemaInfo\n+                            .decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToSinglePartition(topicName, request, partition, asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                owningTopics.get(topicName.getPartitionedTopicName()).remove(topicName.getPartitionIndex());\n+            } else {\n+                t.get().publishMessage(messageToByteBuf(message),\n+                RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    private void publishMessagesToSinglePartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  KeyValueSchema keyValueSchema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void publishMessagesToMultiplePartitions(TopicName topicName, ProducerMessages request,\n+                                                     ConcurrentOpenHashSet<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, KeyValueSchema keyValueSchema,\n+                                                     SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            List<Integer> owningPartitions = partitionIndexes.values();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(owningPartitions.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(owningPartitions\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                    messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            e.printStackTrace();\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    owningTopics.remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic.\n+    // Return if asyncResponse has been completed.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+            // that own partition of the topic or know who own partition of the topic.\n+            if (!owningTopics.containsKey(topicName.getPartitionedTopicName())) {\n+                if (redirectAddresses.isEmpty()) {\n+                    // No broker to redirect, means look up for some partitions failed,\n+                    // client should retry with other brokers.\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                    future.complete(true);\n+                } else {\n+                    // Redirect client to other broker owns the topic or know which broker own the topic.\n+                    try {\n+                        URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath()));\n+                        asyncResponse.resume(Response.temporaryRedirect(redirectURI));\n+                        future.complete(true);\n+                    } catch (URISyntaxException | NullPointerException e) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                        asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                \"Fail to redirect client request.\"));\n+                        future.complete(true);\n+                    }\n+                }\n+            } else {\n+                future.complete(false);\n+            }\n+        }).exceptionally(e -> {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to look up topic: \" + e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Error look up topic: \"\n+                    + e.getLocalizedMessage()));\n+            future.complete(true);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                pulsar().getBrokerService().getLookupRequestSemaphore().release();\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                owningTopics.computeIfAbsent(partitionedTopicName.getPartitionedTopicName(),\n+                        (key) -> new ConcurrentOpenHashSet<Integer>()).add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            log.warn(\"Failed to lookup broker with rest produce message request for topic {}: {}\",\n+                    partitionedTopicName, exception.getMessage(), exception);\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      SchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        if (null != schemaData) {\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else {\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = owningTopics.get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        exception.printStackTrace();\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                        + \" to topic \" + topicName.getPartitionedTopicName()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            if ((keySchema == null || keySchema.isEmpty()) && (valueSchema == null || valueSchema.isEmpty())) {\n+                return null;\n+            } else {\n+                SchemaInfo keySchemaInfo = (keySchema == null || keySchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(keySchema), SchemaInfo.class);\n+                SchemaInfo valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(valueSchema), SchemaInfo.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                if (null == valueSchemaInfo.getName()) {\n+                    valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"\n+                                + topicName.getPartitionedTopicName(),\n+                        keySchemaInfo, valueSchemaInfo,\n+                        KeyValueEncodingType.SEPARATED);\n+                return SchemaData.builder()\n+                        .data(schemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(schemaInfo.getType())\n+                        .props(schemaInfo.getProperties())\n+                        .build();\n+            }\n+        } catch (IOException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to parse schema info for rest produce request with key schema {} and value schema {}\"\n+                        , keySchema, valueSchema);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    // Convert message to ByteBuf\n+    public ByteBuf messageToByteBuf(Message message) {\n+        checkArgument(message instanceof MessageImpl, \"Message must be type of MessageImpl.\");\n+\n+        MessageImpl msg = (MessageImpl) message;\n+        MessageMetadata messageMetadata = msg.getMessageBuilder();\n+        ByteBuf payload = msg.getDataBuffer();\n+        messageMetadata.setCompression(CompressionCodecProvider.convertToWireProtocol(CompressionType.NONE));\n+        messageMetadata.setUncompressedSize(payload.readableBytes());\n+\n+        ByteBuf byteBuf = null;\n+        try {\n+            byteBuf = Commands.serializeMetadataAndPayload(Commands.ChecksumType.Crc32c, messageMetadata, payload);\n+        } catch (Exception e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 511}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMDcyNQ==", "bodyText": "my bad, updated to proper logging.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579620725", "createdAt": "2021-02-20T08:12:49Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =\n+            new ConcurrentOpenHashMap<>();\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    protected  void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (owningTopics.containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // if we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo =\n+                            KeyValueSchemaInfo.decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToMultiplePartitions(topicName, request, owningTopics.get(topic), asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((owningTopics.containsKey(topic) && owningTopics.get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo = KeyValueSchemaInfo\n+                            .decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToSinglePartition(topicName, request, partition, asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                owningTopics.get(topicName.getPartitionedTopicName()).remove(topicName.getPartitionIndex());\n+            } else {\n+                t.get().publishMessage(messageToByteBuf(message),\n+                RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    private void publishMessagesToSinglePartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  KeyValueSchema keyValueSchema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void publishMessagesToMultiplePartitions(TopicName topicName, ProducerMessages request,\n+                                                     ConcurrentOpenHashSet<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, KeyValueSchema keyValueSchema,\n+                                                     SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            List<Integer> owningPartitions = partitionIndexes.values();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(owningPartitions.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(owningPartitions\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                    messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            e.printStackTrace();\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    owningTopics.remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic.\n+    // Return if asyncResponse has been completed.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+            // that own partition of the topic or know who own partition of the topic.\n+            if (!owningTopics.containsKey(topicName.getPartitionedTopicName())) {\n+                if (redirectAddresses.isEmpty()) {\n+                    // No broker to redirect, means look up for some partitions failed,\n+                    // client should retry with other brokers.\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                    future.complete(true);\n+                } else {\n+                    // Redirect client to other broker owns the topic or know which broker own the topic.\n+                    try {\n+                        URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath()));\n+                        asyncResponse.resume(Response.temporaryRedirect(redirectURI));\n+                        future.complete(true);\n+                    } catch (URISyntaxException | NullPointerException e) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                        asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                \"Fail to redirect client request.\"));\n+                        future.complete(true);\n+                    }\n+                }\n+            } else {\n+                future.complete(false);\n+            }\n+        }).exceptionally(e -> {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to look up topic: \" + e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Error look up topic: \"\n+                    + e.getLocalizedMessage()));\n+            future.complete(true);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                pulsar().getBrokerService().getLookupRequestSemaphore().release();\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                owningTopics.computeIfAbsent(partitionedTopicName.getPartitionedTopicName(),\n+                        (key) -> new ConcurrentOpenHashSet<Integer>()).add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            log.warn(\"Failed to lookup broker with rest produce message request for topic {}: {}\",\n+                    partitionedTopicName, exception.getMessage(), exception);\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      SchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        if (null != schemaData) {\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else {\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = owningTopics.get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        exception.printStackTrace();\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                        + \" to topic \" + topicName.getPartitionedTopicName()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            if ((keySchema == null || keySchema.isEmpty()) && (valueSchema == null || valueSchema.isEmpty())) {\n+                return null;\n+            } else {\n+                SchemaInfo keySchemaInfo = (keySchema == null || keySchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(keySchema), SchemaInfo.class);\n+                SchemaInfo valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(valueSchema), SchemaInfo.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                if (null == valueSchemaInfo.getName()) {\n+                    valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"\n+                                + topicName.getPartitionedTopicName(),\n+                        keySchemaInfo, valueSchemaInfo,\n+                        KeyValueEncodingType.SEPARATED);\n+                return SchemaData.builder()\n+                        .data(schemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(schemaInfo.getType())\n+                        .props(schemaInfo.getProperties())\n+                        .build();\n+            }\n+        } catch (IOException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to parse schema info for rest produce request with key schema {} and value schema {}\"\n+                        , keySchema, valueSchema);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    // Convert message to ByteBuf\n+    public ByteBuf messageToByteBuf(Message message) {\n+        checkArgument(message instanceof MessageImpl, \"Message must be type of MessageImpl.\");\n+\n+        MessageImpl msg = (MessageImpl) message;\n+        MessageMetadata messageMetadata = msg.getMessageBuilder();\n+        ByteBuf payload = msg.getDataBuffer();\n+        messageMetadata.setCompression(CompressionCodecProvider.convertToWireProtocol(CompressionType.NONE));\n+        messageMetadata.setUncompressedSize(payload.readableBytes());\n+\n+        ByteBuf byteBuf = null;\n+        try {\n+            byteBuf = Commands.serializeMetadataAndPayload(Commands.ChecksumType.Crc32c, messageMetadata, payload);\n+        } catch (Exception e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjA4OQ=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 511}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDA3OTkzOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjozODozNFrOIjrCoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwODoxMzowMFrOIoxPjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjI1Nw==", "bodyText": "This can be a static method.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574276257", "createdAt": "2021-02-11T06:38:34Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =\n+            new ConcurrentOpenHashMap<>();\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    protected  void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (owningTopics.containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // if we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo =\n+                            KeyValueSchemaInfo.decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToMultiplePartitions(topicName, request, owningTopics.get(topic), asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((owningTopics.containsKey(topic) && owningTopics.get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo = KeyValueSchemaInfo\n+                            .decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToSinglePartition(topicName, request, partition, asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                owningTopics.get(topicName.getPartitionedTopicName()).remove(topicName.getPartitionIndex());\n+            } else {\n+                t.get().publishMessage(messageToByteBuf(message),\n+                RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    private void publishMessagesToSinglePartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  KeyValueSchema keyValueSchema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void publishMessagesToMultiplePartitions(TopicName topicName, ProducerMessages request,\n+                                                     ConcurrentOpenHashSet<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, KeyValueSchema keyValueSchema,\n+                                                     SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            List<Integer> owningPartitions = partitionIndexes.values();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(owningPartitions.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(owningPartitions\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                    messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            e.printStackTrace();\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    owningTopics.remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic.\n+    // Return if asyncResponse has been completed.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+            // that own partition of the topic or know who own partition of the topic.\n+            if (!owningTopics.containsKey(topicName.getPartitionedTopicName())) {\n+                if (redirectAddresses.isEmpty()) {\n+                    // No broker to redirect, means look up for some partitions failed,\n+                    // client should retry with other brokers.\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                    future.complete(true);\n+                } else {\n+                    // Redirect client to other broker owns the topic or know which broker own the topic.\n+                    try {\n+                        URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath()));\n+                        asyncResponse.resume(Response.temporaryRedirect(redirectURI));\n+                        future.complete(true);\n+                    } catch (URISyntaxException | NullPointerException e) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                        asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                \"Fail to redirect client request.\"));\n+                        future.complete(true);\n+                    }\n+                }\n+            } else {\n+                future.complete(false);\n+            }\n+        }).exceptionally(e -> {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to look up topic: \" + e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Error look up topic: \"\n+                    + e.getLocalizedMessage()));\n+            future.complete(true);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                pulsar().getBrokerService().getLookupRequestSemaphore().release();\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                owningTopics.computeIfAbsent(partitionedTopicName.getPartitionedTopicName(),\n+                        (key) -> new ConcurrentOpenHashSet<Integer>()).add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            log.warn(\"Failed to lookup broker with rest produce message request for topic {}: {}\",\n+                    partitionedTopicName, exception.getMessage(), exception);\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      SchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        if (null != schemaData) {\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else {\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = owningTopics.get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        exception.printStackTrace();\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                        + \" to topic \" + topicName.getPartitionedTopicName()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            if ((keySchema == null || keySchema.isEmpty()) && (valueSchema == null || valueSchema.isEmpty())) {\n+                return null;\n+            } else {\n+                SchemaInfo keySchemaInfo = (keySchema == null || keySchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(keySchema), SchemaInfo.class);\n+                SchemaInfo valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(valueSchema), SchemaInfo.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                if (null == valueSchemaInfo.getName()) {\n+                    valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"\n+                                + topicName.getPartitionedTopicName(),\n+                        keySchemaInfo, valueSchemaInfo,\n+                        KeyValueEncodingType.SEPARATED);\n+                return SchemaData.builder()\n+                        .data(schemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(schemaInfo.getType())\n+                        .props(schemaInfo.getProperties())\n+                        .build();\n+            }\n+        } catch (IOException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to parse schema info for rest produce request with key schema {} and value schema {}\"\n+                        , keySchema, valueSchema);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    // Convert message to ByteBuf\n+    public ByteBuf messageToByteBuf(Message message) {\n+        checkArgument(message instanceof MessageImpl, \"Message must be type of MessageImpl.\");\n+\n+        MessageImpl msg = (MessageImpl) message;\n+        MessageMetadata messageMetadata = msg.getMessageBuilder();\n+        ByteBuf payload = msg.getDataBuffer();\n+        messageMetadata.setCompression(CompressionCodecProvider.convertToWireProtocol(CompressionType.NONE));\n+        messageMetadata.setUncompressedSize(payload.readableBytes());\n+\n+        ByteBuf byteBuf = null;\n+        try {\n+            byteBuf = Commands.serializeMetadataAndPayload(Commands.ChecksumType.Crc32c, messageMetadata, payload);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+        return byteBuf;\n+    }\n+\n+    // Build pulsar message from serialized message.\n+    private List<Message> buildMessage(ProducerMessages producerMessages, KeyValueSchema keyValueSchema,\n+                                       String producerName) {\n+        List<ProducerMessage> messages;\n+        List<Message> pulsarMessages = new ArrayList<>();\n+\n+        messages = producerMessages.getMessages();\n+        for (ProducerMessage message : messages) {\n+            try {\n+                MessageMetadata messageMetadata = new MessageMetadata();\n+                messageMetadata.setProducerName(producerName);\n+                messageMetadata.setPublishTime(System.currentTimeMillis());\n+                messageMetadata.setSequenceId(message.getSequenceId());\n+                if (null != message.getReplicationClusters()) {\n+                    messageMetadata.addAllReplicateTos(message.getReplicationClusters());\n+                }\n+\n+                if (null != message.getProperties()) {\n+                    messageMetadata.addAllProperties(message.getProperties().entrySet().stream().map(entry -> {\n+                        org.apache.pulsar.common.api.proto.KeyValue keyValue =\n+                                new org.apache.pulsar.common.api.proto.KeyValue();\n+                        keyValue.setKey(entry.getKey());\n+                        keyValue.setValue(entry.getValue());\n+                        return keyValue;\n+                    }).collect(Collectors.toList()));\n+                }\n+                if (null != message.getKey()) {\n+                    if (keyValueSchema.getKeySchema().getSchemaInfo().getType() == SchemaType.JSON) {\n+                        messageMetadata.setPartitionKey(new String(processJSONMsg(message.getKey())));\n+                    } else {\n+                        messageMetadata.setPartitionKey(new String(keyValueSchema.getKeySchema()\n+                                .encode(message.getKey())));\n+                    }\n+                }\n+                if (null != message.getEventTime() && !message.getEventTime().isEmpty()) {\n+                    messageMetadata.setEventTime(Long.valueOf(message.getEventTime()));\n+                }\n+                if (message.isDisableReplication()) {\n+                    messageMetadata.clearReplicateTo();\n+                    messageMetadata.addReplicateTo(\"__local__\");\n+                }\n+                if (message.getDeliverAt() != 0 && messageMetadata.hasEventTime()) {\n+                    messageMetadata.setDeliverAtTime(message.getDeliverAt());\n+                } else if (message.getDeliverAfterMs() != 0) {\n+                    messageMetadata.setDeliverAtTime(messageMetadata.getEventTime() + message.getDeliverAfterMs());\n+                }\n+                if (keyValueSchema.getValueSchema().getSchemaInfo().getType() == SchemaType.JSON) {\n+                    pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                            ByteBuffer.wrap(processJSONMsg(message.getPayload())), keyValueSchema.getValueSchema()));\n+                } else {\n+                    pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                            ByteBuffer.wrap(keyValueSchema.getValueSchema().encode(message.getPayload())),\n+                            keyValueSchema.getValueSchema()));\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        return pulsarMessages;\n+    }\n+\n+    private byte[] processJSONMsg(String msg) throws JsonProcessingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 579}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMDc1MA==", "bodyText": "updated.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579620750", "createdAt": "2021-02-20T08:13:00Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValue;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ *\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics =\n+            new ConcurrentOpenHashMap<>();\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    protected  void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (owningTopics.containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // if we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo =\n+                            KeyValueSchemaInfo.decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToMultiplePartitions(topicName, request, owningTopics.get(topic), asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((owningTopics.containsKey(topic) && owningTopics.get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    KeyValue<SchemaInfo, SchemaInfo> kvSchemaInfo = KeyValueSchemaInfo\n+                            .decodeKeyValueSchemaInfo(schemaMeta.getLeft().toSchemaInfo());\n+                    publishMessagesToSinglePartition(topicName, request, partition, asyncResponse,\n+                            (KeyValueSchema) KeyValueSchema.of(AutoConsumeSchema.getSchema(kvSchemaInfo.getKey()),\n+                                    AutoConsumeSchema.getSchema(kvSchemaInfo.getValue())), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to add or retrieve schema: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Fail to add or retrieve schema.\"));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                owningTopics.get(topicName.getPartitionedTopicName()).remove(topicName.getPartitionIndex());\n+            } else {\n+                t.get().publishMessage(messageToByteBuf(message),\n+                RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    private void publishMessagesToSinglePartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  KeyValueSchema keyValueSchema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void publishMessagesToMultiplePartitions(TopicName topicName, ProducerMessages request,\n+                                                     ConcurrentOpenHashSet<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, KeyValueSchema keyValueSchema,\n+                                                     SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, keyValueSchema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            List<Integer> owningPartitions = partitionIndexes.values();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(owningPartitions.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(owningPartitions\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                    messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail publish message with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            e.printStackTrace();\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, e.getMessage()));\n+        }\n+    }\n+\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    owningTopics.remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic.\n+    // Return if asyncResponse has been completed.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+            // that own partition of the topic or know who own partition of the topic.\n+            if (!owningTopics.containsKey(topicName.getPartitionedTopicName())) {\n+                if (redirectAddresses.isEmpty()) {\n+                    // No broker to redirect, means look up for some partitions failed,\n+                    // client should retry with other brokers.\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                    future.complete(true);\n+                } else {\n+                    // Redirect client to other broker owns the topic or know which broker own the topic.\n+                    try {\n+                        URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath()));\n+                        asyncResponse.resume(Response.temporaryRedirect(redirectURI));\n+                        future.complete(true);\n+                    } catch (URISyntaxException | NullPointerException e) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                        asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                \"Fail to redirect client request.\"));\n+                        future.complete(true);\n+                    }\n+                }\n+            } else {\n+                future.complete(false);\n+            }\n+        }).exceptionally(e -> {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to look up topic: \" + e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Error look up topic: \"\n+                    + e.getLocalizedMessage()));\n+            future.complete(true);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                pulsar().getBrokerService().getLookupRequestSemaphore().release();\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                owningTopics.computeIfAbsent(partitionedTopicName.getPartitionedTopicName(),\n+                        (key) -> new ConcurrentOpenHashSet<Integer>()).add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.warn(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            log.warn(\"Failed to lookup broker with rest produce message request for topic {}: {}\",\n+                    partitionedTopicName, exception.getMessage(), exception);\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      SchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        if (null != schemaData) {\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (InterruptedException | ExecutionException e) {\n+                future.complete(Pair.of(null, null));\n+            }\n+        } else {\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = owningTopics.get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        exception.printStackTrace();\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                        + \" to topic \" + topicName.getPartitionedTopicName()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            if ((keySchema == null || keySchema.isEmpty()) && (valueSchema == null || valueSchema.isEmpty())) {\n+                return null;\n+            } else {\n+                SchemaInfo keySchemaInfo = (keySchema == null || keySchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(keySchema), SchemaInfo.class);\n+                SchemaInfo valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                        ? StringSchema.utf8().getSchemaInfo() : ObjectMapperFactory.getThreadLocal()\n+                        .readValue(Base64.getDecoder().decode(valueSchema), SchemaInfo.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                if (null == valueSchemaInfo.getName()) {\n+                    valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"\n+                                + topicName.getPartitionedTopicName(),\n+                        keySchemaInfo, valueSchemaInfo,\n+                        KeyValueEncodingType.SEPARATED);\n+                return SchemaData.builder()\n+                        .data(schemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(schemaInfo.getType())\n+                        .props(schemaInfo.getProperties())\n+                        .build();\n+            }\n+        } catch (IOException e) {\n+            if (log.isDebugEnabled()) {\n+                log.warn(\"Fail to parse schema info for rest produce request with key schema {} and value schema {}\"\n+                        , keySchema, valueSchema);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    // Convert message to ByteBuf\n+    public ByteBuf messageToByteBuf(Message message) {\n+        checkArgument(message instanceof MessageImpl, \"Message must be type of MessageImpl.\");\n+\n+        MessageImpl msg = (MessageImpl) message;\n+        MessageMetadata messageMetadata = msg.getMessageBuilder();\n+        ByteBuf payload = msg.getDataBuffer();\n+        messageMetadata.setCompression(CompressionCodecProvider.convertToWireProtocol(CompressionType.NONE));\n+        messageMetadata.setUncompressedSize(payload.readableBytes());\n+\n+        ByteBuf byteBuf = null;\n+        try {\n+            byteBuf = Commands.serializeMetadataAndPayload(Commands.ChecksumType.Crc32c, messageMetadata, payload);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+        return byteBuf;\n+    }\n+\n+    // Build pulsar message from serialized message.\n+    private List<Message> buildMessage(ProducerMessages producerMessages, KeyValueSchema keyValueSchema,\n+                                       String producerName) {\n+        List<ProducerMessage> messages;\n+        List<Message> pulsarMessages = new ArrayList<>();\n+\n+        messages = producerMessages.getMessages();\n+        for (ProducerMessage message : messages) {\n+            try {\n+                MessageMetadata messageMetadata = new MessageMetadata();\n+                messageMetadata.setProducerName(producerName);\n+                messageMetadata.setPublishTime(System.currentTimeMillis());\n+                messageMetadata.setSequenceId(message.getSequenceId());\n+                if (null != message.getReplicationClusters()) {\n+                    messageMetadata.addAllReplicateTos(message.getReplicationClusters());\n+                }\n+\n+                if (null != message.getProperties()) {\n+                    messageMetadata.addAllProperties(message.getProperties().entrySet().stream().map(entry -> {\n+                        org.apache.pulsar.common.api.proto.KeyValue keyValue =\n+                                new org.apache.pulsar.common.api.proto.KeyValue();\n+                        keyValue.setKey(entry.getKey());\n+                        keyValue.setValue(entry.getValue());\n+                        return keyValue;\n+                    }).collect(Collectors.toList()));\n+                }\n+                if (null != message.getKey()) {\n+                    if (keyValueSchema.getKeySchema().getSchemaInfo().getType() == SchemaType.JSON) {\n+                        messageMetadata.setPartitionKey(new String(processJSONMsg(message.getKey())));\n+                    } else {\n+                        messageMetadata.setPartitionKey(new String(keyValueSchema.getKeySchema()\n+                                .encode(message.getKey())));\n+                    }\n+                }\n+                if (null != message.getEventTime() && !message.getEventTime().isEmpty()) {\n+                    messageMetadata.setEventTime(Long.valueOf(message.getEventTime()));\n+                }\n+                if (message.isDisableReplication()) {\n+                    messageMetadata.clearReplicateTo();\n+                    messageMetadata.addReplicateTo(\"__local__\");\n+                }\n+                if (message.getDeliverAt() != 0 && messageMetadata.hasEventTime()) {\n+                    messageMetadata.setDeliverAtTime(message.getDeliverAt());\n+                } else if (message.getDeliverAfterMs() != 0) {\n+                    messageMetadata.setDeliverAtTime(messageMetadata.getEventTime() + message.getDeliverAfterMs());\n+                }\n+                if (keyValueSchema.getValueSchema().getSchemaInfo().getType() == SchemaType.JSON) {\n+                    pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                            ByteBuffer.wrap(processJSONMsg(message.getPayload())), keyValueSchema.getValueSchema()));\n+                } else {\n+                    pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                            ByteBuffer.wrap(keyValueSchema.getValueSchema().encode(message.getPayload())),\n+                            keyValueSchema.getValueSchema()));\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        return pulsarMessages;\n+    }\n+\n+    private byte[] processJSONMsg(String msg) throws JsonProcessingException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjI1Nw=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 579}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDA4NDI5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v3/Topics.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjo0MDozOVrOIjrE5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNTozMzozNlrOJ95OrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjgzOQ==", "bodyText": "Why it is /persistent/topics?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574276839", "createdAt": "2021-02-11T06:40:39Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v3/Topics.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.v3;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.Encoded;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.MediaType;\n+import org.apache.pulsar.broker.admin.impl.TopicsBase;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+@Path(\"/persistent/topics\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMDkxMg==", "bodyText": "The base class AdminResource use this to detect topic domain like persistent/non-persistent and I think we're supporting only persistent topic for now?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579620912", "createdAt": "2021-02-20T08:14:11Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v3/Topics.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.v3;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.Encoded;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.MediaType;\n+import org.apache.pulsar.broker.admin.impl.TopicsBase;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+@Path(\"/persistent/topics\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjgzOQ=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODg4MDU1Ng==", "bodyText": "The complete uri is /admin/v3/persistent/topics/tenant/namespace/topic, From the proposal, it should be /topics/tenant/namespace/topic -> https://github.com/apache/pulsar/wiki/PIP-64%3A-Introduce-REST-endpoints-for-producing%2C-consuming-and-reading-messages#produce-messages", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r668880556", "createdAt": "2021-07-13T15:33:36Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v3/Topics.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.v3;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.Encoded;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.MediaType;\n+import org.apache.pulsar.broker.admin.impl.TopicsBase;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+@Path(\"/persistent/topics\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3NjgzOQ=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDEwMjA5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/TopicsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjo0OTozMFrOIjrOXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwODoxNDozNFrOIoxQXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3OTI2Mg==", "bodyText": "Can you add tests to cover the following test cases?\n\nproduce a message when the topic already exists. produce a message using java client. verify java client can can consume messages.\nproduce a message when a topic doesn't exist before. verify java client can consume the message\nproduce a message with an incompatible schema\ncover non schema, primitive schema, struct schema, key/value schema", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574279262", "createdAt": "2021-02-11T06:49:30Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/TopicsTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.Sets;\n+import org.apache.pulsar.broker.admin.v2.PersistentTopics;\n+import org.apache.pulsar.broker.admin.v3.Topics;\n+import org.apache.pulsar.broker.auth.MockedPulsarServiceBaseTest;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataHttps;\n+import org.apache.pulsar.broker.service.BrokerService;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.Producer;\n+import org.apache.pulsar.broker.service.Topic;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.naming.TopicDomain;\n+import org.apache.pulsar.common.policies.data.*;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import java.util.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.timeout;\n+\n+@PrepareForTest(PersistentTopics.class)\n+public class TopicsTest extends MockedPulsarServiceBaseTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMDk1Nw==", "bodyText": "done.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579620957", "createdAt": "2021-02-20T08:14:34Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/TopicsTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.Sets;\n+import org.apache.pulsar.broker.admin.v2.PersistentTopics;\n+import org.apache.pulsar.broker.admin.v3.Topics;\n+import org.apache.pulsar.broker.auth.MockedPulsarServiceBaseTest;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataHttps;\n+import org.apache.pulsar.broker.service.BrokerService;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.Producer;\n+import org.apache.pulsar.broker.service.Topic;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.naming.TopicDomain;\n+import org.apache.pulsar.common.policies.data.*;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import java.util.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.timeout;\n+\n+@PrepareForTest(PersistentTopics.class)\n+public class TopicsTest extends MockedPulsarServiceBaseTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI3OTI2Mg=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMDExNDk2OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/TopicsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNjo1NTo0N1rOIjrVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwODoxNDo0MVrOIoxQag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI4MDk3OA==", "bodyText": "Can you also add tests to test redirects?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r574280978", "createdAt": "2021-02-11T06:55:47Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/TopicsTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.Sets;\n+import org.apache.pulsar.broker.admin.v2.PersistentTopics;\n+import org.apache.pulsar.broker.admin.v3.Topics;\n+import org.apache.pulsar.broker.auth.MockedPulsarServiceBaseTest;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataHttps;\n+import org.apache.pulsar.broker.service.BrokerService;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.Producer;\n+import org.apache.pulsar.broker.service.Topic;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.naming.TopicDomain;\n+import org.apache.pulsar.common.policies.data.*;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import java.util.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.timeout;\n+\n+@PrepareForTest(PersistentTopics.class)\n+public class TopicsTest extends MockedPulsarServiceBaseTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTYyMDk3MA==", "bodyText": "done.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r579620970", "createdAt": "2021-02-20T08:14:41Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/TopicsTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.Sets;\n+import org.apache.pulsar.broker.admin.v2.PersistentTopics;\n+import org.apache.pulsar.broker.admin.v3.Topics;\n+import org.apache.pulsar.broker.auth.MockedPulsarServiceBaseTest;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataHttps;\n+import org.apache.pulsar.broker.service.BrokerService;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.Producer;\n+import org.apache.pulsar.broker.service.Topic;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.common.naming.TopicDomain;\n+import org.apache.pulsar.common.policies.data.*;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import java.util.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.timeout;\n+\n+@PrepareForTest(PersistentTopics.class)\n+public class TopicsTest extends MockedPulsarServiceBaseTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI4MDk3OA=="}, "originalCommit": {"oid": "bb48e9cdf1e11de755d675cd1d62221345e92a62"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDAyNTYwNjQ0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xOVQwNzoyOToxN1rOJdkLnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yM1QxMTo1NDoyNVrOJgAAzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDk4MTI3Ng==", "bodyText": "If no new messages sent to this broker, seems the cache can't been removed", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r634981276", "createdAt": "2021-05-19T07:29:17Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    // Publish message to a topic, can be partitioned or non-partitioned\n+    protected void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (pulsar().getOwningTopics().containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // If we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessages(topicName, request, pulsar().getOwningTopics().get(topic).values(),\n+                            asyncResponse, AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                            schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message: \" + e.getMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message:\"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    // Publish message to single partition of a partitioned topic.\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((pulsar().getOwningTopics().containsKey(topic) && pulsar().getOwningTopics().get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessagesToPartition(topicName, request, partition, asyncResponse,\n+                            AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message to single partition: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message\"\n+                        + \"to single partition: \"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void internalPublishMessagesToPartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  Schema schema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail publish messages to single partition with rest produce message \"\n+                                + \"request for topic  {}: {} \", topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessages(TopicName topicName, ProducerMessages request,\n+                                                     List<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, Schema schema,\n+                                                     SchemaVersion schemaVersion) {\n+        if (partitionIndexes.size() < 1) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                    new BrokerServiceException.TopicNotFoundException(\"Topic not owned by current broker.\")));\n+        }\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            // Try to publish messages to all partitions this broker owns in round robin mode.\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partitionIndexes.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partitionIndexes\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to publish messages with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog and fail if backlog too large.\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                pulsar().getOwningTopics().get(topicName.getPartitionedTopicName())\n+                        .remove(topicName.getPartitionIndex());\n+            } else {\n+                try {\n+                    t.get().publishMessage(messageToByteBuf(message),\n+                            RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+                } catch (Exception e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish single messages to topic  {}: {} \",\n+                                topicName, e.getCause());\n+                    }\n+                    publishResult.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    // Process results for all message publishing attempts\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    pulsar().getOwningTopics().remove(topicName.getPartitionedTopicName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzUzNDQxMw==", "bodyText": "Are we worrying about potential memory leak here?\nDid a rough calculation, if average topic name has 100 characters, in UTF_32 encoding which occupies 4 byte(other encoding usually take less space), a String could take 400 + ~50 (other meta) = 450 byte, if a broker ever owns 10K topics, it'll takes about 4.3MB, if a broker ever owns 100K topics it'll take about 43MB, but later case should be pretty rare. I think this should be in acceptable range.\nWe can add scheduled task to clean up this, but feel like we don't need to over-optimize for now?\n@codelipenghui what do you think?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r637534413", "createdAt": "2021-05-23T11:54:25Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    // Publish message to a topic, can be partitioned or non-partitioned\n+    protected void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (pulsar().getOwningTopics().containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // If we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessages(topicName, request, pulsar().getOwningTopics().get(topic).values(),\n+                            asyncResponse, AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                            schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message: \" + e.getMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message:\"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    // Publish message to single partition of a partitioned topic.\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((pulsar().getOwningTopics().containsKey(topic) && pulsar().getOwningTopics().get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessagesToPartition(topicName, request, partition, asyncResponse,\n+                            AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message to single partition: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message\"\n+                        + \"to single partition: \"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void internalPublishMessagesToPartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  Schema schema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail publish messages to single partition with rest produce message \"\n+                                + \"request for topic  {}: {} \", topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessages(TopicName topicName, ProducerMessages request,\n+                                                     List<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, Schema schema,\n+                                                     SchemaVersion schemaVersion) {\n+        if (partitionIndexes.size() < 1) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                    new BrokerServiceException.TopicNotFoundException(\"Topic not owned by current broker.\")));\n+        }\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            // Try to publish messages to all partitions this broker owns in round robin mode.\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partitionIndexes.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partitionIndexes\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to publish messages with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog and fail if backlog too large.\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                pulsar().getOwningTopics().get(topicName.getPartitionedTopicName())\n+                        .remove(topicName.getPartitionIndex());\n+            } else {\n+                try {\n+                    t.get().publishMessage(messageToByteBuf(message),\n+                            RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+                } catch (Exception e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish single messages to topic  {}: {} \",\n+                                topicName, e.getCause());\n+                    }\n+                    publishResult.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    // Process results for all message publishing attempts\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    pulsar().getOwningTopics().remove(topicName.getPartitionedTopicName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDk4MTI3Ng=="}, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI0Mjg0OTc5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQwMjo0NzozMVrOJ8qe-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wM1QwMzowMTowNlrOKdDShA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NzU5MDM5NQ==", "bodyText": "Why do I need to cache all topics? We only need to determine whether the Topic is owned by current Broker, otherwise it will be redirected.\nBroker already has Topic cache.\nWe can determine whether it belongs to the current cluster by checking the Namespace.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r667590395", "createdAt": "2021-07-12T02:47:31Z", "author": {"login": "315157973"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java", "diffHunk": "@@ -251,6 +253,9 @@\n     private volatile CompletableFuture<Void> closeFuture;\n     // key is listener name , value is pulsar address and pulsar ssl address\n     private Map<String, AdvertisedListener> advertisedListeners;\n+    // For REST api, keep track of topics served by this pulsar.\n+    @Getter\n+    private ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics = new ConcurrentOpenHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTU1MTIzNg==", "bodyText": "I assume you're talking about the multiLayerTopicsMap in BrokerService, I took a look and it does contain topic ownership data, but it's not very handy in this use case which we need to keep track of serving topics as well as all partitions on a broker when publish to a partition topic so we can distribute message to all partitions.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r701551236", "createdAt": "2021-09-03T03:01:06Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java", "diffHunk": "@@ -251,6 +253,9 @@\n     private volatile CompletableFuture<Void> closeFuture;\n     // key is listener name , value is pulsar address and pulsar ssl address\n     private Map<String, AdvertisedListener> advertisedListeners;\n+    // For REST api, keep track of topics served by this pulsar.\n+    @Getter\n+    private ConcurrentOpenHashMap<String, ConcurrentOpenHashSet<Integer>> owningTopics = new ConcurrentOpenHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NzU5MDM5NQ=="}, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI0Mjg2NDYxOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQwMjo1NTowM1rOJ8qnHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wM1QwMzowMjoyNVrOKdDUGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NzU5MjQ3Nw==", "bodyText": "Why not use TopicLookupBase directly", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r667592477", "createdAt": "2021-07-12T02:55:03Z", "author": {"login": "315157973"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    // Publish message to a topic, can be partitioned or non-partitioned\n+    protected void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (pulsar().getOwningTopics().containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // If we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessages(topicName, request, pulsar().getOwningTopics().get(topic).values(),\n+                            asyncResponse, AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                            schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message: \" + e.getMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message:\"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    // Publish message to single partition of a partitioned topic.\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((pulsar().getOwningTopics().containsKey(topic) && pulsar().getOwningTopics().get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessagesToPartition(topicName, request, partition, asyncResponse,\n+                            AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message to single partition: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message\"\n+                        + \"to single partition: \"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void internalPublishMessagesToPartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  Schema schema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail publish messages to single partition with rest produce message \"\n+                                + \"request for topic  {}: {} \", topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessages(TopicName topicName, ProducerMessages request,\n+                                                     List<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, Schema schema,\n+                                                     SchemaVersion schemaVersion) {\n+        if (partitionIndexes.size() < 1) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                    new BrokerServiceException.TopicNotFoundException(\"Topic not owned by current broker.\")));\n+        }\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            // Try to publish messages to all partitions this broker owns in round robin mode.\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partitionIndexes.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partitionIndexes\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to publish messages with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog and fail if backlog too large.\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                pulsar().getOwningTopics().get(topicName.getPartitionedTopicName())\n+                        .remove(topicName.getPartitionIndex());\n+            } else {\n+                try {\n+                    t.get().publishMessage(messageToByteBuf(message),\n+                            RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+                } catch (Exception e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish single messages to topic  {}: {} \",\n+                                topicName, e.getCause());\n+                    }\n+                    publishResult.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    // Process results for all message publishing attempts\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    pulsar().getOwningTopics().remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    // Return error code depends on exception we got indicating if client should retry with same broker.\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic. Return if asyncResponse has been completed\n+    // which indicating redirect or exception.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTU1MTY0Mg==", "bodyText": "there're some custom logic to update the serving topics and partitions when completing the lookup, so can't directly use TopicLookupBase here.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r701551642", "createdAt": "2021-09-03T03:02:25Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    // Publish message to a topic, can be partitioned or non-partitioned\n+    protected void publishMessages(AsyncResponse asyncResponse, ProducerMessages request,\n+                                           boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        if (pulsar().getOwningTopics().containsKey(topic) || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            // If we've done look up or or after look up this broker owns some of the partitions\n+            // then proceed to publish message else asyncResponse will be complete by look up.\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessages(topicName, request, pulsar().getOwningTopics().get(topic).values(),\n+                            asyncResponse, AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                            schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message: \" + e.getMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message:\"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    // Publish message to single partition of a partitioned topic.\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        // If broker owns the partition then proceed to publish message, else do look up.\n+        if ((pulsar().getOwningTopics().containsKey(topic) && pulsar().getOwningTopics().get(topic).contains(partition))\n+                || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+            addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                    request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+            .thenAccept(schemaMeta -> {\n+                // Both schema version and schema data are necessary.\n+                if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                    internalPublishMessagesToPartition(topicName, request, partition, asyncResponse,\n+                            AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()), schemaMeta.getRight());\n+                } else {\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to add or retrieve schema.\"));\n+                }\n+            }).exceptionally(e -> {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to publish message to single partition: \" + e.getLocalizedMessage());\n+                }\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message\"\n+                        + \"to single partition: \"\n+                        + e.getMessage()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void internalPublishMessagesToPartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  Schema schema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail publish messages to single partition with rest produce message \"\n+                                + \"request for topic  {}: {} \", topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessages(TopicName topicName, ProducerMessages request,\n+                                                     List<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, Schema schema,\n+                                                     SchemaVersion schemaVersion) {\n+        if (partitionIndexes.size() < 1) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                    new BrokerServiceException.TopicNotFoundException(\"Topic not owned by current broker.\")));\n+        }\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            // Try to publish messages to all partitions this broker owns in round robin mode.\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partitionIndexes.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partitionIndexes\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to publish messages with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog and fail if backlog too large.\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                pulsar().getOwningTopics().get(topicName.getPartitionedTopicName())\n+                        .remove(topicName.getPartitionIndex());\n+            } else {\n+                try {\n+                    t.get().publishMessage(messageToByteBuf(message),\n+                            RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+                } catch (Exception e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish single messages to topic  {}: {} \",\n+                                topicName, e.getCause());\n+                    }\n+                    publishResult.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    // Process results for all message publishing attempts\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    pulsar().getOwningTopics().remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    // Return error code depends on exception we got indicating if client should retry with same broker.\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic. Return if asyncResponse has been completed\n+    // which indicating redirect or exception.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NzU5MjQ3Nw=="}, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTI4NDQ5OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNToyNToyMVrOJ94zAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wM1QwMjowNjo1NFrOKdCVhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODg3MzQ3NQ==", "bodyText": "Seems we are providing the message service under the admin package, is it better to use a separate package for implementing the REST API for the messaging service?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r668873475", "createdAt": "2021-07-13T15:25:21Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTUzNTYyMA==", "bodyText": "moved to a separate package org.apache.pulsar.broker.rest", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r701535620", "createdAt": "2021-09-03T02:06:54Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TopicsBase.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.admin.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.rest.RestMessagePublishContext;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODg3MzQ3NQ=="}, "originalCommit": {"oid": "f6dee7808d782a5d5a029ec6db0ec70f20d744e5"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ3MjM4NDI5OnYy", "diffSide": "LEFT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wM1QxNTowNTo0MVrOKdcZDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wNVQwMjozMzo1M1rOKd0Swg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTk2MjUwOA==", "bodyText": "Looks like an unrelated change.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r701962508", "createdAt": "2021-09-03T15:05:41Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "diffHunk": "@@ -34,7 +34,7 @@\n  * 2.The whole range of hash value could be covered by all the consumers.\n  * 3.Once a consumer is removed, the left consumers could still serve the whole range.\n  *\n- * Initializing with a fixed hash range, by default 2 << 5.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b61c6c2cbed1ca0a7c2bf41a47c25734c775bc6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjM1NDExNA==", "bodyText": "https://github.com/apache/pulsar/blob/master/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/StickyKeyConsumerSelector.java#L28\nJust fixing an inconsistent doc when I saw it, probably doesn't worth a separate for such one line change.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r702354114", "createdAt": "2021-09-05T02:33:53Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "diffHunk": "@@ -34,7 +34,7 @@\n  * 2.The whole range of hash value could be covered by all the consumers.\n  * 3.Once a consumer is removed, the left consumers could still serve the whole range.\n  *\n- * Initializing with a fixed hash range, by default 2 << 5.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTk2MjUwOA=="}, "originalCommit": {"oid": "6b61c6c2cbed1ca0a7c2bf41a47c25734c775bc6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ3ODg0MTAzOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/rest/Topics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wNlQxMjowNzozNlrOKeSl9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wN1QwNDoyMDowNVrOKelw9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjg1MDU0OA==", "bodyText": "There seems to be a security issue, can I send messages to any topic?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r702850548", "createdAt": "2021-09-06T12:07:36Z", "author": {"login": "315157973"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/rest/Topics.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.rest;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.Encoded;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.MediaType;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+@Path(\"/\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Produces(MediaType.APPLICATION_JSON)\n+@Api(value = \"/persistent\", description = \"Apis for produce,consume and ack message on topics.\", tags = \"topics\")\n+public class Topics extends TopicsBase {\n+\n+    @POST\n+    @Path(\"/persistent/{tenant}/{namespace}/{topic}\")\n+    @ApiOperation(value = \"Produce message to a persistent topic.\", response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnPersistentTopic(@Suspended final AsyncResponse asyncResponse,\n+                               @ApiParam(value = \"Specify the tenant\", required = true)\n+                               @PathParam(\"tenant\") String tenant,\n+                               @ApiParam(value = \"Specify the namespace\", required = true)\n+                               @PathParam(\"namespace\") String namespace,\n+                               @ApiParam(value = \"Specify topic name\", required = true)\n+                               @PathParam(\"topic\") @Encoded String encodedTopic,\n+                               @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative,\n+                               ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessages(asyncResponse, producerMessages, authoritative);\n+    }\n+\n+    @POST\n+    @Path(\"/persistent/{tenant}/{namespace}/{topic}/partitions/{partition}\")\n+    @ApiOperation(value = \"Produce message to a partition of a persistent topic.\",\n+            response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnPersistentTopicPartition(@Suspended final AsyncResponse asyncResponse,\n+                                        @ApiParam(value = \"Specify the tenant\", required = true)\n+                                        @PathParam(\"tenant\") String tenant,\n+                                        @ApiParam(value = \"Specify the namespace\", required = true)\n+                                        @PathParam(\"namespace\") String namespace,\n+                                        @ApiParam(value = \"Specify topic name\", required = true)\n+                                        @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                        @ApiParam(value = \"Specify topic partition\", required = true)\n+                                        @PathParam(\"partition\") int partition,\n+                                        @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative,\n+                                        ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessagesToPartition(asyncResponse, producerMessages, authoritative, partition);\n+    }\n+\n+    @POST\n+    @Path(\"/non-persistent/{tenant}/{namespace}/{topic}\")\n+    @ApiOperation(value = \"Produce message to a persistent topic.\", response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnNonPersistentTopic(@Suspended final AsyncResponse asyncResponse,\n+                                         @ApiParam(value = \"Specify the tenant\", required = true)\n+                                         @PathParam(\"tenant\") String tenant,\n+                                         @ApiParam(value = \"Specify the namespace\", required = true)\n+                                         @PathParam(\"namespace\") String namespace,\n+                                         @ApiParam(value = \"Specify topic name\", required = true)\n+                                         @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                         @QueryParam(\"authoritative\") @DefaultValue(\"false\")\n+                                                        boolean authoritative,\n+                                         ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessages(asyncResponse, producerMessages, authoritative);\n+    }\n+\n+    @POST\n+    @Path(\"/non-persistent/{tenant}/{namespace}/{topic}/partitions/{partition}\")\n+    @ApiOperation(value = \"Produce message to a partition of a persistent topic.\",\n+            response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnNonPersistentTopicPartition(@Suspended final AsyncResponse asyncResponse,\n+                                                  @ApiParam(value = \"Specify the tenant\", required = true)\n+                                                  @PathParam(\"tenant\") String tenant,\n+                                                  @ApiParam(value = \"Specify the namespace\", required = true)\n+                                                  @PathParam(\"namespace\") String namespace,\n+                                                  @ApiParam(value = \"Specify topic name\", required = true)\n+                                                  @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                                  @ApiParam(value = \"Specify topic partition\", required = true)\n+                                                  @PathParam(\"partition\") int partition,\n+                                                  @QueryParam(\"authoritative\") @DefaultValue(\"false\")\n+                                                                 boolean authoritative,\n+                                                  ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessagesToPartition(asyncResponse, producerMessages, authoritative, partition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd2ecaba82d74192d18369c336eb34ab309ec055"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzE2NDY2Mg==", "bodyText": "yeah, we're missing permission check here,\nadded check to use AuthorizationService#canProduce to verify caller have the permission to publish on given topic.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r703164662", "createdAt": "2021-09-07T04:20:05Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/rest/Topics.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.rest;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.Encoded;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.MediaType;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+@Path(\"/\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Produces(MediaType.APPLICATION_JSON)\n+@Api(value = \"/persistent\", description = \"Apis for produce,consume and ack message on topics.\", tags = \"topics\")\n+public class Topics extends TopicsBase {\n+\n+    @POST\n+    @Path(\"/persistent/{tenant}/{namespace}/{topic}\")\n+    @ApiOperation(value = \"Produce message to a persistent topic.\", response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnPersistentTopic(@Suspended final AsyncResponse asyncResponse,\n+                               @ApiParam(value = \"Specify the tenant\", required = true)\n+                               @PathParam(\"tenant\") String tenant,\n+                               @ApiParam(value = \"Specify the namespace\", required = true)\n+                               @PathParam(\"namespace\") String namespace,\n+                               @ApiParam(value = \"Specify topic name\", required = true)\n+                               @PathParam(\"topic\") @Encoded String encodedTopic,\n+                               @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative,\n+                               ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessages(asyncResponse, producerMessages, authoritative);\n+    }\n+\n+    @POST\n+    @Path(\"/persistent/{tenant}/{namespace}/{topic}/partitions/{partition}\")\n+    @ApiOperation(value = \"Produce message to a partition of a persistent topic.\",\n+            response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnPersistentTopicPartition(@Suspended final AsyncResponse asyncResponse,\n+                                        @ApiParam(value = \"Specify the tenant\", required = true)\n+                                        @PathParam(\"tenant\") String tenant,\n+                                        @ApiParam(value = \"Specify the namespace\", required = true)\n+                                        @PathParam(\"namespace\") String namespace,\n+                                        @ApiParam(value = \"Specify topic name\", required = true)\n+                                        @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                        @ApiParam(value = \"Specify topic partition\", required = true)\n+                                        @PathParam(\"partition\") int partition,\n+                                        @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative,\n+                                        ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessagesToPartition(asyncResponse, producerMessages, authoritative, partition);\n+    }\n+\n+    @POST\n+    @Path(\"/non-persistent/{tenant}/{namespace}/{topic}\")\n+    @ApiOperation(value = \"Produce message to a persistent topic.\", response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnNonPersistentTopic(@Suspended final AsyncResponse asyncResponse,\n+                                         @ApiParam(value = \"Specify the tenant\", required = true)\n+                                         @PathParam(\"tenant\") String tenant,\n+                                         @ApiParam(value = \"Specify the namespace\", required = true)\n+                                         @PathParam(\"namespace\") String namespace,\n+                                         @ApiParam(value = \"Specify topic name\", required = true)\n+                                         @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                         @QueryParam(\"authoritative\") @DefaultValue(\"false\")\n+                                                        boolean authoritative,\n+                                         ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessages(asyncResponse, producerMessages, authoritative);\n+    }\n+\n+    @POST\n+    @Path(\"/non-persistent/{tenant}/{namespace}/{topic}/partitions/{partition}\")\n+    @ApiOperation(value = \"Produce message to a partition of a persistent topic.\",\n+            response = String.class, responseContainer = \"List\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 404, message = \"tenant/namespace/topic doesn't exit\"),\n+            @ApiResponse(code = 412, message = \"Namespace name is not valid\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\") })\n+    public void produceOnNonPersistentTopicPartition(@Suspended final AsyncResponse asyncResponse,\n+                                                  @ApiParam(value = \"Specify the tenant\", required = true)\n+                                                  @PathParam(\"tenant\") String tenant,\n+                                                  @ApiParam(value = \"Specify the namespace\", required = true)\n+                                                  @PathParam(\"namespace\") String namespace,\n+                                                  @ApiParam(value = \"Specify topic name\", required = true)\n+                                                  @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                                  @ApiParam(value = \"Specify topic partition\", required = true)\n+                                                  @PathParam(\"partition\") int partition,\n+                                                  @QueryParam(\"authoritative\") @DefaultValue(\"false\")\n+                                                                 boolean authoritative,\n+                                                  ProducerMessages producerMessages) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        publishMessagesToPartition(asyncResponse, producerMessages, authoritative, partition);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjg1MDU0OA=="}, "originalCommit": {"oid": "cd2ecaba82d74192d18369c336eb34ab309ec055"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ3ODg1MzA4OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/rest/TopicsBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wNlQxMjoxMDo0MVrOKeSs-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wN1QwNDoyMzo1MFrOKel1Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjg1MjM0Nw==", "bodyText": "Should it be moved to SchemaUtils?", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r702852347", "createdAt": "2021-09-06T12:10:41Z", "author": {"login": "315157973"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/rest/TopicsBase.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.rest;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.admin.impl.PersistentTopicsBase;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaImpl;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.SchemaInfoImpl;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    // Publish message to a topic, can be partitioned or non-partitioned\n+    protected void publishMessages(AsyncResponse asyncResponse, ProducerMessages request, boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        try {\n+            if (pulsar().getBrokerService().getOwningTopics().containsKey(topic)\n+                    || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+                // If we've done look up or or after look up this broker owns some of the partitions\n+                // then proceed to publish message else asyncResponse will be complete by look up.\n+                addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                        request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+                        .thenAccept(schemaMeta -> {\n+                            // Both schema version and schema data are necessary.\n+                            if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                                internalPublishMessages(topicName, request, pulsar().getBrokerService()\n+                                                .getOwningTopics().get(topic).values(), asyncResponse,\n+                                        AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                                        schemaMeta.getRight());\n+                            } else {\n+                                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                        \"Fail to add or retrieve schema.\"));\n+                            }\n+                        }).exceptionally(e -> {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish message: \" + e.getMessage());\n+                    }\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message:\"\n+                            + e.getMessage()));\n+                    return null;\n+                });\n+            }\n+        } catch (Exception e) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message: \"\n+                    + e.getMessage()));\n+        }\n+    }\n+\n+    // Publish message to single partition of a partitioned topic.\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        try {\n+            // If broker owns the partition then proceed to publish message, else do look up.\n+            if ((pulsar().getBrokerService().getOwningTopics().containsKey(topic)\n+                    && pulsar().getBrokerService().getOwningTopics().get(topic)\n+                    .contains(partition))\n+                    || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+                addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                        request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+                        .thenAccept(schemaMeta -> {\n+                            // Both schema version and schema data are necessary.\n+                            if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                                internalPublishMessagesToPartition(topicName, request, partition, asyncResponse,\n+                                        AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                                        schemaMeta.getRight());\n+                            } else {\n+                                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                        \"Fail to add or retrieve schema.\"));\n+                            }\n+                        }).exceptionally(e -> {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish message to single partition: \" + e.getLocalizedMessage());\n+                    }\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message\"\n+                            + \"to single partition: \"\n+                            + e.getMessage()));\n+                    return null;\n+                });\n+            }\n+        } catch (Exception e) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message: \"\n+                    + e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessagesToPartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  Schema schema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName, topicName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail publish messages to single partition with rest produce message \"\n+                                + \"request for topic  {}: {} \", topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessages(TopicName topicName, ProducerMessages request,\n+                                                     List<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, Schema schema,\n+                                                     SchemaVersion schemaVersion) {\n+        if (partitionIndexes.size() < 1) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                    new BrokerServiceException.TopicNotFoundException(\"Topic not owned by current broker.\")));\n+        }\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName, topicName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            // Try to publish messages to all partitions this broker owns in round robin mode.\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partitionIndexes.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partitionIndexes\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to publish messages with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog and fail if backlog too large.\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                pulsar().getBrokerService().getOwningTopics().get(topicName.getPartitionedTopicName())\n+                        .remove(topicName.getPartitionIndex());\n+            } else {\n+                try {\n+                    t.get().publishMessage(messageToByteBuf(message),\n+                            RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+                } catch (Exception e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish single messages to topic  {}: {} \",\n+                                topicName, e.getCause());\n+                    }\n+                    publishResult.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    // Process results for all message publishing attempts\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    pulsar().getBrokerService().getOwningTopics().remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    // Return error code depends on exception we got indicating if client should retry with same broker.\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic. Return if asyncResponse has been completed\n+    // which indicating redirect or exception.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            processLookUpResult(redirectAddresses, asyncResponse, future);\n+        }).exceptionally(e -> {\n+            processLookUpResult(redirectAddresses, asyncResponse, future);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            if (!asyncResponse.isDone()) {\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Internal error: \"\n+                        + e.getMessage()));\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private void processLookUpResult(List<String> redirectAddresses,  AsyncResponse asyncResponse,\n+                                     CompletableFuture<Boolean> future) {\n+        // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+        // that own partition of the topic or know who own partition of the topic.\n+        if (!pulsar().getBrokerService().getOwningTopics().containsKey(topicName.getPartitionedTopicName())) {\n+            if (redirectAddresses.isEmpty()) {\n+                // No broker to redirect, means look up for some partitions failed,\n+                // client should retry with other brokers.\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                future.complete(true);\n+            } else {\n+                // Redirect client to other broker owns the topic or know which broker own the topic.\n+                try {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Redirect rest produce request for topic {} from {} to {}.\",\n+                                topicName, pulsar().getWebServiceAddress(), redirectAddresses.get(0));\n+                    }\n+                    URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath(false)));\n+                    asyncResponse.resume(Response.temporaryRedirect(redirectURI).build());\n+                    future.complete(true);\n+                } catch (URISyntaxException | NullPointerException e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                    }\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to redirect client request.\"));\n+                    future.complete(true);\n+                }\n+            }\n+        } else {\n+            future.complete(false);\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        if (!pulsar().getBrokerService().getLookupRequestSemaphore().tryAcquire()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Too many concurrent lookup request.\");\n+            }\n+            future.completeExceptionally(new BrokerServiceException.TooManyRequestsException(\"Too many \"\n+                    + \"concurrent lookup request\"));\n+            return future;\n+        }\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                pulsar().getBrokerService().getOwningTopics().computeIfAbsent(partitionedTopicName\n+                                .getPartitionedTopicName(), (key) -> new ConcurrentOpenHashSet<Integer>())\n+                        .add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to lookup broker with rest produce message request for topic {}: {}\",\n+                        partitionedTopicName, exception.getMessage());\n+            }\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      LongSchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        // If schema version presents try to fetch existing schema.\n+        if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to retrieve schema of version {} for topic {}: {}\",\n+                            schemaVersion.getVersion(), topicName, e.getMessage());\n+                }\n+                future.completeExceptionally(e);\n+            }\n+        } else if (null != schemaData) {\n+            // Else try to add schema to topic.\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to add schema {} for topic {}: {}\",\n+                            new String(schemaData.toSchemaInfo().getSchema()), topicName, e.getMessage());\n+                }\n+                future.completeExceptionally(e);\n+            }\n+        } else {\n+            // Indicating exception.\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    // Add a new schema to schema registry for a topic\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = pulsar().getBrokerService().getOwningTopics()\n+                .get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to add schema to topic \" + topicName.getPartitionedTopicName()\n+                            + \" for partition \" + partitions.get(index) + \" for REST produce request.\");\n+                }\n+            }\n+        }\n+        // Not able to add schema to any partition\n+        if (!result.isDone()) {\n+            result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                    + \" to topic \" + topicName.getPartitionedTopicName()));\n+        }\n+        return result;\n+    }\n+\n+    // Build schemaData from passed in schema string.\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            SchemaInfoImpl valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                    ? (SchemaInfoImpl) StringSchema.utf8().getSchemaInfo() :\n+                    ObjectMapperFactory.getThreadLocal()\n+                            .readValue(valueSchema, SchemaInfoImpl.class);\n+            if (null == valueSchemaInfo.getName()) {\n+                valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+            }\n+            // Value schema only\n+            if (keySchema == null || keySchema.isEmpty()) {\n+                return SchemaData.builder()\n+                        .data(valueSchemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(valueSchemaInfo.getType())\n+                        .props(valueSchemaInfo.getProperties())\n+                        .build();\n+            } else {\n+                // Key_Value schema\n+                SchemaInfoImpl keySchemaInfo = ObjectMapperFactory.getThreadLocal()\n+                        .readValue(keySchema, SchemaInfoImpl.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"\n+                                + topicName.getPartitionedTopicName(),\n+                        keySchemaInfo, valueSchemaInfo,\n+                        KeyValueEncodingType.SEPARATED);\n+                return SchemaData.builder()\n+                        .data(schemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(schemaInfo.getType())\n+                        .props(schemaInfo.getProperties())\n+                        .build();\n+            }\n+        } catch (IOException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to parse schema info for rest produce request with key schema {} and value schema {}\"\n+                        , keySchema, valueSchema);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    // Convert message to ByteBuf\n+    public ByteBuf messageToByteBuf(Message message) {\n+        checkArgument(message instanceof MessageImpl, \"Message must be type of MessageImpl.\");\n+\n+        MessageImpl msg = (MessageImpl) message;\n+        MessageMetadata messageMetadata = msg.getMessageBuilder();\n+        ByteBuf payload = msg.getDataBuffer();\n+        messageMetadata.setCompression(CompressionCodecProvider.convertToWireProtocol(CompressionType.NONE));\n+        messageMetadata.setUncompressedSize(payload.readableBytes());\n+\n+        return Commands.serializeMetadataAndPayload(Commands.ChecksumType.Crc32c, messageMetadata, payload);\n+    }\n+\n+    // Build pulsar message from REST request.\n+    private List<Message> buildMessage(ProducerMessages producerMessages, Schema schema,\n+                                       String producerName, TopicName topicName) {\n+        List<ProducerMessage> messages;\n+        List<Message> pulsarMessages = new ArrayList<>();\n+\n+        messages = producerMessages.getMessages();\n+        for (ProducerMessage message : messages) {\n+            MessageMetadata messageMetadata = new MessageMetadata();\n+            messageMetadata.setProducerName(producerName);\n+            messageMetadata.setPublishTime(System.currentTimeMillis());\n+            messageMetadata.setSequenceId(message.getSequenceId());\n+            if (null != message.getReplicationClusters()) {\n+                messageMetadata.addAllReplicateTos(message.getReplicationClusters());\n+            }\n+\n+            if (null != message.getProperties()) {\n+                messageMetadata.addAllProperties(message.getProperties().entrySet().stream().map(entry -> {\n+                    org.apache.pulsar.common.api.proto.KeyValue keyValue =\n+                            new org.apache.pulsar.common.api.proto.KeyValue();\n+                    keyValue.setKey(entry.getKey());\n+                    keyValue.setValue(entry.getValue());\n+                    return keyValue;\n+                }).collect(Collectors.toList()));\n+            }\n+            if (null != message.getKey()) {\n+                // If has key schema, encode partition key, else use plain text.\n+                if (schema.getSchemaInfo().getType() == SchemaType.KEY_VALUE) {\n+                    KeyValueSchemaImpl kvSchema = (KeyValueSchemaImpl) schema;\n+                    messageMetadata.setPartitionKey(\n+                            Base64.getEncoder().encodeToString(encodeWithSchema(message.getKey(),\n+                                    kvSchema.getKeySchema())));\n+                    messageMetadata.setPartitionKeyB64Encoded(true);\n+                } else {\n+                    messageMetadata.setPartitionKey(message.getKey());\n+                    messageMetadata.setPartitionKeyB64Encoded(false);\n+                }\n+            }\n+            if (null != message.getEventTime() && !message.getEventTime().isEmpty()) {\n+                messageMetadata.setEventTime(Long.valueOf(message.getEventTime()));\n+            }\n+            if (message.isDisableReplication()) {\n+                messageMetadata.clearReplicateTo();\n+                messageMetadata.addReplicateTo(\"__local__\");\n+            }\n+            if (message.getDeliverAt() != 0 && messageMetadata.hasEventTime()) {\n+                messageMetadata.setDeliverAtTime(message.getDeliverAt());\n+            } else if (message.getDeliverAfterMs() != 0) {\n+                messageMetadata.setDeliverAtTime(messageMetadata.getEventTime() + message.getDeliverAfterMs());\n+            }\n+            if (schema.getSchemaInfo().getType() == SchemaType.KEY_VALUE) {\n+                KeyValueSchemaImpl kvSchema = (KeyValueSchemaImpl) schema;\n+                pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                        ByteBuffer.wrap(encodeWithSchema(message.getPayload(), kvSchema.getValueSchema())),\n+                        schema, topicName.toString()));\n+            } else {\n+                pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                        ByteBuffer.wrap(encodeWithSchema(message.getPayload(), schema)), schema,\n+                        topicName.toString()));\n+            }\n+        }\n+\n+        return pulsarMessages;\n+    }\n+\n+    // Encode message with corresponding schema, do necessary conversion before encoding\n+    private byte[] encodeWithSchema(String input, Schema schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd2ecaba82d74192d18369c336eb34ab309ec055"}, "originalPosition": 661}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzE2NTcxMA==", "bodyText": "I took a look, and I think this method is very specific for REST API, mostly encode a message in String with given schema and contains some custom logic when handling Json/Avro schema, might not be useful for other use case, so I think we can keep it here for now, and if we find it can we reuse somewhere else then we can move it to SchemaUtils later.", "url": "https://github.com/apache/pulsar/pull/8125#discussion_r703165710", "createdAt": "2021-09-07T04:23:50Z", "author": {"login": "MarvinCai"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/rest/TopicsBase.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.rest;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pulsar.broker.admin.impl.PersistentTopicsBase;\n+import org.apache.pulsar.broker.lookup.LookupResult;\n+import org.apache.pulsar.broker.namespace.LookupOptions;\n+import org.apache.pulsar.broker.service.BrokerServiceException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistry;\n+import org.apache.pulsar.broker.service.schema.exceptions.SchemaException;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.CompressionType;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.Schema;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.schema.AutoConsumeSchema;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaImpl;\n+import org.apache.pulsar.client.impl.schema.KeyValueSchemaInfo;\n+import org.apache.pulsar.client.impl.schema.SchemaInfoImpl;\n+import org.apache.pulsar.client.impl.schema.StringSchema;\n+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;\n+import org.apache.pulsar.common.api.proto.MessageMetadata;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.partition.PartitionedTopicMetadata;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.KeyValueEncodingType;\n+import org.apache.pulsar.common.schema.LongSchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaInfo;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n+import org.apache.pulsar.common.util.collections.ConcurrentOpenHashSet;\n+import org.apache.pulsar.websocket.data.ProducerAck;\n+import org.apache.pulsar.websocket.data.ProducerAcks;\n+import org.apache.pulsar.websocket.data.ProducerMessage;\n+import org.apache.pulsar.websocket.data.ProducerMessages;\n+\n+/**\n+ * Contains methods used by REST api to producer/consumer/read messages to/from pulsar topics.\n+ */\n+@Slf4j\n+public class TopicsBase extends PersistentTopicsBase {\n+\n+    private static String defaultProducerName = \"RestProducer\";\n+\n+    // Publish message to a topic, can be partitioned or non-partitioned\n+    protected void publishMessages(AsyncResponse asyncResponse, ProducerMessages request, boolean authoritative) {\n+        String topic = topicName.getPartitionedTopicName();\n+        try {\n+            if (pulsar().getBrokerService().getOwningTopics().containsKey(topic)\n+                    || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+                // If we've done look up or or after look up this broker owns some of the partitions\n+                // then proceed to publish message else asyncResponse will be complete by look up.\n+                addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                        request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+                        .thenAccept(schemaMeta -> {\n+                            // Both schema version and schema data are necessary.\n+                            if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                                internalPublishMessages(topicName, request, pulsar().getBrokerService()\n+                                                .getOwningTopics().get(topic).values(), asyncResponse,\n+                                        AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                                        schemaMeta.getRight());\n+                            } else {\n+                                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                        \"Fail to add or retrieve schema.\"));\n+                            }\n+                        }).exceptionally(e -> {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish message: \" + e.getMessage());\n+                    }\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message:\"\n+                            + e.getMessage()));\n+                    return null;\n+                });\n+            }\n+        } catch (Exception e) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message: \"\n+                    + e.getMessage()));\n+        }\n+    }\n+\n+    // Publish message to single partition of a partitioned topic.\n+    protected void publishMessagesToPartition(AsyncResponse asyncResponse, ProducerMessages request,\n+                                                     boolean authoritative, int partition) {\n+        if (topicName.isPartitioned()) {\n+            asyncResponse.resume(new RestException(Status.BAD_REQUEST, \"Topic name can't contain \"\n+                    + \"'-partition-' suffix.\"));\n+        }\n+        String topic = topicName.getPartitionedTopicName();\n+        try {\n+            // If broker owns the partition then proceed to publish message, else do look up.\n+            if ((pulsar().getBrokerService().getOwningTopics().containsKey(topic)\n+                    && pulsar().getBrokerService().getOwningTopics().get(topic)\n+                    .contains(partition))\n+                    || !findOwnerBrokerForTopic(authoritative, asyncResponse)) {\n+                addOrGetSchemaForTopic(getSchemaData(request.getKeySchema(), request.getValueSchema()),\n+                        request.getSchemaVersion() == -1 ? null : new LongSchemaVersion(request.getSchemaVersion()))\n+                        .thenAccept(schemaMeta -> {\n+                            // Both schema version and schema data are necessary.\n+                            if (schemaMeta.getLeft() != null && schemaMeta.getRight() != null) {\n+                                internalPublishMessagesToPartition(topicName, request, partition, asyncResponse,\n+                                        AutoConsumeSchema.getSchema(schemaMeta.getLeft().toSchemaInfo()),\n+                                        schemaMeta.getRight());\n+                            } else {\n+                                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                                        \"Fail to add or retrieve schema.\"));\n+                            }\n+                        }).exceptionally(e -> {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish message to single partition: \" + e.getLocalizedMessage());\n+                    }\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message\"\n+                            + \"to single partition: \"\n+                            + e.getMessage()));\n+                    return null;\n+                });\n+            }\n+        } catch (Exception e) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Fail to publish message: \"\n+                    + e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessagesToPartition(TopicName topicName, ProducerMessages request,\n+                                                  int partition, AsyncResponse asyncResponse,\n+                                                  Schema schema, SchemaVersion schemaVersion) {\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName, topicName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partition + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partition).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail publish messages to single partition with rest produce message \"\n+                                + \"request for topic  {}: {} \", topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private void internalPublishMessages(TopicName topicName, ProducerMessages request,\n+                                                     List<Integer> partitionIndexes,\n+                                                     AsyncResponse asyncResponse, Schema schema,\n+                                                     SchemaVersion schemaVersion) {\n+        if (partitionIndexes.size() < 1) {\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                    new BrokerServiceException.TopicNotFoundException(\"Topic not owned by current broker.\")));\n+        }\n+        try {\n+            String producerName = (null == request.getProducerName() || request.getProducerName().isEmpty())\n+                    ? defaultProducerName : request.getProducerName();\n+            List<Message> messages = buildMessage(request, schema, producerName, topicName);\n+            List<CompletableFuture<PositionImpl>> publishResults = new ArrayList<>();\n+            List<ProducerAck> produceMessageResults = new ArrayList<>();\n+            // Try to publish messages to all partitions this broker owns in round robin mode.\n+            for (int index = 0; index < messages.size(); index++) {\n+                ProducerAck produceMessageResult = new ProducerAck();\n+                produceMessageResult.setMessageId(partitionIndexes.get(index % (int) partitionIndexes.size()) + \"\");\n+                produceMessageResults.add(produceMessageResult);\n+                publishResults.add(publishSingleMessageToPartition(topicName.getPartition(partitionIndexes\n+                                .get(index % (int) partitionIndexes.size())).toString(),\n+                        messages.get(index)));\n+            }\n+            FutureUtil.waitForAll(publishResults).thenRun(() -> {\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+            }).exceptionally(e -> {\n+                // Some message may published successfully, so till return ok with result for each individual message.\n+                processPublishMessageResults(produceMessageResults, publishResults);\n+                asyncResponse.resume(Response.ok().entity(new ProducerAcks(produceMessageResults,\n+                        ((LongSchemaVersion) schemaVersion).getVersion())).build());\n+                return null;\n+            });\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to publish messages with rest produce message request for topic  {}: {} \",\n+                        topicName, e.getCause());\n+            }\n+            asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, e.getMessage()));\n+        }\n+    }\n+\n+    private CompletableFuture<PositionImpl> publishSingleMessageToPartition(String topic, Message message) {\n+        CompletableFuture<PositionImpl> publishResult = new CompletableFuture<>();\n+        pulsar().getBrokerService().getTopic(topic, false)\n+        .thenAccept(t -> {\n+            // TODO: Check message backlog and fail if backlog too large.\n+            if (!t.isPresent()) {\n+                // Topic not found, and remove from owning partition list.\n+                publishResult.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\"Topic not \"\n+                        + \"owned by current broker.\"));\n+                TopicName topicName = TopicName.get(topic);\n+                pulsar().getBrokerService().getOwningTopics().get(topicName.getPartitionedTopicName())\n+                        .remove(topicName.getPartitionIndex());\n+            } else {\n+                try {\n+                    t.get().publishMessage(messageToByteBuf(message),\n+                            RestMessagePublishContext.get(publishResult, t.get(), System.nanoTime()));\n+                } catch (Exception e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Fail to publish single messages to topic  {}: {} \",\n+                                topicName, e.getCause());\n+                    }\n+                    publishResult.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        return publishResult;\n+    }\n+\n+    // Process results for all message publishing attempts\n+    private void processPublishMessageResults(List<ProducerAck> produceMessageResults,\n+                                              List<CompletableFuture<PositionImpl>> publishResults) {\n+        // process publish message result\n+        for (int index = 0; index < publishResults.size(); index++) {\n+            try {\n+                PositionImpl position = publishResults.get(index).get();\n+                MessageId messageId = new MessageIdImpl(position.getLedgerId(), position.getEntryId(),\n+                        Integer.parseInt(produceMessageResults.get(index).getMessageId()));\n+                produceMessageResults.get(index).setMessageId(messageId.toString());\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail publish [{}] message with rest produce message request for topic  {}: {} \",\n+                            index, topicName);\n+                }\n+                if (e instanceof BrokerServiceException.TopicNotFoundException) {\n+                    // Topic ownership might changed, force to look up again.\n+                    pulsar().getBrokerService().getOwningTopics().remove(topicName.getPartitionedTopicName());\n+                }\n+                extractException(e, produceMessageResults.get(index));\n+            }\n+        }\n+    }\n+\n+    // Return error code depends on exception we got indicating if client should retry with same broker.\n+    private void extractException(Exception e, ProducerAck produceMessageResult) {\n+        if (!(e instanceof BrokerServiceException.TopicFencedException && e instanceof ManagedLedgerException)) {\n+            produceMessageResult.setErrorCode(2);\n+        } else {\n+            produceMessageResult.setErrorCode(1);\n+        }\n+        produceMessageResult.setErrorMsg(e.getMessage());\n+    }\n+\n+    // Look up topic owner for given topic. Return if asyncResponse has been completed\n+    // which indicating redirect or exception.\n+    private boolean findOwnerBrokerForTopic(boolean authoritative, AsyncResponse asyncResponse) {\n+        PartitionedTopicMetadata metadata = internalGetPartitionedMetadata(authoritative, false);\n+        List<String> redirectAddresses = Collections.synchronizedList(new ArrayList<>());\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        List<CompletableFuture<Void>> lookupFutures = new ArrayList<>();\n+        if (!topicName.isPartitioned() && metadata.partitions > 1) {\n+            // Partitioned topic with multiple partitions, need to do look up for each partition.\n+            for (int index = 0; index < metadata.partitions; index++) {\n+                lookupFutures.add(lookUpBrokerForTopic(topicName.getPartition(index),\n+                        authoritative, redirectAddresses));\n+            }\n+        } else {\n+            // Non-partitioned topic or specific topic partition.\n+            lookupFutures.add(lookUpBrokerForTopic(topicName, authoritative, redirectAddresses));\n+        }\n+\n+        FutureUtil.waitForAll(lookupFutures)\n+        .thenRun(() -> {\n+            processLookUpResult(redirectAddresses, asyncResponse, future);\n+        }).exceptionally(e -> {\n+            processLookUpResult(redirectAddresses, asyncResponse, future);\n+            return null;\n+        });\n+        try {\n+            return future.get();\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to lookup topic for rest produce message request for topic {}.\", topicName.toString());\n+            }\n+            if (!asyncResponse.isDone()) {\n+                asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR, \"Internal error: \"\n+                        + e.getMessage()));\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private void processLookUpResult(List<String> redirectAddresses,  AsyncResponse asyncResponse,\n+                                     CompletableFuture<Boolean> future) {\n+        // Current broker doesn't own the topic or any partition of the topic, redirect client to a broker\n+        // that own partition of the topic or know who own partition of the topic.\n+        if (!pulsar().getBrokerService().getOwningTopics().containsKey(topicName.getPartitionedTopicName())) {\n+            if (redirectAddresses.isEmpty()) {\n+                // No broker to redirect, means look up for some partitions failed,\n+                // client should retry with other brokers.\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Can't find owner of given topic.\"));\n+                future.complete(true);\n+            } else {\n+                // Redirect client to other broker owns the topic or know which broker own the topic.\n+                try {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Redirect rest produce request for topic {} from {} to {}.\",\n+                                topicName, pulsar().getWebServiceAddress(), redirectAddresses.get(0));\n+                    }\n+                    URI redirectURI = new URI(String.format(\"%s%s\", redirectAddresses.get(0), uri.getPath(false)));\n+                    asyncResponse.resume(Response.temporaryRedirect(redirectURI).build());\n+                    future.complete(true);\n+                } catch (URISyntaxException | NullPointerException e) {\n+                    if (log.isDebugEnabled()) {\n+                        log.error(\"Error in preparing redirect url with rest produce message request for topic  {}: {}\",\n+                                topicName, e.getMessage(), e);\n+                    }\n+                    asyncResponse.resume(new RestException(Status.INTERNAL_SERVER_ERROR,\n+                            \"Fail to redirect client request.\"));\n+                    future.complete(true);\n+                }\n+            }\n+        } else {\n+            future.complete(false);\n+        }\n+    }\n+\n+    // Look up topic owner for non-partitioned topic or single topic partition.\n+    private CompletableFuture<Void> lookUpBrokerForTopic(TopicName partitionedTopicName,\n+                                                         boolean authoritative, List<String> redirectAddresses) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        if (!pulsar().getBrokerService().getLookupRequestSemaphore().tryAcquire()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Too many concurrent lookup request.\");\n+            }\n+            future.completeExceptionally(new BrokerServiceException.TooManyRequestsException(\"Too many \"\n+                    + \"concurrent lookup request\"));\n+            return future;\n+        }\n+        CompletableFuture<Optional<LookupResult>> lookupFuture = pulsar().getNamespaceService()\n+                .getBrokerServiceUrlAsync(partitionedTopicName,\n+                        LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build());\n+\n+        lookupFuture.thenAccept(optionalResult -> {\n+            if (optionalResult == null || !optionalResult.isPresent()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to lookup topic for rest produce message request for topic {}.\",\n+                            partitionedTopicName);\n+                }\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+                return;\n+            }\n+\n+            LookupResult result = optionalResult.get();\n+            if (result.getLookupData().getHttpUrl().equals(pulsar().getWebServiceAddress())) {\n+                // Current broker owns the topic, add to owning topic.\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                pulsar().getBrokerService().getOwningTopics().computeIfAbsent(partitionedTopicName\n+                                .getPartitionedTopicName(), (key) -> new ConcurrentOpenHashSet<Integer>())\n+                        .add(partitionedTopicName.getPartitionIndex());\n+                completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            } else {\n+                // Current broker doesn't own the topic or doesn't know who own the topic.\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Complete topic look up for rest produce message request for topic {}, \"\n+                                    + \"current broker is not owner broker: {}\",\n+                            partitionedTopicName, result.getLookupData());\n+                }\n+                if (result.isRedirect()) {\n+                    // Redirect lookup.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), false), redirectAddresses, future);\n+                } else {\n+                    // Found owner for topic.\n+                    completeLookup(Pair.of(Arrays.asList(result.getLookupData().getHttpUrl(),\n+                            result.getLookupData().getHttpUrlTls()), true), redirectAddresses, future);\n+                }\n+            }\n+        }).exceptionally(exception -> {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to lookup broker with rest produce message request for topic {}: {}\",\n+                        partitionedTopicName, exception.getMessage());\n+            }\n+            completeLookup(Pair.of(Collections.emptyList(), false), redirectAddresses, future);\n+            return null;\n+        });\n+        return future;\n+    }\n+\n+    private CompletableFuture<Pair<SchemaData, SchemaVersion>> addOrGetSchemaForTopic(SchemaData schemaData,\n+                                                                                      LongSchemaVersion schemaVersion) {\n+        CompletableFuture<Pair<SchemaData, SchemaVersion>> future = new CompletableFuture<>();\n+        // If schema version presents try to fetch existing schema.\n+        if (null != schemaVersion) {\n+            String id = TopicName.get(topicName.getPartitionedTopicName()).getSchemaName();\n+            SchemaRegistry.SchemaAndMetadata schemaAndMetadata;\n+            try {\n+                schemaAndMetadata = pulsar().getSchemaRegistryService().getSchema(id, schemaVersion).get();\n+                future.complete(Pair.of(schemaAndMetadata.schema, schemaAndMetadata.version));\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to retrieve schema of version {} for topic {}: {}\",\n+                            schemaVersion.getVersion(), topicName, e.getMessage());\n+                }\n+                future.completeExceptionally(e);\n+            }\n+        } else if (null != schemaData) {\n+            // Else try to add schema to topic.\n+            SchemaVersion sv;\n+            try {\n+                sv = addSchema(schemaData).get();\n+                future.complete(Pair.of(schemaData, sv));\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to add schema {} for topic {}: {}\",\n+                            new String(schemaData.toSchemaInfo().getSchema()), topicName, e.getMessage());\n+                }\n+                future.completeExceptionally(e);\n+            }\n+        } else {\n+            // Indicating exception.\n+            future.complete(Pair.of(null, null));\n+        }\n+        return future;\n+    }\n+\n+    // Add a new schema to schema registry for a topic\n+    private CompletableFuture<SchemaVersion> addSchema(SchemaData schemaData) {\n+        // Only need to add to first partition the broker owns since the schema id in schema registry are\n+        // same for all partitions which is the partitionedTopicName\n+        List<Integer> partitions = pulsar().getBrokerService().getOwningTopics()\n+                .get(topicName.getPartitionedTopicName()).values();\n+        CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+        for (int index = 0; index < partitions.size(); index++) {\n+            CompletableFuture<SchemaVersion> future = new CompletableFuture<>();\n+            String topicPartitionName = topicName.getPartition(partitions.get(index)).toString();\n+            pulsar().getBrokerService().getTopic(topicPartitionName, false)\n+            .thenAccept(topic -> {\n+                if (!topic.isPresent()) {\n+                    future.completeExceptionally(new BrokerServiceException.TopicNotFoundException(\n+                            \"Topic \" + topicPartitionName + \" not found\"));\n+                } else {\n+                    topic.get().addSchema(schemaData).thenAccept(schemaVersion -> future.complete(schemaVersion))\n+                    .exceptionally(exception -> {\n+                        future.completeExceptionally(exception);\n+                        return null;\n+                    });\n+                }\n+            });\n+            try {\n+                result.complete(future.get());\n+                break;\n+            } catch (Exception e) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Fail to add schema to topic \" + topicName.getPartitionedTopicName()\n+                            + \" for partition \" + partitions.get(index) + \" for REST produce request.\");\n+                }\n+            }\n+        }\n+        // Not able to add schema to any partition\n+        if (!result.isDone()) {\n+            result.completeExceptionally(new SchemaException(\"Unable to add schema \" + schemaData\n+                    + \" to topic \" + topicName.getPartitionedTopicName()));\n+        }\n+        return result;\n+    }\n+\n+    // Build schemaData from passed in schema string.\n+    private SchemaData getSchemaData(String keySchema, String valueSchema) {\n+        try {\n+            SchemaInfoImpl valueSchemaInfo = (valueSchema == null || valueSchema.isEmpty())\n+                    ? (SchemaInfoImpl) StringSchema.utf8().getSchemaInfo() :\n+                    ObjectMapperFactory.getThreadLocal()\n+                            .readValue(valueSchema, SchemaInfoImpl.class);\n+            if (null == valueSchemaInfo.getName()) {\n+                valueSchemaInfo.setName(valueSchemaInfo.getType().toString());\n+            }\n+            // Value schema only\n+            if (keySchema == null || keySchema.isEmpty()) {\n+                return SchemaData.builder()\n+                        .data(valueSchemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(valueSchemaInfo.getType())\n+                        .props(valueSchemaInfo.getProperties())\n+                        .build();\n+            } else {\n+                // Key_Value schema\n+                SchemaInfoImpl keySchemaInfo = ObjectMapperFactory.getThreadLocal()\n+                        .readValue(keySchema, SchemaInfoImpl.class);\n+                if (null == keySchemaInfo.getName()) {\n+                    keySchemaInfo.setName(keySchemaInfo.getType().toString());\n+                }\n+                SchemaInfo schemaInfo = KeyValueSchemaInfo.encodeKeyValueSchemaInfo(\"KVSchema-\"\n+                                + topicName.getPartitionedTopicName(),\n+                        keySchemaInfo, valueSchemaInfo,\n+                        KeyValueEncodingType.SEPARATED);\n+                return SchemaData.builder()\n+                        .data(schemaInfo.getSchema())\n+                        .isDeleted(false)\n+                        .user(\"Rest Producer\")\n+                        .timestamp(System.currentTimeMillis())\n+                        .type(schemaInfo.getType())\n+                        .props(schemaInfo.getProperties())\n+                        .build();\n+            }\n+        } catch (IOException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Fail to parse schema info for rest produce request with key schema {} and value schema {}\"\n+                        , keySchema, valueSchema);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    // Convert message to ByteBuf\n+    public ByteBuf messageToByteBuf(Message message) {\n+        checkArgument(message instanceof MessageImpl, \"Message must be type of MessageImpl.\");\n+\n+        MessageImpl msg = (MessageImpl) message;\n+        MessageMetadata messageMetadata = msg.getMessageBuilder();\n+        ByteBuf payload = msg.getDataBuffer();\n+        messageMetadata.setCompression(CompressionCodecProvider.convertToWireProtocol(CompressionType.NONE));\n+        messageMetadata.setUncompressedSize(payload.readableBytes());\n+\n+        return Commands.serializeMetadataAndPayload(Commands.ChecksumType.Crc32c, messageMetadata, payload);\n+    }\n+\n+    // Build pulsar message from REST request.\n+    private List<Message> buildMessage(ProducerMessages producerMessages, Schema schema,\n+                                       String producerName, TopicName topicName) {\n+        List<ProducerMessage> messages;\n+        List<Message> pulsarMessages = new ArrayList<>();\n+\n+        messages = producerMessages.getMessages();\n+        for (ProducerMessage message : messages) {\n+            MessageMetadata messageMetadata = new MessageMetadata();\n+            messageMetadata.setProducerName(producerName);\n+            messageMetadata.setPublishTime(System.currentTimeMillis());\n+            messageMetadata.setSequenceId(message.getSequenceId());\n+            if (null != message.getReplicationClusters()) {\n+                messageMetadata.addAllReplicateTos(message.getReplicationClusters());\n+            }\n+\n+            if (null != message.getProperties()) {\n+                messageMetadata.addAllProperties(message.getProperties().entrySet().stream().map(entry -> {\n+                    org.apache.pulsar.common.api.proto.KeyValue keyValue =\n+                            new org.apache.pulsar.common.api.proto.KeyValue();\n+                    keyValue.setKey(entry.getKey());\n+                    keyValue.setValue(entry.getValue());\n+                    return keyValue;\n+                }).collect(Collectors.toList()));\n+            }\n+            if (null != message.getKey()) {\n+                // If has key schema, encode partition key, else use plain text.\n+                if (schema.getSchemaInfo().getType() == SchemaType.KEY_VALUE) {\n+                    KeyValueSchemaImpl kvSchema = (KeyValueSchemaImpl) schema;\n+                    messageMetadata.setPartitionKey(\n+                            Base64.getEncoder().encodeToString(encodeWithSchema(message.getKey(),\n+                                    kvSchema.getKeySchema())));\n+                    messageMetadata.setPartitionKeyB64Encoded(true);\n+                } else {\n+                    messageMetadata.setPartitionKey(message.getKey());\n+                    messageMetadata.setPartitionKeyB64Encoded(false);\n+                }\n+            }\n+            if (null != message.getEventTime() && !message.getEventTime().isEmpty()) {\n+                messageMetadata.setEventTime(Long.valueOf(message.getEventTime()));\n+            }\n+            if (message.isDisableReplication()) {\n+                messageMetadata.clearReplicateTo();\n+                messageMetadata.addReplicateTo(\"__local__\");\n+            }\n+            if (message.getDeliverAt() != 0 && messageMetadata.hasEventTime()) {\n+                messageMetadata.setDeliverAtTime(message.getDeliverAt());\n+            } else if (message.getDeliverAfterMs() != 0) {\n+                messageMetadata.setDeliverAtTime(messageMetadata.getEventTime() + message.getDeliverAfterMs());\n+            }\n+            if (schema.getSchemaInfo().getType() == SchemaType.KEY_VALUE) {\n+                KeyValueSchemaImpl kvSchema = (KeyValueSchemaImpl) schema;\n+                pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                        ByteBuffer.wrap(encodeWithSchema(message.getPayload(), kvSchema.getValueSchema())),\n+                        schema, topicName.toString()));\n+            } else {\n+                pulsarMessages.add(MessageImpl.create(messageMetadata,\n+                        ByteBuffer.wrap(encodeWithSchema(message.getPayload(), schema)), schema,\n+                        topicName.toString()));\n+            }\n+        }\n+\n+        return pulsarMessages;\n+    }\n+\n+    // Encode message with corresponding schema, do necessary conversion before encoding\n+    private byte[] encodeWithSchema(String input, Schema schema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjg1MjM0Nw=="}, "originalCommit": {"oid": "cd2ecaba82d74192d18369c336eb34ab309ec055"}, "originalPosition": 661}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2115, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}