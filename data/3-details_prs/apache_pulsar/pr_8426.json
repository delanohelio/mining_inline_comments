{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzOTMxNzg4", "number": 8426, "title": "[Transaction]Transaction pendingack server implement patch", "bodyText": "Fix #7981\nthis PR patch #8256\nMotivation\n\nwe need to support transaction pending-ack stat, and we need to support bacth ack.\n\nimplement\n\n\nclient ack with transaction will carry only this ack bit set 1 1 1 1 1 0 1 1\uff0cthe 6 point is this transaction ack bit set point.\n\n\nwe will find the batch size from consumer pendingAcks, when we don't find it ,the ack will fail.\n\n\nthe normal individual ack will sync the bitch size to pending ack handle.\n\n\nwe will remove the position from consumer pending acks after normal ack sync finish then check if batch position in pending ack handle all acked.\n\n\nwhen the position acked finish, we will check it is less than mark delete position then we will clear the position from pending ack handle.\n\n\nabort the transaction, we will recover the transaction acked batch point to 1.\n\n\nVerifying this change\nAdd the tests for it\nDoes this pull request potentially affect one of the following parts:\nIf yes was chosen, please highlight the changes\nDependencies (does it add or upgrade a dependency): (no)\nThe public API: (no)\nThe schema: (no)\nThe default values of configurations: (no)\nThe wire protocol: (no)\nThe rest endpoints: (no)\nThe admin cli options: (no)\nAnything that affects deployment: (no)", "createdAt": "2020-11-02T09:44:21Z", "url": "https://github.com/apache/pulsar/pull/8426", "merged": true, "mergeCommit": {"oid": "dafa7e0d55f08b07e28982b4c898632f93ae7723"}, "closed": true, "closedAt": "2020-11-11T06:35:21Z", "author": {"login": "congbobo184"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdYhWDDAH2gAyNTEzOTMxNzg4OmVmZTBmYjNmZWM2ZmM2N2NmZDE4ZWFhNDhiM2EzYzllNjQ0MTE1MDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbVuezAH2gAyNTEzOTMxNzg4OjQ4ZWY3NTU4Mjk2ZjVhYzQ3NWY3MGVkN2QzZDYzZTkyZjliY2ViYjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "efe0fb3fec6fc67cfd18eaa48b3a3c9e64411507", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/efe0fb3fec6fc67cfd18eaa48b3a3c9e64411507", "committedDate": "2020-11-02T09:42:22Z", "message": "Patch 8256"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e87fb2d3f8a4439ebc5b05e83aa0181832f33472", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/e87fb2d3f8a4439ebc5b05e83aa0181832f33472", "committedDate": "2020-11-02T10:01:30Z", "message": "recover"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7760fba5ecad21223a442eab86056214d629798d", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/7760fba5ecad21223a442eab86056214d629798d", "committedDate": "2020-11-04T02:07:31Z", "message": "Redeliver move to server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7769465800cce281c4b7b66def010fdddf6dab4c", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/7769465800cce281c4b7b66def010fdddf6dab4c", "committedDate": "2020-11-05T10:54:37Z", "message": "Delete cache in broker memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d15164a78f318218734211cce987f27019ac157a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/d15164a78f318218734211cce987f27019ac157a", "committedDate": "2020-11-05T11:08:48Z", "message": "Move ack set util postion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "committedDate": "2020-11-06T07:47:58Z", "message": "Add the clear broker memory test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MDAwMDQ1", "url": "https://github.com/apache/pulsar/pull/8426#pullrequestreview-525000045", "createdAt": "2020-11-06T09:47:42Z", "commit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo0Nzo0M1rOHunFkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMDo0MDozNFrOHvb6Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjk0Nw==", "bodyText": "It's better to throw an exception here, if return -1 it means the currentPosition is lower than otherPosition", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518636947", "createdAt": "2020-11-06T09:47:43Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzOTI3MA==", "bodyText": "Why otherPosition's ackSet is null then return the result?", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518639270", "createdAt": "2020-11-06T09:51:45Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0NDAyOA==", "bodyText": "I think we can use an empty ackset to simplify these lines.", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518644028", "createdAt": "2020-11-06T09:59:53Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }\n+\n+            BitSetRecyclable otherAckSet;\n+            if (currentPosition.getAckSet() == null) {\n+                if (otherPosition.getAckSet() != null) {\n+                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+                    if (otherAckSet.isEmpty()) {\n+                        otherAckSet.recycle();\n+                        return result;\n+                    } else {\n+                        otherAckSet.recycle();\n+                        return 1;\n+                    }\n+\n+                }\n+                return result;\n+            }\n+            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            otherAckSet.recycle();\n+            thisAckSet.recycle();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0ODg0Mg==", "bodyText": "If this for normal ack, shall we need to return TransactionConflictException?", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518648842", "createdAt": "2020-11-06T10:08:26Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MDc0Nw==", "bodyText": "Looks there is much duplicate code with the individualAckNormal, is it possible to refine it?", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518650747", "createdAt": "2020-11-06T10:11:59Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));\n+                    }\n+                    ((PersistentSubscription) subscription)\n+                            .syncBatchPositionBitSetForPendingAck(new MutablePair<>(position, batchSizePair.first));\n+                    //check if the position can remove from the consumer pending acks.\n+                    // the bit set is empty in pending ack handle.\n+                    if (((PersistentSubscription) subscription).checkIsCanDeleteConsumerPendingAck(position)) {\n+                        removePendingAcks(position);\n+                    }\n                 }\n+            } else {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n+            }\n+            positionsAcked.add(position);\n+            if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n+                removePendingAcks(position);\n+            }\n \n-                if (ack.hasValidationError()) {\n-                    log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n-                            consumerId, position, ack.getValidationError());\n-                }\n+            if (ack.hasValidationError()) {\n+                log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n+                        consumerId, position, ack.getValidationError());\n             }\n-            if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Individual);\n+        }\n+        subscription.acknowledgeMessage(positionsAcked, AckType.Individual, properties);\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    //this method is for individual ack carry the transaction\n+    private CompletableFuture<Void> individualAckWithTransaction(CommandAck ack) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUwMjQwNw==", "bodyText": "Move the isTransactionEnabled to the topic or subscription?  We cannot treat consumers differently in transaction.", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r519502407", "createdAt": "2020-11-09T00:40:34Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -131,12 +132,13 @@\n     private static final double avgPercent = 0.9;\n     private boolean preciseDispatcherFlowControl;\n     private PositionImpl readPositionWhenJoining;\n+    private final boolean isTransactionEnabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "committedDate": "2020-11-09T05:54:31Z", "message": "Fix some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODI3MTg2", "url": "https://github.com/apache/pulsar/pull/8426#pullrequestreview-526827186", "createdAt": "2020-11-10T03:31:48Z", "commit": {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMzozMTo0OFrOHwKZvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMzozMTo0OFrOHwKZvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI2NDEyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //this method will return the a copy of the position's ack set\n          \n          \n            \n                //this method will return a copy of the position's ack set", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r520264126", "createdAt": "2020-11-10T03:31:48Z", "author": {"login": "gaoran10"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -2773,6 +2773,24 @@ public boolean isMessageDeleted(Position position) {\n                 ((PositionImpl) position).getEntryId()) || ((PositionImpl) position).compareTo(markDeletePosition) <= 0 ;\n     }\n \n+    //this method will return the a copy of the position's ack set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MTM3Nzkz", "url": "https://github.com/apache/pulsar/pull/8426#pullrequestreview-527137793", "createdAt": "2020-11-10T12:09:14Z", "commit": {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc5618040c5df285f01d94044040eee71efaaaac", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/bc5618040c5df285f01d94044040eee71efaaaac", "committedDate": "2020-11-10T12:09:30Z", "message": "Update managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\nCo-authored-by: ran <gaoran_10@126.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bade2ed2fb7a82f6a1b3f7ba8eb9d40dfdb9f1ac", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/bade2ed2fb7a82f6a1b3f7ba8eb9d40dfdb9f1ac", "committedDate": "2020-11-10T12:51:12Z", "message": "Modify the exception when can't find batch size"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "310bd78645a0093ee3cb8724f738a0d1093ae0d4", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/310bd78645a0093ee3cb8724f738a0d1093ae0d4", "committedDate": "2020-11-10T12:52:09Z", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_server_implement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51bbcb4de293338443e535b43625bc3005910feb", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/51bbcb4de293338443e535b43625bc3005910feb", "committedDate": "2020-11-10T12:53:10Z", "message": "Merge remote-tracking branch 'origin/congbobo184_transaction_pendingack_server_implement' into congbobo184_transaction_pendingack_server_implement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81aafaba0d17be6fe8797ce9e499a45a8a9e10a6", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/81aafaba0d17be6fe8797ce9e499a45a8a9e10a6", "committedDate": "2020-11-11T02:38:41Z", "message": "add the judement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48ef7558296f5ac475f70ed7d3d63e92f9bcebb2", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/48ef7558296f5ac475f70ed7d3d63e92f9bcebb2", "committedDate": "2020-11-11T03:51:58Z", "message": "Fix the exception return"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1154, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}