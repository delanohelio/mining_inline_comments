{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1Mjc0ODkz", "number": 8881, "title": "[Transaction] Transaction pending ack persistent", "bodyText": "Motivation\nin order to handle pending ack persistent.\nimplement\n\nadd the transaction pending ack store, it will handle the pending ack metadata store.\nwhen the sub unload, we will replay the pendingAckHandle.\nwe use one manageLedger to store the pending ack metadata by one sub , and replay by this managedLedger open cursor.\nwhen we commit or abort the transaction, we will append the marker to the pendingAckStore then we will modify state memory in pendingAckHandle\nwe also modify the in memory state when append fail, because we don't know the persistent state, when we replay it, it will produce the wrong operation. so we append fail, we should wait tc time out or client abort this transaction.\nwhen we append pending ack log, we will compare the the log position store the biggest topic position is bigger than persistent topic markDeletePosition. if it is smaller, will delete the position.\n\nVerifying this change\nAdd the tests for it\nDoes this pull request potentially affect one of the following parts:\nIf yes was chosen, please highlight the changes\nDependencies (does it add or upgrade a dependency): (no)\nThe public API: (no)\nThe schema: (no)\nThe default values of configurations: (no)\nThe wire protocol: (no)\nThe rest endpoints: (no)\nThe admin cli options: (no)\nAnything that affects deployment: (no)", "createdAt": "2020-12-09T15:47:16Z", "url": "https://github.com/apache/pulsar/pull/8881", "merged": true, "mergeCommit": {"oid": "8f1f5ba4fd8ecbab1f975623605400f5088c6e32"}, "closed": true, "closedAt": "2021-05-13T04:21:39Z", "author": {"login": "congbobo184"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkcwUvAH2gAyNTM1Mjc0ODkzOjFkODZiNGQ1YzBhMTJlMzI0NmJkYmRiNzVlYzYyZGU4NjdhYTJjMGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeWCXe_gFqTY1NzgzMjI0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1d86b4d5c0a12e3246bdbdb75ec62de867aa2c0e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/1d86b4d5c0a12e3246bdbdb75ec62de867aa2c0e", "committedDate": "2020-12-09T11:08:38Z", "message": "Transaction pending ack persistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4a11de81ab064b5840eaf9daf74d892c4e7960c", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/e4a11de81ab064b5840eaf9daf74d892c4e7960c", "committedDate": "2020-12-09T15:45:19Z", "message": "Fix some named"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "committedDate": "2020-12-10T08:19:07Z", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckHandle.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleImpl.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MDA4NTEy", "url": "https://github.com/apache/pulsar/pull/8881#pullrequestreview-569008512", "createdAt": "2021-01-15T07:39:47Z", "commit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNzozOTo0N1rOIUG8hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODowMTo0OVrOIUJBLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1NjIyOA==", "bodyText": "why do we need this file ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557956228", "createdAt": "2021-01-15T07:39:47Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/generate_protobuf.sh", "diffHunk": "@@ -0,0 +1,23 @@\n+#!/usr/bin/env bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+\n+\n+PROTOC=${PROTOC:-protoc}\n+${PROTOC} --java_out=pulsar-broker/src/main/java pulsar-broker/src/main/proto/TransactionPendingAck.proto", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1NjMzNQ==", "bodyText": "why do we need this file ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557956335", "createdAt": "2021-01-15T07:39:53Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/generate_protobuf_docker.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+\n+# Fail script in case of errors\n+set -e\n+\n+ROOT_DIR=$(git rev-parse --show-toplevel)\n+COMMON_DIR=$ROOT_DIR/\n+cd $COMMON_DIR\n+\n+BUILD_IMAGE_NAME=\"${BUILD_IMAGE_NAME:-apachepulsar/pulsar-build}\"\n+BUILD_IMAGE_VERSION=\"${BUILD_IMAGE_VERSION:-ubuntu-16.04}\"\n+\n+IMAGE=\"$BUILD_IMAGE_NAME:$BUILD_IMAGE_VERSION\"\n+\n+echo $IMAGE\n+\n+# Force to pull image in case it was updated\n+docker pull $IMAGE\n+\n+WORKDIR=/workdir\n+docker run -i \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1ODYyMw==", "bodyText": "can we add checkIdReady to PendingAckHandle ?\nusing instanceof is not a good practice, we should leverage polymorphism", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557958623", "createdAt": "2021-01-15T07:41:39Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java", "diffHunk": "@@ -161,6 +162,12 @@ void setReplicated(boolean replicated) {\n \n     @Override\n     public synchronized void addConsumer(Consumer consumer) throws BrokerServiceException {\n+        if (pendingAckHandle instanceof PendingAckHandleImpl) {\n+            if (!((PendingAckHandleImpl) pendingAckHandle).checkIfReady()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDI0Mw==", "bodyText": "how many times is this method supposed to be called ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557960243", "createdAt": "2021-01-15T07:42:56Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();\n+\n+    /**\n+     * Handle metadata entry.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDU2OQ==", "bodyText": "is there any way to receive notification of a failure ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557960569", "createdAt": "2021-01-15T07:43:11Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2Njk0MA==", "bodyText": "is this expected to happen inside the scheduledExecutorService ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557966940", "createdAt": "2021-01-15T07:48:05Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * In memory implementation of {@link PendingAckStore}.\n+ */\n+public class InMemoryPendingAckStore implements PendingAckStore {\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService scheduledExecutorService) {\n+        pendingAckHandle.changeToReadyState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3MDcxNQ==", "bodyText": "this is not good,\nthe contract is to exit the current activity in case of InterrupedException or at least set Thread.interrupted flag", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557970715", "createdAt": "2021-01-15T07:51:02Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3NzY2NA==", "bodyText": "what is the recovery story for this error ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557977664", "createdAt": "2021-01-15T07:55:10Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op\n+                    }\n+                }\n+            }\n+            pendingAckReplyCallBack.replayComplete();\n+        }\n+    }\n+\n+    class FillEntryQueueCallback implements AsyncCallbacks.ReadEntriesCallback {\n+\n+        private final AtomicLong outstandingReadsRequests = new AtomicLong(0);\n+\n+        public FillEntryQueueCallback() {\n+        }\n+\n+        void fillQueue() {\n+            if (entryQueue.size() < entryQueue.capacity() && outstandingReadsRequests.get() == 0) {\n+                if (cursor.hasMoreEntries()) {\n+                    outstandingReadsRequests.incrementAndGet();\n+                    readAsync(100, this);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n+            entryQueue.fill(new MessagePassingQueue.Supplier<Entry>() {\n+                private int i = 0;\n+                @Override\n+                public Entry get() {\n+                    Entry entry = entries.get(i);\n+                    i++;\n+                    return entry;\n+                }\n+            }, entries.size());\n+\n+            outstandingReadsRequests.decrementAndGet();\n+        }\n+\n+        @Override\n+        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n+            log.error(\"MLPendingAckStore stat reply fail!\", exception);\n+            outstandingReadsRequests.decrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk4MTcyOQ==", "bodyText": "what about creating a method in parent class MLPendingAckStoreProvider\nvoid ensureTimer() {\n     if (timer == null) {\n         synchronized(this) {\n             initialize();  \n       }\n    }\n}\n\nIMHO code will be more readable", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557981729", "createdAt": "2021-01-15T07:57:19Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreProvider.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timer;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.pulsar.broker.service.persistent.PersistentSubscription;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.TransactionPendingAckStoreProvider;\n+import org.apache.pulsar.broker.transaction.pendingack.exceptions.TransactionPendingAckStoreProviderException;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n+import org.apache.pulsar.common.naming.TopicName;\n+\n+/**\n+ * Provider is for MLPendingAckStore.\n+ */\n+@Slf4j\n+public class MLPendingAckStoreProvider implements TransactionPendingAckStoreProvider {\n+\n+    private volatile Timer timer;\n+\n+    private static final long tickTimeMillis = 1L;\n+\n+    @Override\n+    public CompletableFuture<PendingAckStore> newPendingAckStore(PersistentSubscription subscription) {\n+        CompletableFuture<PendingAckStore> pendingAckStoreFuture = new CompletableFuture<>();\n+\n+        if (subscription == null) {\n+            pendingAckStoreFuture.completeExceptionally(\n+                    new TransactionPendingAckStoreProviderException(\"The subscription is null.\"));\n+            return pendingAckStoreFuture;\n+        }\n+\n+        PersistentTopic originPersistentTopic = (PersistentTopic) subscription.getTopic();\n+        String pendingAckTopicName = MLPendingAckStore\n+                .getTransactionPendingAckStoreSuffix(originPersistentTopic.getName(), subscription.getName());\n+\n+        originPersistentTopic.getBrokerService().getManagedLedgerFactory()\n+                .asyncOpen(TopicName.get(pendingAckTopicName).getPersistenceNamingEncoding(),\n+                        new AsyncCallbacks.OpenLedgerCallback() {\n+                            @Override\n+                            public void openLedgerComplete(ManagedLedger ledger, Object ctx) {\n+                                ledger.asyncOpenCursor(MLPendingAckStore.getTransactionPendingAckStoreCursorName(),\n+                                        InitialPosition.Earliest, new AsyncCallbacks.OpenCursorCallback() {\n+                                            @Override\n+                                            public void openCursorComplete(ManagedCursor cursor, Object ctx) {\n+                                                if (timer == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk5MDE4OQ==", "bodyText": "this is very error prone,\ncan we detect an instance of a specific class of exception ?", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557990189", "createdAt": "2021-01-15T08:01:49Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreTimerTask.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.Timeout;\n+import io.netty.util.Timer;\n+import io.netty.util.TimerTask;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Pending ack timer task.\n+ */\n+@Slf4j\n+public class MLPendingAckStoreTimerTask implements TimerTask {\n+\n+    private int intervalTime;\n+\n+    private final int maxIntervalTime;\n+\n+    private final int minIntervalTime;\n+\n+    private final ManagedCursorImpl subManagedCursor;\n+\n+    private final ManagedLedgerImpl storeManagedLedger;\n+\n+    private final ManagedCursorImpl managedCursor;\n+\n+    private final Timer timer;\n+\n+    private volatile PositionImpl markDeletePosition;\n+\n+    public MLPendingAckStoreTimerTask(ManagedCursor managedCursor, ManagedLedger storeManagedLedger,\n+                                      int maxIntervalTime, int minIntervalTime,\n+                                      ManagedCursor subManageCursor, Timer timer) {\n+        this.intervalTime = minIntervalTime;\n+        this.maxIntervalTime = maxIntervalTime;\n+        this.minIntervalTime = minIntervalTime;\n+        this.managedCursor = (ManagedCursorImpl) managedCursor;\n+        this.subManagedCursor = (ManagedCursorImpl) subManageCursor;\n+        this.storeManagedLedger = (ManagedLedgerImpl) storeManagedLedger;\n+        this.markDeletePosition = (PositionImpl) managedCursor.getMarkDeletedPosition();\n+        this.timer = timer;\n+    }\n+\n+    @Override\n+    public void run(Timeout timeout) {\n+        if (this.managedCursor.getState().equals(\"Closed\")) {\n+            return;\n+        }\n+        try {\n+            // when no transaction ack operation in this pending ack store, it will increase the interval time\n+            if (markDeletePosition.compareTo((PositionImpl) storeManagedLedger.getLastConfirmedEntry()) == 0) {\n+                int time = intervalTime + minIntervalTime;\n+                if (time > maxIntervalTime) {\n+                    intervalTime = maxIntervalTime;\n+                } else {\n+                    intervalTime = time;\n+                }\n+                managedCursor.markDelete(markDeletePosition);\n+                timer.newTimeout(MLPendingAckStoreTimerTask.this, intervalTime, TimeUnit.SECONDS);\n+                return;\n+            } else {\n+                int time = intervalTime - minIntervalTime;\n+                if (time < minIntervalTime) {\n+                    intervalTime = minIntervalTime;\n+                } else {\n+                    intervalTime = time;\n+                }\n+            }\n+            // this while in order to find the last position witch can mark delete\n+            while (true) {\n+                PositionImpl nextPosition = storeManagedLedger.getNextValidPosition(markDeletePosition);\n+                Entry entry = getEntry(nextPosition).get();\n+                ByteBuf buffer = entry.getDataBuffer();\n+                ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                        PendingAckMetadataEntry.newBuilder();\n+                PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                try {\n+                    pendingAckMetadataEntry =\n+                            pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                    switch (pendingAckMetadataEntry.getPendingAckOp()) {\n+                        case ACK:\n+                            if (pendingAckMetadataEntry.getAckType() == AckType.Cumulative) {\n+                                PendingAckMetadata pendingAckMetadata =\n+                                        pendingAckMetadataEntry.getPendingAckMetadata(0);\n+                                handleAckCommon(PositionImpl.get(pendingAckMetadata.getLedgerId(),\n+                                        pendingAckMetadata.getEntryId()), nextPosition);\n+                            } else {\n+                                //this judge the pendingAckMetadataEntry is can delete\n+                                PositionImpl largestPosition = null;\n+                                List<PendingAckMetadata> metadataList =\n+                                        pendingAckMetadataEntry.getPendingAckMetadataList();\n+                                for (int i = 0; i < metadataList.size(); i++) {\n+                                    PendingAckMetadata pendingAckMetadata = metadataList.get(0);\n+                                    if (largestPosition == null) {\n+                                        largestPosition = PositionImpl.get(pendingAckMetadata.getLedgerId(),\n+                                                pendingAckMetadata.getEntryId());\n+                                    } else {\n+                                        PositionImpl comparePosition = PositionImpl\n+                                                .get(pendingAckMetadata.getLedgerId(),\n+                                                        pendingAckMetadata.getEntryId());\n+                                        if (largestPosition.compareTo(comparePosition) <  0) {\n+                                            largestPosition = comparePosition;\n+                                        }\n+\n+                                    }\n+                                }\n+                                if (largestPosition != null) {\n+                                    handleAckCommon(largestPosition, nextPosition);\n+                                }\n+                            }\n+                            break;\n+                        case ABORT:\n+                        case COMMIT:\n+                            markDeletePosition = nextPosition;\n+                            break;\n+                        default:\n+                            log.error(\"PendingAck timer task read illegal metadata state! {}\",\n+                                    pendingAckMetadataEntry.getPendingAckOp());\n+                    }\n+                } finally {\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                }\n+                // when markDeletePosition is not nextPosition, before markDeletePosition can delete\n+                if (markDeletePosition != nextPosition) {\n+                    this.managedCursor.markDelete(markDeletePosition);\n+                    break;\n+                }\n+            }\n+            this.timer.newTimeout(this, intervalTime, TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            log.error(\"PendingAck timer task error!\", e);\n+            if (\"Cursor was already closed\".equals(e.getCause().getMessage())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494"}, "originalPosition": 172}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a17e9596eba589777486cfd0589d90923260ad30", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/a17e9596eba589777486cfd0589d90923260ad30", "committedDate": "2021-02-07T04:05:58Z", "message": "Transaction pending ack persistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45588c6d5c755db7995ab6d43e8289aee99ca074", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/45588c6d5c755db7995ab6d43e8289aee99ca074", "committedDate": "2021-02-07T04:05:58Z", "message": "Fix some named"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "516d7d224bedccef2054ef19ffc9a301f91cb469", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/516d7d224bedccef2054ef19ffc9a301f91cb469", "committedDate": "2021-02-07T09:42:49Z", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpom.xml\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/TransactionMarkerDeleteTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/PersistentSubscriptionTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/TransactionTestBase.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98ea58bca66bd14b2076a37b3c761c741496fff4", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/98ea58bca66bd14b2076a37b3c761c741496fff4", "committedDate": "2021-02-07T09:49:21Z", "message": "Merge branch 'congbobo184_transaction_pendingack_persistent' of https://github.com/congbobo184/pulsar into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpom.xml\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckHandle.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckStore.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/TransactionPendingAckStoreProvider.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckReplyCallBack.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreProvider.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreTimerTask.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleDisabled.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleImpl.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/TransactionMarkerDeleteTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/PersistentSubscriptionTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/TransactionTestBase.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckPersistentTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7a9296be7e772401501a6d38c99830a560cd73f", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/b7a9296be7e772401501a6d38c99830a560cd73f", "committedDate": "2021-02-07T09:50:32Z", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_persistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de975916c2d6eda49c669c9e9ca66610d10d5e98", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/de975916c2d6eda49c669c9e9ca66610d10d5e98", "committedDate": "2021-02-07T12:25:15Z", "message": "Change exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed268e1eb57b836a51d59f47fbc4ba8f59f74b32", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/ed268e1eb57b836a51d59f47fbc4ba8f59f74b32", "committedDate": "2021-03-01T11:31:08Z", "message": "Fix some test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14d8268013fc02fda04e1bfe908fbd31c2fda78e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/14d8268013fc02fda04e1bfe908fbd31c2fda78e", "committedDate": "2021-03-01T14:19:42Z", "message": "Fix pending ack test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0434d8e2488c33ab74bd72327410c42a78f0ce93", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/0434d8e2488c33ab74bd72327410c42a78f0ce93", "committedDate": "2021-03-02T10:00:33Z", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckHandle.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleImpl.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79d0e7bc2eb6579a6715bf5f14c61625228a777a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/79d0e7bc2eb6579a6715bf5f14c61625228a777a", "committedDate": "2021-03-16T08:08:15Z", "message": "Fix some design"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d38a40b610147e48c5233f4724757743dba04b2", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/3d38a40b610147e48c5233f4724757743dba04b2", "committedDate": "2021-03-16T14:09:51Z", "message": "Fix the test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a12efc9e2136a6ec52d9f71377b74d0d03bc809", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/5a12efc9e2136a6ec52d9f71377b74d0d03bc809", "committedDate": "2021-03-17T11:02:59Z", "message": "Delete the callback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97851241c55b69e22f9cc6aba83b8aa0543ea8d3", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/97851241c55b69e22f9cc6aba83b8aa0543ea8d3", "committedDate": "2021-03-24T06:26:10Z", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckInMemoryDeleteTest.java\ndelete pending ack recover exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2347bc47b4dd3d878a58f76d0a46823f1eb4f20b", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/2347bc47b4dd3d878a58f76d0a46823f1eb4f20b", "committedDate": "2021-03-25T01:39:09Z", "message": "Delete pending ack topic create pending ack"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d29edb6def31eebf633e520324c26cbc253310a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/8d29edb6def31eebf633e520324c26cbc253310a", "committedDate": "2021-04-20T08:10:32Z", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb4b7be8a95c8eaef59ecd37a2007a17a0021c76", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/cb4b7be8a95c8eaef59ecd37a2007a17a0021c76", "committedDate": "2021-04-25T06:34:56Z", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java\n#\tpulsar-client/src/main/java/org/apache/pulsar/client/impl/ClientCnx.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f79b567c965a280eeb56821b155ad302070dd18", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/3f79b567c965a280eeb56821b155ad302070dd18", "committedDate": "2021-04-25T09:06:49Z", "message": "Add some debug log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a2c078ccee15be51bef5305ed1a017b60586134", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/8a2c078ccee15be51bef5305ed1a017b60586134", "committedDate": "2021-04-25T09:31:45Z", "message": "Fix some codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b668c0ba32da31fbea471dda767e9b2bdd5caaad", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/b668c0ba32da31fbea471dda767e9b2bdd5caaad", "committedDate": "2021-04-25T13:39:14Z", "message": "Fix some test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c2ae9b1cb00d6c8c8f180647cfbf5c896e1cb7d", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/3c2ae9b1cb00d6c8c8f180647cfbf5c896e1cb7d", "committedDate": "2021-04-25T14:09:30Z", "message": "Fix some catch exception."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9553edcd3044677819d72d60cb2cfe73de0cb54a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/9553edcd3044677819d72d60cb2cfe73de0cb54a", "committedDate": "2021-05-10T00:56:48Z", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/f9ac2134732f361abea73086e44a6b335646fe8d", "committedDate": "2021-05-10T01:29:12Z", "message": "Merge master and add some log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23ed17cb1b3a6dffbf327fee7fa644e180cd9e49", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/23ed17cb1b3a6dffbf327fee7fa644e180cd9e49", "committedDate": "2021-05-12T09:03:31Z", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3Njg4NjU0", "url": "https://github.com/apache/pulsar/pull/8881#pullrequestreview-657688654", "createdAt": "2021-05-12T09:52:40Z", "commit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa50b7444daa3bc572fb926499672b55f56198e5", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/aa50b7444daa3bc572fb926499672b55f56198e5", "committedDate": "2021-05-12T09:55:05Z", "message": "Fix some comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2MjExNTI2", "url": "https://github.com/apache/pulsar/pull/8881#pullrequestreview-656211526", "createdAt": "2021-05-11T01:32:29Z", "commit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMVQwMTozMjoyOVrOJYnJkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQxMjowMDowMFrOJZvrZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzAyNQ==", "bodyText": "Why do we need to catch the exception here? If the exception occurs, you already have .exceptionally to deal with this.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629787025", "createdAt": "2021-05-11T01:32:29Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -265,13 +265,23 @@ public void removeProducer(Producer producer) {\n \n         NonPersistentSubscription subscription = subscriptions.computeIfAbsent(subscriptionName,\n                 name -> new NonPersistentSubscription(this, subscriptionName));\n-\n-        try {\n-            Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n-                    cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n-            addConsumerToSubscription(subscription, consumer);\n+        Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n+                cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n+        addConsumerToSubscription(subscription, consumer).thenAccept(v -> {\n             if (!cnx.isActive()) {\n-                consumer.close();\n+                try {\n+                    consumer.close();\n+                } catch (BrokerServiceException e) {\n+                    if (e instanceof ConsumerBusyException) {\n+                        log.warn(\"[{}][{}] Consumer {} {} already connected\", topic, subscriptionName, consumerId,\n+                                consumerName);\n+                    } else if (e instanceof SubscriptionBusyException) {\n+                        log.warn(\"[{}][{}] {}\", topic, subscriptionName, e.getMessage());\n+                    }\n+\n+                    decrementUsageCount();\n+                    future.completeExceptionally(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzUzOQ==", "bodyText": "It's better to get the Cause first and use it in the followings.", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629787539", "createdAt": "2021-05-11T01:34:17Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -282,17 +292,18 @@ public void removeProducer(Producer producer) {\n                 log.info(\"[{}][{}] Created new subscription for {}\", topic, subscriptionName, consumerId);\n                 future.complete(consumer);\n             }\n-        } catch (BrokerServiceException e) {\n-            if (e instanceof ConsumerBusyException) {\n+        }).exceptionally(e -> {\n+            if (e.getCause() instanceof ConsumerBusyException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4ODA3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n          \n          \n            \n                private static final String PENDING_ACK_STORE_CURSOR_NAME = \"__pending_ack_state\";", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629788074", "createdAt": "2021-05-11T01:36:00Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import com.google.common.collect.ComparisonChain;\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.service.BrokerServiceException.PersistenceException;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDk3NTMzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";\n          \n          \n            \n                public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pending_ack\";", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r630975335", "createdAt": "2021-05-12T12:00:00Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import com.google.common.collect.ComparisonChain;\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.service.BrokerServiceException.PersistenceException;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa50b7444daa3bc572fb926499672b55f56198e5"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a58f9c0e3167493b0d610b293932175514dffe8", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/9a58f9c0e3167493b0d610b293932175514dffe8", "committedDate": "2021-05-12T12:39:30Z", "message": "Fix some comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3ODMyMjQ3", "url": "https://github.com/apache/pulsar/pull/8881#pullrequestreview-657832247", "createdAt": "2021-05-12T12:40:11Z", "commit": {"oid": "9a58f9c0e3167493b0d610b293932175514dffe8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 901, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}