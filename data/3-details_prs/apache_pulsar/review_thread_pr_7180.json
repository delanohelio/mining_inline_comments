{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MjU4OTE4", "number": 7180, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozMTo1N1rOEC2QYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMDo1NVrOEDDCUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDIxNTM5OnYy", "diffSide": "RIGHT", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozMTo1N1rOGfjcvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozMTo1N1rOGfjcvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczOTgzOA==", "bodyText": "reader is still not closed here", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r435739838", "createdAt": "2020-06-05T07:31:57Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {\n+                try {\n+                    while(isRunning) {\n+                        Message<byte[]> msg = reader.readNext();\n+                        processAssignment(msg);\n+                    }\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n+        if (!isRunning) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDIxOTM0OnYy", "diffSide": "RIGHT", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozMzoxOVrOGfjfYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0Nzo1NFrOGf3s1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDUxNQ==", "bodyText": "probably should wait as well?", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r435740515", "createdAt": "2020-06-05T07:33:19Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {\n+                try {\n+                    while(isRunning) {\n+                        Message<byte[]> msg = reader.readNext();\n+                        processAssignment(msg);\n+                    }\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n+        if (!isRunning) {\n             return;\n         }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0OTg4Ng==", "bodyText": "we shouldn't need to", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436049886", "createdAt": "2020-06-05T17:05:05Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {\n+                try {\n+                    while(isRunning) {\n+                        Message<byte[]> msg = reader.readNext();\n+                        processAssignment(msg);\n+                    }\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n+        if (!isRunning) {\n             return;\n         }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDUxNQ=="}, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjA4Mw==", "bodyText": "Should we just do\nisRunning = false;\nif (thread is alive) { interrupt(); }\nreader.close();\nmuch simpler", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436052083", "createdAt": "2020-06-05T17:09:39Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {\n+                try {\n+                    while(isRunning) {\n+                        Message<byte[]> msg = reader.readNext();\n+                        processAssignment(msg);\n+                    }\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n+        if (!isRunning) {\n             return;\n         }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDUxNQ=="}, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MTYzOQ==", "bodyText": "sure", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436071639", "createdAt": "2020-06-05T17:47:54Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {\n+                try {\n+                    while(isRunning) {\n+                        Message<byte[]> msg = reader.readNext();\n+                        processAssignment(msg);\n+                    }\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n+        if (!isRunning) {\n             return;\n         }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDUxNQ=="}, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDIyODY0OnYy", "diffSide": "RIGHT", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozNjozMlrOGfjlKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzowMjoxN1rOGf2SuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MTk5Mg==", "bodyText": "instead of two while loop, maybe you can do\nwhile(isRunning) {\ntry { readNext(); processAssignment(); } catch (Exeepton e) { see what kind of exception", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r435741992", "createdAt": "2020-06-05T07:36:32Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0ODU2OQ==", "bodyText": "ya there shouldn't be two while loops", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436048569", "createdAt": "2020-06-05T17:02:17Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,90 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MTk5Mg=="}, "originalCommit": {"oid": "58a424a7aaae09b5481e05e3bcf2b76332ba244b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjE0OTIyOnYy", "diffSide": "RIGHT", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoxMDoxMFrOGf2hXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDo0Njo0OVrOGf84vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjMxNw==", "bodyText": "instead of isRunning, better to word it as stopRunning", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436052317", "createdAt": "2020-06-05T17:10:10Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,91 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fc6eec2a5e1258bf4e91c1525f41425c18dca8c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MDM0NQ==", "bodyText": "why do we need to change it?  We would also need to reverse the boolean logic checks to be semantically correct?", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436070345", "createdAt": "2020-06-05T17:45:25Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,91 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjMxNw=="}, "originalCommit": {"oid": "7fc6eec2a5e1258bf4e91c1525f41425c18dca8c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzQxNQ==", "bodyText": "Yes. isRunning implies that its a state. stopRunning implies its a command.\nWhat we really have here is that the thread should keep running until its commanded by the main thread to stop. Hence the stopRunning instead of isRunning", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436077415", "createdAt": "2020-06-05T17:58:49Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,91 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjMxNw=="}, "originalCommit": {"oid": "7fc6eec2a5e1258bf4e91c1525f41425c18dca8c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODE2MQ==", "bodyText": "But we also have a method called \"start\"?", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436118161", "createdAt": "2020-06-05T19:20:37Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,91 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjMxNw=="}, "originalCommit": {"oid": "7fc6eec2a5e1258bf4e91c1525f41425c18dca8c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NjYwNQ==", "bodyText": "At start() {\nshouldStop = false;\ncreate the thread and start\n}\nAt close() {\nset shoutStop = true, interrupt thread, join and then set it to null;\nclose reader and set it to null\n}\nThis way I can do start() /close() multiple times", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436156605", "createdAt": "2020-06-05T20:46:49Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,91 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjMxNw=="}, "originalCommit": {"oid": "7fc6eec2a5e1258bf4e91c1525f41425c18dca8c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjMwNjMwOnYy", "diffSide": "RIGHT", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1OTo1N1rOGf4F3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1OTo1N1rOGf4F3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3ODA0Ng==", "bodyText": "should make it null here.", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436078046", "createdAt": "2020-06-05T17:59:57Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,85 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(isRunning) {\n+                try {\n+                    Message<byte[]> msg = reader.readNext();\n+                    processAssignment(msg);\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n-            return;\n-        }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();\n+            }\n+            if (reader != null) {\n+                reader.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48c401c26ab8051f92f70c8e4df4ae48b9e36612"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjMwOTI4OnYy", "diffSide": "RIGHT", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMDo1NVrOGf4HuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTozNjoxNlrOGf68PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3ODUyMA==", "bodyText": "also one benefit of doing a join here would be that once the thread is done, we can make it null again.\nThis way we could actually do a start/close multiple times.", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436078520", "createdAt": "2020-06-05T18:00:55Z", "author": {"login": "srkukarni"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,85 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(isRunning) {\n+                try {\n+                    Message<byte[]> msg = reader.readNext();\n+                    processAssignment(msg);\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n-            return;\n-        }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();\n+            }\n+            if (reader != null) {\n+                reader.close();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48c401c26ab8051f92f70c8e4df4ae48b9e36612"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMTE4Mw==", "bodyText": "Is there a use case for that right now?", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436121183", "createdAt": "2020-06-05T19:27:35Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,85 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(isRunning) {\n+                try {\n+                    Message<byte[]> msg = reader.readNext();\n+                    processAssignment(msg);\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n-            return;\n-        }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();\n+            }\n+            if (reader != null) {\n+                reader.close();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3ODUyMA=="}, "originalCommit": {"oid": "48c401c26ab8051f92f70c8e4df4ae48b9e36612"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDczMw==", "bodyText": "Doing this right now makes the code more complicated since the reader needs to be used in FuntcionRuntimeManager", "url": "https://github.com/apache/pulsar/pull/7180#discussion_r436124733", "createdAt": "2020-06-05T19:36:16Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -18,56 +18,85 @@\n  */\n package org.apache.pulsar.functions.worker;\n \n-import java.io.IOException;\n-import java.util.function.Function;\n-\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.pulsar.client.api.Message;\n-import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n-import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.client.api.ReaderBuilder;\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n-import lombok.extern.slf4j.Slf4j;\n+import java.io.IOException;\n \n @Slf4j\n-public class FunctionAssignmentTailer\n-    implements java.util.function.Consumer<Message<byte[]>>, Function<Throwable, Void>, AutoCloseable {\n+public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    @Getter\n     private final Reader<byte[]> reader;\n-    private boolean closed = false;\n+    private volatile boolean isRunning = false;\n \n-    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, Reader<byte[]> reader) {\n+    private final Thread tailerThread;\n+    \n+    public FunctionAssignmentTailer(FunctionRuntimeManager functionRuntimeManager, ReaderBuilder readerBuilder, WorkerConfig workerConfig) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        this.reader = reader;\n-    }\n+        \n+        this.reader = readerBuilder\n+          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n+          .topic(workerConfig.getFunctionAssignmentTopic())\n+          .readCompacted(true)\n+          .startMessageId(MessageId.earliest)\n+          .create();\n \n-    public void start() {\n-        receiveOne();\n+        this.tailerThread = new Thread(() -> {\n+            while(isRunning) {\n+                try {\n+                    Message<byte[]> msg = reader.readNext();\n+                    processAssignment(msg);\n+                } catch (Exception e) {\n+                    if (isRunning) {\n+                        log.error(\"Encountered error in assignment tailer\", e);\n+\n+                        // trigger fatal error\n+                        // TODO add mechanism to notify main thread\n+                    } else {\n+                        if (!(e instanceof InterruptedException)) {\n+                            log.warn(\"Encountered error when assignment tailer is not running\", e);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        });\n+        this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    private void receiveOne() {\n-        reader.readNextAsync()\n-                .thenAccept(this)\n-                .exceptionally(this);\n+    public void start() {\n+        isRunning = true;\n+        tailerThread.start();\n     }\n \n     @Override\n     public void close() {\n-        if (closed) {\n-            return;\n-        }\n-        log.info(\"Stopping function state consumer\");\n+        log.info(\"Stopping function assignment tailer\");\n         try {\n-            closed = true;\n-            reader.close();\n+            isRunning = false;\n+            if (tailerThread != null && tailerThread.isAlive()) {\n+                tailerThread.interrupt();\n+            }\n+            if (reader != null) {\n+                reader.close();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3ODUyMA=="}, "originalCommit": {"oid": "48c401c26ab8051f92f70c8e4df4ae48b9e36612"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1722, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}