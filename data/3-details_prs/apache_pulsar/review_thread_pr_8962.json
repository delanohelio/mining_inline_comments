{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMjA5OTg4", "number": 8962, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowOToxNVrOFFm3sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODowMTo0MVrOFHSgdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI0MDQ4OnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowOToxNVrOIGMvkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowOToxNVrOIGMvkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3MTE1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n          \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\" + System.currentTimeMillis();", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543371155", "createdAt": "2020-12-15T14:09:15Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI2MjkxOnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMjoxOFrOIGM9GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMjoxOFrOIGM9GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NDYxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<String> messages = new HashSet(); // Since messages are in random order\n          \n          \n            \n                    Set<String> messages = new HashSet();// Since messages are in random order", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543374616", "createdAt": "2020-12-15T14:12:18Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI3MjYzOnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMzozMlrOIGNDCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMzozMlrOIGNDCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NjEzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543376137", "createdAt": "2020-12-15T14:13:32Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI3NjI3OnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMzo1OFrOIGNFRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxMzo1OFrOIGNFRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NjcwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543376709", "createdAt": "2020-12-15T14:13:58Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDI3ODU0OnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxNDoxN1rOIGNGrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxNDoxN1rOIGNGrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NzA2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543377068", "createdAt": "2020-12-15T14:14:17Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            // All messages would be received by consumer 1\n+            m = consumer1.receive();\n+            messages.add(new String(m.getData()));\n+            consumer1.acknowledge(m);\n+        }\n+\n+        // Consuming from consumer 2 and 3 again just to be sure\n+        // no message should be returned since they can't decrypt the message\n+        m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        // checking if all messages were received\n+        for (int i = 0; i<numberOfMessages; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDMwNDIzOnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxNzoxMVrOIGNVgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxNzoxMVrOIGNVgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MDg2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n          \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\" + System.currentTimeMillis();", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543380866", "createdAt": "2020-12-15T14:17:11Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDMxNDY3OnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxODoxOVrOIGNbfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxODoxOVrOIGNbfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MjM5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<String> messages = new HashSet(); // Since messages are in random order\n          \n          \n            \n                    Set<String> messages = new HashSet();// Since messages are in random order", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543382399", "createdAt": "2020-12-15T14:18:19Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDMxNzUyOnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxODo0MFrOIGNdIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxODo0MFrOIGNdIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MjgxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543382817", "createdAt": "2020-12-15T14:18:40Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDMxOTcyOnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxODo1NVrOIGNecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxODo1NVrOIGNecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MzE1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543383154", "createdAt": "2020-12-15T14:18:55Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDMyMTY0OnYy", "diffSide": "RIGHT", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxOToxMlrOIGNfmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDoxOToxMlrOIGNfmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MzQ1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543383451", "createdAt": "2020-12-15T14:19:12Z", "author": {"login": "jbampton"}, "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            // All messages would be received by consumer 1\n+            m = consumer1.receive();\n+            messages.add(new String(m.getData()));\n+            consumer1.acknowledge(m);\n+        }\n+\n+        // Consuming from consumer 2 and 3 again just to be sure\n+        // no message should be returned since they can't decrypt the message\n+        m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        // checking if all messages were received\n+        for (int i = 0; i<numberOfMessages; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTg3NTc1OnYy", "diffSide": "RIGHT", "path": "pulsar-client-shaded/pom.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODowMTo0MVrOIItEug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMzo0Mzo1MVrOILH3hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5ODAxMA==", "bodyText": "The client api is meant to not get included in the shaded artifact, otherwise IDEs will not be able to fetch the sources and javadoc for the client APIs.", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r545998010", "createdAt": "2020-12-18T18:01:41Z", "author": {"login": "merlimat"}, "path": "pulsar-client-shaded/pom.xml", "diffHunk": "@@ -104,6 +104,7 @@\n               <artifactSet>\n                 <includes>\n                   <include>org.apache.pulsar:pulsar-client-original</include>\n+                  <include>org.apache.pulsar:pulsar-client-api</include>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5836ee787bb2526f3597716e6e3b27f4c3f27ea3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTM2NA==", "bodyText": "But if we don't include pulsar-client-api, some interfaces may not be relocated correctly.\nFor example, in SimpleProducerConsumerTest:558:\nMessageCrypto crypto = new MessageCryptoBc(\"test\", false);\nPulsarApi.MessageMetadata.Builder metadataBuilder = PulsarApi.MessageMetadata.newBuilder();\nPulsarApi.EncryptionKeys.Builder encKeyBuilder = PulsarApi.EncryptionKeys.newBuilder();\nencKeyBuilder.setKey(encryptionKeyName);\nByteString keyValue = ByteString.copyFrom(dataKey);\nencKeyBuilder.setValue(keyValue);\nPulsarApi.EncryptionKeys encKey = encKeyBuilder.build();\nmetadataBuilder.setEncryptionParam(ByteString.copyFrom(encrParam));\nmetadataBuilder.setEncryptionAlgo(encAlgo);\nmetadataBuilder.setProducerName(\"test\");\nmetadataBuilder.setSequenceId(123);\nmetadataBuilder.setPublishTime(12333453454L);\nmetadataBuilder.addEncryptionKeys(encKey);\nmetadataBuilder.setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType));\nmetadataBuilder.setUncompressedSize(uncompressedSize);\nByteBuf decryptedPayload = crypto.decrypt(() -> metadataBuilder.build(), payloadBuf, reader); \nIt will throw an error in the last line:\n'decrypt(java.util.function.Supplier, io.netty.buffer.ByteBuf, org.apache.pulsar.client.api.CryptoKeyReader)' in 'org.apache.pulsar.client.api.MessageCrypto' cannot be applied to '(<lambda expression>, org.apache.pulsar.shade.io.netty.buffer.ByteBuf, org.apache.pulsar.client.api.CryptoKeyReader)'\nSo we need to include pulsar-client-api to make\nio.netty.buffer.ByteBuf decrypt(java.util.function.Supplier<MetadataT> supplier, io.netty.buffer.ByteBuf byteBuf, org.apache.pulsar.client.api.CryptoKeyReader cryptoKeyReader);\n\nchange to :\norg.apache.pulsar.shade.io.netty.buffer.ByteBuf decrypt(java.util.function.Supplier<MetadataT> supplier, org.apache.pulsar.shade.io.netty.buffer.ByteBuf byteBuf, org.apache.pulsar.client.api.CryptoKeyReader cryptoKeyReader);\n\nCurrently, I haven't found another solution to solve this problem.", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r546561364", "createdAt": "2020-12-21T08:05:07Z", "author": {"login": "RobertIndie"}, "path": "pulsar-client-shaded/pom.xml", "diffHunk": "@@ -104,6 +104,7 @@\n               <artifactSet>\n                 <includes>\n                   <include>org.apache.pulsar:pulsar-client-original</include>\n+                  <include>org.apache.pulsar:pulsar-client-api</include>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5ODAxMA=="}, "originalCommit": {"oid": "5836ee787bb2526f3597716e6e3b27f4c3f27ea3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUzNDE1MA==", "bodyText": "seems the latest intellij idea has fixed the shade issue", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r548534150", "createdAt": "2020-12-24T13:43:51Z", "author": {"login": "jiazhai"}, "path": "pulsar-client-shaded/pom.xml", "diffHunk": "@@ -104,6 +104,7 @@\n               <artifactSet>\n                 <includes>\n                   <include>org.apache.pulsar:pulsar-client-original</include>\n+                  <include>org.apache.pulsar:pulsar-client-api</include>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5ODAxMA=="}, "originalCommit": {"oid": "5836ee787bb2526f3597716e6e3b27f4c3f27ea3"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2711, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}