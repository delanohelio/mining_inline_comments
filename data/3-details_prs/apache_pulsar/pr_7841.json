{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NTkxMzI2", "number": 7841, "title": "[broker] Fix deadlock when adding consumer", "bodyText": "Motivation\nA deadlock occurred on our Pulsar 2.4.2 broker server. The cause is the following two threads:\n\"prometheus-stats-36-1\" #410 prio=5 os_prio=0 tid=0x00007f4b70019800 nid=0x30ca waiting for monitor entry [0x00007f4bbe3b7000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.pulsar.broker.service.persistent.PersistentSubscription.getNumberOfEntriesDelayed(PersistentSubscription.java:1013)\n        - waiting to lock <0x00007f913d098dd0> (a org.apache.pulsar.broker.service.persistent.PersistentSubscription)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator.lambda$getTopicStats$8(NamespaceStatsAggregator.java:129)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator$$Lambda$523/2109257042.accept(Unknown Source)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap$Section.forEach(ConcurrentOpenHashMap.java:385)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap.forEach(ConcurrentOpenHashMap.java:159)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator.getTopicStats(NamespaceStatsAggregator.java:122)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator.lambda$null$0(NamespaceStatsAggregator.java:64)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator$$Lambda$521/1017174654.accept(Unknown Source)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap$Section.forEach(ConcurrentOpenHashMap.java:385)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap.forEach(ConcurrentOpenHashMap.java:159)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator.lambda$null$1(NamespaceStatsAggregator.java:63)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator$$Lambda$520/1098830264.accept(Unknown Source)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap$Section.forEach(ConcurrentOpenHashMap.java:385)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap.forEach(ConcurrentOpenHashMap.java:159)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator.lambda$generate$2(NamespaceStatsAggregator.java:62)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator$$Lambda$316/212211274.accept(Unknown Source)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap$Section.forEach(ConcurrentOpenHashMap.java:385)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap.forEach(ConcurrentOpenHashMap.java:159)\n        at org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator.generate(NamespaceStatsAggregator.java:59)\n        at org.apache.pulsar.broker.stats.prometheus.PrometheusMetricsGenerator.generate(PrometheusMetricsGenerator.java:73)\n        at org.apache.pulsar.broker.stats.prometheus.PrometheusMetricsServlet.lambda$doGet$0(PrometheusMetricsServlet.java:70)\n        at org.apache.pulsar.broker.stats.prometheus.PrometheusMetricsServlet$$Lambda$315/1221766138.run(Unknown Source)\n        at org.apache.bookkeeper.mledger.util.SafeRun$1.safeRun(SafeRun.java:32)\n        at org.apache.bookkeeper.common.util.SafeRunnable.run(SafeRunnable.java:36)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n        at java.lang.Thread.run(Thread.java:748)\n\n\"ForkJoinPool.commonPool-worker-104\" #953 daemon prio=5 os_prio=0 tid=0x00007f4dc8030800 nid=0x3b87 waiting on condition [0x00007f48f6ce1000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00007f913d08b5c8> (a org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap$Section)\n        at java.util.concurrent.locks.StampedLock.acquireRead(StampedLock.java:1215)\n        at java.util.concurrent.locks.StampedLock.readLock(StampedLock.java:428)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap$Section.forEach(ConcurrentOpenHashMap.java:377)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap.forEach(ConcurrentOpenHashMap.java:159)\n        at org.apache.pulsar.common.util.collections.ConcurrentOpenHashMap.values(ConcurrentOpenHashMap.java:174)\n        at org.apache.pulsar.broker.service.persistent.PersistentTopic.getNumberOfConsumers(PersistentTopic.java:1227)\n        at org.apache.pulsar.broker.service.persistent.PersistentDispatcherMultipleConsumers.isConsumersExceededOnTopic(PersistentDispatcherMultipleConsumers.java:178)\n        at org.apache.pulsar.broker.service.persistent.PersistentDispatcherMultipleConsumers.addConsumer(PersistentDispatcherMultipleConsumers.java:144)\n        - locked <0x00007f91120dc258> (a org.apache.pulsar.broker.service.persistent.PersistentDispatcherMultipleConsumers)\n        at org.apache.pulsar.broker.service.persistent.PersistentSubscription.addConsumer(PersistentSubscription.java:238)\n        - locked <0x00007f913d098dd0> (a org.apache.pulsar.broker.service.persistent.PersistentSubscription)\n        at org.apache.pulsar.broker.service.persistent.PersistentTopic.lambda$subscribe$11(PersistentTopic.java:590)\n        at org.apache.pulsar.broker.service.persistent.PersistentTopic$$Lambda$451/1414070467.accept(Unknown Source)\n        at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:670)\n        at java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:683)\n        at java.util.concurrent.CompletableFuture.thenAccept(CompletableFuture.java:2010)\n        at org.apache.pulsar.broker.service.persistent.PersistentTopic.subscribe(PersistentTopic.java:584)\n        at org.apache.pulsar.broker.service.ServerCnx.lambda$null$10(ServerCnx.java:699)\n        at org.apache.pulsar.broker.service.ServerCnx$$Lambda$408/1168861154.apply(Unknown Source)\n        at java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:995)\n        at java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2137)\n        at org.apache.pulsar.broker.service.ServerCnx.lambda$null$13(ServerCnx.java:682)\n        at org.apache.pulsar.broker.service.ServerCnx$$Lambda$406/1351396211.apply(Unknown Source)\n        at java.util.concurrent.CompletableFuture.uniApply(CompletableFuture.java:616)\n        at java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:591)\n        at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\n        at java.util.concurrent.CompletableFuture.postFire(CompletableFuture.java:575)\n        at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:943)\n        at java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:457)\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n        at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n        at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:163)\n\nprometheus-stats-36-1 was trying to lock PersistentSubscription (and PersistentDispatcherMultipleConsumers) after locking PersistentTopic#subscriptions, an instance of ConcurrentOpenHashMap.\nhttps://github.com/apache/pulsar/blob/v2.4.2/pulsar-broker/src/main/java/org/apache/pulsar/broker/stats/prometheus/NamespaceStatsAggregator.java#L122-L129\nOn the other hand, ForkJoinPool.commonPool-worker-104 was trying to lock these instances in reverse order.\nhttps://github.com/apache/pulsar/blob/v2.4.2/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java#L176-L237\nhttps://github.com/apache/pulsar/blob/v2.4.2/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentDispatcherMultipleConsumers.java#L127-L144\nhttps://github.com/apache/pulsar/blob/v2.4.2/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentDispatcherMultipleConsumers.java#L159-L175\nhttps://github.com/apache/pulsar/blob/v2.4.2/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java#L1212-L1214\nPersistentSubscription#getNumberOfEntriesDelayed() is no longer used in the master code, but it seems that this deadlock has not yet been resolved.\n\n  \n    \n      pulsar/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java\n    \n    \n        Lines 1528 to 1529\n      in\n      e06e872\n    \n    \n    \n    \n\n        \n          \n           subscriptions.forEach((name, subscription) -> { \n        \n\n        \n          \n               SubscriptionStats subStats = subscription.getStats(getPreciseBacklog); \n        \n    \n  \n\n\n\n  \n    \n      pulsar/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java\n    \n    \n        Lines 967 to 1000\n      in\n      17ae233\n    \n    \n    \n    \n\n        \n          \n           public SubscriptionStats getStats(Boolean getPreciseBacklog) { \n        \n\n        \n          \n               SubscriptionStats subStats = new SubscriptionStats(); \n        \n\n        \n          \n               subStats.lastExpireTimestamp = lastExpireTimestamp; \n        \n\n        \n          \n               subStats.lastConsumedFlowTimestamp = lastConsumedFlowTimestamp; \n        \n\n        \n          \n               Dispatcher dispatcher = this.dispatcher; \n        \n\n        \n          \n               if (dispatcher != null) { \n        \n\n        \n          \n                   dispatcher.getConsumers().forEach(consumer -> { \n        \n\n        \n          \n                       ConsumerStats consumerStats = consumer.getStats(); \n        \n\n        \n          \n                       subStats.consumers.add(consumerStats); \n        \n\n        \n          \n                       subStats.msgRateOut += consumerStats.msgRateOut; \n        \n\n        \n          \n                       subStats.msgThroughputOut += consumerStats.msgThroughputOut; \n        \n\n        \n          \n                       subStats.bytesOutCounter += consumerStats.bytesOutCounter; \n        \n\n        \n          \n                       subStats.msgOutCounter += consumerStats.msgOutCounter; \n        \n\n        \n          \n                       subStats.msgRateRedeliver += consumerStats.msgRateRedeliver; \n        \n\n        \n          \n                       subStats.chuckedMessageRate += consumerStats.chuckedMessageRate; \n        \n\n        \n          \n                       subStats.unackedMessages += consumerStats.unackedMessages; \n        \n\n        \n          \n                       subStats.lastConsumedTimestamp = Math.max(subStats.lastConsumedTimestamp, consumerStats.lastConsumedTimestamp); \n        \n\n        \n          \n                       subStats.lastAckedTimestamp = Math.max(subStats.lastAckedTimestamp, consumerStats.lastAckedTimestamp); \n        \n\n        \n          \n                   }); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               subStats.type = getType(); \n        \n\n        \n          \n               if (dispatcher instanceof PersistentDispatcherSingleActiveConsumer) { \n        \n\n        \n          \n                   Consumer activeConsumer = ((PersistentDispatcherSingleActiveConsumer) dispatcher).getActiveConsumer(); \n        \n\n        \n          \n                   if (activeConsumer != null) { \n        \n\n        \n          \n                       subStats.activeConsumerName = activeConsumer.consumerName(); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (Subscription.isIndividualAckMode(subStats.type)) { \n        \n\n        \n          \n                   if (dispatcher instanceof PersistentDispatcherMultipleConsumers) { \n        \n\n        \n          \n                       PersistentDispatcherMultipleConsumers d = (PersistentDispatcherMultipleConsumers) dispatcher; \n        \n\n        \n          \n                       subStats.unackedMessages = d.getTotalUnackedMessages(); \n        \n\n        \n          \n                       subStats.blockedSubscriptionOnUnackedMsgs = d.isBlockedDispatcherOnUnackedMsgs(); \n        \n\n        \n          \n                       subStats.msgDelayed = d.getNumberOfDelayedMessages(); \n        \n    \n  \n\n\n\n  \n    \n      pulsar/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentDispatcherMultipleConsumers.java\n    \n    \n         Line 809\n      in\n      6e7d1a8\n    \n    \n    \n    \n\n        \n          \n           public synchronized long getNumberOfDelayedMessages() { \n        \n    \n  \n\n\nModifications\nMoved the isConsumersExceededOnTopic() method to check the number of connected consumers when adding a consumer to the topic from the Dispatcher classes to the AbstractTopic class. Avoid the deadlock mentioned above by calling PersistentTopic#getNumberOfConsumers() before locking the PersistentSubscription instance.", "createdAt": "2020-08-18T15:58:16Z", "url": "https://github.com/apache/pulsar/pull/7841", "merged": true, "mergeCommit": {"oid": "23dc5c74dca8d40cdabe6ff07822583c63dc0dcf"}, "closed": true, "closedAt": "2020-08-27T16:22:48Z", "author": {"login": "massakam"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdApDVTgBqjM2NzM1MjQ4Mzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDC6TXAFqTQ3Njg4NDYyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aac02f0dfc26cb4134353e1b56046e0c997b407f", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/aac02f0dfc26cb4134353e1b56046e0c997b407f", "committedDate": "2020-08-18T19:06:12Z", "message": "Fix test code"}, "afterCommit": {"oid": "53c3d0811f39b1ee1d9564b4bc59d214143e7b70", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/53c3d0811f39b1ee1d9564b4bc59d214143e7b70", "committedDate": "2020-08-20T05:06:31Z", "message": "Fix deadlock when adding consumer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53c3d0811f39b1ee1d9564b4bc59d214143e7b70", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/53c3d0811f39b1ee1d9564b4bc59d214143e7b70", "committedDate": "2020-08-20T05:06:31Z", "message": "Fix deadlock when adding consumer"}, "afterCommit": {"oid": "8962717c114679f2ddcc390b77c20797dc4c9af0", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/8962717c114679f2ddcc390b77c20797dc4c9af0", "committedDate": "2020-08-20T15:57:26Z", "message": "Fix deadlock when adding consumer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNTMxNTEw", "url": "https://github.com/apache/pulsar/pull/7841#pullrequestreview-472531510", "createdAt": "2020-08-21T14:20:22Z", "commit": {"oid": "8962717c114679f2ddcc390b77c20797dc4c9af0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTA4NTQw", "url": "https://github.com/apache/pulsar/pull/7841#pullrequestreview-473908540", "createdAt": "2020-08-24T22:22:35Z", "commit": {"oid": "8962717c114679f2ddcc390b77c20797dc4c9af0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjoyMjozNVrOHF4Svg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjoyMjozNVrOHF4Svg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNzIzMA==", "bodyText": "should we log an error message?", "url": "https://github.com/apache/pulsar/pull/7841#discussion_r475927230", "createdAt": "2020-08-24T22:22:35Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -140,6 +141,38 @@ protected boolean isProducersExceeded() {\n         return false;\n     }\n \n+    protected boolean isConsumersExceededOnTopic() {\n+        Policies policies;\n+        try {\n+            // Use getDataIfPresent from zk cache to make the call non-blocking and prevent deadlocks\n+            policies = brokerService.pulsar().getConfigurationCache().policiesCache()\n+                    .getDataIfPresent(AdminResource.path(POLICIES, TopicName.get(topic).getNamespace()));\n+\n+            if (policies == null) {\n+                policies = new Policies();\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8962717c114679f2ddcc390b77c20797dc4c9af0"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cb89816d682be41aa2ffde1d7fdfed2886cfb5f", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/6cb89816d682be41aa2ffde1d7fdfed2886cfb5f", "committedDate": "2020-08-27T05:10:08Z", "message": "Fix deadlock when adding consumer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75bcef25f179584ec3ad77683f428922579a74b6", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/75bcef25f179584ec3ad77683f428922579a74b6", "committedDate": "2020-08-27T05:10:08Z", "message": "Log warn if getting of namespace policies fails"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3adfd1d913765356a3d02095efc568a4f484be34", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/3adfd1d913765356a3d02095efc568a4f484be34", "committedDate": "2020-08-25T02:05:30Z", "message": "Log warn if getting of namespace policies fails"}, "afterCommit": {"oid": "75bcef25f179584ec3ad77683f428922579a74b6", "author": {"user": {"login": "massakam", "name": "Masahiro Sakamoto"}}, "url": "https://github.com/apache/pulsar/commit/75bcef25f179584ec3ad77683f428922579a74b6", "committedDate": "2020-08-27T05:10:08Z", "message": "Log warn if getting of namespace policies fails"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODg0NjIy", "url": "https://github.com/apache/pulsar/pull/7841#pullrequestreview-476884622", "createdAt": "2020-08-27T16:22:30Z", "commit": {"oid": "75bcef25f179584ec3ad77683f428922579a74b6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 300, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}