{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzOTMxNzg4", "number": 8426, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo0Nzo0M1rOE2BC7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMzozMTo0OFrOE3Cx7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDc1NjkzOnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo0Nzo0M1rOHunFkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo0Nzo0M1rOHunFkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjk0Nw==", "bodyText": "It's better to throw an exception here, if return -1 it means the currentPosition is lower than otherPosition", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518636947", "createdAt": "2020-11-06T09:47:43Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDc3MTY0OnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1MTo0NVrOHunOpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1MTo0NVrOHunOpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzOTI3MA==", "bodyText": "Why otherPosition's ackSet is null then return the result?", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518639270", "createdAt": "2020-11-06T09:51:45Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDgwMTQ0OnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1OTo1M1rOHunhPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1OTo1M1rOHunhPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0NDAyOA==", "bodyText": "I think we can use an empty ackset to simplify these lines.", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518644028", "createdAt": "2020-11-06T09:59:53Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }\n+\n+            BitSetRecyclable otherAckSet;\n+            if (currentPosition.getAckSet() == null) {\n+                if (otherPosition.getAckSet() != null) {\n+                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+                    if (otherAckSet.isEmpty()) {\n+                        otherAckSet.recycle();\n+                        return result;\n+                    } else {\n+                        otherAckSet.recycle();\n+                        return 1;\n+                    }\n+\n+                }\n+                return result;\n+            }\n+            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            otherAckSet.recycle();\n+            thisAckSet.recycle();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDgzMTgwOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowODoyNlrOHun0Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowODoyNlrOHun0Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0ODg0Mg==", "bodyText": "If this for normal ack, shall we need to return TransactionConflictException?", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518648842", "createdAt": "2020-11-06T10:08:26Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDg0Mzg0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxMTo1OVrOHun7ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxMTo1OVrOHun7ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MDc0Nw==", "bodyText": "Looks there is much duplicate code with the individualAckNormal, is it possible to refine it?", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518650747", "createdAt": "2020-11-06T10:11:59Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));\n+                    }\n+                    ((PersistentSubscription) subscription)\n+                            .syncBatchPositionBitSetForPendingAck(new MutablePair<>(position, batchSizePair.first));\n+                    //check if the position can remove from the consumer pending acks.\n+                    // the bit set is empty in pending ack handle.\n+                    if (((PersistentSubscription) subscription).checkIsCanDeleteConsumerPendingAck(position)) {\n+                        removePendingAcks(position);\n+                    }\n                 }\n+            } else {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n+            }\n+            positionsAcked.add(position);\n+            if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n+                removePendingAcks(position);\n+            }\n \n-                if (ack.hasValidationError()) {\n-                    log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n-                            consumerId, position, ack.getValidationError());\n-                }\n+            if (ack.hasValidationError()) {\n+                log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n+                        consumerId, position, ack.getValidationError());\n             }\n-            if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Individual);\n+        }\n+        subscription.acknowledgeMessage(positionsAcked, AckType.Individual, properties);\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    //this method is for individual ack carry the transaction\n+    private CompletableFuture<Void> individualAckWithTransaction(CommandAck ack) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjU3ODQxOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMDo0MDozNFrOHvb6Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMDo0MDozNFrOHvb6Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUwMjQwNw==", "bodyText": "Move the isTransactionEnabled to the topic or subscription?  We cannot treat consumers differently in transaction.", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r519502407", "createdAt": "2020-11-09T00:40:34Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -131,12 +132,13 @@\n     private static final double avgPercent = 0.9;\n     private boolean preciseDispatcherFlowControl;\n     private PositionImpl readPositionWhenJoining;\n+    private final boolean isTransactionEnabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTUyNjg0OnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMzozMTo0OFrOHwKZvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMzozMTo0OFrOHwKZvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI2NDEyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //this method will return the a copy of the position's ack set\n          \n          \n            \n                //this method will return a copy of the position's ack set", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r520264126", "createdAt": "2020-11-10T03:31:48Z", "author": {"login": "gaoran10"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -2773,6 +2773,24 @@ public boolean isMessageDeleted(Position position) {\n                 ((PositionImpl) position).getEntryId()) || ((PositionImpl) position).compareTo(markDeletePosition) <= 0 ;\n     }\n \n+    //this method will return the a copy of the position's ack set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2859, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}