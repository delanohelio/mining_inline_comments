{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNDM1NTQ0", "number": 7429, "title": "[docs]Update content on message deduplication", "bodyText": "Motivation\nThe link to deduplication blog is invalid.\nModifications\n\nUpdate links to streamlio blogs.\nUpdate contents on deduplication.", "createdAt": "2020-07-02T10:48:17Z", "url": "https://github.com/apache/pulsar/pull/7429", "merged": true, "mergeCommit": {"oid": "56fe11aff878a1989014d5e525d92c1ac8f77856"}, "closed": true, "closedAt": "2020-07-03T10:08:16Z", "author": {"login": "Jennifer88huang"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcw6W9SgH2gAyNDQzNDM1NTQ0OjU2ZjJjMTIzMmU1NjM3ZGNiZWRiYzYzMjY3ZjMxMTBkM2E0ZjE5M2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxNDiWAFqTQ0MjE2MzcwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "56f2c1232e5637dcbedbc63267f3110d3a4f193a", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/56f2c1232e5637dcbedbc63267f3110d3a4f193a", "committedDate": "2020-07-02T08:14:01Z", "message": "update links in messaging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f", "committedDate": "2020-07-02T10:42:39Z", "message": "update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjQ3NjE5", "url": "https://github.com/apache/pulsar/pull/7429#pullrequestreview-441647619", "createdAt": "2020-07-02T12:52:34Z", "commit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo1MjozNFrOGsLeMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzowMjowNlrOGsL1zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3ODQ4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | Sync send  | The producer waits for acknowledgement from the broker after sending every message. If acknowledgment is not received, the producer renders the send operation a failure.                                                                                                                                                                                    |\n          \n          \n            \n            | Sync send  | The producer waits for an acknowledgement from the broker after sending every message. If the acknowledgment is not received, the producer treats the sending operation as a failure.                                                                                                                                                                                    |", "url": "https://github.com/apache/pulsar/pull/7429#discussion_r448978480", "createdAt": "2020-07-02T12:52:34Z", "author": {"login": "Anonymitaet"}, "path": "site2/docs/concepts-messaging.md", "diffHunk": "@@ -1,46 +1,46 @@\n ---\n id: concepts-messaging\n-title: Messaging Concepts\n+title: Messaging\n sidebar_label: Messaging\n ---\n \n Pulsar is built on the [publish-subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) pattern (short for pub-sub). In this pattern, [producers](#producers) publish messages to [topics](#topics). [Consumers](#consumers) [subscribe](#subscription-modes) to those topics, process incoming messages, and send an acknowledgement when processing is complete.\n \n-Once a subscription has been created, all messages are [retained](concepts-architecture-overview.md#persistent-storage) by Pulsar, even if the consumer gets disconnected. Retained messages are discarded only when a consumer acknowledges that those messages are processed successfully.\n+When a subscription is created, Pulsar [retains](concepts-architecture-overview.md#persistent-storage) all messages, even if the consumer is disconnected. Retained messages are discarded only when a consumer acknowledges that those messages are processed successfully.\n \n ## Messages\n \n-Messages are the basic \"unit\" of Pulsar. Messages are what producers publish to topics and what consumers then consume from topics (and acknowledge when the message has been processed). Messages are the analogue of letters in a postal service system.\n+Messages are the basic \"unit\" of Pulsar. The following table lists the components of messages.\n \n-Component | Purpose\n+Component | Description\n :---------|:-------\n-Value / data payload | The data carried by the message. All Pulsar messages carry raw bytes, although message data can also conform to data [schemas](schema-get-started.md).\n-Key | Messages can optionally be tagged with keys, which can be useful for things like [topic compaction](concepts-topic-compaction.md).\n+Value / data payload | The data carried by the message. All Pulsar messages contain raw bytes, although message data can also conform to data [schemas](schema-get-started.md).\n+Key | Messages are optionally tagged with keys, which is useful for things like [topic compaction](concepts-topic-compaction.md).\n Properties | An optional key/value map of user-defined properties.\n-Producer name | The name of the producer that produced the message (producers are automatically given default names, but you can apply your own explicitly as well).\n-Sequence ID | Each Pulsar message belongs to an ordered sequence on its topic. A message's sequence ID is its ordering in that sequence.\n-Publish time | The timestamp of when the message was published (automatically applied by the producer).\n-Event time | An optional timestamp that applications can attach to the message representing when something happened, for example, when the message was processed. The event time of a message is 0 if none is explicitly set.\n-TypedMessageBuilder | `TypedMessageBuilder` is used to construct a message. You can set message properties like the message key, message value with `TypedMessageBuilder`. </br> When you set `TypedMessageBuilder`, the best practice is to set the key as a string. If you set the key as other types, for example, an AVRO object, the key is sent as bytes, and it is difficult to get the AVRO object back on the consumer.\n+Producer name | The name of the producer who produces the message. If you do not specify a producer name, the default name is used. \n+Sequence ID | Each Pulsar message belongs to an ordered sequence on its topic. The sequence ID of the message is its order in that sequence.\n+Publish time | The timestamp of when the message is published. The timestamp is automatically applied by the producer.\n+Event time | An optional timestamp attached to a message by applications. For example, applications attach a timestamp on when the message is processed. If nothing is set to event time, the value is `0`. \n+TypedMessageBuilder | It is used to construct a message. You can set message properties such as the message key, message value with `TypedMessageBuilder`. </br> When you set `TypedMessageBuilder`, set the key as a string. If you set the key as other types, for example, an AVRO object, the key is sent as bytes, and it is difficult to get the AVRO object back on the consumer.\n \n-> For a more in-depth breakdown of Pulsar message contents, see Pulsar [binary protocol](developing-binary-protocol.md).\n+> For more information on Pulsar message contents, see Pulsar [binary protocol](developing-binary-protocol.md).\n \n ## Producers\n \n-A producer is a process that attaches to a topic and publishes messages to a Pulsar [broker](reference-terminology.md#broker) for processing.\n+A producer is a process that attaches to a topic and publishes messages to a Pulsar [broker](reference-terminology.md#broker). The Pulsar broker process the messages.\n \n ### Send modes\n \n-Producers can send messages to brokers either synchronously (sync) or asynchronously (async).\n+Producers send messages to brokers synchronously (sync) or asynchronously (async).\n \n-| Mode       | Description                                                                                                                                                                                                                                                                                                                                                              |\n-|:-----------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| Sync send  | The producer will wait for acknowledgement from the broker after sending each message. If acknowledgment isn't received then the producer will consider the send operation a failure.                                                                                                                                                                                    |\n-| Async send | The producer will put the message in a blocking queue and return immediately. The client library will then send the message to the broker in the background. If the queue is full (max size [configurable](reference-configuration.md#broker)), the producer could be blocked or fail immediately when calling the API, depending on arguments passed to the producer. |\n+| Mode       | Description |            \n+|:-----------|-----------|\n+| Sync send  | The producer waits for acknowledgement from the broker after sending every message. If acknowledgment is not received, the producer renders the send operation a failure.                                                                                                                                                                                    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3OTMxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In Pulsar, batches are tracked and stored as single units rather than as individual messages. Consumer unbundle a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.\n          \n          \n            \n            In Pulsar, batches are tracked and stored as single units rather than as individual messages. Consumer unbundles a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.", "url": "https://github.com/apache/pulsar/pull/7429#discussion_r448979315", "createdAt": "2020-07-02T12:53:57Z", "author": {"login": "Anonymitaet"}, "path": "site2/docs/concepts-messaging.md", "diffHunk": "@@ -51,95 +51,93 @@ Messages published by producers can be compressed during transportation in order\n \n When batching is enabled, the producer accumulates and sends a batch of messages in a single request. The batch size is defined by the maximum number of messages and the maximum publish latency. Therefore, the backlog size represents the total number of batches instead of the total number of messages.\n \n-In Pulsar, batches are tracked and stored as single units rather than as individual messages. Under the hood, the consumer unbundles a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.\n+In Pulsar, batches are tracked and stored as single units rather than as individual messages. Consumer unbundle a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4MDAxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When chunking is enabled (`chunkingEnabled=true`), if the message size is greater than the allowed maximum publish-payload size, the producer splits the original message into chunked messages and publishes them with chunked metadata to the broker separately and in order. At the broker side, the chunked messages are stored in the managed-ledger in the same way as that of ordinary messages. The only difference is that the consumer needs to buffer the chunked messages and combines them into the real message when all chunked messages have been collected. The chunked messages in the managed-ledger can be interwoven with ordinary messages. If producer fails to publish all the chunks of a message, the consumer can expire incomplete chunks if consumer fail to receive all chunks in expire time. By default, the expire time is set to 0ne hour.\n          \n          \n            \n            When chunking is enabled (`chunkingEnabled=true`), if the message size is greater than the allowed maximum publish-payload size, the producer splits the original message into chunked messages and publishes them with chunked metadata to the broker separately and in order. At the broker side, the chunked messages are stored in the managed-ledger in the same way as that of ordinary messages. The only difference is that the consumer needs to buffer the chunked messages and combines them into the real message when all chunked messages have been collected. The chunked messages in the managed-ledger can be interwoven with ordinary messages. If producer fails to publish all the chunks of a message, the consumer can expire incomplete chunks if consumer fail to receive all chunks in expire time. By default, the expire time is set to one hour.", "url": "https://github.com/apache/pulsar/pull/7429#discussion_r448980016", "createdAt": "2020-07-02T12:55:07Z", "author": {"login": "Anonymitaet"}, "path": "site2/docs/concepts-messaging.md", "diffHunk": "@@ -51,95 +51,93 @@ Messages published by producers can be compressed during transportation in order\n \n When batching is enabled, the producer accumulates and sends a batch of messages in a single request. The batch size is defined by the maximum number of messages and the maximum publish latency. Therefore, the backlog size represents the total number of batches instead of the total number of messages.\n \n-In Pulsar, batches are tracked and stored as single units rather than as individual messages. Under the hood, the consumer unbundles a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.\n+In Pulsar, batches are tracked and stored as single units rather than as individual messages. Consumer unbundle a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.\n \n-In general, a batch is acknowledged when all its messages are acknowledged by the consumer. This means unexpected failures, negative acknowledgements, or acknowledgement timeouts can result in redelivery of all messages in a batch, even if some of the messages have already been acknowledged.\n+In general, a batch is acknowledged when all of its messages are acknowledged by a consumer. It means unexpected failures, negative acknowledgements, or acknowledgement timeouts can result in redelivery of all messages in a batch, even if some of the messages are acknowledged.\n \n To avoid redelivering acknowledged messages in a batch to the consumer, Pulsar introduces batch index acknowledgement since Pulsar 2.6.0. When batch index acknowledgement is enabled, the consumer filters out the batch index that has been acknowledged and sends the batch index acknowledgement request to the broker. The broker maintains the batch index acknowledgement status and tracks the acknowledgement status of each batch index to avoid dispatching acknowledged messages to the consumer. When all indexes of the batch message are acknowledged, the batch message is deleted.\n \n-By default, batch index acknowledgement is disabled (`batchIndexAcknowledgeEnable=false`). You can enable batch index acknowledgement by setting the `batchIndexAcknowledgeEnable` parameter to `true` at the broker side. Enabling batch index acknowledgement may bring more memory overheads. So, perform this operation with caution.\n+By default, batch index acknowledgement is disabled (`batchIndexAcknowledgeEnable=false`). You can enable batch index acknowledgement by setting the `batchIndexAcknowledgeEnable` parameter to `true` at the broker side. Enabling batch index acknowledgement results in more memory overheads. \n \n ### Chunking\n+When you enable chunking, read the following instructions.\n+- Batching and chunking cannot be enabled simultaneously. To enable chunking, you must disable batching in advance.\n+- Chunking is only supported for persisted topics.\n+- Chunking is only supported for the exclusive and failover subscription modes.\n \n-#### Note\n+When chunking is enabled (`chunkingEnabled=true`), if the message size is greater than the allowed maximum publish-payload size, the producer splits the original message into chunked messages and publishes them with chunked metadata to the broker separately and in order. At the broker side, the chunked messages are stored in the managed-ledger in the same way as that of ordinary messages. The only difference is that the consumer needs to buffer the chunked messages and combines them into the real message when all chunked messages have been collected. The chunked messages in the managed-ledger can be interwoven with ordinary messages. If producer fails to publish all the chunks of a message, the consumer can expire incomplete chunks if consumer fail to receive all chunks in expire time. By default, the expire time is set to 0ne hour.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4MjY1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | Async receive | An async receive returns immediately with a future value---a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) in Java, for example---that completes once a new message is available. |\n          \n          \n            \n            | Async receive | An async receive returns immediately with a future value\u2014for example, a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) in Java\u2014that completes once a new message is available. |\n          \n      \n    \n    \n  \n\nuse em dash", "url": "https://github.com/apache/pulsar/pull/7429#discussion_r448982659", "createdAt": "2020-07-02T12:59:19Z", "author": {"login": "Anonymitaet"}, "path": "site2/docs/concepts-messaging.md", "diffHunk": "@@ -51,95 +51,93 @@ Messages published by producers can be compressed during transportation in order\n \n When batching is enabled, the producer accumulates and sends a batch of messages in a single request. The batch size is defined by the maximum number of messages and the maximum publish latency. Therefore, the backlog size represents the total number of batches instead of the total number of messages.\n \n-In Pulsar, batches are tracked and stored as single units rather than as individual messages. Under the hood, the consumer unbundles a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.\n+In Pulsar, batches are tracked and stored as single units rather than as individual messages. Consumer unbundle a batch into individual messages. However, scheduled messages (configured through the `deliverAt` or the `deliverAfter` parameter) are always sent as individual messages even batching is enabled.\n \n-In general, a batch is acknowledged when all its messages are acknowledged by the consumer. This means unexpected failures, negative acknowledgements, or acknowledgement timeouts can result in redelivery of all messages in a batch, even if some of the messages have already been acknowledged.\n+In general, a batch is acknowledged when all of its messages are acknowledged by a consumer. It means unexpected failures, negative acknowledgements, or acknowledgement timeouts can result in redelivery of all messages in a batch, even if some of the messages are acknowledged.\n \n To avoid redelivering acknowledged messages in a batch to the consumer, Pulsar introduces batch index acknowledgement since Pulsar 2.6.0. When batch index acknowledgement is enabled, the consumer filters out the batch index that has been acknowledged and sends the batch index acknowledgement request to the broker. The broker maintains the batch index acknowledgement status and tracks the acknowledgement status of each batch index to avoid dispatching acknowledged messages to the consumer. When all indexes of the batch message are acknowledged, the batch message is deleted.\n \n-By default, batch index acknowledgement is disabled (`batchIndexAcknowledgeEnable=false`). You can enable batch index acknowledgement by setting the `batchIndexAcknowledgeEnable` parameter to `true` at the broker side. Enabling batch index acknowledgement may bring more memory overheads. So, perform this operation with caution.\n+By default, batch index acknowledgement is disabled (`batchIndexAcknowledgeEnable=false`). You can enable batch index acknowledgement by setting the `batchIndexAcknowledgeEnable` parameter to `true` at the broker side. Enabling batch index acknowledgement results in more memory overheads. \n \n ### Chunking\n+When you enable chunking, read the following instructions.\n+- Batching and chunking cannot be enabled simultaneously. To enable chunking, you must disable batching in advance.\n+- Chunking is only supported for persisted topics.\n+- Chunking is only supported for the exclusive and failover subscription modes.\n \n-#### Note\n+When chunking is enabled (`chunkingEnabled=true`), if the message size is greater than the allowed maximum publish-payload size, the producer splits the original message into chunked messages and publishes them with chunked metadata to the broker separately and in order. At the broker side, the chunked messages are stored in the managed-ledger in the same way as that of ordinary messages. The only difference is that the consumer needs to buffer the chunked messages and combines them into the real message when all chunked messages have been collected. The chunked messages in the managed-ledger can be interwoven with ordinary messages. If producer fails to publish all the chunks of a message, the consumer can expire incomplete chunks if consumer fail to receive all chunks in expire time. By default, the expire time is set to 0ne hour.\n \n-> - Batching and chunking cannot be enabled simultaneously. To enable chunking, you must disable batching in advance.\n-> - Chunking is only supported for persisted topics.\n-> - Chunking is only supported for the exclusive and failover subscription modes.\n+The consumer consumes the chunked messages and buffers them until the consumer receives all the chunks of a message. And then the consumer stitches chunked messages together and places them into the receiver-queue. Clients consume messages from the receiver-queue. Once the consumer consumes the entire large message and acknowledges it, the consumer internally sends acknowledgement of all the chunk messages associated to that large message. You can set the `maxPendingChuckedMessage` parameter on the consumer. When the threshold is reached, the consumer drops the unchunked messages by silently acknowledging them or asking the broker to redeliver them later by marking them unacknowledged.\n \n-When chunking is enabled (`chunkingEnabled=true`), if the message size is greater than the allowed maximum publish-payload size, the producer splits the original message into chunked messages and publishes them with chunked metadata to the broker separately and in order. At the broker, the chunked messages are stored in the managed-ledger in the same way as that of ordinary messages. The only difference is that the consumer needs to buffer the chunked messages and combines them into the real message when all chunked messages have been collected. The chunked messages in the managed-ledger can be interwoven with ordinary messages. If producer fails to publish all the chunks of a message, the consumer can expire incomplete chunks if consumer fail to receive all chunks in expire time. By default, the expire time is set to 0ne hour.\n-\n-The consumer consumes the chunked messages and buffers them until the consumer receives all the chunks of a message. Finally, the consumer stitches chunked messages together and places them into the receiver-queue . Therefore, the client can consume messages from there. Once the consumer consumes entire large message and acknowledges it, the consumer internally sends acknowledgement of all the chunk messages associated to that large message. You can set the `maxPendingChuckedMessage` parameter on the consumer. When the threshold is reached, the consumer drops the unchunked messages by silently acknowledging them or asking the broker to redeliver them later by marking them unacknowledged.\n-\n- The broker does not require any changes to support chunking for non-shared subscription. The broker only use the `chuckedMessageRate` to record chunked message rate on the topic.\n+ The broker does not require any changes to support chunking for non-shared subscription. The broker only uses `chuckedMessageRate` to record chunked message rate on the topic.\n \n #### Handle chunked messages with one producer and one ordered consumer\n \n-As shown in the following figure, when a topic has one producer which publishes large message payload in chunked messages along with regular non-chunked messages. the producer publishes message M1 in three chunks M1-C1, M1-C2 and M1-C3. The broker stores all 3 chunked messages in the managed-ledger and dispatches to the ordered (exclusive/failover) consumer in the same order. The consumer buffers all the chunked messages in memory until it receives all the chunked messages, combines them to one real message and then hands over the original message M1 to the client.\n+As shown in the following figure, when a topic has one producer which publishes large message payload in chunked messages along with regular non-chunked messages. The producer publishes message M1 in three chunks M1-C1, M1-C2 and M1-C3. The broker stores all the three chunked messages in the managed-ledger and dispatches to the ordered (exclusive/failover) consumer in the same order. The consumer buffers all the chunked messages in memory until it receives all the chunked messages, combines them into one message and then hands over the original message M1 to the client.\n \n ![](assets/chunking-01.png)\n \n #### Handle chunked messages with multiple producers and one ordered consumer\n \n-When multiple publishers publishes chunked messages into the single topic. The broker stores all the chunked messages coming from different publishers in the same managed-ledger. As shown below, Producer 1 publishes message M1 in three chunks M1-C1, M1-C2 and M1-C3. Producer 2 publishes message M2 in three chunks M2-C1, M2-C2 and M2-C3. All chunked messages of the specific message are still in the order but might not be consecutive in the managed-ledger. This brings some memory pressure to the consumer because the consumer has to keep separate buffer for each large message to aggregate all chunks of the large message and combine them to one real message.\n+When multiple publishers publish chunked messages into a single topic, the broker stores all the chunked messages coming from different publishers in the same managed-ledger. As shown below, Producer 1 publishes message M1 in three chunks M1-C1, M1-C2 and M1-C3. Producer 2 publishes message M2 in three chunks M2-C1, M2-C2 and M2-C3. All chunked messages of the specific message are still in order but might not be consecutive in the managed-ledger. This brings some memory pressure to the consumer because the consumer keeps separate buffer for each large message to aggregate all chunks of the large message and combine them into one message.\n \n ![](assets/chunking-02.png)\n \n ## Consumers\n \n A consumer is a process that attaches to a topic via a subscription and then receives messages.\n \n-A consumer sends a [flow permit request](developing-binary-protocol.md#flow-control) to a broker to get messages. There is a queue at the consumer side to receive messages pushed from the broker. The queue size is configurable by [`receiverQueueSize`](client-libraries-java.md#configure-consumer) (default: 1000). Each time `consumer.receive()` is called, a message is dequeued from the buffer.  \n+A consumer sends a [flow permit request](developing-binary-protocol.md#flow-control) to a broker to get messages. There is a queue at the consumer side to receive messages pushed from the broker. You can configure the queue size with the [`receiverQueueSize`](client-libraries-java.md#configure-consumer) parameter. The default size is `1000`). Each time `consumer.receive()` is called, a message is dequeued from the buffer.  \n \n ### Receive modes\n \n-Messages can be received from [brokers](reference-terminology.md#broker) either synchronously (sync) or asynchronously (async).\n+Messages are received from [brokers](reference-terminology.md#broker) either synchronously (sync) or asynchronously (async).\n \n | Mode          | Description                                                                                                                                                                                                   |\n |:--------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| Sync receive  | A sync receive will be blocked until a message is available.                                                                                                                                                  |\n-| Async receive | An async receive will return immediately with a future value---a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) in Java, for example---that completes once a new message is available. |\n+| Sync receive  | A sync receive is blocked until a message is available.                                                                                                                                                  |\n+| Async receive | An async receive returns immediately with a future value---a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) in Java, for example---that completes once a new message is available. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4NDA1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For many online business systems, a message is re-consumed due to exception occurs in the business logic processing. To configure the delay time for re-consuming the failed messages, you can configure the producer to send messages to both the business topic and the retry letter topic, and enable automatic retry on the consumer. When automatic retry is enabled on the consumer, a message is stored in the retry letter topic if the messages are not consumed, and therefore the consumer automatically consume the failed messages from the retry letter topic after a specified delay time.\n          \n          \n            \n            For many online business systems, a message is re-consumed due to exception occurs in the business logic processing. To configure the delay time for re-consuming the failed messages, you can configure the producer to send messages to both the business topic and the retry letter topic, and enable automatic retry on the consumer. When automatic retry is enabled on the consumer, a message is stored in the retry letter topic if the messages are not consumed, and therefore the consumer automatically consumes the failed messages from the retry letter topic after a specified delay time.", "url": "https://github.com/apache/pulsar/pull/7429#discussion_r448984059", "createdAt": "2020-07-02T13:01:23Z", "author": {"login": "Anonymitaet"}, "path": "site2/docs/concepts-messaging.md", "diffHunk": "@@ -188,11 +186,11 @@ Dead letter topic depends on message re-delivery. Messages are redelivered eithe\n \n ### Retry letter topic\n \n-For many online business systems, a message needs to be re-consumed because any exception occurs in the business logic processing. Generally, users hope that they can flexibly configure the delay time for re-consuming the failed messages. In this case, you can configure the producer to send messages to both the business topic and the retry letter topic and you can enable automatic retry on the consumer. When automatic retry is enabled on the consumer, a message is stored in the retry letter topic if the messages fail to be consumed and therefore the consumer can automatically consume failed messages from the retry letter topic after a specified delay time.\n+For many online business systems, a message is re-consumed due to exception occurs in the business logic processing. To configure the delay time for re-consuming the failed messages, you can configure the producer to send messages to both the business topic and the retry letter topic, and enable automatic retry on the consumer. When automatic retry is enabled on the consumer, a message is stored in the retry letter topic if the messages are not consumed, and therefore the consumer automatically consume the failed messages from the retry letter topic after a specified delay time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4NDUyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `persistent` / `non-persistent` | This identifies the type of topic. Pulsar supports two kind of topics: [persistent](concepts-architecture-overview.md#persistent-storage) and [non-persistent](#non-persistent-topics). The default is persistent, so if you do not specify a type, the topic is persistent. With persistent topics, all messages are durably persisted on disks (if the broker is not standalone, messages are durably persisted on  multiple disks), whereas data for non-persistent topics is not persisted to storage disks.\n          \n          \n            \n            `tenant`             | The topic tenant within the instance. Tenants are essential to multi-tenancy in Pulsar, and spread across clusters.\n          \n          \n            \n            `namespace`          | The administrative unit of the topic, which acts as a grouping mechanism for related topics. Most topic configuration is performed at the [namespace](#namespaces) level. Each tenant has one or multiple namespaces.\n          \n          \n            \n            `topic`              | The final part of the name. Topic names have no special meaning in a Pulsar instance.\n          \n          \n            \n            `persistent` / `non-persistent` | This identifies the type of topic. Pulsar supports two kind of topics: [persistent](concepts-architecture-overview.md#persistent-storage) and [non-persistent](#non-persistent-topics). The default is persistent, so if you do not specify a type, the topic is persistent. With persistent topics, all messages are durably persisted on disks (if the broker is not standalone, messages are durably persisted on multiple disks), whereas data for non-persistent topics is not persisted to storage disks.\n          \n          \n            \n            `tenant`             | The topic tenant within the instance. Tenants are essential to multi-tenancy in Pulsar, and spread across clusters.\n          \n          \n            \n            `namespace`          | The administrative unit of the topic, which acts as a grouping mechanism for related topics. Most topic configuration is performed at the [namespace](#namespaces) level. Each tenant has one or multiple namespaces.\n          \n          \n            \n            `topic`              | The final part of the name. Topic names have no special meaning in a Pulsar instance.", "url": "https://github.com/apache/pulsar/pull/7429#discussion_r448984524", "createdAt": "2020-07-02T13:02:06Z", "author": {"login": "Anonymitaet"}, "path": "site2/docs/concepts-messaging.md", "diffHunk": "@@ -211,43 +209,42 @@ Consumer<byte[]> consumer = pulsarClient.newConsumer(Schema.BYTES)\n \n ## Topics\n \n-As in other pub-sub systems, topics in Pulsar are named channels for transmitting messages from [producers](reference-terminology.md#producer) to [consumers](reference-terminology.md#consumer). Topic names are URLs that have a well-defined structure:\n+As in other pub-sub systems, topics in Pulsar are named channels for transmitting messages from producers to consumers. Topic names are URLs that have a well-defined structure:\n \n ```http\n {persistent|non-persistent}://tenant/namespace/topic\n ```\n \n Topic name component | Description\n :--------------------|:-----------\n-`persistent` / `non-persistent` | This identifies the type of topic. Pulsar supports two kind of topics: [persistent](concepts-architecture-overview.md#persistent-storage) and [non-persistent](#non-persistent-topics) (persistent is the default, so if you don't specify a type the topic will be persistent). With persistent topics, all messages are durably [persisted](concepts-architecture-overview.md#persistent-storage) on disk (that means on multiple disks unless the broker is standalone), whereas data for [non-persistent](#non-persistent-topics) topics isn't persisted to storage disks.\n-`tenant`             | The topic's tenant within the instance. Tenants are essential to multi-tenancy in Pulsar and can be spread across clusters.\n-`namespace`          | The administrative unit of the topic, which acts as a grouping mechanism for related topics. Most topic configuration is performed at the [namespace](#namespaces) level. Each tenant can have multiple namespaces.\n-`topic`              | The final part of the name. Topic names are freeform and have no special meaning in a Pulsar instance.\n-\n+`persistent` / `non-persistent` | This identifies the type of topic. Pulsar supports two kind of topics: [persistent](concepts-architecture-overview.md#persistent-storage) and [non-persistent](#non-persistent-topics). The default is persistent, so if you do not specify a type, the topic is persistent. With persistent topics, all messages are durably persisted on disks (if the broker is not standalone, messages are durably persisted on  multiple disks), whereas data for non-persistent topics is not persisted to storage disks.\n+`tenant`             | The topic tenant within the instance. Tenants are essential to multi-tenancy in Pulsar, and spread across clusters.\n+`namespace`          | The administrative unit of the topic, which acts as a grouping mechanism for related topics. Most topic configuration is performed at the [namespace](#namespaces) level. Each tenant has one or multiple namespaces.\n+`topic`              | The final part of the name. Topic names have no special meaning in a Pulsar instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b8e6346d247a8c1cfa62aff0a303ea9fff6c97f"}, "originalPosition": 223}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f46e3049c7037f2ac91b2cf06c185dc3c2061e97", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/f46e3049c7037f2ac91b2cf06c185dc3c2061e97", "committedDate": "2020-07-03T01:57:42Z", "message": "Update site2/docs/concepts-messaging.md\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4da55cedd7b3b5510848f350054ecc78dbb08031", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/4da55cedd7b3b5510848f350054ecc78dbb08031", "committedDate": "2020-07-03T01:57:50Z", "message": "Update site2/docs/concepts-messaging.md\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94f7439697f88afd7cda21e1a25ba6b4131b974c", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/94f7439697f88afd7cda21e1a25ba6b4131b974c", "committedDate": "2020-07-03T01:57:57Z", "message": "Update site2/docs/concepts-messaging.md\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f32fcb8e79954743c99f60067424884805ac613", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/1f32fcb8e79954743c99f60067424884805ac613", "committedDate": "2020-07-03T01:58:05Z", "message": "Update site2/docs/concepts-messaging.md\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "131535d60e503751d38207598d1e9a9e897e416a", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/131535d60e503751d38207598d1e9a9e897e416a", "committedDate": "2020-07-03T01:58:19Z", "message": "Update site2/docs/concepts-messaging.md\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "491ea0f5fb6190e1762c35b08982fbc2ba1ead24", "author": {"user": {"login": "Jennifer88huang", "name": "Jennifer Huang"}}, "url": "https://github.com/apache/pulsar/commit/491ea0f5fb6190e1762c35b08982fbc2ba1ead24", "committedDate": "2020-07-03T01:58:26Z", "message": "Update site2/docs/concepts-messaging.md\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTYzNzAw", "url": "https://github.com/apache/pulsar/pull/7429#pullrequestreview-442163700", "createdAt": "2020-07-03T06:01:00Z", "commit": {"oid": "491ea0f5fb6190e1762c35b08982fbc2ba1ead24"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 526, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}